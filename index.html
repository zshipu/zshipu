<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>知识铺</title><meta property="og:type" content="blog"><meta property="og:title" content="知识铺"><meta property="og:url" content="https://zshipu.com/"><meta property="og:site_name" content="知识铺"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zshipu.com/img/og_image.png"><meta property="article:author" content="edwin"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zshipu.com"},"headline":"知识铺","image":["https://zshipu.com/img/og_image.png"],"author":{"@type":"Person","name":"edwin"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script data-ad-client="2183476622" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="generator" content="Hexo 5.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="知识铺" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-07-16T10:43:02.000Z" title="2020-07-16T10:43:02.000Z">2020-07-16</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.402Z" title="2020-09-08T14:03:00.402Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">10 分钟读完 (大约1464个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/16/Spring%20Cloud%20Gateway+Nacos%EF%BC%8Cyml+properties%E4%B8%A4%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BA%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1/">Spring Cloud Gateway+Nacos，yml+properties两种配置文件方式搭建网关服务</a></h1><div class="content"><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>网关的作用不在此赘述，举个最常用的例子，我们搭建了微服务，前端调用各服务接口时，由于各服务接口不一样，如果让前端同事分别调用，前端同事会疯的。而网关就可以解决这个问题，网关屏蔽了各业务服务的端口，对前端同事来说，他们只负责调用网关服务端口下的服务就可以了。本文简单描述如何使用Spring Cloud全家桶中的网关服务，再配以Nacos。关于Nacos简单应用，可以看我其他博客。</p>
<h1 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h1><p>从<a href="https://zshipu.com/t?url=https://start.spring.io/">https://start.spring.io/</a>下载一个原始的spring boot工程，如何下载就不在这里说了。添加依赖：</p>
<p> <a href="https://zshipu.com/t?url=javascript:void(0);" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<dependency>
　　<groupId>org.springframework.boot</groupId>
　　<artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
　　<groupId>com.alibaba.cloud</groupId>
　　<artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
　　<version>2.2.1.RELEASE</version>
</dependency>
<dependency>
　　<groupId>com.alibaba.cloud</groupId>
　　<artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
　　<version>2.2.1.RELEASE</version>
</dependency>

<p> <a href="https://zshipu.com/t?url=javascript:void(0);" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>分别添加了web依赖、配置中心依赖和注册中心依赖。</p>
<p>配置文件如下：</p>
<p> server.port=8070<br>spring.application.name=service-provider<br>spring.cloud.nacos.config.server-addr=127.0.0.1:8848<br>spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848</p>
<p>启动类如下：</p>
<p> <a href="https://zshipu.com/t?url=javascript:void(0);" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>package com.chris.springboot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient;</p>
<p>@SpringBootApplication<br>@EnableDiscoveryClient public class MySpringbootApplication { public static void main(String[] args) {<br>        SpringApplication.run(MySpringbootApplication.class, args);<br>    }<br>}<br> <a href="https://zshipu.com/t?url=javascript:void(0);" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>接口类如下：</p>
<p> <a href="https://zshipu.com/t?url=javascript:void(0);" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>package com.chris.springboot.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.context.config.annotation.RefreshScope; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController;</p>
<p>@RestController<br>@RequestMapping(“/provider”)<br>@RefreshScope public class ConfigController {</p>
<pre><code>@Value(value = &quot;$&#123;Hello:123&#125;&quot;) private String hello;

 @GetMapping(&quot;/helloProvider&quot;) public String helloProvider()&#123; return hello;
    &#125;</code></pre>
<p>}<br> <a href="https://zshipu.com/t?url=javascript:void(0);" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>此服务为我的博客：<a href="https://zshipu.com/t?url=https://www.cnblogs.com/ncwuwsh/p/12732516.html">https://www.cnblogs.com/ncwuwsh/p/12732516.html</a>中的服务，可参看。</p>
<h1 id="网关服务"><a href="#网关服务" class="headerlink" title="网关服务"></a>网关服务</h1><p>从<a href="https://zshipu.com/t?url=https://start.spring.io/">https://start.spring.io/</a>下载一个原始的spring boot工程，如何下载就不在这里说了。添加依赖：</p>
<p> <a href="https://zshipu.com/t?url=javascript:void(0);" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　　　 <dependency><br>            <groupId>org.springframework.cloud</groupId><br>            <artifactId>spring-cloud-starter-gateway</artifactId><br>        </dependency><br>        <dependency><br>            <groupId>com.alibaba.cloud</groupId><br>            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId><br>            <version>2.2.1.RELEASE</version><br>        </dependency><br> <a href="https://zshipu.com/t?url=javascript:void(0);" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>注意，千万不要添加web依赖。</strong></p>
<p>配置文件可以使用properties，也可以使用yml格式。yml格式如下：</p>
<p> <a href="https://zshipu.com/t?url=javascript:void(0);" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>server:<br>  port: 8080<br>spring:<br>  application:<br>    name: api-gateway<br>  cloud:<br>    nacos:<br>      discovery:<br>        server-addr: 127.0.0.1:8848<br>    gateway:<br>      discovery:<br>        locator:<br>          enabled: true #表明gateway开启服务注册和发现的功能，并且spring cloud gateway自动根据服务发现为每一个服务创建了一个router，这个router将以服务名开头的请求路径转发到对应的服务。<br>          lower-case-service-id: true #是将请求路径上的服务名配置为小写（因为服务注册的时候，向注册中心注册时将服务名转成大写的了），比如以/service-hi/*的请求路径被路由转发到服务名为service-hi的服务上。<br>      routes:<br>        - id: gateway-service<br>          uri: lb://service-provider #此配置的值注册到Nacos中服务提供者的spring.application.name的值<br>          predicates:<br>            - Path=/provider/**<br> <a href="https://zshipu.com/t?url=javascript:void(0);" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p><strong>使用yml的同学，一定要去查下yml的一些规则，比如 ：后面，值的前面，一定要有空格，缩进不要使用tab键，而要用两个空格缩进等</strong></p>
<p>下面是properties格式配置文件：</p>
<p> <a href="https://zshipu.com/t?url=javascript:void(0);" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>server.port=8080<br>spring.application.name=api-gateway<br>spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848<br>#表明gateway开启服务注册和发现的功能，并且spring cloud gateway自动根据服务发现为每一个服务创建了一个router，这个router将以服务名开头的请求路径转发到对应的服务。<br>spring.cloud.gateway.discovery.locator.enabled=true<br>#是将请求路径上的服务名配置为小写（因为服务注册的时候，向注册中心注册时将服务名转成大写的了），比如以/service-hi/*的请求路径被路由转发到服务名为service-hi的服务上。<br>spring.cloud.gateway.discovery.locator.lower-case-service-id=true<br>spring.cloud.gateway.routes[0].id=gateway-service<br>spring.cloud.gateway.routes[0].uri=lb://service-provider<br>spring.cloud.gateway.routes[0].predicates[0]=Path=/provider/**<br> <a href="https://zshipu.com/t?url=javascript:void(0);" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>下面是网关的启动类：</p>
<p> <a href="https://zshipu.com/t?url=javascript:void(0);" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>package com.chris.gatewayrouter; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.cloud.gateway.route.RouteLocator; import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder; import org.springframework.context.annotation.Bean;</p>
<p>@SpringBootApplication<br>@EnableDiscoveryClient public class GatewayrouterApplication { public static void main(String[] args) {<br>        SpringApplication.run(GatewayrouterApplication.class, args);<br>    }</p>
<pre><code>@Bean public RouteLocator myRoutes(RouteLocatorBuilder builder) &#123; return builder.routes().build();
&#125;</code></pre>
<p>}<br> <a href="https://zshipu.com/t?url=javascript:void(0);" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>然后启动Nacos，服务提供者和网关服务，使用浏览器访问：<a href="https://zshipu.com/t?url=http://127.0.0.1:8080/provider/helloProvider">http://127.0.0.1:8080/provider/helloProvider</a></p>
<p>搞定。</p>
<p>网关服务的其他高级应用，自己去看官网吧。</p>
<p>官网是最好的老师</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-07-16T10:39:59.000Z" title="2020-07-16T10:39:59.000Z">2020-07-16</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.403Z" title="2020-09-08T14:03:00.403Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">5 分钟读完 (大约800个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/16/Spring%20Cloud+nacos+Feign%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/">Spring Cloud+nacos+Feign，实现注册中心及配置中心</a></h1><div class="content"><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>注册中心、配置中心的概念就不在这里解释了。发现服务原来一直用的是Eureka，因为这家伙闭源了，不爽。然后就发现了nacos，阿里巴巴的，好东西，一个搞定注册中心和配置中心。官网：<a href="https://zshipu.com/t?url=https://nacos.io/en-us/">https://nacos.io/en-us/</a>。官网的手册比较入门可以，实用化还需要结合项目。接下来简单介绍下如何使用nacos搭建注册中心和服务中心。</p>
<p>在进行下面操作前，自己去git上下载一个打包发布后的nacos服务，地址：<a href="https://zshipu.com/t?url=https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a>。Linux下载第一个，windows下载第二个。后面两个是源码。如何启动使用nacos，nacos官网说的很详细，不再赘述。</p>
<p><img src="https://img2020.cnblogs.com/blog/488159/202004/488159-20200419170916251-210044313.png"></p>
<h1 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h1><h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h2><p>从<a href="https://zshipu.com/t?url=https://start.spring.io/">https://start.spring.io/</a>下载一个原始的spring boot工程，别忘了添加Web依赖，如何下载就不在这里说了。添加依赖：</p>
<dependency>
　　<groupId>com.alibaba.cloud</groupId>
　　<artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
　　<version>2.2.1.RELEASE</version>
</dependency>

<p><strong>配置文件application.properties添加配置：</strong></p>
<p>server.port=8070<br>spring.application.name=service-provider<br>spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848</p>
<p><strong>启动类</strong>：</p>
<p><img src="https://img2020.cnblogs.com/blog/488159/202004/488159-20200419171707395-354987438.png"></p>
<p>** 添加一个测试用的Controller：**</p>
<p><img src="https://img2020.cnblogs.com/blog/488159/202004/488159-20200419171907016-978205314.png"></p>
<p> 至此，服务提供者完成。</p>
<h2 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h2><p>同服务提供者操作，下载一个原始的spring boot工程，添加依赖，<strong>注意，</strong>因为要使用feign调用服务提供者，要添加相应依赖：</p>
<dependency>
　　<groupId>com.alibaba.cloud</groupId>
　　<artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
　　<version>2.2.1.RELEASE</version>
</dependency>
　　<dependency>
　　<groupId>org.springframework.cloud</groupId>
　　<artifactId>spring-cloud-starter-openfeign</artifactId>
　　<version>2.2.2.RELEASE</version>
</dependency>

<p><strong>配置文件application.properties添加配置：</strong></p>
<p>server.port=8080<br>spring.application.name=service-consumer<br>spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848</p>
<p><strong>启动类：</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/488159/202004/488159-20200419172450332-632021520.png"></p>
<p> <strong>添加feign的client：</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/488159/202004/488159-20200419172628432-906108239.png"></p>
<p> <strong>添加测试controller：</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/488159/202004/488159-20200419172659471-520990514.png"></p>
<p> 准备工作完成，启动nacos、服务提供者，服务消费者。全部启动成功后，就可以在nacos的控制台界面里看到两个已经注册进去的服务：</p>
<p><img src="https://img2020.cnblogs.com/blog/488159/202004/488159-20200419173019549-744122355.png"></p>
<p> 直接使用浏览器访问：<a href="https://zshipu.com/t?url=http://127.0.0.1:8080/consumer/hello-consumer">http://127.0.0.1:8080/consumer/hello-consumer</a>。</p>
<h1 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h1><p>直接在上面的<strong>服务提供者</strong>中使用nacos的配置中心。添加依赖：</p>
<dependency>
　　<groupId>com.alibaba.cloud</groupId>
　　<artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
　　<version>2.2.1.RELEASE</version>
</dependency>

<p>在Controller添加以下注解及代码，并修改接口：</p>
<p><img src="https://img2020.cnblogs.com/blog/488159/202004/488159-20200419173654043-1739993602.png"></p>
<p> <strong>配置文件application.properties添加配置：</strong></p>
<p>spring.cloud.nacos.config.server-addr=127.0.0.1:8848</p>
<p>重启服务提供者。</p>
<p> 在nacos控制台界面的【配置列表】中添加配置：</p>
<p><img src="https://img2020.cnblogs.com/blog/488159/202004/488159-20200419173825984-1788722329.png"></p>
<p> <img src="https://img2020.cnblogs.com/blog/488159/202004/488159-20200419174208593-620819795.png"></p>
<p> 发布后，再访问<a href="https://zshipu.com/t?url=http://127.0.0.1:8080/consumer/hello-consumer">http://127.0.0.1:8080/consumer/hello-consumer</a>。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>简单介绍了如何使用，至于用到的注解有什么用，大家自行百度。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-07-16T10:32:26.000Z" title="2020-07-16T10:32:26.000Z">2020-07-16</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.386Z" title="2020-09-08T14:03:00.386Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">5 分钟读完 (大约796个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/16/Nacos%E4%BD%9C%E4%B8%BA%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%97%B6%EF%BC%8C%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AAdataId%E7%9A%84%E9%85%8D%E7%BD%AE/">Nacos作为配置中心时，多个服务共用一个dataId的配置</a></h1><div class="content"><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文是对我之前一篇文章《<a href="https://zshipu.com/t?url=https://www.cnblogs.com/ncwuwsh/p/12732516.html">Spring Cloud+nacos+Feign，实现注册中心及配置中心</a>》的补充。此文章中简单写了如何将Nacos作为配置中心。在使用配置中心时，我们会遇到一种情况：多个微服务中有相同的配置，在配置中心中我们也就希望使用同一个dataId的配置。本文就是说明如何解决这个问题的。</p>
<h1 id="多服务共用一个dataId"><a href="#多服务共用一个dataId" class="headerlink" title="多服务共用一个dataId"></a>多服务共用一个dataId</h1><p>关于dataId，Nacos官网是这么解释的：</p>
<p><strong>在 Nacos Spring Cloud 中，<code>dataId</code> 的完整格式如下：</strong></p>
<p><strong><code>$&#123;prefix&#125;-$&#123;spring.profile.active&#125;.$&#123;file-extension&#125;</code></strong> </p>
<ul>
<li><strong><code>prefix</code> 默认为 <code>spring.application.name</code> 的值，也可以通过配置项 <code>spring.cloud.nacos.config.prefix</code>来配置。</strong></li>
<li><strong><code>spring.profile.active</code> 即为当前环境对应的 profile，详情可以参考 <a href="https://zshipu.com/t?url=https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html#boot-features-profiles">Spring Boot文档</a>。 注意：当 <code>spring.profile.active</code> 为空时，对应的连接符 <code>-</code> 也将不存在，dataId 的拼接格式变成 <code>$&#123;prefix&#125;.$&#123;file-extension&#125;</code></strong></li>
<li><strong><code>file-exetension</code> 为配置内容的数据格式，可以通过配置项 <code>spring.cloud.nacos.config.file-extension</code> 来配置。目前只支持 <code>properties</code> 和 <code>yaml</code> 类型</strong></li>
</ul>
<p>上面的这段写的明白，我们可以用spring.cloud.nacos.config.prefix来替代spring.application.name的值。看到这里，大家肯定会认为，如果要多个服务共用一个dataId的配置，我将多个服务的spring.cloud.nacos.config.prefix写成一样的不就可以了吗？然后兴高采烈的去配置文件里做了这个配置，再启动程序，然后测试，可郁闷的发现，没有起作用。。。。。。。。，是不是很伤心，官方文档明明这么写的，却不起作用。</p>
<p>之所以没有起作用，是因为官方文档里虽然写了用spring.cloud.nacos.config.prefix配置，但没有写在哪里写这个配置，大家往往根据经验，写在了application.properties中，不对的，文档里没写，<strong>这个配置是要写在bootstrap.properties中</strong>，工程中没有这个文件？那就自己新建一个，和application.properties在相同路径下。</p>
<p>下面是我代码中的配置，我用的yaml格式，其他代码，参照《<a href="https://zshipu.com/t?url=https://www.cnblogs.com/ncwuwsh/p/12732516.html">Spring Cloud+nacos+Feign，实现注册中心及配置中心</a>》</p>
<p> <a href="https://zshipu.com/t?url=javascript:void(0);" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>server:<br>  port: 7080 spring:<br>  cloud:<br>    nacos:<br>      discovery:<br>        server-addr: 127.0.0.1:8848 config:<br>        server-addr: 127.0.0.1:8848 <strong>prefix: chris</strong><br>        <strong>file**</strong>-<strong>**extension: yaml</strong><br>  application:<br>    name: demo2<br> <a href="https://zshipu.com/t?url=javascript:void(0);" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>Nacos对应的截图为：</p>
<p><img src="https://img2020.cnblogs.com/blog/488159/202005/488159-20200503220521867-608456388.png"></p>
<p> <img src="https://img2020.cnblogs.com/blog/488159/202005/488159-20200503220601772-389015988.png"></p>
<p> 上图中，两个箭头所指要注意：配置格式选择了YAML，配置内容就要按照YAML格式来写，配置格式选择了Properties，配置内容要按照Properties来写，不要搞错了。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-07-16T09:34:29.000Z" title="2020-07-16T09:34:29.000Z">2020-07-16</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.405Z" title="2020-09-08T14:03:00.405Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">6 分钟读完 (大约833个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/16/SpringCloudAlibaba(%E4%B8%89)%EF%BC%9A%E4%BD%BF%E7%94%A8Nacos%E4%BD%9C%E4%B8%BA%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/">SpringCloudAlibaba(三)：使用Nacos作为配置中心</a></h1><div class="content"><p> 之前提到了这次从php技术栈迁移到java技术栈要解决的一个问题就是集中化配置管理。</p>
<p>我们为什么会有配置中心的需求?</p>
<ol>
<li>配置管理变更较为方便</li>
<li>合理控制配置的权限内容</li>
</ol>
<h3 id="Nacos-控制台增加配置文件"><a href="#Nacos-控制台增加配置文件" class="headerlink" title="Nacos 控制台增加配置文件"></a><a name="t0"></a><a name="t0"></a>Nacos 控制台增加配置文件</h3><ol>
<li>进入Nacos管理界面,在【配置管理】-【配置列表】功能页面点击右上角的 + 号。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2NhaW5nYW8uYW55ZGF0YS50b3AvYXNzZXRzL2ltZy9zcHJpbmdjbG91ZGFsaWJhYmEvMy9uYWNvc193ZWJfY29uZmlnX2NvbnNvbGUucG5n?x-oss-process=image/format,png"></li>
<li>进入 新建配置 页面，填写要新增的配置内容<img src="https://img-blog.csdnimg.cn/20200509214305127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1MzIxMDU=,size_16,color_FFFFFF,t_70"></li>
<li><strong>WARN</strong>:Data ID的默认扩展名为<strong>properties</strong>,如果需要使用yaml格式则需要指明是 <strong>.yaml</strong></li>
<li>发布配置 配置完成后点击发布,即可在配置列表中看到刚才新增的配置</li>
</ol>
<h3 id="创建Nacos-Config客户端"><a href="#创建Nacos-Config客户端" class="headerlink" title="创建Nacos Config客户端"></a><a name="t1"></a><a name="t1"></a>创建Nacos Config客户端</h3><ol>
<li>新建项目,由于使用SpringCloudAlibaba直接引用相关依赖 ```xml</li>
</ol>
<p>com.alibaba.cloud spring-cloud-starter-alibaba-nacos-config org.springframework.boot spring-boot-starter-web</p>
<pre><code class="1.">
2.  *   启动类

3.  ```java

4.  @SpringBootApplication

5.  public class NacosConfigApplication &#123;

6.  public static void main(String[] args) &#123;

7.  SpringApplication.run(NacosConfigApplication.class,args);

8.  &#125;

9.  &#125;``` 

*   Controller ```1.  @RefreshScope

   2.  @RestController

   3.  @RequestMapping(&quot;/config&quot;)

   4.  public class ConfigController &#123;

   5.  @Value(&quot;$&#123;useLocalCache:false&#125;&quot;)

   6.  private boolean useLocalCache;

   8.  @Value(&quot;$&#123;name&#125;&quot;)

   9.  private String name;

   11.  @RequestMapping(&quot;/get&quot;)

   12.  public boolean get() &#123;

   13.  return useLocalCache;

   14.  &#125;

   16.  @RequestMapping(&quot;/name&quot;)

   17.  public String name()&#123;

   18.  return name;

   19.  &#125;

   20.  &#125;``` 

   **@RefreshScope**在这里的作用就是让配置内容支持动态刷新，也就是当应用运行中，我们在Nacos控制台修改了配置之后这里也会动态的更新。

1.  项目bootstrap.properties配置服务名称与Nacos地址 ```1.  # 配置中心url

   2.  spring.cloud.nacos.config.server-addr=localhost:8848

   3.  # 配置中心展现的服务名称

   4.  spring.application.name=nacos-config-example

   5.  #配置文件类型[TEXT,JSON,XML,YAML,HTML,Properties]

   6.  spring.cloud.nacos.config.file-extension=properties

   7.  # 配置分组,当前的业务基本选择为某些的GROUP,可以基于业务来划分不同的分组.

   8.  spring.cloud.nacos.config.group=DEFAULT_GROUP

   9.  # 默认选择的配置环境,当前把环境划分为4套, dev[开发环境],test[测试环境],pre[预发环境],prod[生产环境]

   10.  spring.profiles.active=dev``` 

   **WARN** 多环境配置中需要指定Nacos namespace的id，而不是指定namespace的名称

2.  启动应用程序并进行验证
   *   启动应用
       ![](https://img-blog.csdnimg.cn/20200509214405511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1MzIxMDU=,size_16,color_FFFFFF,t_70)
   *   发送请求测试配置是否生效
       ![](https://imgconvert.csdnimg.cn/aHR0cDovL2NhaW5nYW8uYW55ZGF0YS50b3AvYXNzZXRzL2ltZy9zcHJpbmdjbG91ZGFsaWJhYmEvMy9uYWNvc193ZWJfY29uZmlnX3Rlc3QucG5n?x-oss-process=image/format,png)
   *   修改配置进行进行动态刷新
       进入Nacos控制台修改配置信息,name修改为bigData 再次进行测试
       ![](https://imgconvert.csdnimg.cn/aHR0cDovL2NhaW5nYW8uYW55ZGF0YS50b3AvYXNzZXRzL2ltZy9zcHJpbmdjbG91ZGFsaWJhYmEvMy9uYWNvc193ZWJfY29uZmlnX3JlZnJlc2gucG5n?x-oss-process=image/format,png)
       再次发送请求
       ![](https://imgconvert.csdnimg.cn/aHR0cDovL2NhaW5nYW8uYW55ZGF0YS50b3AvYXNzZXRzL2ltZy9zcHJpbmdjbG91ZGFsaWJhYmEvMy9uYWNvc193ZWJfY29uZmlnX3Rlc3RfcmVmcmVzaC5wbmc?x-oss-process=image/format,png)

至此使用Nacos作为配置中心已经完全搞定,并且也实现了多环境的配置。多环境有几种方式实现，但是我依然习惯使用namespace的方式来实现。
**源码:**

```1.  github: https://github.com/CainGao/SpringCloudAlibabaExample 

3.  码云:   https://gitee.com/CainGao/SpringCloudAlibabaExample```</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-07-16T09:31:53.000Z" title="2020-07-16T09:31:53.000Z">2020-07-16</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.385Z" title="2020-09-08T14:03:00.385Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">15 分钟读完 (大约2252个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/16/Nacos%20%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/">Nacos 集群部署</a></h1><div class="content"><p><strong>阅读目录</strong></p>
<ul>
<li><a href="https://zshipu.com/t?url=#_label0">准备数据库</a></li>
<li><a href="https://zshipu.com/t?url=#_label1">准备nacos</a></li>
<li><a href="https://zshipu.com/t?url=#_label2">观察集群</a></li>
<li><a href="https://zshipu.com/t?url=#_label3">Nacos + Docker 集群</a></li>
<li><a href="https://zshipu.com/t?url=#_label4">通过Nginx配置真正的集群</a></li>
<li><a href="https://zshipu.com/t?url=#_label5">其他注意事项</a></li>
</ul>
<p>关于nacos 集群部署，网上的示例往往不全或不可用，而官方的教程太简单了。官方也提供了一个 docker  + nacos 的伪集群的 部署示例。但毕竟是 伪， 不能实际生产使用。</p>
<p>全网就几乎就没有一个 完整的教程？？？！！！</p>
<p>怎么办呢？ 自己动手吧。</p>
<p> <a name="_label0"></a></p>
<h2 id="准备数据库"><a href="#准备数据库" class="headerlink" title="准备数据库"></a>准备数据库</h2><p>数据库用了 mysql， 其实nacos 也是支持mysql  主从集群的，不过简单起见， 这里就只用了一个 mysql 节点。 mysql 是需要自己事先安装 配置的（需要执行 nacos 提供的 conf/nacos-mysql.sql 脚本）</p>
<p>这个其实很简单。schema 名字不重要，重要的是 执行 nacos 的sql 脚本就好了。</p>
<p> <a name="_label1"></a></p>
<h2 id="准备nacos"><a href="#准备nacos" class="headerlink" title="准备nacos"></a>准备nacos</h2><p>一般集群需要至少3个节点。我们先准备3台机器： 192.168.11.200、192.168.11.196、192.168.11.126</p>
<p>nacos 的默认服务端口是 8848 ，但是由于 我们的机器上还有其他nacos 服务正在作用，所以， 我们这里把端口改为 8748， 如下：</p>
<p>192.168.11.200:8748<br>192.168.11.196:8748<br>192.168.11.126:8748</p>
<p>我们需要nacos-server 的安装包， 1.0.0.zip 版本并没有 集群的展示功能， 我们这里使用 nacos-server-1.1.0.zip， 这个也是最新的 nacos server 安装包。 （从github 上下载非常耗时， 最好把这个安装包 共享起来）</p>
<p>安装目录是 /app， 没有的话， 需要自己创建。 将nacos-server-1.1.0.zip 上传到 /app 目录， 然后进入cd /app,</p>
<p>执行下面的 shell （需要3个节点上都要执行！！）：</p>
<p>unzip nacos-server-1.1.0.zip  -d nacos-cluster  &amp;&amp; cd nacos-cluster/nacos  &amp;&amp; cp conf/cluster.conf.example  conf/cluster.conf  &amp;&amp; </p>
<p>echo “192.168.11.200:8748<br>192.168.11.196:8748<br>192.168.11.126:8748” &gt;  conf/cluster.conf  &amp;&amp; sed -i s/server.port=8848/server.port=8748/  conf/application.properties  &amp;&amp; echo “</p>
<p>spring.datasource.platform=mysql</p>
<p>db.num=1<br>db.url.0=jdbc:mysql://192.168.11.200:3316/test3?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true<br>db.user=root<br>db.password=123456”  &gt;&gt; conf/application.properties  &amp;&amp; sh bin/startup.sh</p>
<p>上面的脚本，需要按照情况修改， 主要是其中的 端口、 数据库配置。  上面的脚本 包括了 启动 nacos。 </p>
<p>如果 3个节点都能正常访问了，那么就表明集群部署基本正常了，如果有问题， 那么可以查看nacos 的日志， 位于  logs目录， 主要 是下面几个日志文件：</p>
<p>/app/nacos-cluster/nacos/start.out<br>/app/nacos-cluster/nacos/nacos.out<br>/app/nacos-cluster/nacos/naming-raft.out</p>
<p> <a name="_label2"></a></p>
<h2 id="观察集群"><a href="#观察集群" class="headerlink" title="观察集群"></a>观察集群</h2><p>3个节点都正常启动之后， 可以分别登录 各个web 界面查看 集群的节点、健康状态：</p>
<p><a href="https://zshipu.com/t?url=http://192.168.11.196:8748/nacos/#/clusterManagement?dataId=&group=&appName=&namespace=&serverId=">http://192.168.11.126:8748/nacos/#/clusterManagement?dataId=&amp;group=&amp;appName=&amp;namespace=&amp;serverId=</a></p>
<p><a href="https://zshipu.com/t?url=http://192.168.11.196:8748/nacos/#/clusterManagement?dataId=&group=&appName=&namespace=&serverId=">http://192.168.11.196:8748/nacos/#/clusterManagement?dataId=&amp;group=&amp;appName=&amp;namespace=&amp;serverId=</a></p>
<p><a href="https://zshipu.com/t?url=http://192.168.11.196:8748/nacos/#/clusterManagement?dataId=&group=&appName=&namespace=&serverId=">http://192.168.11.200:8748/nacos/#/clusterManagement?dataId=&amp;group=&amp;appName=&amp;namespace=&amp;serverId=</a></p>
<p>最开始的时候， 所有节点都没有启动， 集群任期 应该都是0 </p>
<p><img src="https://img2018.cnblogs.com/blog/493842/201907/493842-20190717151727270-1463276167.png"></p>
<p>（看到这个图片， 说明 3个节点都正常启动了， 否则请检查是否有步骤遗漏了！）</p>
<p>如果我们只启动一个节点，那么它的状态会是 candidate：</p>
<p><img src="https://img2018.cnblogs.com/blog/493842/201907/493842-20190717151734612-266677501.png"></p>
<p>处于candidate 状态的 集群会一直进行选举， 从而任期也会一直增加：</p>
<p><img src="https://img2018.cnblogs.com/blog/493842/201907/493842-20190717151741138-1049330699.png"></p>
<p>最先启动的节点， 一般就是 leader ， 但这个时候还只是 准leader，需要至少多数节点都启动了， 才能做一个决断。如下面的 126：</p>
<p><img src="https://img2018.cnblogs.com/blog/493842/201907/493842-20190717151750417-1553732482.png"></p>
<p>在没有leader 产生之前， 集群会进行多次的选举。 每次的选举 任期会加1。 从而 最后会进行大概 2次的选举， 从而 126 的任期是2；最后加入的 节点已经没有了选举的机会， 故直接作为 follower 加入， 其任期默认是0；</p>
<p>如果某一个或某几个节点都挂了， 只要剩余节点不少于 1+ 1/N ，那么 集群仍然能够正常运行； 挂掉的节点重新加入集群后，如果此时集群已经有了leader， 那么它的角色一般是follower， 它的任期是0（ 就跟一个新节点一样的）；</p>
<p>当然，如果集群的剩余节点少于 1+ 1/N，集群仍然是可以工作的，只是已经无法保证 高可用了。</p>
<p>任期低节点一般是没有资格参与选举的，leader 一般是在 任期高的几个节点之中产生（至少会有2个节点）。</p>
<p><img src="https://img2018.cnblogs.com/blog/493842/201907/493842-20190717151757830-1661146717.png"></p>
<p>如果把126 的nacos 杀掉，我们会观察到 多个leader，其实这个时候的 126 已经死了， 至少集群保留它之前的状态。同时 集群会重新选举，如下，我们看到200 被选举为 leader，126 的状态被保留（其实他已经死掉了）， 同时任期 +1：</p>
<p><img src="https://img2018.cnblogs.com/blog/493842/201907/493842-20190717151802465-652359809.png"></p>
<p>在已经存在leader 的集群中，如果挂掉的节点不是 leader，那么不会重新进行选举。 挂掉的节点虽不可用（其状态会一直保留直到重启）， 不会影响集群的使用。</p>
<p>如果我们又把 126 启动起来， 那么它的角色会是 follower，任期是0：</p>
<p><img src="https://img2018.cnblogs.com/blog/493842/201907/493842-20190717151808708-141563613.png"></p>
<p>我们再把 200 的nacos 杀掉， 那么又会产生新的 leader：</p>
<p><img src="https://img2018.cnblogs.com/blog/493842/201907/493842-20190717151816018-1280785062.png"></p>
<p> <a name="_label3"></a></p>
<h2 id="Nacos-Docker-集群"><a href="#Nacos-Docker-集群" class="headerlink" title="Nacos + Docker 集群"></a>Nacos + Docker 集群</h2><p>nacos 官方 <a target="_blank" rel="noopener" href="https://hub.docker.com/r/nacos/nacos-server">https://hub.docker.com/r/nacos/nacos-server</a>  有提供docker 的镜像：nacos/nacos-server，我们拿来用即可：</p>
<p>docker run –name nacos  –net=host –env MODE=cluster –env NACOS_SERVERS=”192.168.11.126:8748 192.168.11.196:8748 192.168.11.200:8748” –env MYSQL_DATABASE_NUM=1 –env MYSQL_MASTER_SERVICE_HOST=192.168.11.200 –env MYSQL_MASTER_SERVICE_PORT=3316 –env MYSQL_MASTER_SERVICE_DB_NAME=test3 –env MYSQL_MASTER_SERVICE_USER=root –env MYSQL_MASTER_SERVICE_PASSWORD=123456 –env NACOS_SERVER_PORT=8848 -d -p 8748:8848 nacos/nacos-server</p>
<p>上面的语句即启动了 docker nacos ，同时通过env 设置了所有的相关的参数 比如数据库、端口等。 特别需要注意的是， 网络模式是 host，也就是使用直接宿主机的网络， 这个是最简单的nacos +docker 集群，否则我们可能需要做比较多的docker网络配置。 另外注意，  –net=host 应该放在命令的前面， 不能放最后， 否则不会生效。</p>
<p>NACOS_SERVERS 是所有的节点+端口 配置，目前只能写死， nacos 不提供自动扩容等功能。</p>
<p>如果配置有误，我们只能删除nacos 容器，重新配置 ： docker stop nacos &amp;&amp; docker rm nacos 。</p>
<p>3个节点都执行上面的命令之后，我们的nacos 集群就做好了！</p>
<p> <a name="_label4"></a></p>
<h2 id="通过Nginx配置真正的集群"><a href="#通过Nginx配置真正的集群" class="headerlink" title="通过Nginx配置真正的集群"></a>通过Nginx配置真正的集群</h2><p>上面的集群，虽然可用， 但仍不是真正的集群， 我们一般不会这么用。官方推荐，nacos集群一般有3种方式：</p>
<p><a href="http://ip1:port/openAPI">http://ip1:port/openAPI</a> 直连ip模式，机器挂则需要修改ip才可以使用。</p>
<p><a href="http://VIP:port/openAPI">http://VIP:port/openAPI</a> 挂载VIP模式，直连vip即可，下面挂server真实ip，可读性不好。</p>
<p><a href="http://nacos.com:port/openAPI">http://nacos.com:port/openAPI</a> 域名 + VIP模式，可读性好，而且换ip方便，推荐模式</p>
<p>域名的方式比较麻烦，暂不考虑。vip 的方式也稍稍麻烦。 这里我使用 nginx 的方式。 nginx 做集群很简单， 只要 nginx.conf 做如下的配置就好了：</p>
<p>upstream nacos_server {<br>server 192.168.11.200:8748;<br>server 192.168.11.196:8748;<br>server 192.168.11.126:8748;<br>}</p>
<p>server {<br>listen 8648;<br>server_name localhost;<br>#charset koi8-r;<br>#access_log logs/host.access.log main;<br>location / {<br>proxy_pass <a target="_blank" rel="noopener" href="http://nacos_server/">http://nacos_server</a>;<br>index index.html index.htm;<br>}<br>}</p>
<p>8648 的nginx 提供的 nacos 服务接口，可以自定义。 我们访问 </p>
<p>192.168.11.139:8648/nacos/#/clusterManagement?dataId=&amp;group=&amp;appName=&amp;namespace=&amp;serverId=</p>
<p>，就可以看到：</p>
<p><img src="https://img2018.cnblogs.com/blog/493842/201907/493842-20190717151826015-620927747.png"></p>
<p>我们可以简单测试一下，杀掉 126 或 196 上的 nacos ，看服务是否正常。 后面，我们对微服务提供nacos服务的时候，只要配置这个nginx 端口就好了！！</p>
<p> <a name="_label5"></a></p>
<h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><p>nacos 默认是需要登录， 有些麻烦，开发测试的时候，我们可以把它关闭，怎么办呢？ 修改 conf/application.properties 的相关配置即可：</p>
<h3 id="turn-off-security"><a href="#turn-off-security" class="headerlink" title="turn off security"></a>turn off security</h3><p>spring.security.enabled=false<br>management.security=false<br>security.basic.enabled=false<br>nacos.security.ignore.urls=/**</p>
<p>#nacos.security.ignore.urls=/,/<strong>/<em>.css,/**/</em>.js,/</strong>/<em>.html,/**/</em>.map,/<strong>/<em>.svg,/**/</em>.png,/</strong>/*.ico,/console-fe/public/<strong>,/v1/auth/login,/v1/console/health/</strong>,/v1/cs/<strong>,/v1/ns/</strong>,/v1/cmdb/<strong>,/actuator/</strong>,/v1/console/server/**</p>
<p>另外，我们发现 nacos 的日志实在增长太快， 可以tomcat.accesslog 关闭： </p>
<p>server.tomcat.accesslog.enabled=true – 改为false </p>
<p>另外，我们可以把 日志级别调整一下，修改 conf/nacos-logback.xml 即可。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html</a></p>
<p><a target="_blank" rel="noopener" href="https://hub.docker.com/r/nacos/nacos-server">https://hub.docker.com/r/nacos/nacos-server</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-07-16T09:26:15.000Z" title="2020-07-16T09:26:15.000Z">2020-07-16</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.406Z" title="2020-09-08T14:03:00.406Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">10 分钟读完 (大约1550个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/16/SpringCloudAlibaba(%E4%BA%8C)%EF%BC%9ANacos%E4%BB%8B%E7%BB%8D%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/">SpringCloudAlibaba(二)：Nacos介绍与环境安装</a></h1><div class="content"><p> SpringCloud alibaba在之前已经进行了大概的介绍,在微服务环境下对于大量存在的服务管理等肯定需要一个统一的服务注册中心，同时也由于之前提到的集中式配置中心的需求。那么在SpringCloud alibaba中最优的选择就是Nacos。</p>
<h3 id="什么是Nacos"><a href="#什么是Nacos" class="headerlink" title="什么是Nacos?"></a><a name="t0"></a><a name="t0"></a>什么是Nacos?</h3><p>Nacos用于服务的注册发现与服务的配置管理。Nacos提供了简单易用的Web Console。可以帮助开发者快速的实现服务发现、服务配置管理、服务元数据等需求。<br>它类似于Dubbo的zookeeper注册中心、SpringCloud 的Eureka等。同时又支持了分布式服务配置管理等特点。</p>
<h3 id="Nacos的关键特性"><a href="#Nacos的关键特性" class="headerlink" title="Nacos的关键特性"></a><a name="t1"></a><a name="t1"></a>Nacos的关键特性</h3><ul>
<li><p>服务注册发现与健康检查</p>
</li>
<li><p>动态配置管理，可视化管理界面</p>
</li>
<li><p>动态DNS</p>
</li>
<li><p>服务及元数据管理</p>
</li>
</ul>
<h3 id="Nacos-地图"><a href="#Nacos-地图" class="headerlink" title="Nacos 地图"></a><a name="t2"></a><a name="t2"></a>Nacos 地图</h3><p><img src="https://img-blog.csdnimg.cn/20200508174625934.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1MzIxMDU=,size_16,color_FFFFFF,t_70"></p>
<h3 id="Nacos生态图"><a href="#Nacos生态图" class="headerlink" title="Nacos生态图"></a><a name="t3"></a><a name="t3"></a>Nacos生态图</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS83OTkwYjU2Yi1kYmVkLTQzNGEtOTU2OC1kMjEyZjJlZDM4ZGIucG5n?x-oss-process=image/format,png"></p>
<h3 id="Nacos基础架构与概念"><a href="#Nacos基础架构与概念" class="headerlink" title="Nacos基础架构与概念"></a><a name="t4"></a><a name="t4"></a>Nacos基础架构与概念</h3><h3 id=""><a href="#" class="headerlink" title=""></a><a name="t5"></a><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9iZWFkNWQ3My02NzFiLTRkOTQtYWU0Ny1lMWM5YWQwMDZkYzAuanBlZw?x-oss-process=image/format,png"></h3><ul>
<li><p>服务 (Service)<br>服务是指一个或一组软件功能（例如特定信息的检索或一组操作的执行），其目的是不同的客户端可以为不同的目的重用（例如通过跨进程的网络调用）。Nacos 支持主流的服务生态，如 Kubernetes Service、gRPC|Dubbo RPC Service 或者 Spring Cloud RESTful Service.</p>
</li>
<li><p>服务注册中心 (Service Registry)<br>服务注册中心，它是服务，其实例及元数据的数据库。服务实例在启动时注册到服务注册表，并在关闭时注销。服务和路由器的客户端查询服务注册表以查找服务的可用实例。服务注册中心可能会调用服务实例的健康检查 API 来验证它是否能够处理请求。</p>
</li>
<li><p>服务元数据 (Service Metadata)<br>服务元数据是指包括服务端点(endpoints)、服务标签、服务版本号、服务实例权重、路由规则、安全策略等描述服务的数据</p>
</li>
<li><p>服务提供方 (Service Provider)<br>是指提供可复用和可调用服务的应用方</p>
</li>
<li><p>服务消费方 (Service Consumer)<br>是指会发起对某个服务调用的应用方</p>
</li>
<li><p>配置 (Configuration)<br>在系统开发过程中通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在。目的是让静态的系统工件或者交付物（如 WAR，JAR 包等）更好地和实际的物理运行环境进行适配。配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成这个步骤。配置变更是调整系统运行时的行为的有效手段之一。</p>
</li>
<li><p>配置管理 (Configuration Management)<br>在数据中心中，系统中所有配置的编辑、存储、分发、变更管理、历史版本管理、变更审计等所有与配置相关的活动统称为配置管理。</p>
</li>
<li><p>名字服务 (Naming Service)<br>提供分布式系统中所有对象(Object)、实体(Entity)的“名字”到关联的元数据之间的映射管理服务，例如 ServiceName -&gt; Endpoints Info, Distributed Lock Name -&gt; Lock Owner/Status Info, DNS Domain Name -&gt; IP List, 服务发现和 DNS 就是名字服务的2大场景。</p>
</li>
<li><p>配置服务 (Configuration Service)<br>在服务或者应用运行过程中，提供动态配置或者元数据以及配置管理的服务提供者。</p>
</li>
</ul>
<h2 id="安装Nacos"><a href="#安装Nacos" class="headerlink" title="安装Nacos"></a><a name="t6"></a><a name="t6"></a>安装Nacos</h2><h3 id="1-预备环境准备"><a href="#1-预备环境准备" class="headerlink" title="1. 预备环境准备"></a><a name="t7"></a><a name="t7"></a>1. 预备环境准备</h3><p>nacos是依赖Java环境运行的,如果使用源码来编译运行Nacos那么需要首先准备Apache Maven环境。</p>
<pre><code class="1.">
2.  64 bit JDK1.8+；

3.  Maven 3.2+;``` 
### &lt;a name=&quot;t8&quot;&gt;&lt;/a&gt;&lt;a name=&quot;t8&quot;&gt;&lt;/a&gt;2\. 下载源码或安装包

可以选择使用源码或直接使用安装包的方式获取Nacos

```1.  从Github下载源码的方式

2.  git clone https://github.com/alibaba/nacos.git

3.  cd nacos/

4.  mvn -Prelease-nacos -Dmaven.test.skip=true clean install -U 

5.  ls -al distribution/target/

7.  // change the $version to your actual path

8.  cd distribution/target/nacos-server-$version/nacos/bin

10.  下载编译后的压缩包方式

11.  unzip nacos-server-$version.zip 或者 tar -xvf nacos-server-$version.tar.gz

12.  cd nacos/bin``` 
### &lt;a name=&quot;t9&quot;&gt;&lt;/a&gt;&lt;a name=&quot;t9&quot;&gt;&lt;/a&gt;3.配置MySql服务器

Nacos可以通过两种方式进行数据的持久化管理,1.JDK自带的Derby DB内存数据库 2.使用MySql数据库. 由于DerbyDB对于数据的展现不是很友好,所以我们选择MySql数据库。

```##初始化MySql数据库.``````下载解压Nacos后可以在 /conf目录下找到 nacos-mysql.sql 文件用于初始化MySql数据库.``````##修改Nacos连接配置``````选择 /conf/application.properties配置文件.``````找到 If user MySQL as datasource  修改如下配置信息```
```spring.datasource.platform=mysql```
```### Count of DB:``````db.num=1```
```### Connect URL of DB:``````db.url.0=jdbc:mysql://localhost:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true``````db.user=XXX``````db.password=XXXXXXX```
### &lt;a name=&quot;t10&quot;&gt;&lt;/a&gt;&lt;a name=&quot;t10&quot;&gt;&lt;/a&gt;4\. 启动服务器

Linux/Unix/Mac

启动命令(Standalone代表单机模式,非集群模式):

```sh startup.sh -m standalone```

如果您使用的是ubuntu系统，或者运行脚本报错提示[[符号找不到，可尝试如下运行

```bash startup.sh -m standalone```

Windows

启动命令

```cmd startup.cmd```
### &lt;a name=&quot;t11&quot;&gt;&lt;/a&gt;&lt;a name=&quot;t11&quot;&gt;&lt;/a&gt;5\. Web Console

Nacos的默认端口为8848，启动完成后可以通过访问 http://localhost:8848/nacos 进入web控制台,默认帐号密码为 nacos/nacos

### &lt;a name=&quot;t12&quot;&gt;&lt;/a&gt;&lt;a name=&quot;t12&quot;&gt;&lt;/a&gt;6\. 服务注册发现管理

*   服务注册
   _curl -X POST &#39;http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=8080&#39;_

*   服务发现
   _curl -X GET &#39;http://127.0.0.1:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName&#39;_

*   发布配置
   _curl -X POST &quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld&quot;_

*   获取配置
   _curl -X GET &quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&quot;_

### &lt;a name=&quot;t13&quot;&gt;&lt;/a&gt;&lt;a name=&quot;t13&quot;&gt;&lt;/a&gt;7\. 关闭服务器

Linux/Unix/Mac

```sh shutdown.sh```

Windows

```cmd shutdown.cmd```

或者双击shutdown.cmd运行文件。</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-07-16T09:23:13.000Z" title="2020-07-16T09:23:13.000Z">2020-07-16</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.405Z" title="2020-09-08T14:03:00.405Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">7 分钟读完 (大约1011个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/16/SpringCloudAlibaba(%E4%B8%80)%EF%BC%9A%E6%A6%82%E8%BF%B0%E4%B8%8E%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6/">SpringCloudAlibaba(一)：概述与重要组件</a></h1><div class="content"><h3 id="SpringCloudAlibaba是什么？"><a href="#SpringCloudAlibaba是什么？" class="headerlink" title="SpringCloudAlibaba是什么？"></a><a name="t0"></a><a name="t0"></a>SpringCloudAlibaba是什么？</h3><p><strong>SpringCloud Alibaba是Alibaba结合自身的微服务实践开源的一套微服务全家桶</strong>，在SpringCloud项目中进行孵化并且毕业。既然是SpringCloud的项目那么阿里云其实包含其商业化的产品。 例如Nacos在阿里云就有其商业化的版本 <strong>MSE</strong>。 同时SpringCloud Alibaba的相关组件是经历过双十一大促考验的产品。稳定性较高。</p>
<h3 id="SpringCloud-Alibaba与SpringCloud"><a href="#SpringCloud-Alibaba与SpringCloud" class="headerlink" title="SpringCloud Alibaba与SpringCloud"></a><a name="t1"></a><a name="t1"></a>SpringCloud Alibaba与SpringCloud</h3><p>SpringCloud Alibaba是SpringCloud的子项目，其实很多相关的文章都提到了SpringCloud Alibaba与SpringCloud的关系，其中有很多的论点都比较有意思。大家可以去搜索一下。<br>SpringCloud Alibaba是依赖SpringCloud相关的标准实现的一套微服务的架构。结合阿里巴巴的相关实践与阿里云的相关服务实现的一些组件得以更快的实现相关产品业务。</p>
<h3 id="SpringCloud-Alibaba主要功能"><a href="#SpringCloud-Alibaba主要功能" class="headerlink" title="SpringCloud Alibaba主要功能"></a><a name="t2"></a><a name="t2"></a>SpringCloud Alibaba主要功能</h3><ul>
<li><strong>分布式配置</strong><br>分布式系统的外部配置管理，配置中心可视化、分环境配置控制。配置动态更新能力。</li>
<li><strong>服务注册与发现</strong><br>适配SpringCloud标准的服务注册与服务发现管理。</li>
<li><strong>服务限流与降级</strong><br>可通过控制台进行实时的修改限流降级的规则，实时的Metrics监控。支持多种协议</li>
<li><strong>消息驱动</strong><br>基于RocketMQ实现消息驱动的业务场景开发。</li>
<li><strong>分布式事物</strong> 开源Seata使用@GlobalTransactional注解，零侵入的实现分布式事物的支持。</li>
</ul>
<h3 id="SpringCloud-Alibaba核心组件"><a href="#SpringCloud-Alibaba核心组件" class="headerlink" title="SpringCloud Alibaba核心组件"></a><a name="t3"></a><a name="t3"></a>SpringCloud Alibaba核心组件</h3><p>Nacos (配置中心与服务注册与发现)</p>
<p>Nacos实现了服务的配置中心与服务注册发现的功能，Nacos可以通过可视化的配置降低相关的学习与维护成本，实现动态的配置管理与分环境的配置中心控制。 同时Nacos提供了基于http/RCP的服务注册与发现功能。</p>
<p>Sentinel (分布式流控)</p>
<p>Sentinel是面向分布式微服务架构的轻量级高可用的流控组件，以流量作为切入点，从流量控制，熔断降级，系统负载保护等维度帮助用户保证服务的稳定性。常用与实现限流、熔断降级等策略。</p>
<p>RocketMQ (消息队列)</p>
<p>RocketMQ基于Java的高性能、高吞吐量的消息队列，在SpringCloud Alibaba生态用于实现消息驱动的业务开发，常见的消息队列有Kafka、RocketMQ、RabbitMQ等，相关的比较文档可以自行去翻阅。</p>
<p>Seata (分布式事物)</p>
<p>既然是微服务的产品，那么肯定会用到分布式事物。Seata就是阿里巴巴开源的一个高性能分布式事物的解决方案。</p>
<p>Dubbo (RPC)</p>
<p>Dubbo已经在圈内很火了,SpringCloud Alibaba基于上面提到的Nacos服务注册中心也同样整合了Dubbo。</p>
<p>其他</p>
<p>SpringCloud Alibaba还有一些其他的组件选择，例如schedulerX、SMS、OSS等。但是由于其主要是阿里云的商业化产品就不再过多的进行介绍。集成其商业化产品时才能用到。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a name="t4"></a><a name="t4"></a>总结</h3><p>SpringCloud Alibaba是基于SpringCloud标准由阿里巴巴实现的微服务全家桶，可插拔的方式实现组件的替换，在某些场景中我们需要的组件可以自由进行选择。例如需要分布式链路跟踪我们可以增加sleuth组件用于实现分布式链路跟踪业务等。<br>很多人提到SpringCloudAlibaba的商业问题，记得当年SpringCloudAlibaba推出第一版的时候我也评论了…卖产品全家桶。不可否认是有那么一些，但是其实它本身的很多组件又不一定非要选择商业版本。这个可以自由进行选择。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-07-09T06:39:53.000Z" title="2020-07-09T06:39:53.000Z">2020-07-09</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.377Z" title="2020-09-08T14:03:00.377Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">几秒读完 (大约91个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/09/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8300%E9%97%AE-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/">Java面试宝典300问 第一部分</a></h1><div class="content"><p><img src="https://blog.zshipu.com/tlg/images/pasted-367.png" alt="知识铺-pasted-367.png"><br><img src="https://blog.zshipu.com/tlg/images/pasted-368.png" alt="知识铺-pasted-368.png"><br><img src="https://blog.zshipu.com/tlg/images/pasted-369.png" alt="知识铺-pasted-369.png"><br><img src="https://blog.zshipu.com/tlg/images/pasted-370.png" alt="知识铺-pasted-370.png"><br><img src="https://blog.zshipu.com/tlg/images/pasted-371.png" alt="知识铺-pasted-371.png"><br><img src="https://blog.zshipu.com/tlg/images/pasted-372.png" alt="知识铺-pasted-372.png"><br><img src="https://blog.zshipu.com/tlg/images/pasted-373.png" alt="知识铺-pasted-373.png"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-07-09T05:50:49.000Z" title="2020-07-09T05:50:49.000Z">2020-07-09</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.344Z" title="2020-09-08T14:03:00.344Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">13 分钟读完 (大约1951个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/09/GraaphQL%E5%AE%9E%E6%88%98%EF%BC%9AGraphQL%20Mutations%20%E4%BA%94/">GraphQL实战：GraphQL Mutations 五</a></h1><div class="content"><p> 上周，我在这篇文章中描述了 GraphQL<a href="https://zshipu.com/t?url=https://dev.to/speratus/graphql-basics-3c0d">的基础知识</a>。我们介绍了 GraphQL 的基础知识以及用于设置和使用 GraphQL 的基本概念。本周，我报道了我上周留下的一篇关键文章：GraphQLMutations。</p>
<p> <font _mstmutation="1" _msthash="890708" _msttexthash="392743">#ruby#rails#graphql</font>](<a href="https://zshipu.com/t?url=/speratus/graphql-basics-3c0d">https://zshipu.com/t?url=/speratus/graphql-basics-3c0d</a>) </p>
<p>GraphQL Mutations允许开发人员修改存储在服务器上的数据。</p>
<p>GraphQL 不知道该怎么处理您发送给它的任何数据，因此我们必须具体告诉它，在创建的每个Mutations中应执行哪些操作。</p>
<h1 id="创建Mutations"><a href="#创建Mutations" class="headerlink" title="创建Mutations"></a><a href="https://zshipu.com/t?url=#creating-mutations"></a><font _mstmutation="1" _msthash="289380" _msttexthash="10900942">创建Mutations</font></h1><p><font _mstmutation="1" _msthash="277095" _msttexthash="583437725">GraphQL Gem 具有一个方便的生成器，我们可以用它来开始构建我们的Mutations。跳转到项目目录并运行以下命令：</font></p>
<code>
 rails g graphql:mutation create_topic
rails g graphql:mutation create_reply
rails g graphql:mutation create_like
</code> 

<p>每个命令都会创建一个新的命名Mutations。生成器需要的唯一参数是Mutations的名称。</p>
<p><font _mstmutation="1" _msthash="277953" _msttexthash="38131080">将以下代码添加到 ：</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app&#x2F;graphql&#x2F;mutations&#x2F;create_topic.rb</span><br></pre></td></tr></table></figure>


<code>
 module Mutations
  class CreateTopic < BaseMutation
    # just like queries, mutations return certain fields
    # in this case, the mutation returns a list of strings which are potential errors
    # and the topic that was created if the creation was successful
    field :errors, [String], null: false
    field :topic, Types::TopicType, null: true

<pre><code># mutations also take arguments, very similar to the way queries can take arguments
argument :user_id, ID, required: true
argument :title, String, required: true
argument :content, String, required: true

# Unlike queries, mutations must have a resolve method to tell
# GraphQL what to do with the mutation and the arguments it receives.
def resolve(title:, content:, user_id:)
  # In this case, we will create a new topic.
  topic = Topic.new(title: title, content: content, user_id: user_id)
  if topic.save
    &#123;
      topic: topic,
      errors: []
    &#125;
  else
    &#123;
      topic: nil,
      errors: topic.errors.full_messages
    &#125;
  end
end</code></pre>
<p>  end<br>end<br></code> </p>
<p><font _mstmutation="1" _msthash="290316" _msttexthash="89051209">字段、参数和方法占 GraphQL Mutations的大部分。</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolve</span><br></pre></td></tr></table></figure>


<p><font _mstmutation="1" _msthash="290615" _msttexthash="419175185">GraphQL 不知道如何自己处理多态关联，我们将添加一些专门用于解决这些问题的代码：</font></p>
<code>
 module Mutations
  class CreateReply < BaseMutation
    # As with create_topic, we have fields, arguments and a resolve method
    field :errors, [String], null: false
    field :reply, Types::ReplyType, null: false

<pre><code># We need to give the pieces of the polymorphic info that it needs to
# properly construct the association
argument :post_id, ID, required: true
# post_type tells Rails what kind of model to look for.
argument :post_type, String, required: true

argument :user_id, ID, required: true
argument :content, String, required: true

def resolve(post_id:, user_id:, content:, post_type:)
  # Use the Rails method `constantize` to turn a string into a constant
  # which we know should refer to an ActiveRecord model, allowing us to run
  # the ActiveRecord method `find_by` to get the correct object with that type
  type = post_type.constantize
  post = type.find_by(id: post_id)
  reply = Reply.new(content: content, user_id: user_id, post: post)
  if reply.save
    &#123;
      reply: reply,
      errors: []
    &#125;
  else
    &#123;
      reply: nil,
      errors: reply.errors.full_messages
    &#125;
  end
end</code></pre>
<p>  end<br>end<br></code> </p>
<h3 id="迷你论坛是一个为一系列博客构建的小型论坛应用程序"><a href="#迷你论坛是一个为一系列博客构建的小型论坛应用程序" class="headerlink" title="迷你论坛是一个为一系列博客构建的小型论坛应用程序"></a>迷你论坛是一个为一系列博客构建的小型论坛应用程序</h3><h1 id="创建用户和登录会话"><a href="#创建用户和登录会话" class="headerlink" title="创建用户和登录会话"></a><a href="https://zshipu.com/t?url=#creating-users-and-login-sessions"></a><font _mstmutation="1" _msthash="305032" _msttexthash="33837687">创建用户和登录会话</font></h1><p>我们需要将用户创建与 GraphQL 分开，以便在访问 GraphQL 终结点之前，可以轻松地要求所有用户登录。</p>
<p><font _mstmutation="1" _msthash="292409" _msttexthash="158304055">因此，我们需要生成专用于用户创建功能的控制器：</font></p>
<code>
 rails g controller users create
</code> 

<p><font _mstmutation="1" _msthash="290303" _msttexthash="67256969">打开新控制器并添加以下内容：</font></p>
<code>
 # app/controllers/users_controller.rb
class UsersController < ApplicationController

<pre><code>def create
    user = User.new(user_params)

    if user.save
        render json: user_json(user)
    else
        render json: &#123;
            message: &#39;Failed to create user&#39;,
            errors: user.errors.full_messages
        &#125;
    end
end

private

# Use strong parameters to prevent any unwanted parameters from getting through.
# The password confirmation field is required to allow BCrypt to properly hash the password.
def user_params
    params.require(:user).permit(:name, :username, :email, :password, :password_confirmation)
end

# Turns a user model object into a hash which can be converted to json. Maybe
# not necessary in a controller this small, but certainly necessary in a larger project.
def user_json(user)
    user.as_json(only: [:id, :name, :username, :email])
end</code></pre>
<p>end<br></code> </p>
<h1 id="验证用户"><a href="#验证用户" class="headerlink" title="验证用户"></a><a href="https://zshipu.com/t?url=#authenticating-users"></a><font _mstmutation="1" _msthash="304083" _msttexthash="14098786">验证用户</font></h1><p>由于我们使用<a href="https://zshipu.com/t?url=https://jwt.io/">JWT 来处理</a>用户会话，因此我们需要添加另一个控制器，允许用户通过登录来创建这些会话。</p>
<p><font _mstmutation="1" _msthash="291499" _msttexthash="129126049">创建新控制器来处理登录会话并添加以下代码：</font></p>
<code>
 rails g controller sessions create
</code> 

<p><font _mstmutation="1" _msthash="292097" _msttexthash="41619448">现在编辑新控制器：</font></p>
<code>
 # app/controllers/sessions_controller.rb
class SessionsController < ApplicationController

<pre><code>def create
    # find the user by the username included in the parameters
    user = User.find_by(username: session_params[:username])
    # If the user exists, and can be authenticated with the given password, generate a token 
    # for the session and return it.
    if user &amp;&amp; user.authenticate(session_params[:password])
        # Generate the token based on the user’s id. Use the value of JWT_SECRET in 
        # the `.env` file.
        token = JWT.encode(&#123;user_id: user.id&#125;, ENV[&#39;JWT_SECRET&#39;])
        render json: &#123;token: token, user_id: user.id&#125;
    else
        render json: &#123;message: &quot;Incorrect username or password&quot;&#125;
    end
end

private

# Use strong parameters to make sure we only get a username and password.
def session_params
    params.require(:session).permit(:username, :password)
end</code></pre>
<p>end<br></code> </p>
<p><font _mstmutation="1" _msthash="292695" _msttexthash="158945384">为了使用变量，我们需要在根项目目录中创建一个文件。</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JWT_SECRET   </span><br><span class="line">.env</span><br></pre></td></tr></table></figure>


<blockquote>
<p>_为保证</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JWT_SECRET，</span><br></pre></td></tr></table></figure>
<p>请务必将</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.env</span><br></pre></td></tr></table></figure>
<p>添加到项目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.gitignore</span><br></pre></td></tr></table></figure>
<p>文件中。确保</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.env</span><br></pre></td></tr></table></figure>
<p>永远不会提交到可公开访问的存储库中。_</p>
<p><font _mstmutation="1" _msthash="290589" _msttexthash="56055311">创建后，运行以下命令：</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.env</span><br></pre></td></tr></table></figure>


<code>
 rake secret
</code> 

<p><font _mstmutation="1" _msthash="291187" _msttexthash="92543815">将该命令的输出粘贴到 中的变量中：</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.env</span><br></pre></td></tr></table></figure>


<code>
 JWT_SECRET=<rake output>
</code> 

<p>这样做将确保您有一个加密安全号码，用于编码用户的会话数据。</p>
<p><font _mstmutation="1" _msthash="292084" _msttexthash="222410318">我们需要添加一个方法，以便端可以检查用户是否经过身份验证。</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current_user</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationController</span><br></pre></td></tr></table></figure>


<code>
 # app/controllers/application_controller.rb

<h1 id="This-error-is-used-below-to-specify-that-a-session-is-not-authenticated"><a href="#This-error-is-used-below-to-specify-that-a-session-is-not-authenticated" class="headerlink" title="This error is used below to specify that a session is not authenticated"></a>This error is used below to specify that a session is not authenticated</h1><p>class AuthenticationError &lt; StandardError</p>
<p>end</p>
<p>class ApplicationController &lt; ActionController::API<br>    def current_user<br>        # Authentication setting the <code>Access-Token</code> header to the result of<br>        # the create session route<br>        token = request.headers[‘Access-Token’]<br>        raise AuthenticationError if token.nil?<br>        # Decodes the JWT token and returns only the user id from it.<br>        user_id = JWT.decode(token, ENV[‘JWT_SECRET’])[0][‘user_id’]<br>        @user = User.find_by(id: user_id)<br>    end<br>end<br></code> </p>
<p><font _mstmutation="1" _msthash="292682" _msttexthash="170339377">最后，在 GraphQL 控制器的路由中进行第一个方法调用。</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current_user</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execute</span><br></pre></td></tr></table></figure>


<code>
 # app/controllers/graphql_controller.rb
class GraphqlController < ApplicationController

<p>  def execute<br>    current_user<br>    variables = ensure_hash(params[:variables])<br>    …<br>  end<br>  …<br>end<br></code> </p>
<p>完成之后，我们准备测试我们的Mutations。</p>
<h1 id="使用邮递员测试-GraphQL-Mutations"><a href="#使用邮递员测试-GraphQL-Mutations" class="headerlink" title="使用邮递员测试 GraphQL Mutations"></a><a href="https://zshipu.com/t?url=#testing-graphql-mutations-with-postman"></a><font _mstmutation="1" _msthash="304057" _msttexthash="42445728">使用邮递员测试 GraphQL Mutations</font></h1><p><font _mstmutation="1" _msthash="291174" _msttexthash="930244211">要测试我们的Graph qld Mutations，我们需要在我们的数据库中有一个用户。您可以使用导轨控制台直接创建用户，也可以向使用 Postman 的发布请求发送帖子请求。</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">users_controller</span><br></pre></td></tr></table></figure>


<p><font _mstmutation="1" _msthash="291473" _msttexthash="1922924341">创建用户后，我们必须获取访问令牌。启动 rails 开发服务器，使用要登录的用户名和密码向端端的终结点发送后请求。如果所有内容都设置正确，则您应该收到包含令牌的 json 响应。将新令牌作为标头粘贴到邮递员请求中。</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;sessions</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Token</span><br></pre></td></tr></table></figure>


<p><a href="https://zshipu.com/t?url=https://res.cloudinary.com/practicaldev/image/fetch/s--0JKD13sY--/c_limit,f_auto,fl_progressive,q_auto,w_880/https://dev-to-uploads.s3.amazonaws.com/i/77rqglbmni18fhzr5hy2.png"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--0JKD13sY--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/77rqglbmni18fhzr5hy2.png" alt="Place Access Token here"></a></p>
<p><font _mstmutation="1" _msthash="292071" _msttexthash="208346424">现在，我们可以再次提交 GraphQL 查询。让我们创建一个新主题：</font><br><a href="https://zshipu.com/t?url=https://res.cloudinary.com/practicaldev/image/fetch/s--R66DRxv9--/c_limit,f_auto,fl_progressive,q_auto,w_880/https://dev-to-uploads.s3.amazonaws.com/i/h3o7xb0gcllj8kzuo0ji.png"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--R66DRxv9--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/h3o7xb0gcllj8kzuo0ji.png" alt="Run the CreateTopic mutation"></a></p>
<p><font _mstmutation="1" _msthash="292370" _msttexthash="394876573">如您所看到的，要运行Mutations，我们必须使用关键字以及包含所有必需参数的Mutations名称和 json 对象。</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutation</span><br></pre></td></tr></table></figure>


<p>您也可以使用json对象来保存所有<a href="https://zshipu.com/t?url=https://graphql.org/learn/queries/#variables">Sq.QL变量</a>，但对于像上面的单个查询来说，将它们放在查询字符串中要容易一些。</p>
<p><font _mstmutation="1" _msthash="292968" _msttexthash="712948015">我们的后端现在应该名义上是完整的。我们可以登录和运行查询并创建对象。我们尚未实现更新对象或删除它们。尝试自己创建和Mutations。</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update   </span><br><span class="line">delete</span><br></pre></td></tr></table></figure>


</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-07-09T05:38:27.000Z" title="2020-07-09T05:38:27.000Z">2020-07-09</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.353Z" title="2020-09-08T14:03:00.353Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">13 分钟读完 (大约1878个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/09/Graphql%E5%AE%9E%E6%88%98%EF%BC%9AGraphQL%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%20%20%E5%9B%9B/">Graphql实战：GraphQL 基础知识  四</a></h1><div class="content"><p> GraphQL是Facebook最初于<a href="https://zshipu.com/t?url=https://foundation.graphql.org/">2012年开发的一种相对较新的查询语言</a>。GraphQL 的主要目标是减少 API 查询返回的不必要的数据量。</p>
<p>GraphQL 允许开发人员在单个查询中检索关联的对象。另一方面，REST API 将需要对相同数据进行多个查询。</p>
<p>编写 GraphQL 查询需要比 REST 查询更多的学习曲线，但一旦学习，GraphQL 就很容易理解。</p>
<p>我已决定将原计划为一篇文章的一篇文章分成两篇文章，因为我认为在较小的区块中处理所有内容会更容易。</p>
<h1 id="GraphQL-基础知识"><a href="#GraphQL-基础知识" class="headerlink" title="GraphQL 基础知识"></a><a href="https://zshipu.com/t?url=#graphql-basics"></a><font _mstmutation="1" _msthash="289380" _msttexthash="24307790">GraphQL 基础知识</font></h1><p>在使用 GraphQL 开始编写代码之前，了解一下它在后台的工作方式至关重要。</p>
<p>GraphQL（如 REST）可以在任何编程语言中实现，并且已经有许多<a href="https://zshipu.com/t?url=https://graphql.org/code/">语言的库</a>来帮助启动新用户。本<a href="https://zshipu.com/t?url=https://dev.to/speratus/basic-models-and-polymorphic-associations-223o">系列的第 2</a>部分，我们安装了 GraphQL 的 ruby 实现</p>
<p>GraphQL的主要特点之一是它的类型<a href="https://zshipu.com/t?url=https://graphql.org/learn/schema/#type-system">系统</a>。对于没有 CS 学位的我们这些类型，本质上是类型名称表示的数据类型的描述。</p>
<p>例如：公共类型是整数类型。整数类型只允许其实例包含正整数或负整数。另一种常见类型是字符串类型。字符串允许字符串实例中包含的任何字符序列。有关哪些数据类型及其使用方式的更多详细信息，请查看维基百<a href="https://zshipu.com/t?url=https://en.wikipedia.org/wiki/Data_type">科关于数据类型的文章</a>。</p>
<p>GraphQL 有两种基本类型：用于生成查询的对象类型和表示具体数据的标量类型。随着我们的进展，这两种不同类型的用途应该变得更加清晰。</p>
<h1 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a><a href="https://zshipu.com/t?url=#scalar-types"></a><font _mstmutation="1" _msthash="303472" _msttexthash="12947298">标量类型</font></h1><p><font _mstmutation="1" _msthash="290615" _msttexthash="550436354">GraphQL 有五种内置标量类型。稍后开始构建对象类型时，我们将使用这五种类型。五个内置类型是：、、和 。</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String   </span><br><span class="line">Int   </span><br><span class="line">Float   </span><br><span class="line">Boolean   </span><br><span class="line">ID</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String</span><br></pre></td></tr></table></figure>
<p><font _mstmutation="1" _msthash="290914" _msttexthash="948504427">s 表示任何类型的字符串数据，s 表示正数和负整数，s 表示任何正数或负实数，包括小数点，s 表示真值或假值，s 表示基础数据库系统中对象的 ID。</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Int   </span><br><span class="line">Float   </span><br><span class="line">Boolean   </span><br><span class="line">ID</span><br></pre></td></tr></table></figure>


<h1 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a><a href="https://zshipu.com/t?url=#object-types"></a><font _mstmutation="1" _msthash="304408" _msttexthash="12521912">对象类型</font></h1><p>对象类型主要是开发人员定义的，由五个标量类型的任意组合以及其他对象类型组成。</p>
<p>对象类型是我们将关注的重点，因为我们在接近尾声时构建的对象类型将允许我们使用 GraphQL 查询后端。从本质上讲，我们将简单地将第 2 部分中定义的模型转换为 GraphQL 类型。</p>
<h1 id="GraphQL查询"><a href="#GraphQL查询" class="headerlink" title="GraphQL查询"></a><a href="https://zshipu.com/t?url=#graphql-queries"></a><font _mstmutation="1" _msthash="305344" _msttexthash="13975130">GraphQL查询</font></h1><p><font _mstmutation="1" _msthash="292409" _msttexthash="270709231">查询是 GraphQL 的粘合剂，它将前端绑定到后端。查看基本的 GraphQL 查询：</font></p>
<code>
 query &#123;
    users &#123;
        id
        name
        username
    &#125;
&#125;</code> 

<p><font _mstmutation="1" _msthash="290303" _msttexthash="57506228">以下是查询部分的细目：</font><br><a href="https://zshipu.com/t?url=https://res.cloudinary.com/practicaldev/image/fetch/s--ei_iZWAT--/c_limit,f_auto,fl_progressive,q_auto,w_880/https://dev-to-uploads.s3.amazonaws.com/i/bkx4cuvzh4k2uuxd5c16.png"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--ei_iZWAT--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/bkx4cuvzh4k2uuxd5c16.png" alt="GraphQL Query breakdown"></a></p>
<p><font _mstmutation="1" _msthash="290602" _msttexthash="293661433">假设我们想要获得该用户创建的所有主题的标题，我们只需添加以下内容：</font></p>
<code>
 query &#123;
    users &#123;
        id
        name
        username
        topics &#123;
            title
        &#125;
    &#125;
&#125;</code> 

<p>此查询的结果将包括每个用户创建的主题的所有标题。编写 GraphQL 查询时，请记住，所有查询的对象都必须在某些时候解析为标量类型。</p>
<h1 id="构建我们的-GraphQL-架构"><a href="#构建我们的-GraphQL-架构" class="headerlink" title="构建我们的 GraphQL 架构"></a><a href="https://zshipu.com/t?url=#building-our-graphql-schema"></a><font _mstmutation="1" _msthash="304707" _msttexthash="28417584">构建我们的 GraphQL 架构</font></h1><p>GraphQL gem 提供了一堆有用的生成器，可帮助我们快速构建对象类型。</p>
<p><font _mstmutation="1" _msthash="292097" _msttexthash="81925116">在项目的根目录中运行以下命令：</font></p>
<code>
 rails g graphql:object User username:String name:String email:String id:ID comments:[Reply] likes:[Like] topics:[Topic]</code> 

<p><font _mstmutation="1" _msthash="292695" _msttexthash="1693127956">参数是新 GraphQL 类型的名称。其他每个参数都遵循格式。因此，意味着添加一个名为用户名的字段，该字段具有字符串类型。这些字段映射到模型中具有相同名称的属性。字段（如告诉 graphql）有三件事：</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User   </span><br><span class="line">&lt;field_name&gt;:&lt;field_type&gt;   </span><br><span class="line">username:String   </span><br><span class="line">comments:[Reply]</span><br></pre></td></tr></table></figure>


<ol>
<li><p><font _mstmutation="1" _msthash="463281" _msttexthash="24031904">制作名为 的字段。</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comments</span><br></pre></td></tr></table></figure>
</li>
<li><p>使新字段成为列表。类型周围的括号告诉 GraphQL 使用数组。</p>
</li>
<li><p><font _mstmutation="1" _msthash="464035" _msttexthash="79494571">对于列表的类型，请使用 该类型。</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reply</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p><font _mstmutation="1" _msthash="290589" _msttexthash="228546903">我们尚未制作类型，因此请继续运行以下命令以完成构建基类型：</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reply</span><br></pre></td></tr></table></figure>


<code>
 rails g graphql:object Topic title:String content:String id:ID user:User likes:[Like] replies:[Reply]
rails g graphql:object Like user:User post:Post id:ID
rails g graphql:object Reply content:String id:ID user:User post:Post</code> 

<p><font _mstmutation="1" _msthash="291187" _msttexthash="830637015">为了支持我们在第 2 部分中设置的多态关联，我们需要创建联合类型 Post。联合类型是一种可以表示几种不同类型之一的类型。运行以下命令：</font></p>
<code>
 rails g graphql:union Post Reply Topic</code> 

<p><font _mstmutation="1" _msthash="291785" _msttexthash="205944271">联合类型生成器似乎有一个错误，因此可能需要更改一点：</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_type</span><br></pre></td></tr></table></figure>


<code>
 # app/graphql/types/post_type.rb
module Types
  class PostType < Types::BaseUnion
    # Instead of the following line of code you may see:
    # possible_types [Types::ReplyType, Types::TopicType]
    # If you do, this is a bug. Remove the brackets to fix it.
    possible_types Types::ReplyType, Types::TopicType
  end
end</code> 

<p><font _mstmutation="1" _msthash="292383" _msttexthash="463721856">现在，我们已经生成了所有基类型，我们需要使它们可查询。打开 ，删除默认值并添加以下代码：</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query_type.rb   </span><br><span class="line">test_field</span><br></pre></td></tr></table></figure>


<code>

<h1 id="app-graphql-types-query-type-rb"><a href="#app-graphql-types-query-type-rb" class="headerlink" title="app/graphql/types/query_type.rb"></a>app/graphql/types/query_type.rb</h1><p>module Types<br>  class QueryType &lt; Types::BaseObject<br>    # Add root-level fields here.<br>    # They will be entry points for queries on your schema.</p>
<pre><code>field :users, [Types::UserType], null: false, description: &#39;Returns all the users&#39;

def users
  User.all
end

field :topics, [Types::TopicType], null: false, description: &#39;Returns all the topics&#39;

def topics
  Topic.all
end

field :topic, Types::TopicType, null: true do
  argument :id, ID, required: true
end

def topic(id:)
  Topic.find_by(id: id)
end

field :user, Types::UserType, null: true do
  argument :id, ID, required: true
end

def user(id:)
  User.find_by(id: id)
end</code></pre>
<p>  end<br>end</code> </p>
<p><font _mstmutation="1" _msthash="292981" _msttexthash="2456105457">此处的快捷方式与生成的快捷方式非常相似。第一个参数（例如）是字段的名称，第二个参数是字段的类型，第三个参数确定返回值是否可以为空，最后一个参数是字段的描述。行声明该字段需要一个参数，我们将在本系列稍后将更详细地介绍该参数。</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">field :users argument</span><br></pre></td></tr></table></figure>


<h1 id="正在运行测试查询"><a href="#正在运行测试查询" class="headerlink" title="正在运行测试查询"></a><a href="https://zshipu.com/t?url=#running-test-queries"></a><font _mstmutation="1" _msthash="306566" _msttexthash="34263203">正在运行测试查询</font></h1><p>如果您想测试我们新的 GraphQL 端，可以使用<a href="https://zshipu.com/t?url=https://www.electronjs.org/apps/graphiql">GraphiQL 或</a> <a href="https://zshipu.com/t?url=https://www.postman.com/">Postman 来测试</a>。</p>
<p>GraphQL 是一个非常强大的库，可以大大减少 API 开发时间。与 REST API，GraphQL 需要多一些工作来理解，但我发现这种奖励非常值得付出努力。感谢您的阅读！</p>
<p>与往常一样，代码在<a href="https://zshipu.com/t?url=https://github.com/speratus/miniforum/tree/part3-graphql-1">GitHub 存储库中可用</a></p>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/19/">19</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://www.gravatar.com/avatar/2396bdfe5aadb513e676094004dde830?s=128" alt="edwin"></figure><p class="title is-size-4 is-block line-height-inherit">edwin</p><p class="is-size-6 is-block">知识铺</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国 杭州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">189</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">2</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/liliang8858" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/liliang8858"><i class="Github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="社区"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="设计"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/go/"><span class="level-start"><span class="level-item">go</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T10:43:02.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/Spring%20Cloud%20Gateway+Nacos%EF%BC%8Cyml+properties%E4%B8%A4%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BA%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1/">Spring Cloud Gateway+Nacos，yml+properties两种配置文件方式搭建网关服务</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T10:39:59.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/Spring%20Cloud+nacos+Feign%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/">Spring Cloud+nacos+Feign，实现注册中心及配置中心</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T10:32:26.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/Nacos%E4%BD%9C%E4%B8%BA%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%97%B6%EF%BC%8C%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AAdataId%E7%9A%84%E9%85%8D%E7%BD%AE/">Nacos作为配置中心时，多个服务共用一个dataId的配置</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T09:34:29.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/SpringCloudAlibaba(%E4%B8%89)%EF%BC%9A%E4%BD%BF%E7%94%A8Nacos%E4%BD%9C%E4%B8%BA%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/">SpringCloudAlibaba(三)：使用Nacos作为配置中心</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T09:31:53.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/Nacos%20%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/">Nacos 集群部署</a></p><p class="is-uppercase"></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">37</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">62</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web/"><span class="tag">web</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">广告</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="2183476622" data-ad-slot="pub-2874221941555456" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="知识铺" height="28"></a><p class="size-small"><span>&copy; 2020 edwin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://zshipu.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>