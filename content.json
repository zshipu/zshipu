{"pages":[{"title":"404","text":"","link":"/404.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"contact","text":"","link":"/contact/index.html"},{"title":"friends","text":"","link":"/friends/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"news","text":"","link":"/news/index-1.html"},{"title":"最新资讯","text":"新浪_科技__新浪网 新浪科技是新浪网最重要频道之一,24小时滚动报道IT业界,电信、互联网及大众科技新闻,最及时权威的产业及事件报道平台,手机、数码、笔记本及软件下载一网打尽。 _科技新闻__央视网(cctv.com) 2天前 - 央视网(cctv.com)_科技_频道以全球视角,第一时间呈现最新_科技_资讯、独到的观点和前沿的_科技_产品信息,覆盖通信、互联网、IT产业、IT产品和科普探索等领域… 科技_讯-_科技_生活门户-IT_科技新闻,黑科技,探索发现,科学网 _科技_讯(www.kejixun.com)是综合_科技_生活门户网站,是您的网上_科技_大学。关注_科技_以及_科技_在生活中的应用,传播和普及科普知识。作为有影响力的_科技_媒体,24小时滚动报道… 中国_科技新闻_网 中国_科技新闻_网成立于李克强总理在十二届全国人大三次会议上提出的“互联网+”行动计划会议前夕,在中央全面深化改革领导小组第四次会议《关于推动传统媒体和新兴媒体… 凤凰网科技-直击真相的_科技_媒体_凤凰网 凤凰网_科技_今天06:550 疫情高峰或致日本“医疗崩溃” 央视网_新闻_今天06:350 78亿美元估值,猿辅导凭什么? 虎嗅网今天06:280 瑞幸咖啡周一收盘下跌18.4% 凤凰网… DoNews-互联网_新闻_门户网站-IT资讯_科技_媒体 中国最早的web2.0网站,专业_科技_媒体、互联网行业门户网站。提供互联网_新闻_IT资讯,关注_科技_创新,覆盖移动互联网创业、游戏、风险投资等热点,是中国互联网行业的风向标。 网易_科技_频道_有态度的_科技_门户 网易科技,以独特视角呈现_科技_圈内大事小事,内容包括互联网、IT业界、通信、趋势、_科技_访谈等。 科技新闻 驱动中国 驱动中国科技品达是最具商业价值和影响力的科技媒体,24小时滚动报道最新科技新闻,IT新闻,机器人,互联网,移动互联网,电信,游戏和手机,数码等,还关注科学探索等大众… 科技i资讯杂志首页 科技i资讯杂志是权威部门批准公开发行，双刊号齐全，数据库全文收录的科技期刊科技i资讯欢迎投稿咨询 科技新闻 驱动中国 驱动中国科技品达是最具商业价值和影响力的科技媒体,24小时滚动报道最新科技新闻,IT新闻,机器人,互联网,移动互联网,电信,游戏和手机,数码等,还关注科学探索等大众… _科技_滚动_新闻__新浪网 2天前 - 滚动新闻,新闻_中心,新浪网… 新浪_科技 | 新浪首页 | 新浪导航最新滚动00秒后刷新栏目 标题 时间意见反馈留言板 客服热线:4000520066 欢迎批评指正 新… 科技新闻-中国科技网首页 4天前 - 中国科技网是以_科技新闻_和信息传播为主业的综合性网络媒体。2010年,中央外宣办核准网站名称为“中国科技网”,并视同国家重点新闻网站进行管理,日均网页访问量达百万… 浙江_科技新闻_网_浙江在线 浙江科技新闻_网以“新闻助推科技创新,科技服务科学发展”为己任,主打浙江科技即时报,以网站、视频、微博、手机等全媒体方式做活_科技新闻,做好活动策划,做热网民… _科技__最新_科技_创新资讯_新闻__云掌财经 云掌财经科技_频道24小时滚动播报全球热点、人工智能、轻_科技_、智能终端、通讯、科学、游戏和电商消费等行业_新闻,致力于提供有价值的有实效的_科技_资讯。 资讯中心 ——快科技–_科技_资讯专业发布平台 快科技(驱动之家旗下媒体)资讯中心,每日持续更新报道IT业界、互联网、市场资讯、驱动更新、游戏及产品资讯,是最及时权威的产业资讯及硬件资讯报道平台,快科技(驱动… 中国_科技新闻_学会 根据学会章程和《中国科协全国学会组织通则(试行)》的有关规定,学会定于2019年7月12日下午在北京中国科技会堂召开“中国_科技新闻_学会第六届四次常务理事会”。 各… _科技新闻__最新_科技新闻__最新科技__科技新闻_网_优府网 #Uninf_system:metadescription$… 资讯政策 体育产业 互联网 财经金融 _科技_产业 企服行业 文化产业 旅游产业 美食行业 房产行业 汽车产业 教育产业 视频 博客… _科技新闻_资讯_中英双语阅读_英汉对照阅读 - 可可英语 2020年3月17日 - &gt; 科技新闻 保存到QQ日志 星际旅行要实现了?最近一支澳大利亚研究团队首创一种新技术,称能在五年内驾驭核聚变, 并且清洁,绝对安全,反应堆甚至可以放置… 搜狐科技-搜狐 搜狐_科技_是聚合互联网、智能硬件、创业投资、通讯数码等_科技_资讯的媒体平台,致力提供最专业、最酷炫的_科技_圈新资讯。 科技网__科技新闻_网_海峡都市报专业科技媒体网站-闽南网 科技网是海峡都市报旗下的专业科技媒体网站,提供智能手机、家电、软件应用、游戏、互联网、移动互联网、电子商务等产业领域及时、快速、多角度、宽领域的_科技新闻_资讯… 资讯- 科技_讯-_科技_生活门户-IT_科技新闻,黑科技,探索发现,科学网 5天前 - _科技_讯(www.kejixun.com)是综合_科技_生活门户网站,是您的网上_科技_大学。关注_科技_以及_科技_在生活中的应用,传播和普及科普知识。作为有影响力的_科技_媒体,… _科技新闻_网 _科技新闻_网是专业科技新媒体网站。网站专注于最新_科技新闻_的全面及时报道,让网民在这里第一时间了解全球最新的科技资讯。 北京信息_科技_大学_新闻_网首页 综合新闻 更多 16 2019.11 2019年华北五省(市、自治区)大学生机器人大赛…点击量破亿,北京信息_科技_大学学子制作抗“疫”视频,火遍全网! 03-27 人不到… 科技新闻-木蚂蚁资讯频道-全网最新_科技新闻_和软件游戏资讯教程… 7天前 - _科技新闻_AirPods Pro有杂音怎么办 AirPods Pro有杂音解决办法AirPods防噪耳机,很多小伙伴都入手了,但是不少用户的使用体验不是很好,很多人在使用AirPods有类似于… _科技_资讯-财经频道-金融界 2天前 - 金融界科技 热门推荐:财经滚动名家专栏热点专题财经博客 财经首页7*24实时_新闻_观点评论上市公司国内财经国际财经互联网金融产经_新闻_商业资讯_科技_资讯… 西安电子_科技_大学_新闻_网 西安电子_科技_大学_新闻_网(西电_新闻_网)是西安电子_科技_大学主流媒体之一,网站整合校园资讯,凭借教育网与电信网的双线资源,独立访客数每日成千上万。作为西安电子_科技_大学… _科技新闻__互联网新闻_IT新闻_数码新闻_深港在线 腾讯研究院发布《千里之行·_科技_向善白皮书2020》 2020年1月11日,由腾讯研究院主办的第三届 “_科技_向善” 年度论坛在北京举办,本届论坛以「千里之行·Action No… 科技新闻 - 搜狐视频 科技新闻 首页 上一页 下一页 末页 1/66 转到 页Go 播放 3’53” …播放 37” 未来科技实现 动感照片让秀发飘起来 2011-06-20 11:12 播放… -西安_科技_大学_新闻_网2020 ◆ 西安_科技_大学校园_新闻_836期 19-09-14 ◆ 西安_科技_大学校园_新闻_835期 19-05-24 ◆ 西安_科技_大学校园_新闻_834期 19-05-17 ◆ 西安_科技_大学校园_新闻_833期… 中国机械工程学会-科技新闻 2020年3月18日 - 科技新闻 首页 学会新闻 科技新闻 密度低于水的液态金属!清华大学刘静教授团队突破性研发,为打造新型机器人铺路! 德玛吉推出新型LASERTEC 30 DUAL SLM… _新闻_中心_西南_科技_大学_新闻_网 视频新闻 更多 西南科技_大学2019年第二十三期校园_新闻 2019-12-17 西南科技_大学2019年第二十三期校园_新闻 西南科技_大学2019年第二十二期校园_新闻 西南_科技_大学… _科技_行者-致力于让每一个人都是技术行家 _科技_行者致力于“让每一个人都是技术行家”,是今日头条、悟空问答、喜马拉雅等社交传播平台的战略合作媒体、战略合作机构。 中国科大_新闻_网 欢迎访问中国科大新版_新闻_网123456 双一流建设施工蓝图出台:各地老… 核心…2017_科技_创新人物揭晓:80后两兄… 纪念交大西迁掌校人《彭康文集》… [凤凰… IT_科技___科技解说_IT资讯_新闻-喜马拉雅FM 喜马拉雅FMIT科技频道,畅谈IT业界的新鲜事、奇趣事和热门焦点,掌控热最新的互联网新闻、_科技新闻_和IT业界动态。喜马拉雅FMIT科技频道,信息过载时代的优质内容聚合。36… 一下_科技__相关_新闻_报道_财新网 视频发展的初期,一下_科技_这家公司应该是存在感最高的。微博参与了一下_科技_从2013年7月到2016年11月,从B轮到E轮的… 中美… 科技新闻-中国科技网首页 中国科技网是以_科技新闻_和信息传播为主业的综合性网络媒体。2010年,中央外宣办核准网站名称为“中国科技网”,并视同国家重点新闻网站进行管理,日均网页访问量达百万… 北科大_新闻_网-北科大_新闻_网 学校举办安百拓-北京_科技_大学采矿设备捐赠暨“…_新闻_排行 周 月 年 1王沿东教授团队发现“超临界弹性4148 2中国“翻译力量”助力全球抗疫1772 3冯妍卉教授团队在… 科技新闻 2020年2月27日 - 菲龙网编辑部7瑞幸造假十二问:让COO一人背锅能解救瑞幸吗? 菲龙网新闻部科学家给吸血蝙蝠贴迷你”背包”追踪器 监测其社交活动科技新闻 收藏… 科大_新闻_网 罗公利姚庆国致科大学子的一封信 图片_新闻_山东_科技_大学与乌克兰马卡洛夫国立造船大学签署合作备忘录 19-12-28 12月24日,山东_科技_大学与乌克兰马卡洛夫国立造船大学签署… 莎莎站长网-聚焦最新最热站长资讯!-站长新闻/互联网新闻/科技新闻… 莎莎站长网为个人站长及网络管理员提供最新最全的热点站长资讯、互联网新闻、电商资讯、_科技新闻_、IT资讯、业界动态、人物访谈,等,全力为中国站长创业护航! 新浪网RSS频道聚合__科技新闻_ 新浪网_科技_频道之家电行情导购、家电新品评测。什么是RSS: RSS为Really Simple Syndication(简易供稿)的 缩写,是某一站点用来和其 它站点之间共享内容的一种 简易… 内蒙古_科技_大学_新闻_网 2019届毕业生毕业照 校园的秋 更多+内蒙古_科技_大学党委宣传部(_新闻_中心) 版权所有 地址:内蒙古包头市阿尔丁大街7号 邮政编码:014010 友情链接 … 新Q科技 - 中国_科技新闻_门户,科技资讯专业发布平台 新Q科技是具商业价值和影响力的新科技媒体,为您提供第一手新科技新闻,IT新闻,互联网,移动互联网,IT,通信,家电,数码,手机,业界资讯,手机通讯,时尚数码,数字家电… 机锋网-科技新闻,尽在机锋 热门手机 智能数码 美妆穿搭 超市百货 分期付款Apple/苹果iPhone XS Max iPhone XS 双卡国行原封手机 ￥5365.80 券元 【3期免息 限时钜惠400】Meizu/魅族16t… 和讯_科技_—报道_科技_中国 分享全球智慧 和讯_科技_是和讯网核心资讯频道,以报道_科技_中国,分享全球智慧为目标,为高端财经网络用户提供有关TMT产业领域及时、快速、全面的资讯报道。全方位、多角度、宽领域的… 资讯中心_品不一样的_科技__太平洋电脑网 太平洋电脑网资讯中心面向广大关心_科技_、互联网、创业、市场和产品资讯的网友,以公平、公正、公开的态度传递实时_科技_资讯。 高_科技_行业国内_新闻_动态- OFweek高_科技_行业门户 OFweek提供最国内高_科技_行业动态、_新闻_事件、企业动态、行业活动及市场分析等报道。 _科技_传媒网—致力于推动创新_科技_发展,专注_科技新闻_传播的新媒体平台 科技传媒网是中国最专注_科技新闻_传播的新媒体网站,24小时报道最新科技资讯及科技企业,孵化器,智库产业园提供的高科技产品、创客创投项目的视频图片信息,还报道科技金融… 资讯- _科技新闻_网 4天前 - _科技新闻_网是专业科技新媒体网站。网站专注于最新_科技新闻_的全面及时报道,让网民在这里第一时间了解全球最新的科技资讯。 从哪里能找到国外最新的_科技新闻_资讯? - 知乎 2015年9月30日 - 许多国外第一手的_科技_资讯,移动互联的_新闻_资讯都是从哪里来的?推荐几个这样的国外的网站或者博客 科技新闻 2020年1月10日 - 科技新闻 通知公告 科技新闻 科技成果 科技新闻 首页 科技新闻 科技新闻 …(c)2013 南京理工大学科学技术研究院 All rights reserved 技术支持:梦蕾… 新华_科技__新华网 4天前 - 作为国家重点新闻网站新华网所属频道,新华科技目前覆盖_科技新闻_报道、原创观察报道、专题、科技评论、前沿信息技术、政策解读、科技图片报道、科技创新、科普等多个板块… 欢迎访问黄河_科技_学院_新闻_网 黄河科技_学院,_新闻,经国家教育部批准成立的一所民办普通本科高校… 12月8日晚,中央电视台《_新闻_联播》栏目以我校…院团委干事,现任黄河_科技_学院双创讲…[2020-… 快科技(驱动之家旗下媒体)–_科技_改变未来 快科技(驱动之家旗下媒体)为您提供第一手的_科技新闻_资讯、产品评测、驱动下载等服务。老牌的驱动下载频道通过方便快捷的驱动分类、搜索服务,助您快速找到所需的驱动… 生物科技新闻 - 资讯_生物帮 2天前 - 生物帮(bio1000.com)生命科学网,生物技术、生物科学门户网站,为您提供最新生物科学,生物技术资讯信息,包括最全的生物产品库,生物学,生物产业,生物化学,行业研究报告… 科技新闻 在目前_科技_高速发展的背景下,众多海归人员毅然决定彻底地回到阔别多年的祖国,以巨大的热情投入到这场新形势下的发展中去,且在众多科研领域作出突出成绩,禾骑士研究院… _科技__环球网 环球网科技,不一样的IT视角!以“成为全球_科技_界的一面镜子”为出发点,向关注国际_科技_类资讯的网民,提供国际_科技_资讯的传播与服务。 科技新闻-长安大学科技处 当前位置: 网站首页&gt;&gt;新闻中心&gt;&gt;_科技新闻_科技处党支部开展主题党日活动 2020-03-02 黄河流域生态保护与可持续发展双清论坛视频会议召开 我校设立分会场 2020-03-… 中国电影_科技_网_新闻_中心 7天前 - 为推动我国电影事业发展,促进电影_科技_水平的提高,原国家_新闻_出版广电总局_科技_委电影专业委多年来举办电影_科技_论文评奖,专业性和权威性得到行业一致公认。因电影工作上级… 华北_科技_学院_新闻_网 学校新闻 奋进新时代 再著新华章——学校召开“改革创新、转型发展”专题学习…· 中国教育报:“创新”小平台 “育人”大样本——记华北_科技_学院电信学院创新… 互联网_新闻__IT_新闻_资讯__科技_产品信息中心_数码_科技新闻_资讯网… 华军新闻网是一家提供今日最新的IT新闻、互联网新闻、数码_科技新闻_、手机资讯等科技信息的新闻资讯网。每日不断更新国内最热门的互联网相关新闻。想了解更多精彩新闻,… 新闻_发布 | 澜起_科技 © 2006 – 2020 澜起_科技_。保留所有权利。 沪公网安备 31010402005357号, 沪ICP备18002431号-2 联系我们 网站地图 … 钛媒体__科技_引领新经济 【钛媒体官方网站】钛媒体是国内首家TMT公司人社群媒体,最有钛度的一人一媒体平台,集信息交流融合、IT技术信息、新媒体于一身的媒体平台。 _科技新闻__图文_百度文库 _科技新闻__其它模板PPT模板_实用文档。_科技新闻 Science and Technol ogy News 5G时代 ?5G网络 ? 编辑 5G 网络作为第五代移动通信网 络,其峰值理论传输速度可达… 山西_科技新闻_出版传媒集团 山西_科技新闻_出版传媒集团是根据中央关于非时政类报刊转企改制的有关精神,作为山西省首批转企改制试点单位,2012年9月,经新闻出版总署批准,省工商局正式注册登记成立… 青岛_科技_大学_新闻_网 今日是: 2020年4月7日 星期二 欢迎光临青岛_科技_大学_新闻_网 科大主页 | …青岛_科技_大学海洋学院马翠萍科研团队长期专注于核酸检测研究,在核酸快…[详细] … 双语科技新闻 - 小E英语学习网 小e英语 / 双语_科技新闻_亚马逊成为美国第二大市值过万亿美元的企业 …双语新闻:谷歌新应用“悲伤屏蔽”让你远离负面新闻 双语新闻:世界上第一块盲人… 国际科技新闻-国际科技频道 2020年2月16日 - 国际科技新闻 根际微生物组会影响植物根代谢物分泌近日,一个国际研究团队发现,植物的根际微生物组可以通过系统的根到根信号机制影响根的化学成分和根的分泌物。… 每周全球科技_十大_新闻(2019.7.8-7.14) - 阿明观察 - CSDN博客 2019年7月22日 - _新闻_摘要:亚马逊Amazon向美国FCC提交发射3236颗互联网卫星申请;半导体原材料断供,三星电子被日本“卡脖子”。触犯欧盟GDPR,万豪Marriott数据泄漏遭遇… 极客范_中国科技_网站门户,报道最新_科技新闻 极客范是海量资讯的新闻_服务平台,真实反映每时每刻的_科技_热点,在_科技_与人文之间寻找商业新价值,坚持以人文的视角解读_科技,用专业的精神剖析时代,孜孜不倦探索_科技_与… 前沿_科技_资讯_最新_科技新闻__全球最新科技动态-天气网 2017年1月22日 - 科技前沿是天气网(www.tianqi.com)科学探索主要栏目之一,专注于前沿科技资讯,为您每天送上最新_科技新闻_,带您了解全球最新科技动态。 头条前瞻最具可读性的_科技_头条_最具前瞻性_科技新闻 专注于研究中国与全球各个细分产业发展动向与变迁趋势,对当下产业新风口、新趋势、新模式及案例进行前瞻性分析解读。 _科技__环球网 环球网科技,不一样的IT视角!以“成为全球_科技_界的一面镜子”为出发点,向关注国际_科技_类资讯的网民,提供国际_科技_资讯的传播与服务。 _科技_资讯_科技视界__科技新闻__科技美学_科技之门 - 至诚财经网… 最具商业价值和影响力的科技媒体资讯平台,24小时滚动报道最新_科技新闻_、IT新闻、互联网,移动互联网、电信、游戏和手机、数码等,还关注科学探索等大众科技领域是最… 军事科技(新闻)__新闻__视频_央视网 2020年3月17日 - 节目改版核心概念是:有理有据的“真看见”。以瞄准打赢为所有选题的核心目标,围绕武器装备、攻防战略、前沿科技,解析装备背后的科学依据。 西安建筑_科技_大学笃实_新闻_网 _新闻_热线:82205305-6612 邮箱:news@xauat.edu.cn 主办单位:西安建筑_科技_大学信息网络中心设为首页2020年4月7日 星期二 庚子年 三月十五… _科技_行者-致力于让每一个人都是技术行家 _科技_行者致力于“让每一个人都是技术行家”,是今日头条、悟空问答、喜马拉雅等社交传播平台的战略合作媒体、战略合作机构。 95科技资讯-_科技新闻_资料,今日科技资讯,科技网络资讯 近日据外媒报道,扎克伯格介绍了慈善组织Chan-Zuckerberg Initiative的科学研究,扎克伯格说CZI非常关注技术,他认为对于尖端实验室和生物_科技_初创公司来说,计算成本太高是… 今日IT行业_新闻_关注_数码_新闻__最新最近数码_科技新闻_报道-闽南网 2天前 - 闽南网IT数码频道网罗最新IT行业新闻,今日IT行业新闻关注最新数码_科技新闻_报道;及时更新手机、相机、笔记本等IT数码商品,各种新鲜好玩的潮流数码IT行业动态。 天津市科学技术_局·天津_科技–_新闻_中心 4天前 - _新闻_中心 市_科技_局会同市科协召开科普工作联席会议 要闻速递 2020-04-03湖北14名新冠肺炎疫情防控一线牺牲人员被评定为首批烈士 2020-04-03《新华每… 雅宝科技_科技资讯,科技新闻,科技生活,IT新闻,黑科技,探索发现… 雅宝科技是综合科技生活门户网站,是您的网上科技大学。关注科技以及科技在生活中的应用,传播和普及科普知识。作为有影响力的科技媒体,24小时滚动报道最新_科技新闻_、… 科技新闻 – 技术咨询|技术服务|培训|工业自动化培训|培训课程|… 科技新闻 Ⅱ类医疗器械造假-冷光美白机(仪) 过氧化物需要蓝光才能催化化学反应吗?根据医疗器械监督管理条例第七十条,医疗器械检验机构出具虚假检验报告的,由授予其… E读|一分钟阅读重点科技新闻(4月7日)_Zoom 6小时前 - Zoom股价周一收盘下跌4%,而标普500通讯服务指数大涨逾7%。瑞信分析师Brad Zelnick指出,Zoom估值具有“超高溢价”,预计用户激增将是“短暂的”,或者主要… 科学网,科学探索 - 科技_讯-_科技_生活门户-IT_科技新闻,黑科技,探索… 科学网,科学探索是科技_讯主要栏目之一,提供最新的科学和_科技_前沿资讯,报道科学_新闻,探索自然奥秘,普及最新的科普知识。 新闻- 力太科技 新闻 公司新闻 新闻 news 公司_新闻_行业动态 2020-03-31 新品发布——数字…2018年9月19日——23日,力太_科技_以 “专业为汽车零部件工厂打造产品追溯系统”… 服装_科技__技术资讯|新闻|动态_服装服饰行业资讯 -中服服装网 中服服装网服装服饰行业资讯平台,为您提供全面的服装_科技_技术资讯、服装_科技_技术_新闻_动态信息。 网易新闻 新闻,新闻_中心,包含有时政_新闻,国内新闻,国际新闻,社会新闻,时事评论,_新闻_图片,_新闻_专题,_新闻_论坛,军事,历史,的专业时事报道门户网站 科技-映象网 国防_科技_大学国防_科技_战略研究智库国家安全与军事战略研究所所长朱启超对_科技_日报记者…不良信息举报:dxbb@hnr.cn 经营许可证编号:豫B2-20120014 互联网_新闻_信息服务许…","link":"/news/index.html"}],"posts":[{"title":"100天Spring零基础起飞 一","text":"Spring 概述概述Spring 是最受欢迎的企业级 Java 应用程序开发框架，数以百万的来自世界各地的开发人员使用 Spring 框架来创建性能好、易于测试、可重用的代码。 Spring 框架是一个开源的 Java 平台，它最初是由 Rod Johnson 编写的，并且于 2003 年 6 月首次在 Apache 2.0 许可下发布。 Spring 是轻量级的框架，其基础版本只有 2 MB 左右的大小。 Spring 框架的核心特性是可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO 编程模型来促进良好的编程实践。 使用 Spring 框架的好处下面列出的是使用 Spring 框架主要的好处： Spring 可以使开发人员使用 POJOs 开发企业级的应用程序。只使用 POJOs 的好处是你不需要一个 EJB 容器产品，比如一个应用程序服务器，但是你可以选择使用一个健壮的 servlet 容器，比如 Tomcat 或者一些商业产品。 Spring 在一个单元模式中是有组织的。即使包和类的数量非常大，你只要担心你需要的，而其它的就可以忽略了。 Spring 不会让你白费力气做重复工作，它真正的利用了一些现有的技术，像ORM 框架、日志框架、JEE、Quartz 和 JDK 计时器，其他视图技术。 测试一个用 Spring 编写的应用程序很容易，因为环境相关的代码被移动到这个框架中。此外，通过使用 JavaBean-style POJOs，它在使用依赖注入注入测试数据时变得更容易。 Spring 的 web 框架是一个设计良好的 web MVC 框架，它为比如 Structs 或者其他工程上的或者不怎么受欢迎的 web 框架提供了一个很好的供替代的选择。MVC模式导致应用程序的不同方面(输入逻辑，业务逻辑和UI逻辑)分离，同时提供这些元素之间的松散耦合。 模型(Model)封装了应用程序数据，通常它们将由POJO类组成。 视图(View)负责渲染模型数据，一般来说它生成客户端浏览器可以解释HTML输出。 控制器(Controller)负责处理用户请求并构建适当的模型，并将其传递给视图进行渲染。 Spring 对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。 轻量级的 IOC 容器往往是轻量级的，例如，特别是当与 EJB 容器相比的时候。这有利于在内存和 CPU 资源有限的计算机上开发和部署应用程序。 Spring提供了一致的事务管理接口，可向下扩展到（使用一个单一的数据库，例如）本地事务并扩展到全局事务（例如，使用 JTA）。 依赖注入（DI）Spring 最认同的技术是控制反转的依赖注入（DI）模式。控制反转（IoC）是一个通用的概念，它可以用许多不同的方式去表达，依赖注入仅仅是控制反转的一个具体的例子。 当编写一个复杂的 Java 应用程序时，应用程序类应该尽可能的独立于其他的 Java 类来增加这些类可重用可能性，当进行单元测试时，可以使它们独立于其他类进行测试。依赖注入（或者有时被称为配线）有助于将这些类粘合在一起，并且在同一时间让它们保持独立。 到底什么是依赖注入？让我们将这两个词分开来看一看。这里将依赖关系部分转化为两个类之间的关联。例如，类 A 依赖于类 B。现在，让我们看一看第二部分，注入。所有这一切都意味着类 B 将通过 IoC 被注入到类 A 中。 依赖注入可以以向构造函数传递参数的方式发生，或者通过使用 setter 方法 post-construction。由于依赖注入是 Spring 框架的核心部分，所以我将在一个单独的章节中利用很好的例子去解释这一概念。 面向方面的程序设计（AOP）：Spring 框架的一个关键组件是面向方面的程序设计（AOP）框架。一个程序中跨越多个点的功能被称为横切关注点，这些横切关注点在概念上独立于应用程序的业务逻辑。有各种各样常见的很好的关于方面的例子，比如日志记录、声明性事务、安全性，和缓存等等。 在 OOP 中模块化的关键单元是类，而在 AOP 中模块化的关键单元是方面。AOP 帮助你将横切关注点从它们所影响的对象中分离出来，然而依赖注入帮助你将你的应用程序对象从彼此中分离出来。 Spring 框架的 AOP 模块提供了面向方面的程序设计实现，可以定义诸如方法拦截器和切入点等，从而使实现功能的代码彻底的解耦出来。使用源码级的元数据，可以用类似于.Net属性的方式合并行为信息到代码中。","link":"/2019/12/06/100%E5%A4%A9Spring%E9%9B%B6%E5%9F%BA%E7%A1%80%E8%B5%B7%E9%A3%9E-%E4%B8%80/"},{"title":"100天Spring零基础起飞 二","text":"Spring 体系结构体系结构Spring 有可能成为所有企业应用程序的一站式服务点，然而，Spring 是模块化的，允许你挑选和选择适用于你的模块，不必要把剩余部分也引入。下面的部分对在 Spring 框架中所有可用的模块给出了详细的介绍。 Spring 框架提供约 20 个模块，可以根据应用程序的要求来使用。 核心容器核心容器由spring-core，spring-beans，spring-context，spring-context-support和spring-expression（SpEL，Spring表达式语言，Spring Expression Language）等模块组成，它们的细节如下： spring-core模块提供了框架的基本组成部分，包括 IoC 和依赖注入功能。 spring-beans 模块提供 BeanFactory，工厂模式的微妙实现，它移除了编码式单例的需要，并且可以把配置和依赖从实际编码逻辑中解耦。 context模块建立在由core和 beans 模块的基础上建立起来的，它以一种类似于JNDI注册的方式访问对象。Context模块继承自Bean模块，并且添加了国际化（比如，使用资源束）、事件传播、资源加载和透明地创建上下文（比如，通过Servelet容器）等功能。Context模块也支持Java EE的功能，比如EJB、JMX和远程调用等。ApplicationContext接口是Context模块的焦点。spring-context-support提供了对第三方库集成到Spring上下文的支持，比如缓存（EhCache, Guava, JCache）、邮件（JavaMail）、调度（CommonJ, Quartz）、模板引擎（FreeMarker, JasperReports, Velocity）等。 spring-expression模块提供了强大的表达式语言，用于在运行时查询和操作对象图。它是JSP2.1规范中定义的统一表达式语言的扩展，支持set和get属性值、属性赋值、方法调用、访问数组集合及索引的内容、逻辑算术运算、命名变量、通过名字从Spring IoC容器检索对象，还支持列表的投影、选择以及聚合等。 它们的完整依赖关系如下图所示： 数据访问/集成数据访问/集成层包括 JDBC，ORM，OXM，JMS 和事务处理模块，它们的细节如下： （注：JDBC=Java Data Base Connectivity，ORM=Object Relational Mapping，OXM=Object XML Mapping，JMS=Java Message Service） JDBC 模块提供了JDBC抽象层，它消除了冗长的JDBC编码和对数据库供应商特定错误代码的解析。 ORM 模块提供了对流行的对象关系映射API的集成，包括JPA、JDO和Hibernate等。通过此模块可以让这些ORM框架和spring的其它功能整合，比如前面提及的事务管理。 OXM 模块提供了对OXM实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等。 JMS 模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了spring-messaging模块。。 事务模块为实现特殊接口类及所有的 POJO 支持编程式和声明式事务管理。（注：编程式事务需要自己写beginTransaction()、commit()、rollback()等事务管理方法，声明式事务是通过注解或配置由spring自动处理，编程式事务粒度更细） WebWeb 层由 Web，Web-MVC，Web-Socket 和 Web-Portlet 组成，它们的细节如下： Web 模块提供面向web的基本功能和面向web的应用上下文，比如多部分（multipart）文件上传功能、使用Servlet监听器初始化IoC容器等。它还包括HTTP客户端以及Spring远程调用中与web相关的部分。。 Web-MVC 模块为web应用提供了模型视图控制（MVC）和REST Web服务的实现。Spring的MVC框架可以使领域模型代码和web表单完全地分离，且可以与Spring框架的其它所有功能进行集成。 Web-Socket 模块为 WebSocket-based 提供了支持，而且在 web 应用程序中提供了客户端和服务器端之间通信的两种方式。 Web-Portlet 模块提供了用于Portlet环境的MVC实现，并反映了spring-webmvc模块的功能。 其他还有其他一些重要的模块，像 AOP，Aspects，Instrumentation，Web 和测试模块，它们的细节如下： AOP 模块提供了面向方面的编程实现，允许你定义方法拦截器和切入点对代码进行干净地解耦，从而使实现功能的代码彻底的解耦出来。使用源码级的元数据，可以用类似于.Net属性的方式合并行为信息到代码中。 Aspects 模块提供了与 AspectJ 的集成，这是一个功能强大且成熟的面向切面编程（AOP）框架。 Instrumentation 模块在一定的应用服务器中提供了类 instrumentation 的支持和类加载器的实现。 Messaging 模块为 STOMP 提供了支持作为在应用程序中 WebSocket 子协议的使用。它也支持一个注解编程模型，它是为了选路和处理来自 WebSocket 客户端的 STOMP 信息。 测试模块支持对具有 JUnit 或 TestNG 框架的 Spring 组件的测试。","link":"/2019/12/06/100%E5%A4%A9Spring%E9%9B%B6%E5%9F%BA%E7%A1%80%E8%B5%B7%E9%A3%9E-%E4%BA%8C/"},{"title":"2020年，jQuery需要了解的那些知识点","text":"jQuery作为一个DOM选择、事件绑定、AJAX的工具库来说，依旧还是极其优秀的存在，你甚至可以把jQuery理解为一个浏览器的标准库（实际上也是事实标准）。UI库方面可以使用LayUI（兼容移动端）。需要在前端渲染HTML模板和进行VM视图模型数据绑定时，可以用跟jQuery亲和性更好的JSrender和JSviews： 核心就是下面两句,剩下的就是写模板.$(\"#输出位置\").html( $.templates(\"#模板位置\").render(json) ); // JSrender 渲染模板$.templates(\"#模板位置\").link(\"#输出位置\", json); // JSviews 数据绑定 至于SEO，首先需要明确的是，GET类型的读操作才需要SEO，而大多数POST类型的写操作，不需要SEO。 后端采用MVC分层，严格区分视图层，视图层只有模板和注入的数据（控制器中渲染视图render($template, $data)）。然后把视图层（如module/article/views/index.html.php这个template）交给前端开发者来编写，前端只需要熟悉PHP模板的写法（主要就是在中用PHP写一些foreach循环和if else判断）和数据的调用（可以把注入到模板的数据$data理解为接口返回的数据）即可，这样界面完全由前端编写。对于POST类型提交的AJAX表单（不需要SEO，比如添加/编辑/删除等写操作），后端返回JSON，前端需要在浏览器里渲染HTML时可以使用jQuery模板库JSrender（它的模板也由前端开发者写在视图层中）。这样就实现了MVC的核心思想，彻底分离了界面和逻辑，同时不影响SEO和前后端分工。前端更加专注于UI和交互，不需要关注路由等其他层的逻辑。 &gt; 作者：eechen &gt; 链接：https://www.zhihu.com/question/365278222/answer/1144530972","link":"/2020/05/24/2020%E5%B9%B4%EF%BC%8CjQuery%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E9%82%A3%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"2020编程大牛的网盘资料汇总","text":"2020编程大牛的网盘资料汇总 Web系统运维高级架构师大数据2019版带文档 链接: https://pan.baidu.com/s/1wYTPocOe-VK0bETnEunerg 提取码: bqf7 Java简历模板 链接: https://pan.baidu.com/s/1wcsd16qtKV26kBc69n6Pvg 提取码: p2ug Python3数据科学入门与实战链接: https://pan.baidu.com/s/1KO7uDU48e-zZizkQUFdooQ 提取码: 3hew 实际工作需求文档 链接: https://pan.baidu.com/s/1a1Yp1rq3zfphO-yGg-R8Bw 提取码: yb4g SpringCloud微服务实战 链接: https://pan.baidu.com/s/1gMej53RpLX9jS1AubeJVaA 提取码: 93in 300套小程序 链接: https://pan.baidu.com/s/1AKLXJSM4ioPMeYkSvJf-ng 提取码: 4s99 Google面试官Java面试 链接: https://pan.baidu.com/s/1_WGGsVls9B9mr9DxSqPpBw 提取码: hey5 前端（一） 链接: https://pan.baidu.com/s/1NtH1KIESYlFXNZ8O-A0X-w 提取码: rech Java（一） 链接: https://pan.baidu.com/s/1WB9wPtbeYqh9vYVV8P4VVg 提取码: rc9j 新python机器学习 链接: https://pan.baidu.com/s/1RjFkYOIzNMc4EvjULkTYjw 提取码: h1ir SpringBoot点餐系统 链接: https://pan.baidu.com/s/1k8p1Ivtu6kW_4WroTEg3Cw 提取码: nm2u 从0开始Java开发电商项目 链接: https://pan.baidu.com/s/1wCkJ4nciPNl1PctXAvs56w 提取码: vfv4 Zookeeper分布式 链接: https://pan.baidu.com/s/1yplwWTANnXjM-NFoFXYKyQ 提取码: ixx4 面试指导 链接: https://pan.baidu.com/s/1BOGexWDjSd-lbCmPx1XdyA 提取码: a6vu java算法大全源码包 链接: https://pan.baidu.com/s/10TlotV18BDexD9jp1xwrMg 提取码: sep9 小程序教程大全 链接: https://pan.baidu.com/s/1ByLHoZbQBKApqmAGIJc57A 提取码: 9msv 前端成长之路 链接: https://pan.baidu.com/s/1JMAK1qVUCr5rBqIxGelorw 提取码: qey8 前端面试题 链接: https://pan.baidu.com/s/11A1OwZn-QzzdecN-JQClow 提取码: hub2 前端跳槽技巧 链接: https://pan.baidu.com/s/1nEi4VU_kvG7mPmqwx_Av0w 提取码: petc Java面试套路 链接: https://pan.baidu.com/s/1E9M-KYc75BCafHZ9GzgJrQ 提取码: gmk3 Java面试突击营 链接: https://pan.baidu.com/s/1zUEimHjvg17c1dABrjeu3A 提取码: qsnr 9000套网页模板 链接: https://pan.baidu.com/s/1IxPdgZLpoBUvewyCm4hY9w 提取码: 8get Java笔试题库 链接: https://pan.baidu.com/s/1x9d-NpNIrJ0vxwuCiomOBw 提取码: 6and 进入大数据 Spark SQL 的世界 链接: https://pan.baidu.com/s/1cOUnGTX5FvG5GtBiDV3tfw 提取码: 7tig Java深入微服务原理改造房产销售平台 链接: https://pan.baidu.com/s/1oAd11CLU-bsWGFMxjxCiMg 提取码: d88s JS设计模式全解 链接: https://pan.baidu.com/s/1fYkCfOQQdb_PFGap_vCTLw 提取码: fwxm 疑难问题解决方案 链接: https://pan.baidu.com/s/1z5FXuVzMTx_IzQS8YkwDyA 提取码: f2a6 React Native项目实战 链接: https://pan.baidu.com/s/1VnCivgkqxfYeHr7JXMkJWw 提取码: vbpb React 贯穿全栈开发APP 链接: https://pan.baidu.com/s/1BSMdvKmTvonegV_P0RfYZQ 提取码: 36mj Java并发编程 链接: https://pan.baidu.com/s/1zX41jbjZjG7Hads-q-0uWw 提取码: 53it 前端视频和资料： 链接: https://pan.baidu.com/s/1euDIVgo2hHyBl1YcLwu3nQ 提取码: 7xzc Python高级编程技巧 链接: https://pan.baidu.com/s/1jtC8WerhWeIEFoUag8hpDg 提取码: xwxx bootstrap视频和资料： 链接: https://pan.baidu.com/s/1SGfKhzibnYh-5W5IQNnluQ 提取码: md4w 0基础入门安卓 链接: https://pan.baidu.com/s/1T9QsNZWBAz43io-gJWFEcQ 提取码: xkkd 软件测试指导 链接: https://pan.baidu.com/s/1-C845J5vIiqmTXMAYEOEcQ 提取码: vx4b 高级架构师进阶 链接: https://pan.baidu.com/s/1-sGHknOU0IZjhdk_-7XUzg 提取码: ujs8 PPT2000套 链接: https://pan.baidu.com/s/1qVX5zDUPSnnTGoqMrSBM9w 提取码: s93g Hadoop视频和资料： 链接: https://pan.baidu.com/s/12fOK6lIYKNPZU4Kc-Ir3TQ 提取码: dy4y Linux指导 链接: https://pan.baidu.com/s/1EIEAmgQGcxUD7YgzNfIRJg 提取码: 3431 JavaEE实战 链接: https://pan.baidu.com/s/1TzKXFANtO5qL2PRg3hmr8w 提取码: ycjn mysql视频和资料： 链接: https://pan.baidu.com/s/1c1ErxrBn7YC6ALtnMz9bNg 提取码: qk5g go语言视频和资料： 链接：https://pan.baidu.com/s/1bIqDCXld1oHxHTqfhx6Acw 密码：xp6v 手机端开发视频和资料： 链接：https://pan.baidu.com/s/1z8Q2bZ_ZYzLbjIHRqVjrvQ 密码：1xgt scale视频和资料： 链接：https://pan.baidu.com/s/1IOX-gjWJtWam3XYZk9l6BQ 密码：euql 微服务气象实战： 链接：https://pan.baidu.com/s/1A-9DPRPK7D3d2KcocZwRig 提取码：qz2f spark视频和资料： 链接：https://pan.baidu.com/s/1IOX-gjWJtWam3XYZk9l6BQ 密码：euql 响应式一招开发制胜 链接：https://pan.baidu.com/s/1yLxWwW2Ql0fo0R-p8mt_qw 提取码：r52v 四大维度解锁Webpack3.0前端工程化 链接：https://pan.baidu.com/s/1svUZaIruItMV8NPAMzW-cw 提取码：uwe7 SVN视频和资料： 链接：https://pan.baidu.com/s/1QOXjJNF0_BOLN2hePal5_g 密码：1way 网上商城Extjs4.1+Spring3.2+hibernate4.1+MySql5（视频+源码）： 链接：https://pan.baidu.com/s/1wQAGwXBDK5XmZCl_J29Qug 提取码：xyme vue.js高仿饿了么 链接：https://pan.baidu.com/s/1uqBpqttmP_jCZoao57Gz9g 提取码：km8w 大型SpringMVC，Mybatis，Redis，Solr，Nginx，SSM分布式电商项目视频教程 链接：https://pan.baidu.com/s/1m71jc-K-0xfJ3zC6Au_byQ 提取码：tjpx Spring Cloud 链接：https://pan.baidu.com/s/1EkZwDVcqLY8OZ42NxHEuPA 提取码：18nj 第一套前端全套视频和源码： 链接：https://pan.baidu.com/s/1-eTjKfe1Ozge0YccblhY4w 密码：eyxs 第二套前端全套视频和源码： 链接：https://pan.baidu.com/s/1e6OC7fBWWQuzU6sGDj0Spw 密码：p8qm 第三套前端全套视频和源码： 链接：https://pan.baidu.com/s/1rd6gB64fS17ylqi3A9IA-w 密码：egy5 PHP全套第一套视频和资料： 链接：https://pan.baidu.com/s/13DCQxHpLos6VcB6gY5LZSw 密码：tmqq PHP全套第二套视频和资料： 链接：https://pan.baidu.com/s/18GF5u8Z4PploD2lYFgs_Ww 密码：l84u Web自动化测试 Selenium基础到企业应用 链接：https://pan.baidu.com/s/1XAuKpMXenB9qs1QNMF9g-Q 提取码：2xew 京东手机端制作视频和源码： 链接：https://pan.baidu.com/s/1GcCgnuYoZoOUadA8IpiywA 密码：o7z9 基于Laravel，AngularJS全栈开发知乎 链接：https://pan.baidu.com/s/1MKwxwY6GmHJIdT2d3s_F2Q 提取码：uvv7 强力django+杀手级xadmin 打造上线标准的在线教育平台 链接：https://pan.baidu.com/s/1enDpWa6jmRh5FR5cMvTFJQ 提取码：bfwy 前端 Vue+Node+MongoDB高级全栈开发 链接：https://pan.baidu.com/s/1EpuXIb7kpVc_7VrstTMWRg 提取码：8vcp 电商秒杀活动视频和源码 链接：https://pan.baidu.com/s/1RHHV8SOC7Q9BnPRTSVWYNg 密码：ze4h Web自动化测试 Selenium基础到企业应用 链接：https://pan.baidu.com/s/1IlcpX_iHrC2b3d3lyJbZ4w 提取码：23jb Nginx 链接：https://pan.baidu.com/s/1fRjIbk-rsL0HBo1WWaM-OQ 提取码：5z3a 麦子商城制作视频和源码： 链接：https://pan.baidu.com/s/1DpoF958TsQwdqYGK7r34lw 密码：5ab6 前端到后台ThinkPHP开发整站 链接：https://pan.baidu.com/s/1FZa8O03NLEOdSeqqb_HgEw 提取码：3km2 快速上手Linux 玩转典型应用 链接：https://pan.baidu.com/s/1dPZA47vku2eYQY_PhfCOtg 提取码：2rdm Vue核心技术 vue实战精讲 链接：https://pan.baidu.com/s/1sHStCWy4XJWflft6H_qAKA 提取码：0ybr 天猫商城购物车实战视频资料： 链接：https://pan.baidu.com/s/1UxtMqsszcAKpZ_2a41raSQ 密码：c1rd 移动端混合APP视频和资料： 链接：https://pan.baidu.com/s/1bwDYjR8UMk5pgpvPcxWBfA 密码：tkyj 企业级网站前端制作视频和源码： 链接：https://pan.baidu.com/s/1joNyOi5CegvJW4G-UeBODA 密码：wock 企业级网站后台制作视频和源码： 链接：https://pan.baidu.com/s/1769hXRG6OnWOfpZWwMpA-w 密码：k2wn OA办公自动化项目 链接：https://pan.baidu.com/s/1YqRWtnWJZAFNNCf_Z2SLtA 密码：ccj9 CRM客户管理项目 链接：https://pan.baidu.com/s/1I-OJSE-VXbX9dm8aN0QP4w 密码：o1vv 宅急送项目 链接：https://pan.baidu.com/s/1VFJ7TTwApFUZsQQnogjr-A 密码：phtf 校园网项目 链接：https://pan.baidu.com/s/1H4nUEtw3-WKVN78b6TuklA 密码：87gc Java邮件开发教程 链接：https://pan.baidu.com/s/1ZpLoacAYhk4v8_PzyGzxIg 密码：yzsb Java网上在线支付实战视频 链接：https://pan.baidu.com/s/1t3DjD7Fa7Vv66wyTND2ddQ 密码：3q1o 俄罗斯方块游戏开发视频教程 链接：https://pan.baidu.com/s/1_qXE5PpkEA3h2BX9dz64Bw 密码：jat1 银行业务调度系统视频教程 链接：https://pan.baidu.com/s/18cZZ22va495qjlAAU4jFzA 密码：w6ri 供应链系统视频教程 链接：https://pan.baidu.com/s/1TfV2dfrLnUAYlCVG8ppOlA 密码：hpz8 网上商城项目 链接：https://pan.baidu.com/s/1nHpOCPTinMDOhi07YFRR4w 密码：xrz0 药品集中采购视频教程 链接：https://pan.baidu.com/s/1i4xffBJjF-dwFC-QhrZA0g 密码：mwtw 杰信商贸ssm版 链接：https://pan.baidu.com/s/1m0EmptzKd7WDpYQ_i5fa4Q 密码：yukp 国家税务协同平台项目 链接：https://pan.baidu.com/s/1VkFTRv4DfKShN4VrlZyxdA 密码：runc Javaweb聊天室 链接：https://pan.baidu.com/s/1qKyQEzRABYDXAOK7Mx8XDQ 密码：evf5 网上书店 链接：https://pan.baidu.com/s/1Ya2NhTvoSNWthhCAvHUnSw 密码：82od 手机进销存系统 链接：https://pan.baidu.com/s/1SgZnAA_OhOZEjlB4Tr5GRA 密码：lbng QQ聊天器 链接：https://pan.baidu.com/s/1G1CX_GerVYMYWI3y7bbJRQ 密码：yvbn 坦克大战 链接：https://pan.baidu.com/s/1iQD04fXlCqrSG1Ezna_iqg 密码：fjtv 五子棋游戏 链接：https://pan.baidu.com/s/1Nwau0LZyWxAWp6Yqmsz0fw 密码：pw1l 报名系统 链接：https://pan.baidu.com/s/1bpJwXzysEgiOfLmULBMBOQ 密码：vm11 OA供应链系统 链接：https://pan.baidu.com/s/1YBoNDKUmmRg-ycTMKxeMNg 密码：kr6t 用户管理系统 链接：https://pan.baidu.com/s/1-LO1aDSdC0Kxy0c7ZNU_Bg 密码：2wlf Java web网上图书商城·完整项目 链接：https://pan.baidu.com/s/1tjmhDwGAn3Mdsof0Iu-efA 密码：k3sx VIP商场 链接：https://pan.baidu.com/s/1n3DuWFFIyyRzGI2RxR7jsw 密码：q8zt 《企业招聘系统》视频-jeecg开源频台 链接：https://pan.baidu.com/s/12b_V2LxoBoEP7EWK4Kc_Ew 密码：20sd 博客系统项目 链接：https://pan.baidu.com/s/1xGTxVPr-tijhyZPup54Euw 密码：4em4 超级玛丽 链接：https://pan.baidu.com/s/1Xr3S8Q4DKPoYQkNaW6oOuA 密码：aw9z 成绩管理系统 链接：https://pan.baidu.com/s/1ilvozGK8oB_-j5bhlvcB7w 密码：l4v2 个人理财系统 链接：https://pan.baidu.com/s/1uBY0ym-8jrNTn9ues_a-aw 密码：lbpc 人事管理系统项目实战视频 链接：https://pan.baidu.com/s/1wCNWOG-xaLb1yAvsIdK5Og 密码：3ayb JBPM采购申请系统 链接：https://pan.baidu.com/s/1tZdSrIIYH4bnZrMBOBqGHg 密码：0su2","link":"/2020/05/26/2020%E7%BC%96%E7%A8%8B%E5%A4%A7%E7%89%9B%E7%9A%84%E7%BD%91%E7%9B%98%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"},{"title":"21.深入Java系列Java之异常处理","text":"异常的定义异常：在Java语言中，将程序执行中发生的不正常情况称为“异常”。 （开发过程中的语法错误和逻辑错误不是异常） 1. 异常的体系结构Java程序在执行过程中所发生的异常事件可分为两类： Error： Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如： StackOverflowError和OOM。一般不编写针对性的代码进行处理。 Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如： 空指针访问 试图读取不存在的文件 网络连接中断 数组角标越界 123456789101112131415异常的体系结构 * java.lang.Throwable * |-----java.lang.Error:一般不编写针对性的代码进行处理。 * |-----java.lang.Exception:可以进行异常的处理 * |------编译时异常(checked)不会生成字节码文件 * |-----IOException * |-----FileNotFoundException * |-----ClassNotFoundException * |------运行时异常(unchecked,RuntimeException) * |-----NullPointerException//空指针异常 * |-----ArrayIndexOutOfBoundsException//数组角标越界 * |-----ClassCastException//类型转化异常 * |-----NumberFormatException//编码格式异常 * |-----InputMismatchException//输入不匹配 * |-----ArithmeticException//算术异常&lt;/code&gt; java中异常类的继承关系 2. 按照异常发生的时间可以分为两类 运行时异常：执行javac.exe命名时，可能出现的异常 是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。 java. lang. Runtime Exception类及它的子类都是运行时异常。 对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响 编译时异常：执行java.exe命名时，出现的异常 是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序==必须捕获或声明所有编译时异常== 对于这类异常，如果程序不处理，可能会带来意想不到的结果。 3.常见的异常类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//******************以下是运行时异常*************************** //ArithmeticException @Test public void test6(){ int a = 10; int b = 0; System.out.println(a / b); } //InputMismatchException @Test public void test5(){ Scanner scanner = new Scanner(System.in); int score = scanner.nextInt(); System.out.println(score); scanner.close(); } //NumberFormatException @Test public void test4(){ String str = &quot;123&quot;; str = &quot;abc&quot;; int num = Integer.parseInt(str); } //ClassCastException @Test public void test3(){ Object obj = new Date(); String str = (String)obj; } //IndexOutOfBoundsException @Test public void test2(){ //ArrayIndexOutOfBoundsException// int[] arr = new int[10];// System.out.println(arr[10]); //StringIndexOutOfBoundsException String str = &quot;abc&quot;; System.out.println(str.charAt(3)); } //NullPointerException @Test public void test1(){ // int[] arr = null;// System.out.println(arr[3]); String str = &quot;abc&quot;; str = null; System.out.println(str.charAt(0)); } //******************以下是编译时异常*************************** @Test public void test7(){// File file = new File(&quot;hello.txt&quot;);// FileInputStream fis = new FileInputStream(file);// // int data = fis.read();// while(data != -1){// System.out.print((char)data);// data = fis.read();// }// // fis.close(); } 异常的处理1. java异常处理的抓抛模型过程一：”抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出。一旦抛出对象以后，其后的代码就不再执行。 关于异常对象的产生： ① 系统自动生成的异常对象 ② 手动的生成一个异常对象，并抛出（throw） 过程二：”抓”：可以理解为异常的处理方式：① try-catch-finally ② throws 2.异常处理方式一：try-catch-finally2.1 使用说明：1234567891011121314try{ //可能出现异常的代码}catch(异常类型1 变量名1){ //处理异常的方式1}catch(异常类型2 变量名2){ //处理异常的方式2}catch(异常类型3 变量名3){ //处理异常的方式3} ....finally{ //一定会执行的代码} 说明： finally是可选的。 使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配 一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的try-catch结构（在没写finally的情况。继续执行其后的代码） catch中的异常类型如果没子父类关系，则谁声明在上，谁声明在下无所谓。 catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错 常用的异常对象处理的方式： ① String getMessage() ② printStackTrace() 在try结构中声明的变量，再出了try结构以后，就不能再被调用 try-catch-finally结构可以嵌套 如何看待代码中的编译时异常和运行时异常？ 使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。 开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。==针对于编译时异常，我们说一定要考虑异常的处理==。 2.2. finally的再说明： finally是可选的 finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中return语句，catch中return语句等情况。 像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。 3. 异常处理方式二：“throws + 异常类型”==写在方法的声明处==。指明此方法执行时，可能会抛出的异常类型。 一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！ 4. 对比两种处理方式try-catch-finally:真正的将异常给处理掉了。 throws的方式只是将异常抛给了方法的调用者。==并没真正将异常处理掉==。 5. 开发中应该如何选择两种处理方式？ 如果父类中被重写的方法没throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中异常，必须使用try-catch-finally方式处理。 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。 补充： 方法重写的规则之一： 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型 手动抛出异常对象1.使用说明在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的throw一个异常类的对象。 2.经典面试题throw 和 throws区别： throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。 throws 属于异常处理的一种方式，声明在方法的声明处。 3.代码示例12345678910111213141516171819202122class Student{ private int id; public void regist(int id) throws Exception { if(id &gt; 0){ this.id = id; }else{ //手动抛出异常对象// throw new RuntimeException(&quot;您输入的数据非法！&quot;);// throw new Exception(&quot;您输入的数据非法！&quot;); throw new MyException(&quot;不能输入负数&quot;); } } @Override public String toString() { return &quot;Student [id=&quot; + id + &quot;]&quot;; }} 自定义异常类1.如何自定义异常类 继承于现的异常结构：RuntimeException 、Exception 提供全局常量：serialVersionUID（对类的唯一标识） 提供重载的构造器 2.代码示例123456789101112public class MyException extends Exception{ static final long serialVersionUID = -7034897193246939L; public MyException(){ } public MyException(String msg){ super(msg); }}","link":"/2020/04/05/21-%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97Java%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"title":"22.深入Java系列结构模式之组合模式","text":"1 概述组合模式(Composite Pattern)，是指把一类有共同抽象的对象组合在一起，形成树状结构，来表示部分-整体的关系。 2 组合模式我们经常会遇到一些对象有相同的行为，同时对象之间又有层级结构。像这种情况，使用组合模式可以使系统高内聚，低耦合。通过把类组合成树形结构，调用者能够以统一的方式对待单个对象和整体结构，忽略个体和整体之间的差异。实现组合模式一般需要： 定义一个接口/抽象类，并定义对象的公共行为，其中包括维护对象间层次结构的方法。 定义对象的实体，实现接口/抽象类中的方法。 按树形结构，将所有的实体组合在一起，形成一个整体。 3 案例看一个例子。所有公司的员工，其实都是同一族的对象，有相似的属性与行为，同时，员工之间又有层级结构，很适合用组合模式来表示员工之间的关系： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121public class Test { public static void main(String[] args) { // 构建层级结构 Director director = new Director(&quot;Polly&quot;); Manager frontendManager = new Manager(&quot;Lilei&quot;); Manager backendManager = new Manager(&quot;Hanmeimei&quot;); Engineer jsEngineer = new Engineer(&quot;Lily&quot;); Engineer ueDesigner = new Engineer(&quot;Lucy&quot;); Engineer javaEngineer = new Engineer(&quot;Jim&quot;); Engineer dbAdmin = new Engineer(&quot;Kate&quot;); director.addChild(frontendManager); director.addChild(backendManager); frontendManager.addChild(jsEngineer); frontendManager.addChild(ueDesigner); backendManager.addChild(javaEngineer); backendManager.addChild(dbAdmin); // 如对待整体如对待单个对象一般 director.work(); }}// 定义了Employee的公共方法，同时定义了添加/删除节点的方法public interface Employee&lt;T extends Employee&gt; { String getName(); Collection&lt;T&gt; getChildren() throws OperationNotSupportedException; void addChild(T employee) throws OperationNotSupportedException; void removeChild(T employee) throws OperationNotSupportedException; void work();}public class Director implements Employee&lt;Manager&gt; { private String name; private Collection&lt;Manager&gt; children = new ArrayList&lt;&gt;(); Director(String name) { this.name = name; }; [@Override](https://my.oschina.net/u/1162528) public String getName() { return name; } [@Override](https://my.oschina.net/u/1162528) public Collection getChildren() { return children; } [@Override](https://my.oschina.net/u/1162528) public void addChild(Manager employee) { children.add(employee); } [@Override](https://my.oschina.net/u/1162528) public void removeChild(Manager employee) { children.remove(employee); } // 循环调用子节点的方法 [@Override](https://my.oschina.net/u/1162528) public void work() { System.out.println(&quot;Director &quot; + name + &quot; gives command to his subordinate...&quot;); for (Employee child : children) { child.work(); } }}public class Manager implements Employee&lt;Engineer&gt; { private String name; private Collection&lt;Engineer&gt; children = new ArrayList&lt;&gt;(); Manager(String name) { this.name = name; }; @Override public String getName() { return name; } @Override public Collection getChildren() { return children; } @Override public void addChild(Engineer employee) { children.add(employee); } @Override public void removeChild(Engineer employee) { children.remove(employee); } // 循环调用子节点的方法 @Override public void work() { System.out.println(&quot;Manager &quot; + name + &quot; gives command to his subordinates...&quot;); for (Employee child : children) { child.work(); } }}public class Engineer implements Employee { private String name; Engineer(String name) { this.name = name; }; @Override public String getName() { return name; } @Override public Collection getChildren() throws OperationNotSupportedException { throw new OperationNotSupportedException(&quot;No child under engineer.&quot;); } @Override public void addChild(Employee employee) throws OperationNotSupportedException { throw new OperationNotSupportedException(&quot;Can not add child for engineer.&quot;); } @Override public void removeChild(Employee employee) throws OperationNotSupportedException { throw new OperationNotSupportedException(&quot;Can not remove child for engineer.&quot;); } @Override public void work() { System.out.println(&quot;Engineer &quot; + name + &quot; is coding...&quot;); }}``` 输出： Director Polly gives command to his subordinate…Manager Lilei gives command to his subordinates…Engineer Lily is coding…Engineer Lucy is coding…Manager Hanmeimei gives command to his subordinates…Engineer Jim is coding…Engineer Kate is coding… 12345678![知识铺-pasted-266.png](https:\\/\\/blog.zshipu.com/tlg/images/pasted-266.png)运用**组合模式**，我们可以用一致的行为来操作整体与单个对象，显著降低了系统的复杂度。同时，树形结构也很易于扩展，方便日后的维护。`java.awt.Container`就运用了**组合模式**，各个组件之间，其实是个树形结构，`Container`是所有组件的根结点： public class Container extends Component { private java.util.List component = new ArrayList&lt;&gt;(); // 添加组件 protected void add(Component comp, Object constraints, int index) { … //index == -1 means add to the end. if (index == -1) { component.add(comp); } else { component.add(index, comp); } comp.parent = this; comp.setGraphicsConfiguration(thisGC); … } // 移除组件 public void remove(int index) { synchronized (getTreeLock()) { … component.remove(index); comp.setGraphicsConfiguration(null); … } } // 调用updateGraphicsData方法，以及子节点的updateGraphicsData方法 boolean updateGraphicsData(GraphicsConfiguration gc) { boolean ret = super.updateGraphicsData(gc); for (Component comp : component) { if (comp != null) { ret |= comp.updateGraphicsData(gc); } } return ret; } …} ``` 4 总结当对象之间存在层级关系的时候，可以考虑使用组合模式，统一单个对象和组合对象，降低系统复杂度。 文中例子的github地址","link":"/2020/04/05/22-%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"title":"27.深入Java系列Java - 文件和 I&#x2F;O","text":"Java - 文件和 I/O java.io包包含在 Java 中执行输入和输出 （I/O） 可能需要的几乎所有类。所有这些流表示输入源和输出目标。java.io包中的流支持许多数据，如基元、对象、本地化字符等。 流流可以定义为一系列数据。有两种类型的流 | 输入流– 输入流用于从源读取数据。 OutPutStream – 输出流用于将数据写入目标。 Java 为与文件和网络相关的 I/O 提供了强大但灵活的支持，但本教程涵盖了与流和 I/O 相关的非常基本的功能。我们将看到最常用的示例一个接一个 | 字节流Java 字节流用于执行 8 位字节的输入和输出。虽然有许多与字节流相关的类，但最常用的类是，文件输入流和文件输出流。下面是一个示例，它利用这两个类将输入文件复制到输出文件中 | 例子 12345678910111213141516171819202122232425import java.io.*;public class CopyFile { public static void main(String args[]) throws IOException { FileInputStream in = null; FileOutputStream out = null; try { in = new FileInputStream(&quot;input.txt&quot;); out = new FileOutputStream(&quot;output.txt&quot;); int c; while ((c = in.read()) != -1) { out.write(c); } }finally { if (in != null) { in.close(); } if (out != null) { out.close(); } } }} 现在，让我们有一个文件输入.txt与以下内容 | 1This is test for copy file. 作为下一步，编译上述程序并执行它，这将导致创建输出.txt 文件，其内容与输入.txt 中的内容相同。因此，让我们把上述代码放在CopyFile.java文件中，并做以下操作 ： 12$javac CopyFile.java$java CopyFile 字符流Java字节流用于执行 8 位字节的输入和输出，而 Java字符流用于为 16 位单码执行输入和输出。虽然有许多与字符流相关的类，但最常用的类是FileReader和FileWriter。虽然内部文件阅读器使用 FileInputStream，文件编写器使用文件输出流，但这里的主要区别是 FileReader 一次读取两个字节，FileWriter 一次写入两个字节。 我们可以重写上述示例，这利用这两个类将输入文件（具有单码字符）复制到输出文件中 | 例子 12345678910111213141516171819202122232425import java.io.*;public class CopyFile { public static void main(String args[]) throws IOException { FileReader in = null; FileWriter out = null; try { in = new FileReader(&quot;input.txt&quot;); out = new FileWriter(&quot;output.txt&quot;); int c; while ((c = in.read()) != -1) { out.write(c); } }finally { if (in != null) { in.close(); } if (out != null) { out.close(); } } }} 现在，让我们有一个文件输入.txt与以下内容 | 1This is test for copy file. 作为下一步，编译上述程序并执行它，这将导致创建输出.txt 文件，其内容与输入.txt 中的内容相同。因此，让我们把上述代码放在CopyFile.java文件中，并做以下操作 ： 12$javac CopyFile.java$java CopyFile 标准流所有编程语言都支持标准 I/O，用户可以从键盘获取输入，然后在计算机屏幕上生成输出。如果您了解 C 或C++编程语言，则必须了解 STDIN、STDOUT 和 STDERR 三种标准设备。同样，Java 提供了以下三个标准流 | 标准输入– 这用于将数据馈送到用户的程序，通常键盘用作标准输入流，并表示为System.in。 标准输出– 这用于输出用户程序生成的数据，通常计算机屏幕用于标准输出流，并表示为System。 标准错误– 这用于输出用户程序生成的错误数据，通常计算机屏幕用于标准错误流，并表示为System.err。 下面是一个简单的程序，它创建InputStreamReader来读取标准输入流，直到用户键入”q” | 例子 现场演示 123456789101112131415161718import java.io.*;public class ReadConsole { public static void main(String args[]) throws IOException { InputStreamReader cin = null; try { cin = new InputStreamReader(System.in); System.out.println(&quot;Enter characters, 'q' to quit.&quot;); char c; do { c = (char) cin.read(); System.out.print(c); } while(c != 'q'); }finally { if (cin != null) { cin.close(); } } }} 让我们将上述代码保存在 ReadConsole.java 文件中，并尝试编译和执行它，如以下程序所示。此程序继续读取和输出相同的字符，直到我们按”q” | 123456789$javac ReadConsole.java$java ReadConsoleEnter characters, 'q' to quit.11eeqq 读取和写入文件如前所述，流可以定义为一系列数据。输入流用于从源读取数据，输出流用于将数据写入目标。 下面是处理输入和输出流的类层次结构。 两个重要的流是文件输入流和文件输出流，这将在本教程中讨论。 文件输入流此流用于从文件中读取数据。可以使用关键字new创建对象，并且可以使用多种类型的构造函数。 以下构造函数将文件名作为字符串来创建用于读取文件的输入流对象 | 1InputStream f = new FileInputStream(&quot;C:/java/hello&quot;); 以下构造函数采用文件对象来创建用于读取文件的输入流对象。首先，我们使用 File（） 方法创建一个文件对象，如下所示 ： 12File f = new File(&quot;C:/java/hello&quot;);InputStream f = new FileInputStream(f); 一旦您手头有_InputStream_对象，则有一个帮助器方法的列表，可用于读取以流或对流执行其他操作。 | Sr.No | 方法和描述 || 1 | *公共空隙关闭（） 引发 IOException ** 此方法关闭文件输出流。释放与该文件关联的任何系统资源。引发 IO 异常。 || 2 | 受保护的空位定稿（）引发 IO 例外 | 此方法清理到该文件的连接。确保在不再引用此流时调用此文件输出流的关闭方法。引发 IO 异常。 || 3 | *公共 int 读取 （int r） 引发 IOException** 此方法从输入流读取指定的数据字节。返回 int. 返回数据的下一个字节，如果是文件结尾，则返回 -1。 || 4 | *公共 int 读取 （字节 = r） 引发 IOException** 此方法从输入流读取 r.长度字节到数组中。返回读取的字节总数。如果是文件结尾，则将返回 -1。 || 5 | *公共 int 可用 （） 引发 IOException** 提供可以从此文件输入流读取的字节数。返回 int。 | 文件输出流文件输出流用于创建文件并将数据写入其中。流将在打开文件以进行输出之前创建一个文件（如果该文件不存在）。 下面是两个构造函数，可用于创建文件输出流对象。 以下构造函数将文件名作为字符串来创建输入流对象来写入文件 | 1OutputStream f = new FileOutputStream(&quot;C:/java/hello&quot;) 后续构造函数采用文件对象来创建输出流对象来写入文件。首先，我们使用 File（） 方法创建文件对象，如下所示 ： 12File f = new File(&quot;C:/java/hello&quot;);OutputStream f = new FileOutputStream(f); 一旦拥有_了 OutputStream_对象，则有一个帮助程序方法的列表，可用于写入流或在流上执行其他操作。 | Sr.No | 方法和描述 || 1 | *公共空隙关闭（） 引发 IOException ** 此方法关闭文件输出流。释放与该文件关联的任何系统资源。引发 IO 异常。 || 2 | 受保护的空位定稿（）引发 IO 例外 | 此方法清理到该文件的连接。确保在不再引用此流时调用此文件输出流的关闭方法。引发 IO 异常。 || 3 | *公共空写（int w）引发 IOException** 此方法将指定的字节写入输出流。 || 4 | 公共空写（字节= w） 将带长字节从上述字节数组写入输出流。 | 例子 下面是演示输入流和输出流的示例 | 1234567891011121314151617181920212223import java.io.*;public class fileStreamTest { public static void main(String args[]) { try { byte bWrite [] = {11,21,3,40,5}; OutputStream os = new FileOutputStream(&quot;test.txt&quot;); for(int x = 0; x &lt; bWrite.length ; x++) { os.write( bWrite[x] ); // writes the bytes } os.close(); InputStream is = new FileInputStream(&quot;test.txt&quot;); int size = is.available(); for(int i = 0; i &lt; size; i++) { System.out.print((char)is.read() + &quot; &quot;); } is.close(); } catch (IOException e) { System.out.print(&quot;Exception&quot;); } }} 上述代码将创建文件 test.txt，并将以二进制格式写入给定数字。在防稳的屏幕上的输出也是如此。 文件导航和 I/O我们还将经历其他几个类，以便了解文件导航和 I/O 的基础知识。 Java 中的目录目录是一个文件，它可以包含其他文件和目录的列表。您可以使用File对象创建目录，以列出目录中可用的文件。有关完整详细信息，请查看可以调用 File 对象的所有方法以及与目录相关的方法的列表。 创建目录有两种有用的文件实用程序方法，可用于创建目录 | mkdir（ 方法创建一个目录，在成功时返回 true，在失败时返回 false。失败指示 File 对象中指定的路径已存在，或者无法创建目录，因为整个路径尚不存在。 mkdirs（）方法同时创建目录和目录的所有父目录。 以下示例创建”/tmp/用户/java/bin”目录 | 例子 12345678910import java.io.File;public class CreateDir { public static void main(String args[]) { String dirname = &quot;/tmp/user/java/bin&quot;; File d = new File(dirname); // Create directory now. d.mkdirs(); }} 编译并执行上述代码以创建”/tmp/用户/java/bin”。 注意– Java 根据约定自动处理 UNIX 和 Windows 上的路径分隔符。如果在 Java 的 Windows 版本上使用前斜杠 （/），则路径仍将正确解析。 列出目录您可以使用File对象提供的列表（ ）方法列出目录中可用的所有文件和目录，如下所示 ： 例子 12345678910111213141516171819202122import java.io.File;public class ReadDir { public static void main(String[] args) { File file = null; String[] paths; try { // create new file object file = new File(&quot;/tmp&quot;); // array of files and directory paths = file.list(); // for each name in the path array for(String path:paths) { // prints filename and directory name System.out.println(path); } } catch (Exception e) { // if any error occurs e.printStackTrace(); } }} 这将根据**/tmp**目录中可用的目录和文件生成以下结果 | 输出 test1.txttest2.txtReadDir.javaReadDir.class","link":"/2020/04/06/27-%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97Java-%E6%96%87%E4%BB%B6%E5%92%8C-I-O/"},{"title":"28.深入Java系列Java - 对象和类","text":"Java - 对象和类Java 是面向对象的语言。作为具有面向对象功能的语言，Java 支持以下基本概念 | 多 态 性 继承 封装 抽象 类 对象 实例 方法 消息传递 在本章中，我们将介绍概念 - 类和对象。 对象= 对象具有状态和行为。示例：狗有状态 - 颜色，名称，品种以及行为 - 摇尾巴，吠叫，吃。对象是类的实例。 类– 类可以定义为描述其类型对象支持的行为/状态的模板/蓝图。 Java 中的对象现在让我们深入探讨什么是对象。如果我们考虑现实世界，我们可以发现我们周围的许多物体，汽车，狗，人类等。所有这些对象都有一个状态和行为。 如果我们考虑一只狗，那么它的状态是 - 名称，品种，颜色，和行为是 - 吠叫，摇尾巴，运行。 如果将软件对象与实际对象进行比较，它们具有非常相似的特征。 软件对象也具有状态和行为。软件对象的状态存储在字段中，行为通过方法显示。 因此，在软件开发中，方法对对象的内部状态进行操作，对象到对象的通信是通过方法完成的。 Java 中的类类是创建单个对象的蓝图。 下面是类的示例。 例子1234567891011121314public class Dog { String breed; int age; String color; void barking() { } void hungry() { } void sleeping() { }} 类可以包含以下任何变量类型。 局部变量= 在方法、构造函数或块内定义的变量称为局部变量。变量将在方法中声明和初始化，并且变量将在方法完成后销毁。 实例变量= 实例变量是类中的变量，但在任何方法之外。当实例化类时，这些变量将初始化。可以从该特定类的任何方法、构造函数或块内部访问实例变量。 类变量= 类变量是使用静态关键字在类中声明的变量，在任何方法之外。 类可以具有任意数量的方法来访问各种方法的值。在上面的例子中，吠叫（）、饥饿和睡觉是方法。 以下是在研究 Java 语言类时需要讨论的一些重要主题。 构造 函数讨论类时，最重要的子主题之一是构造函数。每个类都有一个构造函数。如果我们不显式为类编写构造函数，Java 编译器将为该类生成默认构造函数。 每次创建新对象时，将至少调用一个构造函数。构造函数的主要规则是它们应具有与类相同的名称。类可以有多个构造函数。 下面是构造函数的示例 | 例子12345678public class Puppy { public Puppy() { } public Puppy(String name) { // This constructor has one parameter, _name_. }} 注意= 我们有两种不同类型的构造函数。我们将在后续章节中详细讨论构造函数。 创建对象如前所述，类提供对象的蓝图。因此，基本上，对象是从类创建的。在 Java 中，新关键字用于创建新对象。 从类创建对象时有三个步骤 | 声明= 具有具有对象类型的变量名称的变量声明。 实例化– 使用”新”关键字创建对象。 初始化– “new”关键字后跟对构造函数的调用。此调用初始化新对象。 下面是创建对象的示例 | 例子 现场演示 1234567891011public class Puppy { public Puppy(String name) { // This constructor has one parameter, _name_. System.out.println(&quot;Passed Name is :&quot; + name ); } public static void main(String []args) { // Following statement would create an object myPuppy Puppy myPuppy = new Puppy( &quot;tommy&quot; ); }} 如果我们编译并运行上述程序，那么它将产生以下结果 | 输出1Passed Name is :tommy 访问实例变量和方法实例变量和方法通过创建的对象进行访问。要访问实例变量，下面是完全限定的路径 | 12345678/* First create an object */ObjectReference = new Constructor();/* Now call a variable as follows */ObjectReference.variableName;/* Now you can call a class method as follows */ObjectReference.MethodName(); 例子此示例说明如何访问类的实例变量和方法。 现场演示 12345678910111213141516171819202122232425262728public class Puppy { int puppyAge; public Puppy(String name) { // This constructor has one parameter, _name_. System.out.println(&quot;Name chosen is :&quot; + name ); } public void setAge( int age ) { puppyAge = age; } public int getAge( ) { System.out.println(&quot;Puppy's age is :&quot; + puppyAge ); return puppyAge; } public static void main(String []args) { /* Object creation */ Puppy myPuppy = new Puppy( &quot;tommy&quot; ); /* Call class method to set puppy's age */ myPuppy.setAge( 2 ); /* Call another class method to get puppy's age */ myPuppy.getAge( ); /* You can access instance variable as follows as well */ System.out.println(&quot;Variable Value :&quot; + myPuppy.puppyAge ); }} 如果我们编译并运行上述程序，那么它将产生以下结果 | 输出123Name chosen is :tommyPuppy's age is :2Variable Value :2 源文件声明规则作为本节的最后一部分，现在让我们来看看源文件声明规则。在源文件中声明类、_导入_语句和_包_语句时，这些规则至关重要。 每个源文件只能有一个公共类。 源文件可以有多个非公共类。 公共类名称应该是源文件的名称，并且应在末尾由**.java**追加。例如：类名称是_公共类”员工]”，_则源文件应为 Employ.java。 如果类在包中定义，则包语句应该是源文件中的第一个语句。 如果存在导入语句，则必须在包语句和类声明之间写入它们。如果没有包语句，则导入语句应该是源文件中的第一行。 导入和包语句将意味着源文件中存在的所有类。无法将不同的导入和/或包语句声明给源文件中的不同类。 类具有多个访问级别，并且有不同类型的类;抽象类、最终类等。我们将在访问修改器章节中解释所有这些。 除了上述类类型外，Java 还有一些称为内部类和匿名类的特殊类。 Java 包简单地说，它是对类和接口进行分类的一种方式。在 Java 中开发应用程序时，将编写数百个类和接口，因此对这些类进行分类是必须的，而且使生活更加轻松。 导入语句在 Java 中，如果提供了完全限定的名称（包括包和类名称），则编译器可以轻松地查找源代码或类。导入语句是为编译器提供查找该特定类的正确位置的一种方式。 例如，以下行将要求编译器加载目录java_installation/java/io 中提供的所有类 | 1import java.io.*; 简单案例研究对于我们的案例研究，我们将创建两个类。他们是员工和员工测试。 首先打开记事本并添加以下代码。请记住，这是”员工”类，该类是公共类。现在，用名称”员工.java”保存此源文件。 员工类有四个实例变量 - 名称、年龄、名称和工资。类有一个显式定义的构造函数，它采用一个参数。 例子123456789101112131415161718192021222324252627282930313233import java.io.*;public class Employee { String name; int age; String designation; double salary; // This is the constructor of the class Employee public Employee(String name) { this.name = name; } // Assign the age of the Employee to the variable age. public void empAge(int empAge) { age = empAge; } /* Assign the designation to the variable designation.*/ public void empDesignation(String empDesig) { designation = empDesig; } /* Assign the salary to the variable salary.*/ public void empSalary(double empSalary) { salary = empSalary; } /* Print the Employee details */ public void printEmployee() { System.out.println(&quot;Name:&quot;+ name ); System.out.println(&quot;Age:&quot; + age ); System.out.println(&quot;Designation:&quot; + designation ); System.out.println(&quot;Salary:&quot; + salary); }} 如本教程前面提到的，处理从主方法开始。因此，为了运行此员工类，应该有一个主要的方法，并且应该创建对象。我们将为这些任务创建一个单独的类。 下面是_”员工测试”_类，该类创建类 Employ 的两个实例，并调用每个对象的方法为每个变量分配值。 将以下代码保存在员工Test.java文件中。 1234567891011import java.io.*;public class EmployeeTest { public static void main(String args[]) { /* Create two objects using constructor */ Employee empOne = new Employee(&quot;James Smith&quot;); Employee empTwo = new Employee(&quot;Mary Anne&quot;); // Invoking methods for each object created empOne.empAge(26); empOne.empDesignation(&quot;Senior Software Engineer&quot;); empOne.empSalary(1000); empOne.printEmployee(); empTwo.empAge(21); empTwo.empDesignation(&quot;Software Engineer&quot;); empTwo.empSalary(500); empTwo.printEmployee(); }} 现在，编译两个类，然后运行_”员工测试”_以查看结果，如下所示 | 输出1234567891011C:\\&gt; javac Employee.javaC:\\&gt; javac EmployeeTest.javaC:\\&gt; java EmployeeTestName:James SmithAge:26Designation:Senior Software EngineerSalary:1000.0Name:Mary AnneAge:21Designation:Software EngineerSalary:500.0","link":"/2020/04/06/28-%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97Java-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/"},{"title":"29.深入Java系列Java - 构造函数","text":"Java - 构造函数 构造函数在创建对象时初始化对象。它与它的类具有相同的名称，在语法上与方法类似。但是，构造函数没有显式返回类型。 通常，您将使用构造函数为类定义的实例变量提供初始值，或执行创建完全形成的对象所需的任何其他启动过程。 所有类都有构造函数，无论您是否定义一个，因为 Java 会自动提供一个默认构造函数，将所有成员变量初始化为零。但是，一旦定义自己的构造函数，将不再使用默认构造函数。 语法以下是构造函数的语法 | 1234class ClassName { ClassName() { }} Java 允许两种类型的构造函数，即 | 无参数构造函数 参数化构造函数 无参数构造函数由于名称指定 Java 的 no 参数构造函数不接受任何参数，因此使用这些构造函数，将使用所有对象的固定值初始化方法的实例变量。 例子12345Public class MyClass { Int num; MyClass() { num = 100; }} 您将调用构造函数来初始化对象，如下所示 1234567public class ConsDemo { public static void main(String args[]) { MyClass t1 = new MyClass(); MyClass t2 = new MyClass(); System.out.println(t1.num + &quot; &quot; + t2.num); }} 这将产生以下结果 1100 100 参数化构造函数通常，您需要一个接受一个或多个参数的构造函数。参数被添加到构造函数的方式与添加到方法的方式相同，只需在构造函数的名称之后的括号内声明它们。 例子下面是一个使用构造函数的简单示例 | 12345678// A simple constructor.class MyClass { int x; // Following is the constructor MyClass(int i ) { x = i; }} 您将调用构造函数来初始化对象，如下所示 | 1234567public class ConsDemo { public static void main(String args[]) { MyClass t1 = new MyClass( 10 ); MyClass t2 = new MyClass( 20 ); System.out.println(t1.x + &quot; &quot; + t2.x); }} 这将产生以下结果 | 110 20","link":"/2020/04/06/29-%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97Java-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"title":"30.深入Java系列Java - 数据结构","text":"Java - 数据结构 Java 实用程序包提供的数据结构非常强大，并执行各种功能。这些数据结构由以下接口和类组成 | 枚举 位集 向量 堆栈 字典 哈希表 性能 所有这些类现在都是遗留的，Java-2 引入了一个名为集合框架的新框架，下一章将对此进行讨论。• 枚举枚举接口本身不是数据结构，但它在其他数据结构的上下文中非常重要。枚举接口定义从数据结构检索连续元素的方法。 例如，枚举定义一种称为 NextElement 的方法，该方法用于获取包含多个元素的数据结构中的下一个元素。 位集BitSet 类实现一组可以单独设置和清除的位或标志。 在需要跟上一组布尔值的情况下，此类非常有用;只需为每个值分配一点，并根据需要设置或清除它。 矢量Vector 类类似于传统的 Java 数组，只不过它可以根据需要增长以适应新元素。 与数组一样，矢量对象的元素可以通过索引访问到矢量中。 使用 Vector 类的好处是，您不必担心在创建时将其设置为特定大小;必要时自动收缩和生长。 堆栈堆栈类实现最后一个先出 （LIFO） 元素堆栈。 您可以将堆栈从字面上视为对象的垂直堆栈;添加新元素时，它堆叠在其它元素之上。 当您从堆栈中拉出元素时，它从顶部脱落。换句话说，添加到堆栈的最后一个元素是第一个返回的元素。 词典字典类是一个抽象类，用于定义数据结构，用于将键映射到值。 当您希望能够通过特定键而不是整数索引访问数据时，这非常有用。 由于字典类是抽象的，它仅提供键映射数据结构的框架，而不是特定的实现。 哈希表哈希表类提供了一种基于某些用户定义的密钥结构组织数据的方法。 例如，在地址列表哈希表中，您可以存储和排序数据基于键（如邮政编码，而不是基于人员的姓名）。 键对哈希表的具体含义完全取决于哈希表及其包含的数据的用法。 属性属性是哈希表的子类。它用于维护键为字符串且该值也是字符串的值列表。 属性类由许多其他 Java 类使用。例如，它是系统.getProperties（ ） 获取环境值时返回的对象类型。","link":"/2020/04/06/30-%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97Java-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"Spring Security url 拦截匹配规则","text":"Spring Security 可以为 url 设置各种访问规则，比如： http.authorizeRequests().antMatchers(“/api/**”).denyAll(); //拒绝访问 http.authorizeRequests().antMatchers(“/api/**”).authenticated(); //需认证通过 http.authorizeRequests().antMatchers(“/api/**”).permitAll(); //无条件允许访问 但是遇到下面这些情况，SpringSecurity会如何处理呢？ 1、一个url可以匹配多个规则：如 /api/bbb/ccc 这个url ，既可以匹配 /** ，又可以匹配 /api/**，最终会匹配哪条规则呢？ 2、存在相同url 的匹配规则，如上面例子中 “/api/**” 一共有三条规则，一个denyAll，一个authenticated，一个permitAll ，最终会匹配哪条规则呢？ 让我们深入代码弄清楚这些问题【版本 SpringSecurity 5.0.7】： 每注册一个规则 antMatchers(“/api/**”).xxx() 时， SpringSecurity会把这个规则按注册先后顺序放到一个**ArrayList**中，先注册的规则放前面，后注册的放后面。 然后将这个 ArrayList 进行处理（ AbstractConfigAttributeRequestMatcherRegistry.createRequestMap 方法）。 处理的规则是这样： 按顺序遍历这个ArrayList，以 url的RequestMatcher 为 key ，以 denyAll，authenticated 等 为值， put 进一个 LinkedHashMap。 这个 LinkedHashMap 就是最终的 规则集合。 此时，有访问请求Web服务器， Web服务器从request中取出访问的url。 通过之前得到的那个 LinkedHashMap 去 对 url 进行权限判断，第一个能匹配上这个url的规则，就是最终会执行的规则。（DefaultFilterInvocationSecurityMetadataSource.getAttributes 方法） 上面的内容可能看起来有点晕，简单说就是： 1、注册的规则 按先后顺序放到一个List， 然后又用Map去掉完全相同的 url匹配规则。这个Map 就是最终的规则存放处。 2、当有访问到来时，则根据访问的url 循环这个 Map 进行匹配，能匹配上的第一个规则就是 最终执行的规则。 然后回到我们上面提出的两个问题： 1、一个url可以匹配多个规则：如 /api/bbb/ccc 这个url ，既可以匹配 /** ，又可以匹配 /api/**，最终会匹配哪条规则呢？ 解答：按你注册规则的顺序，第一条能匹配上的，就是最终会执行的规则。 延伸：注册规则的时候一定要注意顺序，如果 /** 第一个注册，则后面的任何规则都不会被匹配了，永远执行 /** 的这个规则。 2、存在相同url 的匹配规则，如上面例子中 “/api/**” 一共有三条规则，一个denyAll，一个authenticated，一个permitAll ，最终会匹配哪条规则呢？ 解答：在 ArrayList 转 LinkedHashMap 时，相同的url 的匹配规则中 后面的会冲掉 前面的， 所以，最终执行的规则会是最后注册的那条。","link":"/2020/04/15/B1-Spring-Security-url-%E6%8B%A6%E6%88%AA%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"},{"title":"Bulma CSS - 开始","text":"Bulma CSS - 开始 Bulma CSS框架教程Bulma CSS – 简介Bulma CSS – 开始Bulma CSS – CSS类Bulma CSS – 模块化Bulma CSS – 响应式 有数种方法可以安装Bulma： 使用npm安装Bulma包 使用cdnjs CDN链接到Bulma样式表 从GitHub项目库获得最新的开发版本 1. 使用npm安装Bulma包npm install bulma 2. 使用cdnjs CDNhttps://cdnjs.com/libraries/bulma 3. 从GitHub项目库下载https://github.com/jgthms/bulma/tree/master/css Font Awesome 字体图标如果想使用图标，可加上Font Awesome 字体图标库： 规范要求Bulma能正常工作需要把网页设置为支持响应式。 1. 使用HTML5 doctype 2. 添加支持响应式的viewport元标记 起始模板可以使用下面的模板作为写网页的起始模板： Hello Bulma! Hello World My first website with Bulma! ### Bulma-start 如果习惯使用npm，可以使用Bulma-start。 Bulma-start是一个很小的npm包，包含了使用Bulma开发网站的全部依赖项。 Bulma-start 安装 npm install bulma-start 或者 yarn add bulma-start 详情可参考项目网址","link":"/2020/05/24/Bulma%20CSS%20-%20%E5%BC%80%E5%A7%8B/"},{"title":"Bulma Vue.js集成","text":"Vue Admin - 基于 Vue &amp; Bulma 后台管理面板 - 梦想天空…_博客园 2017年6月25日 - Vue Admin 是一个基于 Vue 2.0 &amp; Bulma 0.3 的后台管理面板(管理系统),相当于是 Vue 版本的 Bootstrap 管理系统,提供了一组通用的后台界面 UI 和组件,… Vue Admin – 基于 Vue &amp; Bulma 后台管理面板-前端里 2017年6月19日 - Vue Admin 是一个基于 Vue 2.0 &amp; Bulma 0.3 的后台管理面板(管理系统),相当于是 Vue 版本的 Bootstrap 管理系 基于vue_2 的弹层组件 _vue-bulma-dialog - 前端栈开发 2018年7月27日 - vue-bulma-dialog 详细介绍vue-bulma-dialog 是基于 _Vue_2、_bulma_0.5.3 实现的弹层组件。接口借鉴了 layer 的使用方式,调用比较简单,配置灵活。当前版… vue-admin: 一个基于 Vue 2.0 和 Bulma 0.3 的 后台管理框架 原始仓库: https://github.com/_vue_-_bulma_/_vue_-admin 一个基于 Vue 2.0 和 Bulma 0.3 的 后台管理框架 502 次提交 5 个分支 13 个标签 0 个发行版 21 … Vue _Bulma_的Datepicker组件 - JavaScript开发社区 | CTOLib码库 2016年7月11日 - Datepicker component is based on flatpickr for Vue Bulma. Installation $ npm install vue-bulma-datepicker –save Examples Single Input &lt;tem… vue-blu_基于_Vue_js和_Bulma_开发的开源UI组件库 Vue-Blu是基于 Vue_js 和 _Bulma 开发的开源UI组件库。旨在为PC端的前端开发(特别是中后台产品)提供一个快速且灵活的解决方案。全面、灵活且强大的ui组件,API友好… GitHub - vue-bulma/switch: Switch Component for Vue Bulma Switch Component for Vue Bulma. Contribute to vue-bulma/switch development by creating an account on GitHub. Bulma+Vue_一款基于现在浏览器的响应式后台管理框架_vue-admin-紫金网 2019年6月25日 - 熟悉_bulma_的同学都知道_bulma_的好处(免费,移动优先(100%响应式), 组件模块化,现代浏览器(css3 flexbox构建)),github star 数 35K+,纯css 响应式框… Vue Admin - 基于 Vue &amp; Bulma 后台管理面板_javascrip…_CSDN博客 2017年6月25日 - Vue Admin 是一个基于 Vue 2.0 &amp; Bulma 0.3 的后台管理面板(管理系统),相当于是 Vue 版本的 Bootstrap 管理系统,提供了一组通用的后台界面 UI 和… vue-bulma Bulma Vue vue_x _vue-router vue-resource 特别提示 本项目构建中已使用eslint,力求代码排版标准化方便阅读,建议不要在设置里取消该设定。本项目不含jQuery库,原因…","link":"/2020/05/24/Bulma%20Vue.js%E9%9B%86%E6%88%90/"},{"title":"Bulma 起步","text":"Bulma: 基于Flexbox的免费、开源、现代化的CSS框架 | _Bulma_中文网 // Update Bulma‘s global variables $family-sans-serif: “Nunito”, sans-serif; $grey-dark: $brown; $grey-light: $beige-light; $primary: $purple;… CSS 框架 Bulma 教程 - 阮一峰的网络日志 2017年10月24日 - Bootstrap 是最著名的 CSS 框架,但是今天我想推荐另一个更轻量化、更易用的框架—_Bulma_。有了它,即使完全不懂 CSS,也可以轻而易举做出美观的网页。 … _bulma_和bootstrap等前端框架我应该选择哪个? - 知乎 2019年5月17日 - bootstrap,_bulma_都用过。两者最大的区别是,_bulma_是纯css,没有js,bootstrap有JS。当用vuejs,reactjs… Bulma | web前端中文站 2020年2月27日 - 前面《Bulma 简介》一文中我们对 Bulma 有了最基本的认识,本文将介绍它 Bulma 的基本用法。……继续阅读 » web前端中文站 3年前 (2017-10-24) 5170… .c-group-top{margin-bottom:0!important;padding:10px 10px 11px;border-top:1px solid #E3E3E3;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3}.c-group-middle{margin-bottom:0!important;padding:0 10px 8px;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3}.c-group-bottom{padding:0 10px 10px;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3;border-bottom:1px solid #E3E3E3}.c-group-title{margin-bottom:5px;font-size:16px}.c-group{width:516px!important} .c-group-top{margin-bottom:0!important;padding:10px 10px 11px;border-top:1px solid #E3E3E3;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3}.c-group-middle{margin-bottom:0!important;padding:0 10px 8px;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3}.c-group-bottom{padding:0 10px 10px;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3;border-bottom:1px solid #E3E3E3}.c-group-title{margin-bottom:5px;font-size:16px}.c-group{width:516px!important} Bulma 中文文档 | _Bulma_中文网 Coming from Bootstrap See how Bulma is an alternative to Bootstrap Bulma 扩展 Side projects to enhance Bulma Bulma start 开始使用_Bulma_的最小npm包 首页… Bulma | Dragon Ball Wiki | Fandom Bulma (ブルマ Buruma) is a brilliant scientist and the second daughter of Capsule Corporation’s founder Dr. Brief and his wife Panchy, the younger … bulma (v0.8.2) - Bulma 是一个基于 Flexbox 布局技术的免费… Bulma 是一个基于 Flexbox 布局技术的免费、开源的现代 CSS 框架。官网 GitHub仓库 版本:0.8.2 复制 标签 复制链接https://cdn.bootcdn.net/ajax/libs/_bulma_/… .c-group-top{margin-bottom:0!important;padding:10px 10px 11px;border-top:1px solid #E3E3E3;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3}.c-group-middle{margin-bottom:0!important;padding:0 10px 8px;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3}.c-group-bottom{padding:0 10px 10px;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3;border-bottom:1px solid #E3E3E3}.c-group-title{margin-bottom:5px;font-size:16px}.c-group{width:516px!important} bulma - cdnjs.com - The best FOSS CDN for web related… bulma - Modern CSS framework based on Flexbox - cdnjs.com - The best FOSS CDN for web related libraries to speed up your websites! CSS 框架 Bulma 中文文档(翻译) - DP2PX.COM 2019年6月5日 - 网页样式需要大量时间开发,最省事的方法就是使用 CSS 框架。Bootstrap 是最著名的 CSS 框架,但是今天我想推荐另一个更轻量化、更易用的框架_Bulma_。有… bulma - npm 2020年4月12日 - Bulma is a modern CSS framework based on Flexbox. Quick install Bulma is constantly in development! Try it out now: NPM npm install bulma or… _bulma__基于 Flexbox 的当代 CSS 框架 Bulma 是一个基于 Flexbox 的现代化的 CSS 框架,设计的初衷就是移动优先(Mobile First),模块化设计,可以轻松用来实现各种简单或者复制的内容布局,浏览器支持:浏览… Bulma CSS - 开始 - 吴吃辣 - 博客园 2019年5月22日 - 如果习惯使用npm,可以使用Bulma-start。 Bulma-start是一个很小的npm包,包含了使用Bulma_开发网站的全部依赖项。 _Bulma-start 安装 npm install bulma-… Bulma CSS - 入门 - 「dt猫」 2019年5月22日 - 有数种方法可以安装Bulma:使用npm安装Bulma_包使用cdnjs CDN链接到_Bulma_样式表从GitHub项目库获得最新的开发版本1. 使用npm安装_Bulma_包 npm install _bu… Una Revista sobre Sociedad, Deportes y Tecnología - Bulma Somos una revista de web donde tratamos la tecnología, el lenguaje y códigos de software, cultura, deporte y también tratamos las noticias del mundo. CSS、_Bulma_介绍_网络_青墟的CSDN博客-CSDN博客 2018年12月6日 - CSS 基础 Bulma 布局介绍 Bulma 组件运用 TODO 例子二、CSS 基础1. CSS 介绍层叠样式表(英语:Cascading Style Sheets)简而言之:美化网页的语言… bulma - 简书 2018年5月18日 - yarn add bulma-start npm install bulma https://cdnjs.com/libraries/_bulma_ //icon bulma-JavaScript中文网-JavaScript教程资源分享门户 2018年5月15日 - Modern CSS framework based on Flexbox Bulma(https://bulma.io) Bulma is a modern CSS framework based on Flexbox(https://developer.mozilla.org…","link":"/2020/05/24/Bulma-%E8%B5%B7%E6%AD%A5/"},{"title":"Bulma和Bootstrap 区别","text":"比Bootstrap_还好用的CSS 框架 _Bulma –教程_javascript…_CSDN博客 2018年1月27日 - CSS 框架 Bulma 教程 网页样式需要大量时间开发,最省事的方法就是使用 CSS 框架。 Bootstrap 是最著名的 CSS 框架,但是今天我想推荐另一个更轻量化、… 前端框架比比看:bootstrap, bulma, foundation, materi…_CSDN博客 2020年1月28日 - Bootstrap 的用户量仍然遥遥领先,但我已经在尝试 Bulma 和 Material. 点赞 收藏 分享 亮子… 推荐一个比 Bootstrap 更轻量化、更易用的 CSS 框架—Bulma 2017年11月11日 - Bulma 框架最大的特点,就是简单好用。所有样式都…入群交流(和以上内容无关):加入Go大咖交流群,或… Bulma: _Bootstrap_的替代品 | _Bulma_中文网 Made with Bulma The official community badge Coming from Bootstrap See how Bulma is an alternative to Bootstrap Bulma 扩展 Side projects to enhance Bu… 非引战,纯提问,关于有人提到 bootstrap 已经过时的问题,想知道… 2017年4月27日 - 这个作者从来没有自定义过 bootstrap 的源码. 你的站当然和别人一样了, 这有…比如 bulma 这样的不提供 js 的框架.Bootstrap 不是最好, 最合适, 但是… 两个同事为 bootstrap 和 semantic 哪个好,在公司群里干起来了… 2016年10月20日 - 我票还是_投给 _bootstrap ……9 Seita 2016-10-20 21:08:10 +08:00 结果现在用 bulma 23310 DoraJDJ 2016-10-20 21:22:59 +08:00 via Android … CSS 框架 Bulma 教程 - 阮一峰的网络日志 2017年10月24日 - Bootstrap 是最著名的 CSS 框架,但是今天我想推荐另一个更轻量化、更易用的框架—_Bulma_。有了它,即使完全不懂 CSS,也可以轻而易举做出美观的网页。 … Bulma-基于 Flexbox 的现代化的 CSS 框架 - 简书 2018年8月21日 - Bulma 还是 Bootstrap ? Bulma 的作者自己在博客文章中说到他自己也是 Bootstrap 的粉丝,Bulma 是受 Bootstrap 的目标和目的的启发而产生的,对此他做… 热衷_bootstrap_的人开始醒醒吧!_bootstrap与_jquery mobil…_CSDN论坛 2013年6月7日 - bootstrap_和jquery_区别 Bootstrap_简单介绍 _Bootstrap_是基于HTML5和CSS3开发…比_Bootstrap_还好用的CSS 框架 _Bulma –教程 CSS 框架 Bulma 教程 … Bulma CSS框架教程 - 海边长大 - 博客园 2019年9月12日 - _Bulma_是一个轻量级的现代CSS框架,基于flex,_跟bootstrap_不一样纯CSS没有JS,与vuejs、reactjs这样JavaScript框架可以很好地集成。 为降低学习难度,让初… _Bulma_框架的安装与自定义教程-百度经验 2017年10月31日 - _Bulma_作为一个新的css框架,_Bulma_的使用_还是_比较简单的,不过简单并不意味着他的… Bulma-基于 Flexbox 的现代化的 CSS 框架|SevDot的个人博客网站 Bulma 的作者自己在博客文章中说到他自己也是 Bootstrap 的粉丝, Bulma 是受 Bootstrap 的目标和目的的启发而产生的,对此他做了一个比较供选择不定… Bootstrap vs Foundation vs Bulma vs Semantic vs UIkit - WP建站 2019年6月27日 - 回到关于Bootstrap vs Foundation vs Bulma的辩论,Bulma有一个更温和的学习曲线。 _Bulma与Bootstrap_和Foundation之间的显着差异是CSS的唯一关注点,框… Bulma UI框架 · 万能Web开发文档笔记 · 看云 bulma` ~ …内置函数和定义函数 织梦核心改动 织梦插件/底层标签开发 PHP相关…_bootstrap_3 clipboard复制 slideout侧滑 imagehover.css… Bulma Bulma 是基于Flexbox的现代CSS框架。Bulma_是一个CSS框架,因此,唯一的输出是单个CSS文件:_bulma.css。Bulma_是_Bootstrap 之外的另一种选择。 您可以使用该文件,“开箱… Bulma / Bootstrap comparison | _Bulma_中文网 2017年8月1日 - Bulma has always been a Bootstrap fan, inspired by its goal and purpose… 免费开源纯CSS框架一览:bulma.css_设计前沿 2019年10月18日 - 介绍Bulma是一个免费的开源CSS框架,基于Flexbox( 弹性布局 ),已有200,000多名开发人员使用。_Bulma和Bootstrap_都是CSS框架,使开发人员可以轻松快速地构… Bulma-前端里 2017年6月19日 - Vue Admin 是一个基于 Vue 2.0 &amp; Bulma 0.3 的后台管理面板(管理系统),相当于是 Vue 版本的 Bootstrap 管理系统,提供了一组通用的后台界面 UI 和组件,… 除了bootstrap 还有什么好看的 CSS 库?实在有点审美疲劳了 - V2EX 2017年9月7日 - 哎,太多网站用 bootstrap,现在看着有点想吐的感觉 …_Bulma_UIKitSemantic UIMaterial Design阿里家的 AntDesign… _Bootstrap_和Foundation以及Semantic UI对比和使用_Java…_CSDN博客 2015年7月6日 - 前端框架比比看:bootstrap, bulma, foundation, material-design-lite, materialize…[前端框架] Bootstrap 3 与 Foundation 5 的五大区别(译) 开发工程师, 使用… 推荐几个_跟bootstrap_差不多的网站 - 小人物的博客 2019年9月23日 - Node与element的_区别_是什么? 11-09 我在用jdom…想推荐另一个更轻量化、更易用的框架—_Bulma_。…metro ui,_跟bootstrap_差不多,一个很不错的前端框… _bulma和bootstrap_等前端框架我应该选择哪个? - 知乎 2018年1月5日 - 首先这个问题 题的很好,_bulma和bootstrap_选择哪个,前端CSS框架很多比如 Bootstrap、 Bulma、Foundation、Milligram、Pure、Semantic、 UIKit。你很… _bulma和bootstrap_等前端框架我应该选择哪个? - 知乎 2018年1月3日 - _bulma_没用过,之前也没听说过,说说_bootstrap_吧,我觉得用的公司应该比较多,我们公司后台系统也是基于_bootstrap_的,而且基于_bootstrap_的js框架也比较多。… _bulma和bootstrap_等前端框架我应该选择哪个? - 知乎 2018年1月8日 - bootstrap,_bulma_都用过。两者最大的_区别_是,_bulma_是纯css,没有js,_bootstrap_有JS。 当用vuejs,reactjs时,带有js的css框架并不适合,需要纯的css框架。在… _bulma和bootstrap_等前端框架我应该选择哪个? - 知乎 bootstrap,_bulma_都用过。两者最大的_区别_是,_bulma_是纯css,没有js,_bootstrap_有JS。当用vuejs,reactjs… Bootstrap VS Semantic VS Foundation 几个css框架比较…_CSDN博客 2017年4月24日 - 很火的一个CSS框架,很多人会在Bootstrap_和Semantic…CSS 框架 _Bulma 教程 阅读数 1257 作者: 阮一峰网页…epoll的执行流程和epoll反应堆的流程区别… _bootstrap_过时了吗? - 知乎 2017年4月19日 - 另外: 感觉bs现在有个毛病是稍微重了点,喜欢折腾可以看下 bulma 这个小巧的纯…目前来说是不会过时,最起码做后台管理系统的时候有_bootstrap还是_很省… 推荐一个比 Bootstrap 更轻量化、更易用的 CSS 框架—Bulma 2017年11月11日 - Bulma 框架最大的特点,就是简单好用。所有样式都…入群交流(和以上内容无关):加入Go大咖交流群,或…","link":"/2020/05/24/Bulma%E5%92%8CBootstrap%20%E5%8C%BA%E5%88%AB/"},{"title":"Bulma和Buefy框架如何自定义主题？","text":"如何Bulma和Buefy自定义主题，全局修改css前端UI框架中，Bulma和基于其开发的Buefy都是非常简单好用的选择，但是在自定义其主题的过程中碰到了一些问题，在此记录解决办法。 本文所有操作都是基于页面直接通过script引入这些框架的开发模式来操作的。 自定义Bulma主题安装SassmacOS下通过brew进行安装 brew install sass/sass/sass 下载Bulma地址 解压缩之后，放到mybulma文件夹中，文件夹结构如下 $ mybulma tree -L 2 . └── bulma ├── CHANGELOG.md ├── LICENSE ├── README.md ├── bulma.sass ├── css ├── package.json └── sass 创建Sass文件创建sass文件夹，然后在里面创建mystyles.scss文件，文件夹结构如下 . ├── bulma │ ├── CHANGELOG.md │ ├── LICENSE │ ├── README.md │ ├── bulma.sass │ ├── css │ ├── package.json │ └── sass └── sass └── mystyles.scs 在mystyles.scss文件内写入 @charset &quot;utf-8&quot;; @import &quot;../bulma/bulma.sass&quot;; 创建测试HTML文件在mybulma文件夹下创建mypage.html文件，写入如下内容 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;My custom Bulma website&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/mystyles.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class=&quot;title&quot;&gt; Bulma &lt;/h1&gt; &lt;p class=&quot;subtitle&quot;&gt; Modern CSS framework based on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox&quot;&gt;Flexbox&lt;/a&gt; &lt;/p&gt; &lt;div class=&quot;field&quot;&gt; &lt;div class=&quot;control&quot;&gt; &lt;input class=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;Input&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;p class=&quot;control&quot;&gt; &lt;span class=&quot;select&quot;&gt; &lt;select&gt; &lt;option&gt;Select dropdown&lt;/option&gt; &lt;/select&gt; &lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;a class=&quot;button is-primary&quot;&gt;Primary&lt;/a&gt; &lt;a class=&quot;button is-link&quot;&gt;Link&lt;/a&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 生成CSS文件终端输入命令 sass --no-source-map sass/mystyles.scss:css/mystyles.css 为了可以实时观察修改情况，也可以输入 sass --watch --no-source-map sass/mystyles.scss:css/mystyles.css 修改mystyles.scss文件来自定义主题修改完成后刷新网页查看效果 @charset &quot;utf-8&quot;; // Import a Google Font @import url('https://fonts.googleapis.com/css?family=Nunito:400,700'); // Set your brand colors $purple: #8A4D76; $pink: #FA7C91; $brown: #757763; $beige-light: #D0D1CD; $beige-lighter: #EFF0EB; // Update Bulma's global variables $family-sans-serif: &quot;Nunito&quot;, sans-serif; $grey-dark: $brown; $grey-light: $beige-light; $primary: $purple; $link: $pink; $widescreen-enabled: false; $fullhd-enabled: false; // Update some of Bulma's component variables $body-background-color: $beige-lighter; $control-border-width: 2px; $input-border-color: transparent; $input-shadow: none; // Import only what you need from Bulma @import &quot;../bulma/sass/utilities/_all.sass&quot;; @import &quot;../bulma/sass/base/_all.sass&quot;; @import &quot;../bulma/sass/elements/button.sass&quot;; @import &quot;../bulma/sass/elements/container.sass&quot;; @import &quot;../bulma/sass/elements/title.sass&quot;; @import &quot;../bulma/sass/form/_all.sass&quot;; @import &quot;../bulma/sass/components/navbar.sass&quot;; @import &quot;../bulma/sass/layout/hero.sass&quot;; @import &quot;../bulma/sass/layout/section.sass&quot;; 下载Buefy源代码地址 解压缩后文件夹结构如下 . ├── buefy │ ├── BACKERS.md │ ├── ... │ ├── src │ ├── ... ├── bulma │ ├── CHANGELOG.md │ ├── LICENSE │ ├── README.md │ ├── bulma.sass │ ├── css │ ├── package.json │ └── sass ├── css │ └── mystyles.css ├── mypage.html └── sass └── mystyles.scss mypage.html引入Vue和buefy修改代码如下 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;title&gt;My custom Bulma website&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/mystyles.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class=&quot;title&quot;&gt; Bulma &lt;/h1&gt; &lt;p class=&quot;subtitle&quot;&gt; Modern CSS framework based on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox&quot; &gt;Flexbox&lt;/a &gt; &lt;/p&gt; &lt;div class=&quot;field&quot;&gt; &lt;div class=&quot;control&quot;&gt; &lt;input class=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;Input&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;p class=&quot;control&quot;&gt; &lt;span class=&quot;select&quot;&gt; &lt;select&gt; &lt;option&gt;Select dropdown&lt;/option&gt; &lt;/select&gt; &lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;a class=&quot;button is-primary&quot;&gt;Primary&lt;/a&gt; &lt;a class=&quot;button is-link&quot;&gt;Link&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;app&quot;&gt; &lt;main class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;b-button type=&quot;is-primary&quot;&gt;Click Me&lt;/b-button&gt; &lt;/div&gt; &lt;/main&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/buefy/dist/buefy.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue({ el: &quot;#app&quot;, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 修改mystyles.scss文件@charset &quot;utf-8&quot;; // Import a Google Font @import url('https://fonts.googleapis.com/css?family=Nunito:400,700'); // Import only what you need from Bulma @import &quot;../bulma/sass/utilities/_all.sass&quot;; // Set your brand colors $purple: #8A4D76; $pink: #FA7C91; $brown: #757763; $beige-light: #D0D1CD; $beige-lighter: #EFF0EB; // Update Bulma's global variables $family-sans-serif: &quot;Nunito&quot;, sans-serif; $grey-dark: $brown; $grey-light: $beige-light; $primary: $purple; $link: $pink; $widescreen-enabled: false; $fullhd-enabled: false; // // Update some of Bulma's component variables $body-background-color: $beige-lighter; $control-border-width: 2px; $input-border-color: transparent; $input-shadow: none; // Set your colors $primary-invert: findColorInvert($primary); // Setup $colors to use as bulma classes (e.g. 'is-twitter') $colors: ( &quot;white&quot;: ($white, $black), &quot;black&quot;: ($black, $white), &quot;light&quot;: ($light, $light-invert), &quot;dark&quot;: ($dark, $dark-invert), &quot;primary&quot;: ($primary, $primary-invert), &quot;info&quot;: ($info, $info-invert), &quot;success&quot;: ($success, $success-invert), &quot;warning&quot;: ($warning, $warning-invert), &quot;danger&quot;: ($danger, $danger-invert), ); // Links $link: $primary; $link-invert: $primary-invert; $link-focus-border: $primary; // Import only what you need from Bulma // @import &quot;../bulma/sass/utilities/_all.sass&quot;; // @import &quot;../bulma/sass/base/_all.sass&quot;; // @import &quot;../bulma/sass/elements/button.sass&quot;; // @import &quot;../bulma/sass/elements/container.sass&quot;; // @import &quot;../bulma/sass/elements/title.sass&quot;; // @import &quot;../bulma/sass/form/_all.sass&quot;; // @import &quot;../bulma/sass/components/navbar.sass&quot;; // @import &quot;../bulma/sass/layout/hero.sass&quot;; // @import &quot;../bulma/sass/layout/section.sass&quot;; @import &quot;../bulma/bulma.sass&quot;; @import &quot;../buefy/src/scss/buefy.scss&quot;; 查看页面，可以看到Buefy的按钮也被重新定义了颜色 作者：爱写程序的小哥哥链接：https://www.zhihu.com/question/394983567/answer/1224156706","link":"/2020/05/24/Bulma%E5%92%8CBuefy%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98%EF%BC%9F/"},{"title":"CSS编码规范2","text":"CSS语法 缩进使用2个空格； 每个属性独占一行； 每个属性末尾需要加分号； 属性名全小写，用下划线做分隔符； 选择器与 { 之间必须添加一个空格； : 之前不能有空格，之后必须有空格； 省略小于 1 的小数前面的 0 （ 例如，.5 代替 0.5；）； 选择器中的属性需加双引号，例如，input[type=&quot;text&quot;]； 十六进制值应该全部小写，尽量使用简写形式，例如，#fff； 避免为 0 值指定单位，例如，用 margin: 0; 代替 margin: 0px; 12345678.selector,.selector-secondary,.selector[type=&quot;text&quot;] { padding: 15px; margin-bottom: 15px; background-color: rgba(0,0,0,.5); box-shadow: 0 1px 2px #ccc, inset 0 1px 0 #fff;} 声明顺序由于定位（positioning）可以使元素脱离正常文本流，并且还能覆盖盒模型（box model）相关的样式，因此排在首位。盒模型排在第二位，因为它决定了组件的尺寸和位置。其他属性只是影响组件的内部（inside）或者是不影响前两组属性，因此排在后面； Positioning，相关属性包括：position / top / right / bottom / left / z-index； Box model，相关属性包括：display / float / width / height / padding / margin / border / overflow / …； Typographic（文本排版），相关属性包括：font / line-height / text-align / word-wrap / …； Visual（视觉外观），相关属性包括：color / background / list-style / transform / animation / transition / …； 如果包含 content 属性，应放在最前面 命名规范 使用语义化、通用的命名方式； 使用下划线_连接多个单词； 避免选择器和 Class、ID 叠加使用； 避免选择器嵌套层级过多，尽量少于 3 级； 避免过度简写。.btn表示button，但.a 没有意义； 对于通用元素使用class，少用标签名； 推荐使用的css名： 表示状态：.on, .active, .selected； 表示位置：.first, .last, .main, .side； 表示结构：.hd, .bd, .ft, .col, .section； 通用元素：.tb, .nav, .list, .item, .tag, .pic, .info &nbsp; 注释注释统一用’/* */‘（scss中也不要用’//‘），具体参照右边的写法；缩进与下一行代码保持一致；可位于一个代码行的末尾，与代码间隔一个空格。 123456789101112131415161718/* 单行注释 */.modal-header { ...}/* * 多行注释 */.modal-header { ...}.modal-header { /* 50px */ width: 50px; color: red; /* color red */} 不要使用@import与 &lt;link&gt; 相比，@import 要慢很多，不光增加额外的请求数，还会导致不可预料的问题。 链接的样式顺序a:link -&gt; a:visited -&gt; a:hover -&gt; a:active（lvha） 带前缀的属性当使用特定厂商的带有前缀的属性时，通过缩进的方式，让每个属性的值在垂直方向对齐，这样便于多行编辑。 '-webkit' : Webkit内核： 主要代表为Chrome和Safari '-moz' : Gecko内核： 主要代表为Firefox '-ms' : Trident内核：主要代表为IE浏览器 '-o': Presto内核： 主要代表为Opera 属性缩写在可以使用缩写的情况下，尽量使用缩写形式（无继承关系时使用缩写，存在继承关系使用分拆方式） 可缩写的属性有： padding margin font background border border-radius transition animation 1234567background-color: #000;background-image: url(images/bg.png);background-repeat: no-repeat;background-position: top right;/* 可缩写为*/background: #000 url(images/bg.png) no-repeat top right; 清除浮动当元素需要撑起高度以包含内部的浮动元素时，通过对伪类设置 clear 或触发 BFC 的方式进行 clearfix。尽量不使用增加空标签的方式。伪类设置 clear： 1.clear:after{display:block;content:&quot;.&quot;; clear:both;font-size: 0;height: 0;visibility: hidden;} 触发BFC的方式有很多，常见的有： float 非 none position 非 static overflow 非 visible 正确使用display属性display属性会影响页面的渲染，请合理使用。 display: inline后不应该再使用 width、height、margin、padding 以及 float； display: inline-block 后不应该再使用 float； display: block 后不应该再使用 vertical-align； display: table-* 后不应该再使用 margin 或者 float 不滥用 Floatfloat在渲染时计算量比较大，尽量减少使用。 更高效地使用选择器CSS 选择器对性能的影响主要在于浏览器匹配选择器和文档元素时所消耗的时间，所以优化选择器的原则是应尽量避免使用消耗更多匹配时间的选择器。 CSS 选择器的匹配机制是从右到左进行匹配的，了解了这个机制后，你懂的。 避免使用通用选择器 1*{margin: 0;padding: 0;} 避免使用标签选择器限制 class 或 id 选择器 12div.con{...}div#con{...} 避免使用多层标签选择器。使用 class 选择器替换，减少css查找 12345/* bad */dl &gt; dd &gt; p{...}/* better */.describe{...} 避免使用子选择器 12345/* bad */ul &gt; li{...}/* better*/.list{...} vue 文件使用样式，不允许使用 scoped 作用域，而应该使用命名空间 因为每个使用了 scoped 的样式 引用了外部文件，都会重复打包，增加了代码量 杂项 使用字体图标 单色图标推荐使用字体图标","link":"/2019/11/22/CSS%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83-%E7%AC%AC%E4%BA%8C%E9%83%A8/"},{"title":"CSS控制长串英文字母换行问题","text":"CSS控制长串英文字母换行问题这段时间在编写网页时，遇到了将一个随机字符码显示的问题。因为字符码全部由字母组成，而且长度比较长，在我布局的容器中居然不换行了。传统的英文语句在单词之间的空格处可以自动换行。但是，因为这里是字母串，中间没有空格，导致了没有自动换行问题…… 英文语句的换行代码如下： 12345&lt;body&gt;&lt;div style=&quot;width: 100px; height: 100px; background-color: cadetblue;&quot;&gt;This blog is only a note of notes.&lt;/div&gt;&lt;/body&gt; 效果如下： 可以看出，传统的英文语句在空格的地方自动换行了。 字母串不会换行代码如下： 12345&lt;body&gt;&lt;div style=&quot;width: 100px; height: 100px; background-color: cadetblue;&quot;&gt;ThisBlogIsOnlyANoteOfNotes.&lt;/div&gt;&lt;/body&gt; 效果如下： 解决方法在需要强制换行的地方加上如下样式：word-break:break-all;即可。修改后：代码如下： 12345&lt;body&gt;&lt;div style=&quot;width: 100px; height: 100px; background-color: cadetblue; word-break:break-all;&quot;&gt;ThisBlogIsOnlyANoteOfNotes.&lt;/div&gt;&lt;/body&gt; 效果如下：","link":"/2019/11/13/CSS%E6%8E%A7%E5%88%B6%E9%95%BF%E4%B8%B2%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/"},{"title":"Dos批量修改文件后缀","text":"Dos批量修改文件后缀第一种1234@echo offfor /f &quot;tokens=* delims=&quot; %%i in ('dir /b/s *.txt') do (rename &quot;%%i&quot; &quot;*.dxh&quot;) 第二种1ren *.txt *.dxh","link":"/2019/11/27/Dos%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80/"},{"title":"Deno 1.0 简介，node.js的代替者出现","text":"简介动态语言是有用的工具。脚本化允许用户快速、简洁地将复杂的系统结合在一起，表达想法，而不必担心内存管理或构建系统等细节。近年来，使用 Rust 和 Go 等编程语言使得生成复杂的本机代码变得更加容易;这些项目是计算机基础设施中非常重要的发展。但是，我们声称，拥有一个强大的脚本环境，可以解决广泛的问题域，这仍然很重要。 JavaScript 是使用最广泛的动态语言，使用 Web 浏览器在每台设备上运行。大量的程序员精通JavaScript，并投入了大量精力来优化其执行。通过ECMA国际等标准组织，语言得到了认真和不断的改进。我们相信JavaScript是动态语言工具的自然选择;无论是在浏览器环境中还是作为独立进程。 我们在这方面的最初事业，Node.js，被证明是一个非常成功的软件平台。人们发现它对于构建 Web 开发工具、构建独立 Web 服务器以及无数其他用例非常有用。然而，Node是在2009年设计的，当时JavaScript是一种完全不同的语言。出于必要，Node不得不发明后来被标准组织采用的概念，并以不同的方式添加到语言中。在演示中，在 Node 中设计错误，对此进行了更详细的讨论。由于 Node 拥有大量用户，因此系统发展起来非常困难且缓慢。 随着 JavaScript 语言的不断变化，以及 TypeScript 等新增加功能，构建 Node 项目可能会成为一项艰巨的任务，包括管理构建系统和其他重手工具，从而远离动态语言脚本的乐趣。此外，链接到外部库的机制基本上通过 NPM 存储库集中，这与 Web 的理想不一致。 我们认为 JavaScript 和周围的软件基础架构的格局已经变化到足以简化。我们寻求一个有趣和高效的脚本环境，可用于各种任务。 命令行脚本的 Web 浏览器Deno 是在 Web 浏览器之外执行 JavaScript 和 TypeScript 的新运行时。 Deno 尝试提供一个独立的工具，用于快速编写复杂功能的脚本。Deno 是（并且将永远）单个可执行文件。与 Web 浏览器一样，它知道如何获取外部代码。在 Deno 中，单个文件可以定义任意复杂的行为，而无需任何其他工具。 12345678import { serve } from &quot;https://deno.land/std@0.50.0/http/server.ts&quot;;for await (const req of serve({ port: 8000 })) {req.respond({ body: &quot;Hello World\\n&quot; });} 此处将完整的 HTTP 服务器模块作为依赖项添加到一行中。没有额外的配置文件，没有安装做事先，只是**deno运行示例.** 与浏览器一样，默认情况下在安全沙盒中执行代码。脚本无法访问硬盘、打开网络连接或在未经许可的情况下进行任何其他潜在的恶意操作。浏览器提供用于访问摄像机和麦克风的 API，但用户必须首先授予权限。Deno 在终端中提供类似的行为。除非提供了命令行标志，否则上述示例将失败。--allow-net Deno 小心不要偏离标准化的浏览器 JavaScript API。当然，并不是每个浏览器 API 都与 Deno 相关，但 Deno 所处的位置并不偏离标准。 头等舱类型脚本支持我们希望 Deno 适用于广泛的问题域：从小型单行脚本到复杂的服务器端业务逻辑。随着程序变得越来越复杂，进行某种形式的类型检查变得越来越重要。TypeScript 是 JavaScript 语言的扩展，允许用户有选择地提供类型信息。 Deno 支持 TypeScript，无需其他工具。运行时的设计考虑到了 TypeScript。该命令为 Deno 提供的所有内容提供类型声明。Deno 的标准模块都用 TypeScript 编写。deno types 承诺一路向下节点是在 JavaScript 具有承诺或异步/等待的概念之前设计的。节点与承诺的对应项是事件发射器，重要的 API 以它为基础，即套接字和 HTTP。抛开异步/等待的人体工程学优势，EventEmitter 模式的背压问题。例如，以 TCP 套接字为例。套接字在收到传入数据包时将发出”数据”事件。这些”数据”回调将不受限制地发出，使进程充满事件。由于 Node 继续接收新的数据事件，因此基础 TCP 套接字没有适当的回压，因此远程发送方不知道服务器已过载并继续发送数据。为了缓解此问题，添加了一个方法。这可以解决问题，但它需要额外的代码;并且由于泛洪问题仅在进程非常繁忙时出现，因此许多 Node 程序可能会充斥着数据。结果是尾部延迟错误的系统。pause() 在 Deno 中，套接字仍然是异步的，但接收新数据需要用户显式 。无需额外的暂停语义即可正确构造接收套接字。这不是 TCP 套接字所独有的。系统的最低绑定层从根本上与承诺相关联 - 我们将这些绑定称为”ops”。Deno 中以某种形式进行的所有回调都源于承诺。read() Rust 有自己的承诺式抽象，称为期货。通过”op”抽象，Deno 可以轻松地将基于 Rust 的未来 API 绑定到 JavaScript 承诺中。 锈蚀 API我们提供的主要组件是 Deno 命令行接口 （CLI）。CLI 是当今版本 1.0。但 Deno 不是一个整体程序，而是设计为 Rust 板条箱的集合，允许在不同层进行集成。 deno_core箱是Deno的一个非常裸露的骨头版本。它对 TypeScript 和Tokio没有依赖项。它只是提供我们的运营和资源基础结构。也就是说，它提供了一种有组织的方式将 Rust 期货绑定到 JavaScript 承诺。当然，CLI 完全建立在deno_core之上。 rusty_v8箱为 V8 C++ API 提供高质量的 Rust 绑定。API 尝试尽可能紧密地匹配原始C++ API。它是零成本绑定 - Rust 中公开的对象正是您在C++中操作的对象。（例如，以前对 Rust V8 绑定的尝试强制使用持久句柄。该条箱提供在 Github 操作 CI 中构建的二进制文件，但它也允许用户从头开始编译 V8 并调整其许多生成配置。所有 V8 源代码都分布在箱内。最后rusty_v8尝试成为安全接口。还不是100%安全，但我们越来越近了。能够以安全的方式与 V8 这样的复杂 VM 进行交互，这相当惊人，并且使我们能够在 Deno 本身中发现许多困难的错误。 稳定性我们承诺在 Deno 中保持稳定的 API。Deno 有很多接口和组件，因此，对”稳定”的含义保持透明非常重要。我们发明的与操作系统交互的 JavaScript API 都位于”Deno”命名空间（例如 ）。这些已经仔细研究，我们不会对它们作出不兼容的倒退。Deno.open() 所有尚未准备好稳定功能的功能都隐藏在命令行标志后面。你可以在这里看到不稳定的接口的文档。在后续版本中，其中一些 API 也将稳定下来。--unstable 在全局命名空间中，您将找到各种其他对象（例如。 和 。我们非常努力地保持这些接口与浏览器中的接口相同;但如果我们发现无意不兼容，我们将发布更正。浏览器标准定义了这些接口，而不是我们。我们发出的任何更正都是错误修复，而不是接口更改。如果与浏览器标准 API 不兼容，则在主要发布之前可能会更正该不兼容。setTimeout()``````fetch() Deno 还有许多 Rust API，即deno_core和rusty_v8箱。这些 API 均未处于 1.0。我们将继续对他们进行迭代。 限制请务必了解 Deno 不是节点的分叉 - 这是一个全新的实现。Deno 开发仅两年，而 Node 已经开发了十多年。鉴于对 Deno 的兴趣，我们预计它将继续发展和成熟。 对于某些应用程序，Deno 可能是今天不错的选择，对于其他应用程序来说，Deno 可能不是。这取决于要求。我们希望在考虑使用 Deno 时，对这些限制保持透明，帮助人们做出明智的决策。 兼容性不幸的是，许多用户会发现与现有的JavaScript工具缺乏兼容性令人沮丧。Deno 通常与节点 （NPM） 包不兼容。正在https://deno.land/std/node/构建一个新生的兼容性层，但它还远远不完整。 尽管 Deno 采用了简化模块系统的强硬方法，但最终 Deno 和 Node 是具有类似目标的非常相似的系统。随着时间的推移，我们预计 Deno 能够运行越来越多的节点程序开箱即用。 HTTP 服务器性能我们不断跟踪 Deno 的 HTTP 服务器的性能。hello world Deno HTTP 服务器每秒执行大约 25k 个请求，最大延迟为 1.3 毫秒。类似的 Node 程序每秒执行 34k 请求，最大延迟在 2 到 300 毫秒之间相当不稳定。 Deno 的 HTTP 服务器在 TypeScript 中实现，位于本机 TCP 套接字之上。Node 的 HTTP 服务器以 C 编写，并作为高级绑定公开到 JavaScript。我们抵制了向 Deno 添加本机 HTTP 服务器绑定的冲动，因为我们希望优化 TCP 套接字层层，更一般地优化操作接口。 Deno 是一个合适的异步服务器，对于大多数目的来说，每秒 25k 请求已经足够了。（如果不是，则 JavaScript 可能不是最佳选择。此外，我们预计 Deno 通常会表现出更好的尾部延迟，因为承诺无处不在（上文讨论）。话虽如此，我们确实相信系统中还有更多的性能胜利，我们希望在未来的版本中实现这一点。 TSC 瓶颈内部 Deno 使用 Microsoft 的 TypeScript 编译器来检查类型并生成 JavaScript。与 V8 解析 JavaScript 所需的时间相比，它非常缓慢。在项目的早期，我们曾希望”V8 快照”能在这里提供显著的改进。快照确实有帮助，但它仍然令人不满意地慢。我们当然认为，在现有 TypeScript 编译器的基础上，可以在此处进行改进，但我们很清楚，最终需要在 Rust 中实现类型检查。这将是一项艰巨的任务，不会很快发生;但它将在开发人员经历的关键路径中提供数量级的性能改进。TSC 必须移植到 Rust。如果您有兴趣在此问题上进行协作，请与我们联系。 插件/扩展我们有一个新兴的插件系统，用于使用自定义操作扩展 Deno 运行时。但是，此接口仍在开发中，并已标记为不稳定。因此，访问 Deno 提供的本机系统是比较困难的。 确认非常感谢许多贡献者，他们帮助使此版本成为可能。特别是：@kitsonk谁在系统的许多部分，包括（但不限于）TypeScript编译器主机，deno_typescript，deno捆绑包，deno安装，deno类型，流实现。@kevinkassimo在整个项目历史中贡献了无数的错误修复。他的贡献包括计时器系统，TTY集成，是支持。Deno.makeTempFile， Deno.kill， Deno.hostname， Deno.realPath， std/节点的要求， 窗口.queueMircotask， 和REPL历史.他还创建了徽标。@kt3k实现了连续基准系统（该系统几乎在所有主要重构中都有作用）、信号处理程序、权限 API 和许多关键错误修复。@nayeemrmn在 Deno 的许多部分提供错误修复，最显著的是，他极大地改进了堆栈跟踪和错误报告，并且对稳定 1.0 的 API 提供了有力的帮助。@justjavac贡献了许多小而关键的修复，使 deno API 与 Web 标准保持一致，最著名的是他写了 VS Code deno 插件。@zekth贡献了很多模块的藏匿，其中包括std/编码/csv，std/编码/汤姆，std/http/cookies，以及许多其他的错误修复。@axetroy帮助处理与漂亮相关的所有事项，提供了许多错误修复，并维护了 VS Code 插件。@afinch7实现了插件系统。@keroxp实现了 Websocket 服务器，并提供了许多错误修复。@cknight提供了大量的文档和 std/节点多填充。@lucacasonato几乎建立了整个deno.land网站。@hashrock做了很多惊人的艺术作品，如doc.deno.land上的加载页和这个页面顶部可爱的图像！","link":"/2020/05/19/Deno-1-0-%E7%AE%80%E4%BB%8B%EF%BC%8Cnode-js%E7%9A%84%E4%BB%A3%E6%9B%BF%E8%80%85%E5%87%BA%E7%8E%B0/"},{"title":"ECG ×AI: 机器&#x2F;深度学习的ECG应用入门（1）","text":"前言 你好，我是研究ECG算法的搬砖工Winham。目前搞这个方向已经挺长时间了，总想着把自己的一些入门经验分享一下，却不知道从何下手。说实话，关于ECG算法的研究相对冷门一些，网络上系统的资料也比较少，有的多是故作高深的论文。想想当时入门时真是走了不少弯路，也真心体会到如果能有一个相对系统一点的教程或是博客，再配合一些可以直接上手的代码，对于初学者来说是很重要的。所以写了这几篇渣文，内容简短，简单，都是这个方向的基础。不求大家看了觉得多好，只求可以让初学的童鞋少走一点弯路。涉及到的代码也都开源了，放在了我的github上：https://github.com/Aiwiscal/ECG-ML-DL-Algorithm-Matlab 。代码为Matlab写成。由于涉及到了机器/深度学习，建议还是有这方面的知识比较好。说起机器/深度学习，Python更适合一点，后续Python版本的代码也会放出来。不过就本人体验来说，入门的话，还是Matlab更适合一些。 ECG，是electrocardiogram的缩写。就是我们平时常见的心电图。典型的心电信号由P波，QRS波，T波等一系列特征波组成，它们以及一些特征段（QRS间期，ST段，PR段等）包含着丰富的病理信息： 医生就是通过分析这些波形的特点，结合自己的经验给出诊断结果。近几年，随着人工智能的兴起，“智能医疗”的概念也火了起来。说白了，就是用一些机器学习或深度学习算法，学习数据中的规律，能够像医生一样给出一个准确的诊断结果。想象一下，其实这件事情如果真做成了，那自然是一件大好事，毕竟医疗资源是很紧缺的。不过目前挑战还是很大的……有点扯远了，还是说回ECG。我们的目的，就是研究如何有效利用机器/深度学习算法以及一些数字信号处理算法，使用ECG信号，实现对一些心血管异常的诊断。 接下来的几部分将会从数据库的获取，QRS波定位，传统机器学习，深度学习四个方面对算法的设计和应用进行探讨，所涉及内容均为基础，并有配套源代码，并且推荐了一部分代表性文献供研究。有些地方可能会有错误和疏漏，请谅解。另外，算法的设计，有时候很依赖于个人的经验，其具体原理很难阐述地非常清楚，需要长时间积累才能领会。","link":"/2020/04/18/ECG-%C3%97AI-%E6%9C%BA%E5%99%A8-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84ECG%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%EF%BC%881%EF%BC%89/"},{"title":"ECG ×AI: 机器&#x2F;深度学习的ECG应用入门（2）","text":"ECG数据库：解决数据来源问题1.数据库简介与获取 经过上一章节的介绍，相信你对于我们的研究对象——心电信号ECG已经有了一个初步的认识，也清楚了我们的目标就是使用机器/深度学习算法，能自动识别指定的ECG类型，从而实现“人工智能”式的诊断（汗。。。）。“巧妇难为无米之炊”，我们的“米”（ECG数据）从哪里来呢？当然有喜闻乐见的数据库供我们使用。 首先贴一个网址：https://archive.physionet.org/cgi-bin/atm/ATM 这个网站上汇集了许许多多生理信号，除了我们熟悉的ECG，还有脑电信号EEG，心音信号PCG等等。“弱水三千，只取一瓢”，这里我们主要来说一下ECG领域最常用（没有之一）的数据库：MIT-BIH Arrhythmia Database。如上图所示，点击“Input”选择框，下拉选择MIT-BIH Arrhythmia Database（注意，有很多MIT-BIH打头的数据库，不要搞错了），“Input”选择框下面还有几个选择框，可以分别选择记录，信号，标记等等，选定后页面上会有一个区域展示一小段信号。如果想详细了解并下载数据，点击上图右下角红圈中的链接可以跳转至数据库专属页面。 详细的介绍可以自己去看，全英文，英语不好的建议配合有道词典。在这里只说一些重要的信息：MIT-BIH Arrhythmia Database（以下简称MITdb）包含了48条双导联ECG记录，其中，除少数记录外，每条记录的第一个导联都是II导联，每条记录长度为30分钟，采样率360 Hz，算起来有3060360=648000个采样点，但其实每条记录都有650000个点，也就是并非严格等于30分钟。不过这没什么很大影响。打开MITdb的专属页面后，很容易就发现了大量数据文件的链接，48条记录（不连续编号100-234），每一条记录对应着3个文件，就像这样： 各个文件的作用，已经展示的很清楚。.atr：标记文件，保存着人工标注的心拍位置和类型。.dat:数据文件，保存着我们需要的心电信号。.hea：头文件，保存着这条记录的附加信息。这三个文件中头文件（.hea）可以直接打开，其余两个不可直接打开，强行记事本打开后看到的都是乱码。打开头文件后，一般看到的是这样的： 第一行含义为：记录编号 导联数 采样率 采样点数。第二、三行则说明了.dat文件的信息，它是212格式编码的等等。其详细的说明请参照文献：（宋喜国, 邓亲恺. MIT-BIH心率失常数据库的识读及应用[J]. 中国医学物理学杂志, 2004, 21(4):230-232.）当然，如果你对这些东西并不关心也可以不看，对我们后面的内容影响不大。至于这个数据库中到底包含了哪些我们感兴趣的类型，作为我们分类识别的目标，这个我们用到的时候再说。 说了半天，似乎我们一直在纸上谈兵，目前手里什么也没有。一个不好的消息：如果你不会一些下载技巧，要下载这48*3=144个文件，你需要每个都点一下，因为官方似乎并没有提供一个完整的包。这一点其实不用担心，本人已经下载好并且打好了包提供给各位下载。方式是大家喜闻乐见的百度网盘：链接: https://pan.baidu.com/s/1cAOc8jzGuwx7mXlfcrErgw 提取码: 8zw8 2.数据库的Matlab读取 如果你阅读了上一段建议的，对于MITdb数据格式说明的论文，十有八九会对读取数据库感到困难。这种格式并不常见，而且对于初学者并不友好。自己编程实现数据库读取的门槛又比较高，不是每个人都能实现，而且我们的目标也不是数据的编解码研究。还好有大佬已经为我们写好了读取数据的代码，我们只需要run一下就基本达成目的了。目前该代码已经放到了我的github上(文后有地址），名为rddata.m： 简单说下怎么用，建议单独建一个文件夹作为我们后续代码的存放处，例如这里我建立了一个名为ECGPrimer的文件夹，路径为：F:\\MATLAB\\ECGPrimer。把rddata.m文件放入该文件夹。 1）打开matlab（这里为2013a版本，其余版本类似），点击界面偏上方显示路径的框的偏右空白处（例如下图中椭圆处），输入我们刚才的路径，回车。当前路径就成为了我们刚才建立的文件夹，左边可以看到我们之前放入的rddata.m文件，双击打开。 2） 打开rddata.m后，注意一开始的关于数据库文件的存放路径，以及指定文件名的设置，如图： 例如图中我把下载好的144个数据库文件解压，放在了F:\\MATLAB\\MIT-BIH，然后需要读取编号为234的记录，指定读取的点数为1024。点击控制栏的run按钮，相关数据会被读入到matlab的工作空间workspace中。与此同时，matlab会生成一张信号图，上面同时绘制了两个导联的信号，以及一些标记的数字，这里我们先关掉不理会。 3）然后我们观察matlab的workspace，此时应该如下图所示： 注意，此时变量名为M的矩阵中包含了我们需要的ECG信号，尺寸为1024（指定读取点数）*2（导联数）。我们只关心第一个导联的信号，在matlab命令窗口里输入：plot(M(:,1));grid on;可绘制出第一个导联的信号： 至此，我们已经成功将数据库中的ECG信号读取至matlab中。另外，workspace中其余2个矩阵也值得我们注意。如3）中的workspace截图，一个是ANNOT，存储了该记录中各心拍的人工标注类型代码，例如有： 完整的对比说明表也已经上传至本人github：Data Instructions.txt。ANNOT的意义在于提供给了我们各心拍专家诊断的结果，用于后续深度学习算法的标签。另外一个是ATRTIME，它存储了各心拍的人工标注位置，一般以QRS波为基准。即该记录的几分几秒出现了一个心拍。而这个矩阵的意义在于后续帮助我们评估心拍定位算法的准确性，或是直接根据它提供的人工标注位置截取心拍。 3.小结本节我们学习了ECG数据库的获取与matlab读取，解决了数据来源问题。如果你对其他数据库也感兴趣，可以在上面介绍的网站中继续了解。然而现在还不宜直接进行机器/深度学习模型的开发，还有那些重要的事情没做？且听下回分解。 ** MIT-BIH数据库下载： 链接: https://pan.baidu.com/s/1cAOc8jzGuwx7mXlfcrErgw 提取码: 8zw8 ** 相关代码文件下载：https://github.com/Aiwiscal/ECG-ML-DL-Algorithm-Matlab","link":"/2020/04/18/ECG-%C3%97AI-%E6%9C%BA%E5%99%A8-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84ECG%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%EF%BC%882%EF%BC%89/"},{"title":"Emoji 转换 base64","text":"Mysql存_emoji_表情(_base64_编码) - 云+社区 - 腾讯云 2019年3月26日 - 1 String _emoji_Str = MimeUtility.decodeWord(mysqlColumn); 相对于这种使用_Base64转换_的方式,… 前端处理支持_emoji_表情 - 简书 2017年7月21日 - 前端解决的方案:在提交数据时,通过正则获取所有的emoji_表情,将其转成 _base64 ,然后提交给后台,后台不需要做任何操作,当请求数据时再原封不动的返给前… 字符串和base64_的相互_转换–包含emjo表情转换_成_base64 2019年12月10日 - 2、方式二:全部转换_成_base64,但是将_base64转换_回来的时候是ascii码,需要二次_转换_。 个人推荐第二种啊,第一种还是不太严谨。 用到的插件如下: (functio… 特殊字符,如_Emoji_表情_Base64_存储到数据库 - xtjatswc - 博客园 2019年12月3日 - 有些特殊字符,如Emoji,存储到oracle数据库就会变成乱码,解决方案就是_Base64_转码后存储到数据库,取出后再解码传输,经过验证是可以的。 编码存储,接收参… 将包含一组_Emoji_的文本_转换_为Unicode编码列表 2017年4月3日 - 一系列的 Emoji 表情,方便用户在文字中插入 Emoji_。…文档是包含一系列 _Emoji 字符的文本,而项目代码中定义…js 将图片转换为_base64_编 将图片_转换_为… 移动端_emoji_表情转码 - 小哥 - CSDN博客 2018年12月7日 - 接下来我们要讨论的就是怎么把_emoji_表情字符_转换_成实体字符。 首先,我们来看看手机输入法里自带的_emoji_字符是什么样。下面截了一张图,来自 http://com… Mysql存_emoji_表情(_base64_编码) | 大专栏 2019年12月10日 - Mysql的utf8编码为何存储不了Emoji_表情? _Emoji 首先的知道Emoji_的编码方式,_Emoji_即_绘文字,绘意指图形,文字则是图形的隐喻,可用来代表多种表情,如笑脸… 如何将4字节utf-8的_emoji_表情_转换_为unicode字符编码-CSDN论坛 2015年2月4日 - 就会显示乱码错误,我们可以把_emoji转_成unicode编码或者utf8编码格式传…(如果不能升级,请用_base64_保存,推送时再转码) 2 将表和推送内容表字… 小程序:_emoji_等表情_base64_后乱码解决方案 - 「dt猫」 2020年3月28日 - 最近在做小程序即时聊天,发现发送_emoji_等表情经过_base64_传给后台后解析出来的就是乱码,最初的问题是前端用_base64_方法对_emoji_的支持不太友好,于是查询… GitHub - watson/base64-emoji: Like base64 but encoding into… Like base64 but encoding into emojis ⭐✊☕. Contribute to watson/base64-emoji development by creating an account on GitHub. 如何转义_emoji_表情,让它可以存入utf8的数据库? - 的回答… 2015年9月7日 - _转为其他格式的_emoji_又怕以后新增了表情不好做,你们在不改数据库编码的前提下,是怎么弄的? 方法1:_base__encode_64 这种方法是可以,但是旧数据没有经过en… …基于php5.6下函数_base64__encode,且支持_Emoji_的实现 – 永夜 2016年6月22日 - 结果发现MySQL中存储的数据对于_Emoji_的支持还不够完善,昵称为:jQuery32101362436134032332_1590662425277?yangqin??? 6、最终决定排序规则还是还原为:utf8_general_ci,基于php函数_base64__enco… 在Javascript 中的_Base64_加密,支持中文加密及_emoji_表情的unicode… 2016年2月24日 - 转载高人分享的_Base64_加密。解决了楼主在使用webscoket做web了聊天接口时出现的_emoji_表情的unicode编码的_base64_加密错误问题。(function(global){ ‘us… Vue实现_base64_编码图片间的切换功能_vue.js_脚本之家 2019年12月4日 - webpack中配置了图片在10kb以内自动转换base64,所有就有了本篇文章的分享…emoji.json [ { “name”: “pout”, “src”: “1fix@2x.png“, “info… _emoji_表情的替换如何处理好一点_慕课猿问 2018年11月30日 - 如何处理emoji_表情更好一点 现在前端框里面的表情用类似哭这样的符号代替 处理…_转换或者以_base64_加密,缺点是增加了数据的长度,而且每次写入读取都要… 欸? 数据库版本低不支持emoji ,可不可以_base64_加密一次【firefox… 2018年11月30日 - 不如只把_emoji_编码(当然你得添加标记表示这是_emoji_……) 绯色起源 驰骋网络 15 可以啊,为啥不可以现在大家人手E5,解密下_base64_算个毛事 矮子高 校… jQuery 识别 emoji softbank 编码并转html | PHPer | Web前端 |… 2017年3月12日 - 部份用户昵称中添加_emoji_表情,存储到utf8数据库中,是无法插入数据的,因为本案中_base64__encode处理存储,能读取出来,但还是无法识别的编码 + Unified 编… _emoji_2_base64_png - npm Converts unicode emoji in html with base64 inlined png images… npm i _emoji_2_base64_png version 1.0.1 license MIT last publish a few seconds ago coll… mysql数据库保存_emoji_表情转义 - 四季变幻的个人空间 - OSCHINA 2019年6月8日 - _base64__encode($r[0]);}, $str_emoji_); return $text; } /** * 解析表情 **/ function parseHtml_emoji_ ($text) { $text_r = preg_replace_callback(… 简述· 如何理解_base64_编码 - 知乎 2020年4月28日 - 字符集,倘若需要存储的文本中包含_emoji_表情,其中的一种方式就是使用_base64_编码再…_转换_过程如下,假设现在有个字符串“ab”,ascii表示即‭01100001‬01100010,拆… 小程序:_emoji_等表情_base64_后乱码解决方案_唔厌组的秋秋…_CSDN博客 2020年3月28日 - 最近在做小程序即时聊天,发现发送_emoji_等表情经过_base64_传给后台后解析出来的就是乱码,最初的问题是前端用_base64_方法对_emoji_的支持不太友好,于是查询… _Emoji_与unicode特殊字符的处理 - Daniel.zhan - 博客园 2015年5月22日 - import com.google.common.base.Strings; import com…1F600-1F_64_F * 交通和地图符号:1F680-1F6FF …都转 } /** * 将带有_emoji_字符的字符串_转换_成… _Base64_编码_转换___base64_编码_转换__js_转换base64_编码 - 云+社区… 对数据存储的_base64_编码后的字符串逆向解码 1 string _emoji_str =mimeutility.decodeword(mysqlcolumn); 相对于这种使用_base64转换_的方式,我们只需要在服务端做编码和… 关于_base64_编码解码(Android编码,JS解码,案例为解决安…_CSDN博客 2016年7月14日 - Base64_编码要求把3个8位字节(38=24)_转化为_4个6位的字节(46=24),之后…[“woman-kiss-woman”],39,20,7,0] }; //字符表情与别名的数据 _emoji… _emoji_表情转码_java_weixin_43839900的博客-CSDN博客 2019年6月25日 - 接下来我们要讨论的就是怎么把_emoji_表情字符_转换_成实体字符。 首先,我们来看看手机输入法里自带的_emoji_字符是什么样。下面截了一张图,来自 http://com… 用android 自带base64 解决 _Emoji_表情问题_移动开发_u0…_CSDN博客 2014年5月14日 - 当我们上传手机自带的Emoji 表情 ,上传到服务器,发现h移动开发… 当我们上传手机自带的Emoji 表情 ,上传到服务器…Android 与H5交互心得(Base64) 1… 微信_emoji_表情编码的处理与储存_数据库_Lyndon的专栏-CSDN博客 2017年6月28日 - 当二进制_转换成用户所熟悉的图片,文字形式的时候,例如…_Emoji_就是一种在Unicode位于\\u1F601-\\u1F_64_F区段…collation_data_base | utf8mb4_general_ci | | … Emoji 表情转义止于前端_前端_Gzejia-CSDN博客 2017年5月4日 - 而解决问题关键就是将特定的表情符号转为_与数据故…对比 _Base64 加密处理,虽记录值也随之变长,但可…某些表情或因官方新的 Emoji 表情包更新,而没有… Java Base64 加密解密 (数据加密或解决手机_Emoji_表情被…_CSDN博客 2018年9月18日 - 通常会遇到一种场景,当用手机输入法输入_Emoji_表情符的时候,由于数据库不支持,保存时这些表情符号就会被过滤掉以至于无法显示,android和h5开发中可以使… 关于转换_微信表情符号和_emoji-CSDN论坛 2014年7月23日 - 大家有没有转换_过微信的表情符号 或者_emoji_表情符的! 给个例子看看 谢谢! 比如…_emoji字体表情库应该使用_base64__encode编码,拿信息的时候ba…","link":"/2020/05/28/Emoji%20%E8%BD%AC%E6%8D%A2%20base64/"},{"title":"Flutter 404页面自定义","text":"Flutter 已经发布了 Web 支持，允许您创建动态网站。Flutter 支持处理可能来自 Web 使用的任何错误，如 404 错误。但是，如何为您的 Flutter 应用程序创建自定义 404 页？ 本文介绍如何创建用户导航到不存在的页面时显示的自定义页面。 如何将客户端重定向到 Flutter 中的自定义 404 页浏览互联网时，每个人都遇到”404：页面未发现错误”。Flutter 通过自动将您重定向到初始路由来处理此问题。这通常是应用程序的主页。但是，如果你想有一个花哨的404页面，像在AirBnb，GitHub，甚至Flutter网站？ 您可以使用 Flutter 轻松执行此操作。 要创建自定义 404 页，应用程序需要使用 、 或小部件。大多数应用程序使用这三个小部件之一;它是创建 Flutter 应用程序时调用的第一个小部件。 1MaterialApp 1CupertinoApp 1WidgetsApp 材料应用配置顶级导航器以按以下顺序搜索路由： 对于路由，将使用属性（如果为非 null）。 1/ 1[home](https://zshipu.com/t?url=https://api.flutter.dev/flutter/material/MaterialApp/home.html) 否则，如果表具有路由的条目，则使用该表。 1[routes](https://zshipu.com/t?url=https://api.flutter.dev/flutter/material/MaterialApp/routes.html) 否则，如果提供，则调用。它应返回 和 未处理的任何有效路由的非 null 值。 1[onGenerateRoute](https://zshipu.com/t?url=https://api.flutter.dev/flutter/material/MaterialApp/onGenerateRoute.html) 1[home](https://zshipu.com/t?url=https://api.flutter.dev/flutter/material/MaterialApp/home.html) 1[routes](https://zshipu.com/t?url=https://api.flutter.dev/flutter/material/MaterialApp/routes.html) 最后，如果所有其他失败都调用。1[onUnknownRoute](https://zshipu.com/t?url=https://api.flutter.dev/flutter/material/MaterialApp/onUnknownRoute.html) 如果路由未在这些表中处理，则它使用 属性来处理导航。此回调通常用于错误处理。例如，此函数可能始终生成描述未找到的路由的”未找到”页面。未知路由可能由应用中的错误或外部请求（如来自 Android 意图）产生。 1[onUnknownRoute](https://zshipu.com/t?url=https://api.flutter.dev/flutter/material/MaterialApp/onUnknownRoute.html) 下面的示例代码演示如何为 属性定义匿名函数，该函数采用 .以下代码段显示了定义属性是多么简单： 1onUnknownRoute 1RouteFactory 1RouteSettings function 1Route 1onUnknownRoute onUnknownRoute: (settings) { return MaterialPageRoute(builder: (_) =&gt; PageNotFound());}, PageNotFound是一个自定义的小部件，创建404页。此页面可能会解释发生的情况，并将用户重定向到主页，但在创建 404 页面时，您可以随心所欲地创作。 闭幕词创建 Flutter 应用程序时，处理可能出现的任何问题非常重要。使用 中的 属性，或允许您处理网站中不可避免的”页面未找到”错误。 1onUnknownRoute 1MaterialApp 1CupertinoApp 1WidgetApp","link":"/2020/06/25/Flutter%20404%E9%A1%B5%E9%9D%A2%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"title":"Flutter 八大优势","text":"Flutter的优势您可能会假设每个跨平台框架都可以执行某些操作，并提供一些对作业至关重要的功能，您有观点。但！在一些关键方面，Flutter与竞争对手略有不同。 1. 所有平台中的相同 UI 和业务逻辑 我们，专家，知道基本上任何跨平台框架提供了一种在目标平台之间共享代码库的方法。但是，除了 Flutter 之外，没有这样的应用程序框架允许共享 UI 代码本身。 为了说明这一点，下面是大多数跨平台框架中 UI 呈现的外观示例： 这种渲染过程使构建在每个平台上看起来本机的应用变得简单。但魔鬼在细节。依赖特定于平台的组件进行渲染，因此需要平台小部件的属性映射层和框架小部件数据同步。这就是需要将每个动画映射到特定于平台的小部件调用的原因。比它需要的要复杂得多，对吗？ 相反，Flutter 不需要任何特定于平台的 UI 组件来呈现它的 UI。Flutter 唯一需要显示应用程序 UI 的就是要绘制的画布。下面是它的外观： Flutter 的渲染方式使框架真正从人群中脱颖而出，消除了对不同平台上 UI 一致性的任何担忧。 简而言之，与 Flutter 共享 UI 和业务逻辑可节省时间、精力和开发人员的运行状况，同时不影响最终产品的性能。 2. 缩短代码开发时间 根据我的经验，构建一个通常的中型 Android 应用程序至少需要 40 秒才能被运送到测试设备。有时，只需调整布局中的一个小视觉方面即可。你们中有些人可能会说，’等等，但Android工作室有一个布局预览。确实如此。然而，当然，有一个：功能是有限的，并不总是按预期工作，特别是自定义视图。 Flutter 的”热重装”功能，反过来，允许几乎立即看到应用的更改，甚至不会丢失当前应用程序状态。而这正是由于开发速度提高，使 Flutter 应用程序开发速度提高数倍的原因。 此外，Flutter 团队已投入大量精力来提供各种即用小部件。其中大部分是令人难以置信的可定制，节省你的时间像没有其他框架之前。除了许多核心布局小部件外，Flutter 还提供一大组材料和库比蒂诺小部件，可完美模仿每种设计语言的行为。以下是它们的工作原理： 总之，在使用 Flutter 时，您跳过了应用开发中几个耗时极其耗时的步骤，这使得整个过程更快、更简单、更令人担忧。 3. 提高上市时间速度 这一个非常简单。Flutter 开发框架的功能比其替代方法快。在大多数情况下，与为 Android 和 iOS 单独开发的同一应用相比，Flutterapp 应用至少需要两倍的工作时间。主要原因是简单：您无需编写任何特定于平台的代码即可在应用程序中实现所需的视觉对象。任何基于 2D 的 UI 都可以在 Flutter 中实现，而无需与本机应用程序对应项进行交互。 除此之外，Flutter 还提供了用于构建 UI 的声明性 API，根据我的经验，它显著提高了性能。这在视觉调整方面最为明显。 4. 与本机应用性能类似 应用程序性能对于良好的 UX 至关重要。虽然很难分辨出确切的数字，但可以肯定地说，在大多数情况下，Flutter应用程序的性能与本机应用没有区别，在复杂的 UI 动画方案中甚至更好。 为什么？与大多数跨平台框架的方法相反，Flutter 并不依赖于任何中间代码表示或解释。Flutter 应用程序直接内置到机器代码中，消除了解释过程的任何性能错误。 最终，您提前使用 Flutter 编译了发布应用程序。 5. 任何复杂性的自定义、动画 UI 可用 Flutter 的最大优势之一是能够自定义在屏幕上看到的任何内容，而不管它有多复杂。虽然在本机平台上通常也可以执行非常自定义的 UI，但所需的工作量因顺序大小而异。下面是这样简单但自定义 UI 的示例： 但是，Flutter 使流程更加灵活和通用，而不会增加工作负载。共享元素过渡、形状/颜色/阴影操作、剪切、转换 – Flutter 可让您轻松执行所有这些操作。这里有一些更多例子它是如何工作的。 6. 自己的渲染引擎 Flutter 允许您使用其他平台上不可用的应用执行大量操作。显然，它需要框架非常强大。事实上，如果没有高性能的跨平台呈现引擎，上述大多数要点是不可能的。 飞溅使用斯基亚用于将自己渲染到平台提供的画布上。由于引擎，内置于 Flutter 的 UI 几乎可以在任何平台上启动。换个说法不同，您不再需要调整 UI 将其传输到平台，这大大简化了开发过程。 7. 简单的平台特定逻辑实现 除了 UI 之外，许多真实的移动应用程序还依赖于高级操作系统级功能，例如获取 GPS 坐标、蓝牙通信、收集传感器数据、权限处理、使用凭据等。在通过 Google 支持的即用插件开发 Flutter 应用程序时，其中许多都可用。 当然，在某些情况下，您的应用程序可能依赖于操作系统级功能，该功能尚未作为插件提供。但是团队也把你也覆盖了！Flutter 提供了一种易于使用的方式，用于通过平台本机代码和 Dart 之间建立通信平台通道.这样，您可以实现本机应用可以在 Flutter app 上执行的任何操作，只需在本机方面稍加一点功夫即可实现。下面是通道如何工作的示例： 8. 超越移动的潜在能力 使用 Flutter，您可以超越移动上的 Flutter 应用程序开发。现在也有”为 Web 和 颤动桌面嵌入而显示”。。例如，在今年的 I/O 会议上，Google 提供了飞溅的 Web使得可以在浏览器中运行纯 Flutter 应用程序，而无需修改源代码。检查会议视频： 这一重要事件标志着 Flutter 从跨平台移动应用程序框架过渡到成熟的跨平台开发工具。 尽管除了框架的移动部分之外的所有内容尚未被视为生产就绪，但经验丰富的开发人员可以让纯 Flutter 应用程序在如今的任何主要平台上运行，包括 Android、iOS、Web 浏览器、Windows、macOS、Linux，甚至嵌入式设备。应用程序将正常运行，无需更改 Dart 代码。","link":"/2020/06/25/Flutter%20%E5%85%AB%E5%A4%A7%E4%BC%98%E5%8A%BF/"},{"title":"Flutter 滑块小部件有哪些新增功能","text":"Flutter 允许您创建美观的本机编译应用程序。Fluter之所以能做到这一点，是因为材料是一个设计系统，有助于建立高质量的数字体验。随着 UI 设计的不断发展，材料继续更新其组件、运动和设计系统。 Flutter 最近更新了 和 小部件到最新的材料指南。新的滑块的设计考虑到了更好的可访问性：轨道更高，拇指有阴影，并且值指示器具有新的形状和改进的文本缩放支持。 1[Slider](https://zshipu.com/t?url=https://api.flutter.dev/flutter/material/Slider-class.html) 1[RangeSlider](https://zshipu.com/t?url=https://api.flutter.dev/flutter/material/RangeSlider-class.html) 本文介绍了 对 和 部件的更改。 1Slider 1RangeSlider 有什么新内容？1Slider 并更新，让您在使用这些小部件时获得更流畅的体验。此图演示了制作滑块小部件的五个不同的组件。 1RangeSlider 和 由五部分组成： 1Slider 1RangeSlider 显示拇指值标签的值指示器 拇指滑过的轨迹 指示值位置的拇指 按下拇指时显示的叠加 滑块离散时，在轨道上打勾 注意：本文指的是两种不同类型的叠加： 该组件表示上图中提到的组件。 1OverlaySlider Flutter 的类用于在以下屏幕上显示的所有其他小部件上”浮动”小部件。 1Overlay 新的默认值指示器形状旧滑块和新滑块小部件之间最大的视觉差异是默认值指示器：和 。这些指示器反映了材料的最新设计变化。旧的指示器形状是一个倒置的梨，新的形状更矩形，看起来像一个语音气泡。值指示器已更新为 和。 1[RectangularSliderValueIndicatorShape](https://zshipu.com/t?url=https://master-api.flutter.dev/flutter/material/RectangularSliderValueIndicatorShape-class.html) 1Slider 1[RectangularRangeSliderValueIndicatorShape](https://zshipu.com/t?url=https://master-api.flutter.dev/flutter/material/RectangularRangeSliderValueIndicatorShape-class.html) 1RangeSlider 1Slider 1RangeSlider 叠加上的值指示器绘制更新的值指示器现在绘制在叠加上。这意味着指标不再局限于滑块的范围，可以在其他小部件上显示。这是预料之中的，因为指标仅在处理手势检测器时激活，这意味着它仅在用户与滑块交互时显示。通过将 与 、和 widgets 集成，值指示器可以显示在其他小部件上。要了解有关此机制的更多信息，请参阅如何在（可能转换的）UI 小部件上浮动叠加小部件。 1MediaQuery 1[Overlay](https://zshipu.com/t?url=https://api.flutter.dev/flutter/widgets/Overlay-class.html) 1[CompositedTransformTarget](https://zshipu.com/t?url=https://api.flutter.dev/flutter/widgets/CompositedTransformTarget-class.html) 1[CompositedTransformFollower](https://zshipu.com/t?url=https://api.flutter.dev/flutter/widgets/CompositedTransformFollower-class.html) 1[Layerlink](https://zshipu.com/t?url=https://api.flutter.dev/flutter/rendering/LayerLink-class.html) 下图显示了 和 小部件的制作方式： 1Slider 1RangeSlider 您可能会注意到，我们使用单独的来绘制叠加上的指示器。这是因为我们需要在类和屏幕上绘制，你不能从同一个小部件执行。 1LeafRenderObjectWidget 1Overlay 1LeafRenderObjectWidget 由于我们现在正在叠加上绘制值指示器，因此不再局限于包含滑块的范围。指标不再剪切到该框，这意味着整个值指示器始终显示。 1MediaQuery 注意：此示例使用设置为 4 进行，以便更好地演示。 1textScaleFactor 值指示器矩形被移动，以便指标的一部分不会消失在屏幕上。此改进允许您增加指标中的位数，并增加应用程序的文本比例因子，而不必担心文本是否超过屏幕大小。在下图中，值指示器文本刻度为 4，包含 3 位值，但滑块处理时没有问题。 double getHorizontalShift({ RenderBox parentBox, Offset center, TextPainter labelPainter, double textScaleFactor, Size sizeWithOverflow, double scale,}) { assert(!sizeWithOverflow.isEmpty); const double edgePadding = 8.0; final double rectangleWidth = _upperRectangleWidth(labelPainter, scale, textScaleFactor); /// Value indicator draws on the overlay, and by using the global Offset, /// we are making sure that we use the bounds of the Overlay instead of the Slider. final Offset globalCenter = parentBox.localToGlobal(center); // The rectangle must be shifted toward the center so that it minimizes the // chance of it rendering outside the bounds of the render box. If the shift // is negative, then the lobe is shifted from right to left. If the shift is // positive, then the lobe is shifted from left to right. final double overflowLeft = math.max(0, rectangleWidth / 2 — globalCenter.dx + edgePadding); final double overflowRight = math.max(0, rectangleWidth / 2 — (sizeWithOverflow.width — globalCenter.dx — edgePadding)); if (rectangleWidth &lt; sizeWithOverflow.width) { return overflowLeft — overflowRight; } else if (overflowLeft — overflowRight &gt; 0) { return overflowLeft — (edgePadding * textScaleFactor); } else { return -overflowRight + (edgePadding * textScaleFactor); }} 注意：此示例使用设置为 4 进行，以便更好地演示。 1textScaleFactor 激活的值指示器优先数值指标也已更新，以便当前活动指标优先于静止指标。这意味着，如果指标重叠，则活动指标”浮动”于另一个指标。 1RangeSlider 注意：此示例使用设置为 4 进行，以便更好地演示。 1textScaleFactor 更新旧值指示器我们保留了小部件，并更新了它，以具有更好的可扩展性和可访问性。小部件也打印在类似 的 上。在下面的示例中，您可以看到这两个 和 都使用旧值指示器。 1PaddleValueIndicator 1PaddleValueIndicator 1Overlay 1RectangularSliderValueIndicatorShape 1Slider 1RangeSlider 如果要继续使用旧值指示器，只需使用 包装小部件，并将 属性设置为 。过程对于 是相同的。使用 包包小部件，并将 属性设置为 。 1Slider 1SliderTheme 1valueIndicatorShape 1SliderThemeData 1PaddleSliderValueIndicatorShape 1RangeSlider 1RangeSlider 1SliderTheme 1rangeValueIndicatorShape 1SliderThemeData 1PaddleRangeSliderValueIndicatorShape 活动轨道大于非活动轨道中的其他组件形状也已更新。轨道形状已更改，以便轨道的活动部分大于轨道的非活动部分。这意味着，如果应用程序使用从左到右的语言，则轨道的左侧部分大于右侧。如果应用程序使用从右到左的语言，则轨道的右侧部分大于左侧。对于 ，活动轨道是两个拇指之间的轨道部分。 1Slider 1RangeSlider 标记标记组件刻度线大小和定位已更改。刻度线现在是轨道组件的一部分，而不是延伸轨道的末尾。刻度线上也有填充，因此它显示在轨道组件中。刻度线的大小现在具有 1 的半径。 拇指组件具有阴影激活拇指滑块组件时，现在出现在 上 有 。 1Shadow 1Overlay 闭幕词您可以通过切换到 Flutter 版本 1.18.0_9.0 来尝试这些更改。此版本仅在本文发布期间在主分支上可用。您可以通过运行 然后 切换到主分支。 1flutter channel master 1flutter upgrade","link":"/2020/06/25/Flutter%20%E6%BB%91%E5%9D%97%E5%B0%8F%E9%83%A8%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD/"},{"title":"Flutter：初学者的学习资源","text":"Flutter是谷歌的移动UI技术和SDK，使您能够从用Dart编写的单个代码库为多个平台（Android &amp; iOS）构建原生应用。当前版本是在Beta v3，并考虑生产准备。 更新： 2018年6月20日Flutter 团队刚刚宣布发布预览版 1，这表明我们现在已经开始冲刺到官方 v1.0 版本 我在哪里可以了解更多信息？这是一个活的文件，我计划跟上新的和更新的学习资源。 _先读这个！_粉碎杂志有一个优秀的Fluter介绍今天（6月21日）从迈克蓝斯坦张贴。现在，我该与任何人分享”什么是Fluter？去读吧！ 有许多方法可以开始。以下是一些我认为有价值的： 入门。从这里开始。Flutter 团队为设置开发环境提供了很好的指导。此外，一个简单的教程，让您熟悉基本的概念。 颤动的法典 。如果您的学习风格倾向于编码概念，那么从这里开始。有9个代码实验室可从谷歌IO（2018年5月），涵盖了介绍飞镖，写你的第一个Fluter的应用程序与2个部分，使用材料组件的颤动与4个部分，并集成火库。其中每一个都附带初学者代码，使您能够直接使用代码了解特定功能。 @Udacity。如果你是一个喜欢了解事情是如何在引擎盖下工作，或想更好地了解概念之前，潜入代码实验室，这是给你。目前，由两部分组成的”飞溅”团队课程，涵盖“飞溅框架”和“构建互动应用程序“，预计很快会有更多的内容。请查看本课程的相关GitHub 存储库。 由谷歌：视频。由 Flutter 团队策划的 YouTube 播放列表，包含来自 #IO18 和 Flutter 开发人员拥护者的视频。值得订阅。 《飘扬周刊》是一份社区策划的时事通讯，是一种快速的方式来关注社区发布的文章和教程。查看过去的存档问题或在此处订阅。 FlutterDevs列表是一个Twitter列表，我维护的Fluter球迷，包括在谷歌的颤动团队的人，和来自社区的颤动专家。还要查看谷歌开发者专家名单，Flutter。我也非常主张跟随来自Flutter团队的NilayYener，他负责监督社区外联工作。 Awesome-Flutter是一款令人敬畏的 GitHub 存储库，其中包含用于自导探索的众多 Flutter 资源的更新列表，包括文章、组件和开源项目。 飘荡的例子是理解如何在”Fluter”中_思考_的最佳来源之一。大多数开发人员通过解构来学习，然后重新混合工作示例，Flutter 也不例外。_虽然此_回购包含来自 Flutter 团队的示例（包括旗舰飞溅库应用），但您也可以查看开源社区应用，了解另一组透视图。 飘荡的FYI。无耻的插头#1。我最近建立了这个网站，分享文章和见解，从我自己探索的Flutter。我也希望回去，从我参加过的各种谈话中发表素描笔记。我的目标是共享结构化（集合）和非结构化（帖子），前者将用来定期将后者收集到有用的_学习路径_，以帮助提供特定主题的涵盖。 在雷迪特上飘荡。这实际上是一个关键视频，文章和更多的良好存储库。 飘荡的Utils。这是用于列出应用、工具或库，帮助您使用 Flutter 提高工作效率。首先是FlutterStudio一个伟大的应用程序，以模拟和实现一个视图。我还在维护一个“按示例“Twitter 时刻收集来自各地 Flutter 作者对应用、代码示例和最佳实践的引用。接下来，Brian Egan 的“飞溅示例“为 Flutter 应用程序的建筑设计提供了很好的示例（例如，从状态管理、测试和进化角度看他 2018 年 DartConf 的上下文讲座）。 **飘荡的食谱**。不错的_食谱_集合，以解决经常遇到的问题或需求，在一个飘荡的环境中。维护在官方的Flutter文档网站，这是真棒！ 按社区进行我将使用本部分来突出YouTube视频创作者/播放列表和Fluter博客，这是值得订阅的，在Flutter开发。每天都有大量资源联机，因此将其移到自己的子部分。还添加了一个新的部分，侧重于演示文稿 - 这是专门分享演讲者甲板（允许），其他人可以用来启动谈话/意识在他们的社区。 博客 古鲁冥想-托马斯·伯克哈特的博客，谁带来了夏马林的专业知识，以飘荡。 伊罗·克兰卡的博客来自GDE利罗·克兰卡谁带来了Android和科特林的专业知识的颤动。（这个网站以前是Fluter的岩石）。 Fluter样本-由布赖恩·伊根等人撰写博客，对 Flutterapp 应用程序开发的建筑模式有深入见解 值得一提的 / 飞溅- 博客由布尔汉努丁拉希德与颤动见解为Android开发人员 视频 波动的挑战- 通过构建完整/复杂 UI 或用于挑战的功能的视频。 使用颤动编码-来自安德里亚·比佐的视频，他带来了 iOS 专业知识。 MTechViral - 70+视频教程从帕万库马尔GDE与Android专业知识的颤动。 飞镖/飞镖教程- 从Tensor编程博客背后的人 演示文稿（幻灯片） Flutter 现在在测试版中：简介- 由Pascal Welsh在 Flutter 中谷歌开发人员专家 建立美丽的应用程序与谷歌飞溅- 由真棒艾哈迈德阿布埃尔达哈布，社区和#FlutterBus组织者！ Fluter，然后飞-从我，在风城DevFest在一月，当Fluter在阿尔法。有些事情改变了，但核心仍然是有价值的。 存储库（代码示例、应用） 帕万·库马尔 巴维克·马克瓦纳 Flutter的片状 还有什么需要我了解的吗？无耻的插头#2。我经营着谷歌开发者集团，纽约市，一直是Flutter的超级粉丝。我在2018年IWD NYC举办了一个Fluter的研讨会，并在6月初的I/O扩展活动中举办了一个Fluter的研究班。我将在7月的OSCON上做一次深入探讨。 我们目前计划第一个Fluter的营地，一个全天沉浸式学习研讨会为初学者。如果您居住在大纽约地区，请加入GDG NYC并注册此表单，在活动注册打开时收到通知。我建议你在上下文的评论部分提及Dev.To。 我们只剩下几个地方要填补。这是初学者友好，我希望看到平等的代表性！","link":"/2020/06/25/Flutter%EF%BC%9A%E5%88%9D%E5%AD%A6%E8%80%85%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"},{"title":"GraphQL实战：GraphQL Mutations 五","text":"上周，我在这篇文章中描述了 GraphQL的基础知识。我们介绍了 GraphQL 的基础知识以及用于设置和使用 GraphQL 的基本概念。本周，我报道了我上周留下的一篇关键文章：GraphQLMutations。 #ruby#rails#graphql](https://zshipu.com/t?url=/speratus/graphql-basics-3c0d) GraphQL Mutations允许开发人员修改存储在服务器上的数据。 GraphQL 不知道该怎么处理您发送给它的任何数据，因此我们必须具体告诉它，在创建的每个Mutations中应执行哪些操作。 创建MutationsGraphQL Gem 具有一个方便的生成器，我们可以用它来开始构建我们的Mutations。跳转到项目目录并运行以下命令： rails g graphql:mutation create_topic rails g graphql:mutation create_reply rails g graphql:mutation create_like 每个命令都会创建一个新的命名Mutations。生成器需要的唯一参数是Mutations的名称。 将以下代码添加到 ： 1app/graphql/mutations/create_topic.rb module Mutations class CreateTopic < BaseMutation # just like queries, mutations return certain fields # in this case, the mutation returns a list of strings which are potential errors # and the topic that was created if the creation was successful field :errors, [String], null: false field :topic, Types::TopicType, null: true # mutations also take arguments, very similar to the way queries can take arguments argument :user_id, ID, required: true argument :title, String, required: true argument :content, String, required: true # Unlike queries, mutations must have a resolve method to tell # GraphQL what to do with the mutation and the arguments it receives. def resolve(title:, content:, user_id:) # In this case, we will create a new topic. topic = Topic.new(title: title, content: content, user_id: user_id) if topic.save { topic: topic, errors: [] } else { topic: nil, errors: topic.errors.full_messages } end end endend 字段、参数和方法占 GraphQL Mutations的大部分。 1resolve GraphQL 不知道如何自己处理多态关联，我们将添加一些专门用于解决这些问题的代码： module Mutations class CreateReply < BaseMutation # As with create_topic, we have fields, arguments and a resolve method field :errors, [String], null: false field :reply, Types::ReplyType, null: false # We need to give the pieces of the polymorphic info that it needs to # properly construct the association argument :post_id, ID, required: true # post_type tells Rails what kind of model to look for. argument :post_type, String, required: true argument :user_id, ID, required: true argument :content, String, required: true def resolve(post_id:, user_id:, content:, post_type:) # Use the Rails method `constantize` to turn a string into a constant # which we know should refer to an ActiveRecord model, allowing us to run # the ActiveRecord method `find_by` to get the correct object with that type type = post_type.constantize post = type.find_by(id: post_id) reply = Reply.new(content: content, user_id: user_id, post: post) if reply.save { reply: reply, errors: [] } else { reply: nil, errors: reply.errors.full_messages } end end endend 迷你论坛是一个为一系列博客构建的小型论坛应用程序创建用户和登录会话我们需要将用户创建与 GraphQL 分开，以便在访问 GraphQL 终结点之前，可以轻松地要求所有用户登录。 因此，我们需要生成专用于用户创建功能的控制器： rails g controller users create 打开新控制器并添加以下内容： # app/controllers/users_controller.rb class UsersController < ApplicationController def create user = User.new(user_params) if user.save render json: user_json(user) else render json: { message: 'Failed to create user', errors: user.errors.full_messages } end end private # Use strong parameters to prevent any unwanted parameters from getting through. # The password confirmation field is required to allow BCrypt to properly hash the password. def user_params params.require(:user).permit(:name, :username, :email, :password, :password_confirmation) end # Turns a user model object into a hash which can be converted to json. Maybe # not necessary in a controller this small, but certainly necessary in a larger project. def user_json(user) user.as_json(only: [:id, :name, :username, :email]) end end 验证用户由于我们使用JWT 来处理用户会话，因此我们需要添加另一个控制器，允许用户通过登录来创建这些会话。 创建新控制器来处理登录会话并添加以下代码： rails g controller sessions create 现在编辑新控制器： # app/controllers/sessions_controller.rb class SessionsController < ApplicationController def create # find the user by the username included in the parameters user = User.find_by(username: session_params[:username]) # If the user exists, and can be authenticated with the given password, generate a token # for the session and return it. if user &amp;&amp; user.authenticate(session_params[:password]) # Generate the token based on the user’s id. Use the value of JWT_SECRET in # the `.env` file. token = JWT.encode({user_id: user.id}, ENV['JWT_SECRET']) render json: {token: token, user_id: user.id} else render json: {message: &quot;Incorrect username or password&quot;} end end private # Use strong parameters to make sure we only get a username and password. def session_params params.require(:session).permit(:username, :password) end end 为了使用变量，我们需要在根项目目录中创建一个文件。 12JWT_SECRET .env _为保证 1JWT_SECRET， 请务必将 1.env 添加到项目的 1.gitignore 文件中。确保 1.env 永远不会提交到可公开访问的存储库中。_ 创建后，运行以下命令： 1.env rake secret 将该命令的输出粘贴到 中的变量中： 1.env JWT_SECRET= 这样做将确保您有一个加密安全号码，用于编码用户的会话数据。 我们需要添加一个方法，以便端可以检查用户是否经过身份验证。 1current_user 1ApplicationController # app/controllers/application_controller.rb This error is used below to specify that a session is not authenticatedclass AuthenticationError &lt; StandardError end class ApplicationController &lt; ActionController::API def current_user # Authentication setting the Access-Token header to the result of # the create session route token = request.headers[‘Access-Token’] raise AuthenticationError if token.nil? # Decodes the JWT token and returns only the user id from it. user_id = JWT.decode(token, ENV[‘JWT_SECRET’])[0][‘user_id’] @user = User.find_by(id: user_id) endend 最后，在 GraphQL 控制器的路由中进行第一个方法调用。 1current_user 1execute # app/controllers/graphql_controller.rb class GraphqlController < ApplicationController def execute current_user variables = ensure_hash(params[:variables]) … end …end 完成之后，我们准备测试我们的Mutations。 使用邮递员测试 GraphQL Mutations要测试我们的Graph qld Mutations，我们需要在我们的数据库中有一个用户。您可以使用导轨控制台直接创建用户，也可以向使用 Postman 的发布请求发送帖子请求。 1users_controller 创建用户后，我们必须获取访问令牌。启动 rails 开发服务器，使用要登录的用户名和密码向端端的终结点发送后请求。如果所有内容都设置正确，则您应该收到包含令牌的 json 响应。将新令牌作为标头粘贴到邮递员请求中。 1/sessions 1Access-Token 现在，我们可以再次提交 GraphQL 查询。让我们创建一个新主题： 如您所看到的，要运行Mutations，我们必须使用关键字以及包含所有必需参数的Mutations名称和 json 对象。 1mutation 您也可以使用json对象来保存所有Sq.QL变量，但对于像上面的单个查询来说，将它们放在查询字符串中要容易一些。 我们的后端现在应该名义上是完整的。我们可以登录和运行查询并创建对象。我们尚未实现更新对象或删除它们。尝试自己创建和Mutations。 12update delete","link":"/2020/07/09/GraaphQL%E5%AE%9E%E6%88%98%EF%BC%9AGraphQL%20Mutations%20%E4%BA%94/"},{"title":"GraphQL 微服务化","text":"GraphQL 在_微服务_架构中的实践 - 前端大全 - CSDN博客 2018年7月29日 - 这篇文章中,首先会简单介绍 GraphQL 是什么,它能够解决的问题;在这之后,我们会重点分析 GraphQL 在_微服务_架构中的使用以及在实践过程中遇到的棘手问题… GraphQL_在_微服务_架构中的实践_Docker的专栏-CSDN博客__graphql微服务 2018年7月19日 - 在过去的将近半年的时间里,作者一直在使用_GraphQL_这门相对新兴的技术开发Web服务,与更早出现的SOAP和REST相比,_GraphQL_其实提供的是一…__graphql微服务_ 在微服务_下基于 _GraphQL 构建 BFF-前端里 2018年8月4日 - GraphQL 只是解析客户端请求,知道客户端的“意图”之后,再通过对_微服务_API的访问获取到数据,对数据进行一系列的组装或者过滤。 5. 无须版本化 const PhotoType =… 实践微服务,第14部分:GraphQL - 云+社区 - 腾讯云 2018年6月27日 - 在实践_微服务_系列博客的这一篇中,我们将看看如何使用_GraphQL_将Account对象提供给我们的客户端。 【转载】_微服务_下使用_GraphQL_构建BFF - 简书 2018年11月22日 - 本文摘自ThoughtWorks: https://insights.thoughtworks.cn/use-_graphql_-build-bff-in-microservices/ _微服务_架构,这个在几年前还算比较前卫的技术在如今遍地开花。得… GraphQL-BFF:_微服务_背景下的前后端数据交互方案 - 云+社区 - 腾讯云 2019年8月1日 - 从SearchParams, FormData 到 JSON,再到 GraphQL 查询语句,我们看到不断有新的数据通讯方式出现,满足不同的场景和复杂度的要求。 站在这个层面上看,Gr… 基于_graphql_的_微服务_基础框架 - Golang 中国 2018年12月26日 - base是一个小而美的业务基础框架,它使用_graphql_作为api通信协议基础。然后提供了一些…支持_微服务_之间的rpc调用和数据解析 轻易支持立即容器化 目录… 基于_graphql_的_微服务_基础框架首页、文档和下载 - 小而美 - Go语言… 2018年12月26日 - base是一个小而美的业务基础框架,它使用_graphql_作为api通信协议基础。然后提供了一些…支持_微服务_之间的rpc调用和数据解析 轻易支持立即容器化 目录结构 .├── REA… _微服务_下使用_GraphQL_构建BFF的实践 2018年5月2日 - GraphQL 查询请求,同时我们在 BFF 端增加了 /api/${serviceName} 进行API 透传,对于一些没有必要进行 GraphQL 封装的请求,可以直接通过透传访问到相关… [译] 使用 Go 编写微服务_及其 _GraphQL 网关 | 码农网 2019年5月22日 - 几个月前,一个优秀的 GraphQL Go 包下面列出的一些代码可能存在一些缺失,完整的代码请访问Spidey 包含了三个不同的服务_并暴露给了 _GraphQL 网关。集群内部的通信… 【第1683期】GraphQL-BFF:_微服务_背景下的前后端数据交互方案_接口 2019年7月29日 - 任何接口设计复杂到一定程度后,都会包含一个临时开发的、不合规范的、只有一半功能的 GraphQL 实现。 从SearchParams, FormData 到 JSON,再到 GraphQL 查询语句,… _GraphQL_在_微服务_架构中实践架构 - 豆丁网 2018年8月13日 - 来源:CDA数据分析 GraphQL_在_微服务_架构中的实践架构 目录 _GraphQL 是什么?… _GraphQL_在_微服务_架构中的使用 _GraphQL_在实践过程中遇到的棘手问题… _GraphQL_在_微服务_架构中的实践架构_百度文库 评分:5/5 41页 2018年8月8日 - 二、GraphQL 在微服务_架构中的使用 类型系统 _GraphQL 的强大表达能力主要还是来自于它完备的类型系统,与 REST 不同,它将整个 Web 服务中的全部资源看… 基于RESTful API 的 GraphQL _服务_构建实践_慕课手记 2019年9月2日 - 前不久看了工业聚的文章《GraphQL-BFF:微服务_背景下的前后端数据交互方案》[2],非常非常精彩,又重新拾起了对 _GraphQL 的兴趣。本身在工作的项目中,已… GraphQL 在_微服务_架构中的实践这篇文章… 来自分布式实验室 - 微博 2018年7月19日 - 在最后作者将给出心中合理的 GraphQL 微服务_架构的设计,希望能为同样在_微服务_架构中使用 _GraphQL 的工程师提供一定的帮助,至于给出的建议是否能够满足… python-如何为_微服务_创建_Graphql_服务器?——CSDN问答频道 2018年11月6日 - 通常,他们建议在GraphQL_中也使用_微服务,并在_GraphQL_网关中执行模式检测。我认为这不是理想的选择,因为使用模式缝合时,存在进行最佳_GraphQL_模式设计的… _GraphQL_在_微服务_查询中实现聚合器与搜索索引的作用 -Netflix Tech… 2019年11月7日 - 展示了Netflix如何利用_GraphQL_和Kafka和Elasticsearch来建立索引,通过总的查询聚合器以跨多个松耦合_服务_搜索数据。如何使用_GraphQL_中定义的关系和架构… …一个开源后端开发框架来开发和部署生产就绪的_GraphQL微服务_器… 2019年8月7日 - Graphcool⚡️一个开源后端开发框架来开发和部署生产就绪的_GraphQL微服务_器。使用Gr更多下载资源、学习资料请访问CSDN下载频道. GraphQL-BFF:_微服务_背景下的前后端数据交互方案 - 码农头条 2019年8月11日 - GraphQL-BFF:微服务_背景下的前后端数据交互方案 “我们对 _GraphQL 的期望,不仅仅停留在 BFF 层。我们希望通过积累在 BFF 层使用 GraphQL 的成功经验,… 从gRPC_微服务_和其他Protobuf源生成统一的GraphQL schema - Java… GraphQL Queryfinal class TodoQuerySchemaModule extends SchemaModule { @Query(“listTodo”) ListenableFuture listTodo(ListTodoRequest request,… GraphQL 在_微服务_架构中的实践_360linker-CSDN博客 2019年3月18日 - 作者:dravenesshttps://draveness.me/_graphql_-microserv… 在微服务_架构中的使用以及在实践过程中遇到的棘手问题,在最后作者将给出心中合理的 _GraphQ… _微服务_下使用_GraphQL_构建BFF_z69183787的专栏-CSDN博客__graphql_bff 2018年4月18日 - 在微服务_下基于 _GraphQL 构建 BFF,我们在项目中已经开始了相关的实践。在我们项目对应的业务场景下,微服务_后台有近 10 个_微服务,客户端包括针对不同角… 基于_graphql_的_微服务_基础框架_java_weixin_33794672的博客-CSDN博客 2018年12月25日 - base是一个小而美的业务基础框架,它使用_graphql_作为api通信协议基础。然后提供了一些可以直接使用的后端存储_服务_。 基础特性 只支持_graphql_协议通信;… [译] 使用 Go 编写微服务_及其 _GraphQL 网关 - weixin_3…-CSDN博客 2018年9月9日 - 几个月前,一个优秀的 GraphQL Go 包 vektah/gqlgen 开始流行。本文描述了在 Spidey 项目(一个在线商店的基本微服务)中如何实现 _GraphQL_。 下面列出的… …一个开源后端开发框架来开发和部署生产就绪的_GraphQL微服务_器… Graphcool ⚡️ 一个开源后端开发框架来开发和部署生产就绪的GraphQL微服务_器。使用Graphcool,您可以设计数据模型,并在几分钟内即可在线制作生产就绪的_GraphQL … [译] 怎样使用GraphQL - 4.大局(架构) - 从前端到上天 - Segment… 2017年7月25日 - 如果你想使用GraphQL,你必须自己去搭建GraphQL服务_。你可以选择任何编程语言来实现(例如这些可参考的实现方式)或通过选用像Graphcool这样的_服务,它提… Node.js-_GraphQL微服务GraphQL_Microservice下载-CSDN论坛 2019年12月28日 - 前端每周清单第 26 期:Node.js 微服务_实践,Vue.js 与 _GraphQL,Angular 组件技巧,HeadlessChrome 攻防作者:王下邀月熊 编辑:徐川前端每周清单专注前端… GraphQL 在微服务_架构中的实践 -_微服务 2018年8月29日 - 本文来自于微信,介绍了GraphQL 是什么, GraphQL 在微服务_架构中的使用以及在实践过程中遇到的棘手问题。 _GraphQL 简单对象访问协议(SOAP)从今天来看已… GraphQL 在_微服务_架构中的实践 2018年7月19日 - 这篇文章中,首先会简单介绍 GraphQL 是什么,它能够解决的问题;在这之后,我们会重点分析 GraphQL 在_微服务_架构中的使用以及在实践过程中遇到的棘手问题,在最后作者… GraphQL 在_微服务_架构中的实践_java_不好好做安全的运…_CSDN博客 2018年8月24日 - _GraphQL_类型系统集中式 vs 分散式Relay 标准对象标识符连接与分页可变请求小结N + 1 问题 _微服务_架构Schema 设计前缀粘合组合小结认证与授权认证授权…","link":"/2020/06/14/GraphQL%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8C%96/"},{"title":"GraphQL 最佳资源","text":"GraphQL 的”新”API 查询语言很棒，但一开始可能有点压倒性。我们最近写了一个教程与图形供电的CMS在我们的博客上，我们很好地概述了什么是GraphQL，以及它与REST有何不同。在此过程中，我们还编译了关键资源。它们是： 图形QL官方文件，最简洁和最好的地方之一，了解它。 正式的Facebook草案RFC规范的图形QL，重，但深入。 萨什科·斯图巴伊洛的图形QL查询的剖析，阿波罗开发博客上的杀手级帖子 菲尔·斯图尔特的”GraphQL vs REST：概述”，详细查看使用其中一种或一种时的原因和时间。 真棒-graphql，一个巨大的 GitHub 存储库列出了许多与 GraphQL 相关的库、工具、示例和帖子。 图表QL周刊，关于图形QL和阿波罗所有事情的精心策划的通讯。 • Wes Bos 还在他的几集中讨论了 GraphQL、Graphcool 和阿波罗语法播客. 希望这有帮助！","link":"/2020/06/25/GraphQL%20%E6%9C%80%E4%BD%B3%E8%B5%84%E6%BA%90/"},{"title":"GraphQL 深入理解系列 一","text":"GraphQL 将执行 JSON 对 XML 所做的操作。 GraphQL 解决的 3 个最重要的问题是： 需要执行多次往返以获取视图所需的数据：使用 GraphQL，您始终可以通过单个往返服务器获取视图所需的所有初始数据。要对 REST API 执行相同的操作，我们需要引入难以管理和扩展的非结构化参数和条件。 客户端依赖于服务器：使用 GraphQL，客户端会使用请求语言：1） 无需服务器硬编码数据的形状或大小，2） 将客户端与服务器分离。这意味着我们可以独立于服务器维护和改进客户端。 糟糕的前端开发人员体验：使用 GraphQL，开发人员使用声明性语言表达其用户界面的数据要求。他们表达他们所需要的，而不是如何使它可用。UI 需要的数据与开发人员在 GraphQL 中表达数据描述的方式之间存在紧密关系。 但是，REST API 有什么问题呢？ REST API 的最大问题是多个终结点的性质。 这要求客户端执行多次往返以获取其数据。 REST API 通常是终结点的集合，其中每个终结点表示资源。因此，当客户端需要来自多个资源的数据时，它需要执行多个到 REST API 的往返，以组合所需的数据。 在 REST API 中，没有客户端请求语言。客户端无法控制服务器将返回的数据。没有语言可以做到这一点。更准确地说，客户端可用的语言非常有限。 例如，读取 REST API 终结点可以是： GET - 从该资源获取所有记录的列表，或/ResouceName GET - 获取该 ID 标识的单个记录。/ResourceName/ResourceID 例如，客户端无法指定要为该资源中的记录选择哪些字段。该信息位于 REST API 服务本身中，REST API 服务将始终返回所有字段，而不管客户端实际需要哪个字段。GraphQL 针对此问题的术语是过度提取不需要的信息。这是客户端和服务器网络和内存资源的浪费。 REST API 的另一个大问题是版本控制。如果需要支持多个版本，这通常意味着新的终结点。这在使用这些终结点时会导致更多问题，并且可能是服务器上代码重复的原因。 上面提到的 REST API 问题是特定于 GraphQL 试图解决的问题。它们当然不是 REST API 的所有问题，我不想进入 REST API 是什么，不是。我主要谈论流行的基于资源的 HTTP 端点 API。这些 API 中的每一个最终都变成了具有常规 REST 终结点的混合 - 出于性能原因制作的自定义临时终结点。这是 GraphQL 提供了更好的替代方案。 GraphQL 如何施展其魔力？ GraphQL 背后有很多概念和设计决策，但最重要的可能是： GraphQL 架构是强类型架构。要创建 GraphQL 架构，我们定义具有类型的字段。这些类型可以是基元类型或自定义类型，并且架构中的其他所有类型都需要一个类型。这种丰富的类型系统允许丰富的功能，如具有内省 API 和可为客户端和服务器构建功能强大的工具。 GraphQL 将数据作为图形表示，数据自然是图形。如果需要表示任何数据，正确的结构是图形。GraphQL 运行时允许我们使用与该数据的自然图形形状相匹配的图形 API 来表示数据。 GraphQL 具有用于表示数据需求的声明性。GraphQL 为客户端提供了声明性语言，供他们表达其数据需求。这种声明性性质围绕使用 GraphQL 语言创建了一个心理模型，该语言与我们在英语中思考数据需求的方式非常接近，并且与替代方法相比，使用 GraphQL API 容易得多。 最后一个概念是为什么我个人认为GraphQL是一个游戏规则的改变者。 这些都是高层次的概念。让我们来了解一些细节。 为了解决多个往返问题，GraphQL 使响应服务器只是单个终结点。基本上，GraphQL 将自定义终结点的想法提升到极致，只是使整个服务器成为单个自定义终结点，可以回复所有数据问题。 与这个单一终结点概念相一起的另一个大概念是使用该自定义单终结点所需的丰富客户端请求语言。如果没有客户端请求语言，单个终结点是无用的。它需要一种语言来处理自定义请求，并响应该自定义请求的数据。 具有客户端请求语言意味着客户端将处于控制之下。 他们可以询问他们到底需要什么，服务器会回复他们到底要什么。这解决了过度提取的问题。 当涉及到版本控制时，GraphQL 对此有一个有趣的介绍。可以一起避免版本控制。基本上，我们可以只添加新字段而不删除旧字段，因为我们有一个图形，并且可以通过添加更多节点灵活地增长图形。因此，我们可以在图形上保留旧 API 的路径，并引入新的路径，而无需将它们标记为新版本。API 刚刚增长。 这对移动客户端尤其重要，因为我们无法控制他们使用的 API 版本。安装后，移动应用可能会继续使用同一旧版本的 API 多年。在 Web 上，很容易控制 API 的版本，因为我们只是推送新代码。对于移动应用来说，这要困难得多。 还没有完全相信？在 GraphQL 和 REST 之间使用实际示例进行一对一比较怎么样？ RESTful API 与图形QL API = 示例 让我们想象一下，我们是负责构建一个闪亮的新用户界面来代表星球大战电影和人物的开发人员。 我们负责构建的第一个 UI 很简单：显示有关单个星球大战人员信息的视图。例如，达斯·维德，以及这个人出演的所有电影。此视图应显示该人的姓名、出生年份、行星名称以及他们出现的所有影片的标题。 As simple as that sounds, we’re actually dealing with 3 different resources here: Person, Planet, and Film. The relationship between these resources is simple and anyone can guess the shape of the data here. A person object belongs to one planet object and it will have one or more films objects. The JSON data for this UI could be something like: { “data”: { “person”: { “name”: “Darth Vader”, “birthYear”: “41.9BBY”, “planet”: { “name”: “Tatooine” }, “films”: [ { “title”: “A New Hope” }, { “title”: “The Empire Strikes Back” }, { “title”: “Return of the Jedi” }, { “title”: “Revenge of the Sith” } ] } } } 假设数据服务为我们提供了数据的这种精确结构，下面是一种用 React.js 表示其视图的一种可能方法： // The Container Component: // The PersonProfile Component: Name: {person.name} Birth Year: {person.birthYear} Planet: {person.planet.name} Films: {person.films.map(film =&gt; film.title)} 这是一个简单的例子，虽然我们与星球大战的经验可能帮助我们在这里一点点，UI和数据之间的关系是非常明确的。UI 使用了我们想象中的 JSON 数据对象中的所有”键”。 现在，让我们看看如何使用 RESTful API 请求此数据。 我们需要一个人的信息，假设我们知道此人的 ID，则 RESTful API 应公开该信息： GET - /people/{id} 此请求将向我们提供姓名、出生年份和其他有关此人的信息。一个好的RESTful API也将给我们这个人的星球的ID和一系列ID的所有电影，这个人出现在。 此请求的 JSON 响应可能类似于： { “name”: “Darth Vader”, “birthYear”: “41.9BBY”, “planetId”: 1 “filmIds”: [1, 2, 3, 6], * other information we do not need * } 然后，要阅读行星的名称，我们问： GET - /planets/1 要阅读电影标题，我们要求： GET - /films/1 GET - /films/2 GET - /films/3 GET - /films/6 一旦我们从服务器收到所有 6 个响应，我们可以将它们组合起来，以满足视图所需的数据。 除了我们必须进行 6 次往返以满足简单 UI 的简单数据需求之外，我们这里的方法也是必不可少的。我们提供了有关如何获取数据以及如何处理数据以使其为视图做好准备的说明。 如果你想明白我的意思，你可以自己试试这个。星球大战数据有一个RESTful API当前托管在http://swapi.co/.继续尝试在那里构造我们的数据人员对象。密钥可能略有不同，但 API 终结点将相同。您需要执行 6 次 API 调用。此外，您必须获取视图不需要的信息。 当然，这只是此数据的 RESTful API 的一个实现。可能有更好的实现，这将使此视图更容易实现。例如，如果 API 服务器实现了嵌套资源并理解人与胶片之间的关系，我们可以读取影片数据： GET - /people/{id}/films 但是，纯 RESTful API 服务器很可能无法实现这一点，我们需要要求后端工程师为我们创建此自定义终结点。这就是扩展 RESTful API 的现实 - 我们只是添加自定义终结点，以有效满足不断增长的客户需求。管理这样的自定义终结点是很困难的。 现在，让我们来看看 GraphQL 方法。服务器上的 GraphQL 包含自定义终结点的想法，并将其带到极致。服务器将只是单个终结点，通道无关紧要。如果我们通过 HTTP 执行此操作，HTTP 方法肯定也无关紧要。假设我们有一个 GraphQL 终结点在 HTTP 上公开。/graphql 由于我们希望在一次往返中请求所需的数据，我们需要一种方法来表达我们对服务器的完整数据需求。我们使用 GraphQL 查询执行此操作： GET or POST - /graphql?query={…} GraphQL 查询只是一个字符串，但它必须包含我们需要的所有数据部分。这就是声明性力量的用处。 在英语中，我们是如何声明我们的数据要求：我们需要一个人的名字，出生年份，行星的名字，以及他们所有电影的标题。在 GraphQL 中，这转换为： { person(ID: …) { name, birthYear, planet { name }, films { title } } } 再阅读一次英语表达的要求，并将其与 GraphQL 查询进行比较。它尽可能接近。现在，将此 GraphQL 查询与我们开始的原始 JSON 数据进行比较。GraphQL 查询是 JSON 数据的确切结构，但不包括所有”值”部分。如果我们从问答关系的角度来考虑这个问题，问题就是没有答案部分的答案陈述。 如果答案语句是： 离太阳最近的行星是水星。 问题的良好表现是同一陈述，没有答案部分： （什么是距离太阳最近的行星？ 相同的关系适用于 GraphQL 查询。采取 JSON 响应，删除所有”答案”部分（即值），您最终得到一个GraphQL查询，非常适合表示有关该 JSON 响应的问题。 现在，将 GraphQL 查询与我们为数据定义的声明性 React UI 进行比较。GraphQL 查询中的所有内容都用于 UI，UI 中使用的所有内容都显示在 GraphQL 查询中。 这是GraphQL的伟大心理模型。UI 知道它需要的确切数据，并提取该要求相当容易。提出 GraphQL 查询只是直接从 UI 中提取用作变量的内容。 如果我们反转这个模型，它仍然会保持力量。如果我们有 GraphQLquery，我们确切知道如何在 UI 中使用其响应，因为查询将与响应”结构”相同。我们不需要检查响应来了解如何使用它，也不需要任何关于 API 的文档。都是内置的 星球大战数据有一个图形QL API托管在https://github.com/graphql/swapi-graphql.继续尝试在那里构造我们的数据人员对象。稍后我们将解释一些小差异，但以下是您可以针对此 API 读取视图数据要求的官方查询（以达斯·维德为例）： { person(personID: 4) { name, birthYear, homeworld { name }, filmConnection { films { title } } } } 此请求为我们提供了非常接近视图使用的响应结构，请记住，我们在一次往返中获取所有这些数据。","link":"/2020/06/25/GraphQL%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%B3%BB%E5%88%97%20%E4%B8%80/"},{"title":"Graphql实战：GraphQL 基础知识  四","text":"GraphQL是Facebook最初于2012年开发的一种相对较新的查询语言。GraphQL 的主要目标是减少 API 查询返回的不必要的数据量。 GraphQL 允许开发人员在单个查询中检索关联的对象。另一方面，REST API 将需要对相同数据进行多个查询。 编写 GraphQL 查询需要比 REST 查询更多的学习曲线，但一旦学习，GraphQL 就很容易理解。 我已决定将原计划为一篇文章的一篇文章分成两篇文章，因为我认为在较小的区块中处理所有内容会更容易。 GraphQL 基础知识在使用 GraphQL 开始编写代码之前，了解一下它在后台的工作方式至关重要。 GraphQL（如 REST）可以在任何编程语言中实现，并且已经有许多语言的库来帮助启动新用户。本系列的第 2部分，我们安装了 GraphQL 的 ruby 实现 GraphQL的主要特点之一是它的类型系统。对于没有 CS 学位的我们这些类型，本质上是类型名称表示的数据类型的描述。 例如：公共类型是整数类型。整数类型只允许其实例包含正整数或负整数。另一种常见类型是字符串类型。字符串允许字符串实例中包含的任何字符序列。有关哪些数据类型及其使用方式的更多详细信息，请查看维基百科关于数据类型的文章。 GraphQL 有两种基本类型：用于生成查询的对象类型和表示具体数据的标量类型。随着我们的进展，这两种不同类型的用途应该变得更加清晰。 标量类型GraphQL 有五种内置标量类型。稍后开始构建对象类型时，我们将使用这五种类型。五个内置类型是：、、和 。 12345String Int Float Boolean ID 1String s 表示任何类型的字符串数据，s 表示正数和负整数，s 表示任何正数或负实数，包括小数点，s 表示真值或假值，s 表示基础数据库系统中对象的 ID。 1234Int Float Boolean ID 对象类型对象类型主要是开发人员定义的，由五个标量类型的任意组合以及其他对象类型组成。 对象类型是我们将关注的重点，因为我们在接近尾声时构建的对象类型将允许我们使用 GraphQL 查询后端。从本质上讲，我们将简单地将第 2 部分中定义的模型转换为 GraphQL 类型。 GraphQL查询查询是 GraphQL 的粘合剂，它将前端绑定到后端。查看基本的 GraphQL 查询： query { users { id name username } } 以下是查询部分的细目： 假设我们想要获得该用户创建的所有主题的标题，我们只需添加以下内容： query { users { id name username topics { title } } } 此查询的结果将包括每个用户创建的主题的所有标题。编写 GraphQL 查询时，请记住，所有查询的对象都必须在某些时候解析为标量类型。 构建我们的 GraphQL 架构GraphQL gem 提供了一堆有用的生成器，可帮助我们快速构建对象类型。 在项目的根目录中运行以下命令： rails g graphql:object User username:String name:String email:String id:ID comments:[Reply] likes:[Like] topics:[Topic] 参数是新 GraphQL 类型的名称。其他每个参数都遵循格式。因此，意味着添加一个名为用户名的字段，该字段具有字符串类型。这些字段映射到模型中具有相同名称的属性。字段（如告诉 graphql）有三件事： 1234User &lt;field_name&gt;:&lt;field_type&gt; username:String comments:[Reply] 制作名为 的字段。 1comments 使新字段成为列表。类型周围的括号告诉 GraphQL 使用数组。 对于列表的类型，请使用 该类型。 1Reply 我们尚未制作类型，因此请继续运行以下命令以完成构建基类型： 1Reply rails g graphql:object Topic title:String content:String id:ID user:User likes:[Like] replies:[Reply] rails g graphql:object Like user:User post:Post id:ID rails g graphql:object Reply content:String id:ID user:User post:Post 为了支持我们在第 2 部分中设置的多态关联，我们需要创建联合类型 Post。联合类型是一种可以表示几种不同类型之一的类型。运行以下命令： rails g graphql:union Post Reply Topic 联合类型生成器似乎有一个错误，因此可能需要更改一点： 1post_type # app/graphql/types/post_type.rb module Types class PostType < Types::BaseUnion # Instead of the following line of code you may see: # possible_types [Types::ReplyType, Types::TopicType] # If you do, this is a bug. Remove the brackets to fix it. possible_types Types::ReplyType, Types::TopicType end end 现在，我们已经生成了所有基类型，我们需要使它们可查询。打开 ，删除默认值并添加以下代码： 12query_type.rb test_field app/graphql/types/query_type.rbmodule Types class QueryType &lt; Types::BaseObject # Add root-level fields here. # They will be entry points for queries on your schema. field :users, [Types::UserType], null: false, description: 'Returns all the users' def users User.all end field :topics, [Types::TopicType], null: false, description: 'Returns all the topics' def topics Topic.all end field :topic, Types::TopicType, null: true do argument :id, ID, required: true end def topic(id:) Topic.find_by(id: id) end field :user, Types::UserType, null: true do argument :id, ID, required: true end def user(id:) User.find_by(id: id) end endend 此处的快捷方式与生成的快捷方式非常相似。第一个参数（例如）是字段的名称，第二个参数是字段的类型，第三个参数确定返回值是否可以为空，最后一个参数是字段的描述。行声明该字段需要一个参数，我们将在本系列稍后将更详细地介绍该参数。 1field :users argument 正在运行测试查询如果您想测试我们新的 GraphQL 端，可以使用GraphiQL 或 Postman 来测试。 GraphQL 是一个非常强大的库，可以大大减少 API 开发时间。与 REST API，GraphQL 需要多一些工作来理解，但我发现这种奖励非常值得付出努力。感谢您的阅读！ 与往常一样，代码在GitHub 存储库中可用","link":"/2020/07/09/Graphql%E5%AE%9E%E6%88%98%EF%BC%9AGraphQL%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%20%20%E5%9B%9B/"},{"title":"Graphql实战：基本模型和多态关联 二","text":"模型任何论坛的基本单位都是主题。每个主题都围绕一个特定问题。其他用户可以写问题的答案，并评论其他用户的答复。 马上，很明显，我们将有至少三个基本模型：， 和 。用户可以有多个主题，每个主题可以有许多答复。对于此示例，对主题的每个答复本身可以具有许多答复。 1User 1Topic 1Reply 让我们增加一点复杂性：喜欢。用户可以喜欢他们认为特别有用或有趣的主题或评论。 就目前情况，我们现在有四种模式，用户、主题、回复和赞。 是一个基础对象，它有许多主题和许多答复，我们将调用注释，以明确。主题可以有很多答复和许多赞。他们还必须有一个标题和内容。回复有内容，可以有很多赞，属于用户和主题或回复。 1User 生成rails应用先决条件在生成新的rails应用之前，我们需要确保安装了 PostgreSQL。在 Mac 或 Linux 上， 您可以安装它与自制这样的： brew install postgresql 在 Mac 上，您可以使用以下命令启动后灰色： brew services start postgresql 不幸的是，Homebrew 不支持 linux 上的自制服务，因此您将无法使用上述命令在 linux 上启动 PostgreSQL。相反，您必须创建系统服务。有关我实现PostgreSQL 系统服务，请参阅此链接。 构建后端导航到新应用将目录并运行以下命令的目录： rails new miniforum --api -d postgresql --skip-bundle 这将创建一个新的精简下轨应用程序使用 PostgreSQL 作为其数据库引擎。暂时跳过，因为我们将立即更新 Gemfile，无论如何都需要运行捆绑安装。 1bundle install 命令完成后，导航到新的应用目录，打开 Gemfile 并添加以下行： # Uncomment the line with BCryptgem 'bcrypt'gem 'jwt'gem 'dotenv-rails'gem 'graphql' 现在，我们已经指定了额外的依赖项，请继续并运行 。一旦捆绑程序完成依赖项的安装，我们将需要将 GraphQL Gem 安装到我们的应用程序中。运行以下命令以做到这一点： 123bundle install rails g graphql:install 我们尚未使用 GraphQL，但现在安装它将意味着我们稍后将准备好使用它进行开发。 我们将从生成模型开始： 1User rails g model User email username name password_digest 默认情况下，我们将所有这些属性都作为字符串保存，因为 BCrypt 要求将密码摘要存储为字符串。BCrypt 要求调用数据库中的密码字段才能使用宏。 1password_digest 1has_secure_password 接下来，我们将生成模型： 1Topic rails g model Topic title content:text user:belongs_to 在主题中，我们希望内容是文本类型，因为文本类型旨在保存比普通字符串更长的数据。 接下来，生成模型： 1Reply rails g model Reply content:text user:references post:references{polymorphic} 由于答复可以属于主题，也可以属于另一个答复，因此我们希望确保我们建立了多态关系。从本质上讲，多态关联允许同一关联引用多种不同的模型。在我们的案例中，由于有两个模型的回复可以属于 （ 或 ），我们需要一个多态关联来表示此行为。我强烈推荐这篇文章有关多态性关联的详细信息。 1Topic 1Reply 在构建多态关联时，字段的名称应是一个抽象，表示将关联的所有不同类型的模型。在我们的案例中，我们调用表示主题/回复关联字段的字段为”帖子”，因为主题和回复都是各种帖子。 最后，使用以下命令生成模型： 1Like rails g model Like user:references post:references{polymorphic} 同样，与模型一样，like 可以属于主题或答复，因此我们设置了与上面设置的相同种类的多态关联。 1Reply 现在，我们已经生成了所有模型，我们需要创建数据库并迁移模型： rake db:createrake db:migrate 我使用而不是仅仅因为使用削减了一点点代码，rails必须运行，以找出要完成什么任务。Rake 直接到达任务，因此应该运行得更快一点。 1rake db:migrate 1rails db:migrate 1rake 添加关联和验证为了建立好我们的协会，我们还有一些工作要做。 用户模型向模型添加以下代码： 123User # app/models/user.rbclass User < ApplicationRecord has_secure_password has_many :topics has_many :comments, class_name: \"Reply\" has_many :likes validates :email, :name, :username, :password, presence: true validates :username, :email, uniqueness: true validates :username, format: {with: /\\w/, message: &quot;only alphanumeric characters allowed&quot;} validates :email, format: {with: /[\\w\\.\\+]+@\\w+(?:\\.\\w+)+/, message: &quot;must be a valid email address&quot;} end 请注意，在第二行中，这是对用户在其他帖子上的评论的引用。参数告诉活动记录，查找注释属性的类实际上是类 123has_many :comments 123class_name: “Reply” 123Reply 验证可确保每个用户都有电子邮件、姓名、用户名和密码。用户名和电子邮件必须是唯一的。第三个验证行使用正则表达式来验证用户名是否为字母数字。最后，最后一行使用正则表达式来验证电子邮件地址大致遵循 的格式。 1hello@world.com 如果您需要正则表达式的帮助，请查看此正则表达式测试器以及此有关JavaScript 正则表达式的优秀文章（这些正则表达式大多延续到 Ruby 正则表达式）。 主题模型接下来向模型添加以下代码： 123Topic # app/models/topic.rbclass Topic < ApplicationRecord belongs_to :user has_many :replies, as: :post has_many :likes, as: :post validates :title, :content, :user, presence: true end 请注意 和 。这些行设置主题和回复之间的关联。活动记录知道在答复表中查找主题的 ID 以查找所有关联的对象，但由于关联是多态的，因此活动记录将无法在表中找到正确的字段。 12345has_many :replies, as: :posthas_many :likes, as: :post:topic_id 参数告诉”活动记录”在答复表中查找，但要查找字段而不是字段。以这种方式设置模型意味着我们将能够以正常方式访问主题的回复和赞列表。 12345as: :post:post_id:topic_id 回复模型对于模型，我们需要做类似的事情： 123Reply # app/models/reply.rbclass Reply < ApplicationRecord belongs_to :user belongs_to :post, polymorphic: true has_many :replies, as: :post validates :content, :user, :post, presence: true end 请注意，这里除了多态”答复”字段外，我们还有行。这告诉活动记录数据库中的发布字段应该是多态的。如果没有参数，Active Record 将尝试查找名为”帖子”的表，并引发错误，因为我们没有定义此类表。 123belongs_to :post, polymorphic: true 123polymorphic: true 喜欢模型最后，对于模型，我们需要添加的是： 123Like # app/models/like.rbclass Like < ApplicationRecord belongs_to :user belongs_to :post, polymorphic: true validates :user, :post, presence: true end 同样，我们有参数，但除此之外，这是我们数据库中最简单的模型。 123polymorphic: true 一切都很好去这个职位。我希望你，这是有启发性地获得后端设置的基础知识。多态关联一开始可能难以理解，但它们为数据库关联增加了更多的功能。 该系列这一部分的整个代码可以在这里找到。","link":"/2020/07/09/Graphql%E5%AE%9E%E6%88%98%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%A4%9A%E6%80%81%E5%85%B3%E8%81%94%20%E4%BA%8C/"},{"title":"Graphql实战：自动执行后端测试 三","text":"为什么要自动测试？自动测试最简单和最明显的原因是它使开发人员能够保证他们的代码在某些级别上工作，而不必打开 Web 浏览器并手动执行应用程序。 自动测试有助于确保应用程序的所有部分按预期工作并按设计协同工作，从而确保代码质量的基线级别。手动测试应用程序是无可替代的，但如果您想知道是否正确设置了关联，自动测试可以节省打开导轨控制台和手动设置环境的麻烦。 在大多数情况下，一套自动化测试可以在比人类手动运行更少的时间内完成更多的测试，从而在初始开发阶段节省时间，并能够在代码出现问题之前检测损坏的代码。最后，自动测试通过帮助开发人员在可能的失败点缩小范围来简化调试过程，使开发人员能够发现其代码库的哪些部分功能正常，哪些部分不能正常工作。 编写良好测试的原则尽管测试对于维护高质量代码至关重要，但存在代码测试的事实并不能证明代码是好的。 编写良好测试的第一步是编写可测试的代码。可测试代码是可预测的代码。设计方法和函数，以给定相同输入的方式工作，它们将始终返回相同的输出。 在设计方法或函数时，尝试使用纯函数以实现最大的可预测性。纯函数是给定相同输入时，始终返回相同的输出且无副作用的函数。例如，如果每次 x = 6 的输出为 12，f/x） 是纯函数。另一方面，如果 f（x） 在返回 12 之前向文件写入内容，则它有副作用，而不是纯粹的函数。 纯函数是理想的，但它们并不总是可行的。识别纯函数何时可以使用纯函数，何时可以使用纯函数， 何时可以使用纯函数。 可测试代码最重要的属性是，它通常是可预测的。函数的可预测最基本的方式是，它返回一个已知输出，假设所有输入都是已知的。 编写导轨测试Ruby on Rails 使用称为 Minitest 的框架内置测试集成功能。我决定坚持使用此项目的 Minitest 而不是 RSpec 来减少依赖关系和所需的配置量，尽管使用 RSpec 编写测试是一个类似的过程。 Rails 在生成模型时生成起始文件，因此，如果您遵循上周的文章，则应该已设置项目结构以编写测试。 夹具夹具是使用 Minitest 编写自动化测试的关键部分。夹具允许开发人员访问存储在测试数据库中的模型。 要编写夹具，只需为要添加的模型打开适当的夹具，并使用YAML格式添加新夹具。夹具可以在 中找到。每个固件都有一个名称，后跟在模型架构中声明的属性列表。每个属性都是键值对，键是属性的名称，对的值是属性的值。在 YAML 中，键值对由冒号分隔。 1tests/fixtures/&lt;modelname&gt;.yml 在测试中，固件被赋予一个与模型名称对应的方法。使用夹具库提供的方法访问模型夹具。若要获取特定的夹具，请将夹具的名称作为符号传递，以便获取名为”demo”的用户固件，您需要编写类似 ： 。我们需要各种装置进行测试。 1User users user = users(:demo) 编写测试让我们通过编写测试来开始编写测试，以确认我们的验证和关联设置正确。我不会详细说明我写的所有测试，因为有很多，但如果你有兴趣，你可以在这里找到他们所有。 第一个测试将确保有效对象如预期的那样保存： # test/models/user_test.rbtest \"Saves valid objects\" do user = User.new( username: \"jon\", name: \"Jon doe\", email: \"hello@world.com\", password: \"nobody knows\" ) assert_equal true, user.save end 在顶部，测试线声明一个新的测试，并给它一个识别说明。测试中最重要的行是行。断言相等意味着如果第二个参数不等于第一个参数，测试套件将失败。的第一个参数是断言的预期结果，第二个参数是正在测试的结果。在我们的案例中，我们希望返回 true，因为这意味着已成功保存新的用户对象。如果新用户无效，则返回 false。Minitest 内置了多种断言。他们是什么，他们做什么可以在这里找到。 1assert_equal assert_equal user.save user.save 编写测试以编写测试时，这是一个好主意，在编写通过的测试之前，您知道该测试会失败，从而确保您知道新的测试用例会测试您打算测试的测试。首先编写失败的测试可以查看代码正在运行。测试驱动开发中的常见做法是在实际编写代码之前编写测试。这证明测试工作正常，而且代码在测试通过后也有效。我没有时间深入测试驱动开发，但快速的 Google 搜索会很快为您提供有用的文章，详细说明为什么以及如何进行测试驱动开发。 编写测试后，请运行测试： rake 设置特拉维斯 · 西Travis 是一个持续集成/持续部署服务，与 GitHub 紧密集成。持续集成是将应用程序中的本地更改与主存储库持续组合的过程。在添加新更改时持续运行测试，使开发人员能够捕获代码中的中断，然后再成为严重问题。 设置 Travis 会导致每次提交时运行测试，如果出现任何失败，则提供实时更新。 Travis 有一个免费的开源选项，开发人员可以使用他们的 GitHub 注册。 登录后，单击”我的存储库”选项卡旁边的加号按钮，然后查找论坛应用的存储库。选择它，然后单击激活，使 Travis 跟踪它。但是，为了让 Travis 对存储库执行任何准备，我们需要在根项目目录中设置一个。 1.travis.yml 在我们的案例中，它应该看起来像这样： language: rubyrvm: 2.7 Everything after this point is necessary for Travis to work with Postgresservices: postgresql before_script: psql -c ‘create database travis_ci_test;’ -U postgres 由于我们使用 Postgres 作为数据库引擎，因此我们必须更改文件以告诉 Rails 要使用哪个用户进行测试。 1database.yml 打开测试部分并更改为以下内容： 1config/database.yml # config/database.ymlTest:","link":"/2020/07/09/Graphql%E5%AE%9E%E6%88%98%EF%BC%9A%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%E5%90%8E%E7%AB%AF%E6%B5%8B%E8%AF%95%20%E4%B8%89/"},{"title":"Graphql实战：构建论坛应用，从代码到部署 一","text":"堆栈以下是我计划使用的堆栈的一些详细信息。 后台 PostgreSQL数据库 postgresql GraphQL（以节省前端和后端的时间） 前端 nodejs react（使用创建react应用程序） Redux （也许反应钩代替） Bulma通过rbx （我绝对不是世界上最好的前端开发人员， 我发现 Bulma 易于使用和自定义） 测试和持续集成 后端的迷你测试 前端的玩笑 持续集成 CI持续集成 部署 docker 各种亚马逊网络服务（可能是EC2，但可能是弹性豆茎，AWS放大或法盖特，如果EC2证明太难使用）。 开发环境我将使用 Ubuntu 20.04 作为我的开发环境，但是一切都应该在 Mac 上工作得很好。不幸的是，Ruby 在 Rails 和 Docker 上似乎只有部分 Windows 支持，因此 Windows 用户将不得不使用用于 Linux 的 Windows 子系统的 Ubuntu 发行版。 我将使用可视化工作室代码作为我的编辑器。 路线图以下是我希望在此系列中介绍的简要概述： 后端a. 域建模和生成模型 b. 编写模型测试， 并集成持续集成 Ci c. Graphql 介绍， 编写类型和突变我们的模型 前端a. 线框和组件层次结构b. 编写测试和构建基本组件 c. 添加Graphql 查询 d. 将所有内容捆绑在一起 部署a. 为前端和后端 b.配置亚马逊服务创建 Docker 容器","link":"/2020/07/09/Graphql%E5%AE%9E%E6%88%98%EF%BC%9A%E6%9E%84%E5%BB%BA%E8%AE%BA%E5%9D%9B%E5%BA%94%E7%94%A8%EF%BC%8C%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E9%83%A8%E7%BD%B2%20%E4%B8%80/"},{"title":"HTML编码规范2","text":"HTML语法 缩进使用4个空格； 嵌套的节点应该缩进； 属性名全小写，用下划线做分隔符； 在属性上，使用双引号，不要使用单引号； 自闭合标签，无需闭合 ( 例如： img input 等 )； 可选的闭合标签，需闭合 ( 例如：li 或 body 等 )； 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Page title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;images/logo.png&quot; alt=&quot;Company&quot;&gt; &lt;h1 class=&quot;hello-world&quot;&gt;Hello, world!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; HTML5 doctype为每个 HTML 页面的第一行添加标准模式（standard mode）的声明， 这样能够确保在每个浏览器中拥有一致的表现。 1234&lt;!DOCTYPE html&gt;&lt;html&gt; ...&lt;/html&gt; 字符编码 以无 BOM 的 utf-8 编码作为文件格式; 指定字符编码的 meta 必须是 head 的第一个直接子元素； 1234567 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/head&gt; ...&lt;/html&gt; IE 兼容模式 优先使用最新版本的IE 和 Chrome 内核； 1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; 属性顺序HTML 属性应该按照特定的顺序出现以保证易读性； id class name data-* src,for,type,href title,alt required, readonly, disabled 布尔（boolean）型属性HTML5 规范中 disabled、checked、selected 等属性不用设置值； 1234567&lt;input type=&quot;text&quot; disabled&gt;&lt;input type=&quot;checkbox&quot; value=&quot;1&quot; checked&gt;&lt;select&gt; &lt;option value=&quot;1&quot; selected&gt;1&lt;/option&gt;&lt;/select&gt; 标签嵌套a 不允许嵌套 div这种约束属于语义嵌套约束，与之区别的约束还有严格嵌套约束，比如a 不允许嵌套 a； 语义嵌套约束 &lt;li&gt; 用于 &lt;ul&gt; 或 &lt;ol&gt; 下； &lt;dd&gt;, &lt;dt&gt; 用于 &lt;dl&gt; 下； &lt;thead&gt;, &lt;tbody&gt;, &lt;tfoot&gt;, &lt;tr&gt;, &lt;td&gt; 用于 &lt;table&gt; 下； 严格嵌套约束 inline-Level 内联元素，仅可以包含文本或其它 inline-Level 内联元素; &lt;a&gt;里不可以嵌套交互式元素&lt;a&gt;、&lt;button&gt;、&lt;select&gt;等； &lt;p&gt;里不可以嵌套块级元素&lt;div&gt;、&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;ul&gt;/&lt;ol&gt;/&lt;li&gt;、&lt;dl&gt;/&lt;dt&gt;/&lt;dd&gt;、&lt;form&gt;等； 更多详情请参考 WEB标准系列-HTML元素嵌套 引入 CSS 和 JavaScript 文件 link 必须声明 rel=”stylesheet”； CSS 没有特殊要求的情况下写在 head 标签内部； &nbsp;JS &nbsp;&nbsp;没有特殊要求的情况下写在 body 内部末尾； 引入 CSS 和 JS 时不需要指明 type，因为 text/css 和 text/javascript 分别是他们的默认值； 123456789101112131415&lt;!-- External CSS --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;code_guide.css&quot;&gt;&lt;!-- In-document CSS --&gt;&lt;style&gt; ...&lt;/style&gt;&lt;!-- External JS --&gt;&lt;script src=&quot;code_guide.js&quot;&gt;&lt;/script&gt;&lt;!-- In-document JS --&gt;&lt;script&gt; ...&lt;/script&gt; 图片【强制】禁止 img 的 src 取值为空；延迟加载的图片也要增加默认的 src；src 取值为空，会导致部分浏览器重新加载一次当前页面； 【建议】添加 width 和 height 属性，以避免页面抖动； 【建议】为重要图片添加 alt 属性；可以提高图片加载失败时的用户体验； 【建议】有下载需求或者预期会灵活变动的图片采用 img 标签实现，无下载需求的图片采用 CSS 背景图实现；用户头像、用户产生的图片等有潜在下载需求的图片，以 img 形式实现，能方便用户下载；无下载需求的图片，比如：icon、背景、代码使用的图片等，尽可能采用 css 背景图实现。 表单有文本标题的控件必须使用 label 标签将其与其标题相关联； 将控件置于 label 内； label 的 for 属性指向控件的 id； 推荐使用第一种，减少不必要的 id。如果 DOM 结构不允许直接嵌套，则应使用第二种；123&lt;label&gt;&lt;input name=&quot;confirm&quot; type=&quot;checkbox&quot; value=&quot;on&quot;&gt; 我已确认上述条款&lt;/label&gt;&lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt; &lt;input id=&quot;username&quot; name=&quot;username&quot; type=&quot;checkbox&quot;&gt; 在针对移动设备开发的页面时，根据内容类型指定输入框的 type 属性；根据内容类型指定输入框类型，能获得能友好的输入体验；1&lt;input type=&quot;number&quot; value=&quot;1&quot;&gt;","link":"/2019/11/22/HTML%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%832/"},{"title":"HTML编码规范3","text":"1 前言 2 代码风格 2.1 文件 2.2 结构 2.2.1 缩进 2.2.2 空格 2.2.3 换行 2.3 命名 2.4 注释 3 语言特性 3.1 DOCTYPE 3.2 元素 3.3 属性 4 常见元素 4.1 html 4.2 head 4.3 title 4.4 meta 4.5 link 4.6 script 4.7 img 4.8 table 5 其他 5.1 代码有效性 1 前言无 2 代码风格2.1 文件[建议] 用不带 BOM 头的 UTF-8 编码用没有字节顺序标记的UTF-8编码格式进行编写。 在HTML模板和文件中指定编码 &lt;meta charset=&quot;utf-8&quot;&gt; . 不需要制定样式表的编码，它默认为UTF-8. 2.2 结构2.2.1 缩进[强制] 每次缩进 4 个空格，不允许使用 2 个空格过 tab 字符[强制] 每个块元素、列表元素或表格元素都独占一行，每个子元素都相对于父元素进行缩进将块元素、列表元素或表格元素都放在新行。 另外，需要缩进块元素、列表元素或表格元素的子元素。 （如果出现了列表项左右空文本节点问题，可以试着将所有的 li 元素都放在一行。 ) 123456789101112131415161718192021222324&lt;blockquote&gt; &lt;p&gt;&lt;em&gt;Space&lt;/em&gt;, the final frontier.&lt;/p&gt;&lt;/blockquote&gt;&lt;ul&gt; &lt;li&gt;一&lt;/li&gt; &lt;li&gt;二&lt;/li&gt; &lt;li&gt;三&lt;/li&gt;&lt;/ul&gt;&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;16&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; [强制] html、head、body 以及 head 和 body 的直接子元素不缩进2.2.2 空格[强制] 元素属性中的 = 左右不能出现空格1234567&lt;!-- good --&gt;&lt;p class=&quot;foo&quot;&gt;...&lt;/p&gt;&lt;!-- bad --&gt;&lt;p class =&quot;foo&quot;&gt;...&lt;/p&gt;&lt;p class= &quot;foo&quot;&gt;...&lt;/p&gt;&lt;p class = &quot;foo&quot;&gt;...&lt;/p&gt; 2.2.3 换行[建议] 每行代码不超过 120 个字符考虑到 html 的特殊性，不作强制要求。 2.3 注释[建议] 在模块的开始和结束位置添加模块开始/结束注释这样做是很有必要的，可以使代码结构更加清晰，便于维护，尤其是模块代码很多行的时候。 开始注释：&lt;!-- 模块名 --&gt;。 结束注释：&lt;!-- /模块名 --&gt;。 模块代码比较少的时候允许只有开始注释！ 12345678910111213&lt;!-- 头部 --&gt;&lt;div class=&quot;header&quot;&gt; &lt;!-- logo --&gt; &lt;h1 class=&quot;logo&quot;&gt;&lt;a href=&quot;#&quot;&gt;logo&lt;/a&gt;&lt;/h1&gt; &lt;!-- /logo --&gt; &lt;!-- 导航 --&gt; &lt;ul class=&quot;menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;nav1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;nav2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- /导航 --&gt;&lt;/div&gt;&lt;!-- /头部 --&gt; 3 语言特性3.1 DOCTYPE[强制] 使用HTML5标准，且DOCTYPE大写DOCTYPE 不可省略。 1&lt;!DOCTYPE html&gt; 3.2 元素[强制] 元素名必须小写12345&lt;!-- good --&gt;&lt;div&gt;&lt;/div&gt;&lt;!-- bad --&gt;&lt;DIV&gt;&lt;/DIV&gt; [强制] 不要省略可选的结束标签（closing tag）12345&lt;!-- good --&gt;&lt;p&gt;这是一段文本&lt;/p&gt;&lt;!-- bad --&gt;&lt;p&gt;这是一段文本 [强制] 不要在自闭合元素（Void elements）尾部添加斜线常见的自闭合元素： 1&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; 不太常见的无内容元素： 12&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt;&lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt; 示例： 12345&lt;!-- good --&gt;&lt;img src=&quot;xxx.jpg&quot;&gt;&lt;!-- bad --&gt;&lt;img src=&quot;xxx.jpg&quot; /&gt; [强制] 标签必须合理地嵌套 块元素可以包含内联元素或块元素。 内联元素不能包含块元素。 几个特殊的块元素只能包含内联元素，不能包含块元素：h1-h6、p、dt、caption、hr。 其他规则，如 tbody 必须置于 table 中。 [建议] 合理使用语义化标签合理使用，不滥用。 原因：SEO优化。 [建议] 不使用样式有关的元素如center、u 等等。 [建议] 减少不必要的嵌套1234567&lt;!-- good --&gt;&lt;img class=&quot;foo&quot; src=&quot;xxx.jpg&quot;&gt;&lt;!-- bad --&gt;&lt;div class=&quot;foo&quot;&gt; &lt;img src=&quot;xxx.jpg&quot;&gt;&lt;/div&gt; 3.3 属性[强制] 属性必须小写1234567&lt;!-- good --&gt;&lt;img src=&quot;xxx.jpg&quot;&gt;&lt;div onclick=&quot;foo()&quot;&gt;&lt;/div&gt;&lt;!-- bad --&gt;&lt;img SRC=&quot;xxx.jpg&quot;&gt;&lt;div onClick=&quot;foo()&quot;&gt;&lt;/div&gt; [建议] 自定义属性以 data- 开头12345&lt;!-- good --&gt;&lt;img class=&quot;post-image&quot; src=&quot;default.jpg&quot; data-original=&quot;foo.png&quot;&gt;&lt;!-- bad --&gt;&lt;img class=&quot;post-image&quot; src=&quot;default.jpg&quot; original-image=&quot;foo.png&quot;&gt; [强制] 属性值必须用双引号包围不允许使用单引号，不允许不加引号。 123456&lt;!-- good --&gt;&lt;img src=&quot;xxx.jpg&quot;&gt;&lt;!-- bad --&gt;&lt;img src='xxx.jpg'&gt;&lt;img src='xxx.jpg&gt; [建议] 属性值必须小写（除了文本和 CDATA ）12345&lt;!-- good --&gt;&lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;百度一下&lt;/a&gt;&lt;!-- bad --&gt;&lt;a href=&quot;&quot; target=&quot;_BLANK&quot;&gt;百度一下&lt;/a&gt; [建议] 布尔类型的属性不添加属性值1234567891011&lt;!-- good --&gt;&lt;input type=&quot;text&quot; disabled&gt; &lt;input type=&quot;checkbox&quot; checked&gt; &lt;select&gt; &lt;option selected&gt;1&lt;/option&gt;&lt;/select&gt;&lt;!-- bad --&gt;&lt;input type=&quot;text&quot; disabled=&quot;true&quot;&gt; [建议] 属性应当按照以下给出的顺序依次排列 class id, name data-* src, for, type, href title, alt aria-*, role 依据属性的重要程度来书写。必须属性写在非必须属性前面。 class 用于标识组件，相当于一个元素的名称，因此应该排在首位。 id 用于标识具体组件，排在第二位。 4 常见元素4.1 html[建议] 为 html 元素添加 lang 属性为文档设置正确的语言。 这将有助于语音合成工具确定其所应该采用的发音，有助于翻译工具自动翻译等等。 如果是中文，lang 属性值为 zh-CN。 1&lt;html lang=&quot;zh-CN&quot;&gt; 4.2 head[建议] head 元素各子元素按顺序编写 meta title link script style 4.3 title[强制] title 元素必不可少标题不可为空。 4.4 meta[强制] 使用 &lt;meta charset=&quot;&quot;&gt; 来定义页面编码页面必须指定编码。 1&lt;meta charset=&quot;utf-8&quot;&gt; [建议] 启用 IE 兼容模式IE 支持通过特定的 标签来确定绘制当前页面所应该采用的 IE 版本。除非有强烈的特殊需求，否则最好是设置为 edge mode，从而通知 IE 采用其所支持的最新的模式。 1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; 4.5 link[强制] 使用 link 引用外部 css 文件时，必须加 rel=&quot;stylesheet&quot;12345&lt;!-- good --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;foo.css&quot;&gt;&lt;!-- bad --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;foo.css&quot;&gt; [强制] 使用 link 引用外部 css 文件时，不允许加 type=&quot;text/css&quot;HTML5 默认 type 为 text/css，所以没必要指定。即便是老浏览器也是支持的。 12345&lt;!-- good --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;foo.css&quot;&gt;&lt;!-- bad --&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;foo.css&quot;&gt; [建议] 使用 link 引用外部 css 文件时，rel=&quot;stylesheet&quot; 写在 href 属性前面仅仅是为了对齐，看起来美观而已。 1234567&lt;!-- good --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;foo.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;long-path/foo.css&quot;&gt;&lt;!-- bad --&gt;&lt;link href=&quot;foo.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;long-path/foo.css&quot; rel=&quot;stylesheet&quot; &gt; 4.6 script[强制] 使用script元素引用外部 javascript 文件时，不允许加 type=&quot;text/javascript&quot;HTML5默认 script 元素的 type 为 text/javascript 类型，所以没必要指定。即便是老浏览器也是支持的。 12345&lt;!-- good --&gt;&lt;script src=&quot;foo.js&quot;&gt;&lt;/script&gt;&lt;!-- bad --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;foo.js&quot;&gt;&lt;/script&gt; 4.7 img4.8 table[强制] 除非必要，否则不要使用 table 元素来布局除了显示表格数据外，尽可能避免使用表格来布局。 [强制] table 元素必须包含 thead 和 tbody 元素如果不需要标题，thead 可以不写。 语义化元素header“网页”或“section”的页眉。也就是说header的直接父元素不是body就是section。通常显示网站标题，副标题，logo等信息。 footer“网页”或“section”的页脚。也就是说header的直接父元素不是body就是section。显示版权等信息。 nav导航栏，网站的导航 5 其他5.1 代码有效性HTML代码有效性[建议] 尽量使用有效的HTML代码比如元素的闭合、必要的元素等等。 编写有效的HTML代码，否则很难达到性能上的提升。 用类似 W3C HTML validator 这样的工具来进行测试。 HTML代码有效性是重要的质量衡量标准，并可确保HTML代码可以正确使用。 兼容性大胆地使用 html5 语义标签，兼容性问题用 html5shiv 解决 TODO[建议] 用 TODO 标记代办事项和正活动的条目说明：只用 TODO 来强调代办事项， 不要用其他的常见格式，例如 @@ 。 附加联系人（用户名或电子邮件列表），用括号括起来，例如 TODO(contact) 。 可在冒号之后附加活动条目说明等，例如 TODO: 活动条目说明 。 1234567{# TODO(cha.jn): 重新置中 #}&lt;center&gt;Test&lt;/center&gt;&lt;!-- TODO: 删除可选元素 --&gt;&lt;ul&gt; &lt;li&gt;Apples&lt;/li&gt; &lt;li&gt;Oranges&lt;/li&gt;&lt;/ul&gt; 多媒体后备方案[建议] 为多媒体提供备选内容对于多媒体，如图像，视频，通过 canvas 读取的动画元素，确保提供备选方案。 对于图像使用有意义的备选文案（ alt ） 对于视频和音频使用有效的副本和文案说明。 提供备选内容是很重要的，原因：给盲人用户以一些提示性的文字，用 @alt 告诉他这图像是关于什么的，给可能没理解视频或音频的内容的用户以提示。 （图像的 alt 属性会产生冗余，如果使用图像只是为了不能立即用CSS而装饰的 ，就不需要用备选文案了，可以写 alt=”” 。） 关注点分离[建议] 尽可能保持结构（html）、表现（css）和行为（Javascript）分离。确保文档和模板只包含HTML结构， 把所有表现都放到样式表里，把所有行为都放到脚本里。 此外，尽量使脚本和样式表在文档与模板中有最小接触面积，即减少外链。 具体见后面几条规范。 [建议] 尽量避免写在 HTML 标签中写 style 属性[建议] 尽量避免 JavaScript 生成标签通过 JavaScript 生成的标签让内容变得不易查找、编辑，并且降低性能。 [建议] 避免内联到 HTML 的 Javascript 代码1234567&lt;!-- good --&gt;&lt;a id=&quot;myId&quot; href=&quot;javascript:;&quot;&gt;foo&lt;/a&gt;$(&quot;#myId&quot;).on(&quot;click&quot;, handler);&lt;!-- bad --&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;handler();&quot;&gt;foo&lt;/a&gt; 协议[建议] 嵌入式资源书写省略协议头省略图像、媒体文件、样式表和脚本等URL协议头部声明 ( http: , https: )。如果不是这两个声明的URL则不省略。 省略协议声明，使URL成相对地址，防止内容混淆问题和导致小文件重复下载。 12345678910111213&lt;!-- 不推荐 --&gt;&lt;script src=&quot;http://www.google.com/js/gweb/analytics/autotrack.js&quot;&gt;&lt;/script&gt;&lt;!-- 推荐 --&gt;&lt;script src=&quot;//www.google.com/js/gweb/analytics/autotrack.js&quot;&gt;&lt;/script&gt;/* 不推荐 */.example { background: url(http://www.google.com/images/example);}/* 推荐 */.example { background: url(//www.google.com/images/example);} 实体引用不要用实体引用。不需要使用类似 &mdash; 、 &rdquo; 和 ☺ 等的实体引用, 假定团队之间所用的文件和编辑器是同一编码（UTF-8）。 在HTML文档中具有特殊含义的字符（例如 &lt; 和 &amp; )为例外， 噢对了，还有 “不可见” 字符 （例如no-break空格）。 欧元货币符号是 &amp;ldquo;&amp;eur;&amp;rdquo;。 欧元货币符号是 “€”。","link":"/2019/11/22/HTML%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%833/"},{"title":"HTTP 请求方法指南","text":"在这篇文章中，我们将讨论不同类型的可用 HTTP 方法及其用法。 HTTP 方法是指示要对给定资源执行所需操作的请求集。这些请求方法也称为 HTTP 谓词。最常用的 HTTP 方法是 POST、GET、PUT 和 DELETE。这些对应于创建、读取、更新和删除（或 CRUD）操作（在进行 REST API 调用时）。让我们来探讨所有可用的请求方法。 HTTP 请求方法 1. GETGET 请求用于从使用 URL 访问的服务器检索数据。GET 请求仅准备好类型请求，并且不会在服务器上执行任何类型的读取/更新操作。 它可以缓存，也可以在浏览器历史记录中排序。不应使用 GET 方法传递敏感数据。 2. POSTPOST 请求方法用于将数据发送到服务器以创建新资源。POST 方法以纯文本格式发送数据，并且数据在 URL 中不可见。请注意，如果没有 SSL，POST 请求与 GET 请求一样安全，因为它也会通过网络以未加密方式发送）。 POST 方法是非幂等的，意味着相同的 POST 请求多次可以创建相同的资源多次。 3. PUTPUT 方法用于将数据发送到服务器以完全更新已存在的资源。PUT 请求也可以用于创建像 POST 这样的资源，但两者的区别在于 PUT 是幂等的，即多次调用同一 PUT 请求将始终产生相同的结果，而 POST 重复请求将多次创建相同的资源。 4. DELETE由于名称符号化，DELETE 方法用于删除资源。删除请求是幂等的，如果我们删除资源，它被删除，并重复调用 DELETE 该资源最终相同：资源被删除。 5. TRACETRACE 方法通过回显接收的请求向客户端提供调试机制，以便客户端可以看到中间服务器所做的（如果有）添加或更改。 6. OPTIONS选项方法描述目标资源的通信选项。它允许客户端找出 HTTP 方法以及 Web 服务器支持的其他选项。 7. CONNECTCONNECT 方法创建与请求的资源的双向通信。它通常可用于打开 TCP/IP 隧道，以便通过未加密的 HTTP 代理促进 SSL 加密通信 （HTTPS）。 8. PATCHPATCH 方法用于部分更新资源。HTTP PUT 和 PATCH 方法之间的区别在于 PUT 方法只允许完全替换资源。此外，修补程序方法不是幂等的，即多个相同的修补程序请求可能具有不同的效果。 各种 HTTP 方法及其特征表","link":"/2020/04/12/HTTP-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E6%8C%87%E5%8D%97/"},{"title":"Istio 是什么","text":"istio 是什么 Istio 提供一种简单的方式来为已部署的服务建立网络，该网络具有负载均衡、服务间认证、监控等功能，而不需要对服务的代码做任何改动。 istio 适用于容器或虚拟机环境（特别是 k8s），兼容异构架构。 istio 使用 sidecar（边车模式）代理服务的网络，不需要对业务代码本身做任何的改动。 HTTP、gRPC、WebSocket 和 TCP 流量的自动负载均衡。 istio 通过丰富的路由规则、重试、故障转移和故障注入，可以对流量行为进行细粒度控制；支持访问控制、速率限制和配额。 istio 对出入集群入口和出口中所有流量的自动度量指标、日志记录和跟踪。 _istio_官网 Connect, secure, control, and observe services…. Istio Connect, secure, control, and observe services. Connect Intelligently control the flow of traffic a… Istio / 文档 2020年3月17日 - 了解如何部署、使用和运维 Istio_。… 了解如何部署、使用和运维 _Istio_。 概念 一些概念,理解它们有助于您更好地了解 _Istio 系统的不同部分及其使用的… istio 简介 - 简书 2018年12月18日 - 最近接触到了 istio,感觉十分强大,写篇短文推荐给大家。本文所涉及的具体实验步骤可以参考官网教程。 istio 相关文章列表: istio 简介 istio 性能测试 i… _Istio_是啥?一文带你彻底了解!_代理_搜狐 2018年10月19日 - 如果你比较关注新兴技术的话,那么很可能在不同的地方听说过 Istio,并且知道它和 Service Mesh 有着牵扯。 这篇文章可以作为了解 Istio 的入门介绍,了解什么是 Is… _istio_的原理和功能介绍 - Jo_ZSM - 博客园 2019年5月21日 - 而Istio_则为我们把这件事执行的更彻底。让我们看看_Istio_到底能干啥?_Istio lets you connect, secure, control, and observe services.官方给出的_Istio_的总结,很… 在生产中使用Istio,我们学到了什么? - 简书 2019年6月10日 - 首先,给大家简单介绍一下Istio,_Istio_是一个Service Mesh的开源框架,来自Google,大部分使用Go语言来开发,是Service Mesh的集大成者。 I… Istio - 知乎 2019年2月15日 - 本文转载自:宋净超的博客 这不是一篇教程,本文试图带您梳理清楚 Kubernetes、Envoy(xDS 协议)以及 Istio Service Mesh 之间的关系及内在联系。本文介… _Istio_简介_如果你是一个县长,吃着火锅唱着歌,突然就被…_CSDN博客 2018年4月2日 - _Istio_简介1、简介1.1、ServiceMesh上网了解一下:Servicemesh和sidec… 旁白:事先准备一个Ansible的脚本确实很方便,在部署_Istio_的过程中出现过很多问… Istio,下一个Kubernetes? - 老孙的博客 - CSDN博客 2018年11月19日 - 近年来,开源项目被业界予以厚望,为业界众多技术大咖所推崇,其中一个项目就是由谷歌和IBM联合打造的_Istio_。_Istio_的出现使得服务网格——ServiceMesh这一概念开始流行… istio_云计算解决方案 istio平台是在容器调度平台 Kubernetes 上构建的企业级分布式多租户容器管理平台具有多集群管理多存储类型支持等特性，在网络，存储方面提供多种便捷可靠方案 istio KubeSphere – 企业容器平台 KubeSphere 是基于 Kubernetes 构建的多租户，企业级容器管理平台，具有强大且完善的网络与存储能力，提供完善的 CI / CD ，微服务，多集群管理，应用管理等功能 Istio 中文社区 文档Istio 官方英文文档 Istio 官方中文文档纸质书籍 #TODO 电子书 _Istio_深度解析与项目实践该电子书深度解析服务网格开源项目_Istio_的基本原理,实现机制,以及如何在… istio · Service Mesh|服务网格中文社区 作者马若飞 | 2900字 | 阅读大约需要6分钟 | 归档于istio 2020年3月3日 本文基于_istio_最新的架构调整设计文档,分析了_istio_未来的设计目标。 继续阅读 ist… _Istio__Kubernetes中文社区 5天前 - 在_Istio_中,使用网关定义在网格边缘运行的负载均衡器,用于接收传入或传出的HTTP / TCP请求,网关配置适用于在网格边缘运行的独立Envoy代理。 与其他控制进入系统流量的… 使用_Istio_治理微服务入门 - 割肉机 - 博客园 2018年8月8日 - 三、_Istio_安装 _Istio_目前支持最好的就是Kubernetes了,因此我们的实验环境就定在Kubernetes上。至于版本,_Istio_当前最新版本为0.4.0,这个版本据说要Kub… _Istio_首页、文档和下载 - 大型微服务系统管理工具 - OSCHINA 2017年5月26日 - Istio 是一个由谷歌、IBM 与 Lyft 共同开发的开源项目,旨在提供一种统一化的微服务连接、安全保障、管理与监控方式。Istio 项目能够为微服务架构提供流量管理机制… 《_Istio_官方文档》什么是_Istio_——综述 | 并发编程网 – ifeve.com 2018年1月5日 - 本文介绍Istio:开源的连接,管理和安全的微服务。_Istio_提供了一种简单方式,让发布的服务创建连接并实现负载均衡,服务间的认证,监控,还有更多,而在… _Istio__最佳实践_容器服务Kubernetes版-阿里云 在Kubernetes上基于_Istio_实现Service Mesh智能路由 基于_Istio_实现Kubernetes与ECS上的应用服务混合编排 基于_Istio_实现TCP入口流量路由的统一管理 基于_Istio_实现服务的… _Istio_是什么?_百度知道 2018年11月22日 - 回答：_Istio_是由Google、IBM和Lyft开源的微服务管理、保护和监控框架。_Istio_为希腊语,意思是”起航“使用_istio_可以很简单的创建具有负载均衡、服务间… istio_资源的页面 - _Istio | IBM 2020年1月27日 - Learn about Istio as a tool for managing microservices at scale and get started with useful resources from IBM Cloud. 码云极速下载/istio istio/api. This repository defines component-level APIs and common configuration formats for the Istio platform. istio/proxy. The Istio proxy contains ext… 简单解释_Istio_是什么 2018年10月12日 - Envoy是_Istio_控制的主要部分,Envoy核心功能可以被认为是一个第7层路由表。或者,可以认为是没有DNS的DNS,类似DNS,但是不是真正DNS。 假如你在主机上运… Istio / Istio 是什么? 2020年3月17日 - 介绍Istio,它要解决的问题,高层面的架构和设计目标。… Istio 允许您连接、保护、控制和观察服务。 从较高的层面来说,Istio 有助于降低这些部署的复… _istio__Kubernetes中文社区 5天前 - _Istio_被称作Kubernetes的最佳云原生拍档。从今天起,我们推出“_Istio_技术实践”系列专题,在本专题中,我们将通过技术文章+视频授课的方式,为大家详细阐… _istio_架构及各个组件介绍 - itanony - 博客园 2019年12月3日 - Istio 服务网格从逻辑上分为数据平面和控制平面。 数据平面由一组智能代理(Envoy)组成,被部署为 sidecar。这些代理通过一个通用的策略和遥测中心(Mixe… 带你玩转Istio-第3篇—_Istio_架构概述篇_坚持的道路注…_CSDN博客 2019年9月26日 - _Istio_架构概述前面的内容分别讲解了_Istio_是什么,以及_Istio_能做什么。本章将在此基础上进行 _Istio_简介_网络_z69183787的专栏-CSDN博客 2019年6月3日 - _Istio_简介1、简介1.1、Service Mesh上网了解一下:Service mesh和sid网络… 旁白:事先准备一个Ansible的脚本确实很方便,在部署_Istio_的过程中出现过很多问题,很多时… Istio – IBM Developer – IBM Developer Connect, manage, and secure microservices with this open-source platform…. Istio is an open-source service mesh platform that connects microservices and … _istio_入门教程 - 个人文章 - SegmentFault 思否 2019年8月7日 - [root@_istio_host ~]# wget https://storage.googleapis.com/kubernetes-helm/helm-v2.9.1-linux-amd64.tar.gz [root@_istio_host ~]# tar zxvf helm-v2… istio – 运维派 2019年4月5日 - Google、IBM和Lyft开源其大型微服务系统管理工具Istio 谷歌、IBM 与 Lyft 三方已经共同公布了 Istio 项目的首次公开发行版。Istio 是一个开源项目,旨… _Istio_官方文档中文版 2018年7月17日 - https://istio.io/docs/concepts/what-is-istio/goals.html为什么要使用Istio?在从单体应用程序向分布式微服务架构的转型过程中,开发人员和运维人员面…","link":"/2020/04/09/Istio-%E6%98%AF%E4%BB%80%E4%B9%88-1/"},{"title":"JVM入门到入魔：01JVM基础必备知识","text":"java -&gt; class","link":"/2020/03/28/JVM%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%AD%94%EF%BC%9A01JVM%E5%9F%BA%E7%A1%80%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"title":"JVM入门到入魔：00课程大纲","text":"","link":"/2020/03/27/JVM%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%AD%94%EF%BC%9A%E8%AF%BE%E7%A8%8B%E5%A4%A7%E7%BA%B2/"},{"title":"JVM自动推荐文章列表","text":"技术月刊第 40 期 | 知识铺 2019年11月19日 - 上手简单、文档完备、无代码侵入式的可以对正在运行的 jvm 进程进行监控,简单易用的命令行工具。线上出 bug 了,有了 arthas 先喝口咖啡压压惊,问题分… _JVM_入门到入魔:01_JVM_基础必备知识 | 技术分享 | 知识铺 原始链接:https://blog.zshipu.com/tlg/2020/03/28/_JVM_入门到入魔:01_JVM_基础必备知识/ 版权声明: “署名-非商用-相同方式共享 4.0” 转载请保留原文链接及作者… 14.深入Java系列Java堆内存 | 技术分享 | 知识铺 5天前 - 2018年7月6日 - 堆内存 Java 中的堆是 JVM 所管理的最大的一块内存空间,主要用于存放各种类的实例对象。 在Java 中,堆被划分成两个不同的区域:新生代 … _JVM_入门到入魔:00课程大纲 | 知识铺 原始链接:https://blog.zshipu.com/tlg/2020/03/27/_JVM_入门到入魔:课程大纲/ 版权声明: “署名-非商用-相同方式共享 4.0” 转载请保留原文链接及作者。 … 团队管理:打造高绩效团队 | 知识铺 系列之JVM 2020/03/31 将您的Spring Booot应用迁移到最新的Spring Security 和 OAuth 2.0 2020/03/31 Neo4j系列:CentOS下Neo4j安装教程 2020/03/31 _JVM_入门到…","link":"/2020/04/10/JVM%E8%87%AA%E5%8A%A8%E6%8E%A8%E8%8D%90%E6%96%87%E7%AB%A0%E5%88%97%E8%A1%A8-1/"},{"title":"Java 字符串拼接一次学到位","text":"01、“+”号操作符要说姿势，“+”号操作符必须是字符串拼接最常用的一种了，没有之一。 String chenmo = \"沉默\";String wanger = \"王二\"; System.out.println(chenmo + wanger);复制代码 我们把这段代码使用 JAD 反编译一下。 String chenmo = \"\\u6C89\\u9ED8\"; // 沉默String wanger = \"\\u738B\\u4E8C\"; // 王二System.out.println((new StringBuilder(String.valueOf(chenmo))).append(wanger).toString());复制代码 我去，原来编译的时候把“+”号操作符替换成了 StringBuilder 的 append 方法。也就是说，“+”号操作符在拼接字符串的时候只是一种形式主义，让开发者使用起来比较简便，代码看起来比较简洁，读起来比较顺畅。算是 Java 的一种语法糖吧。 02、StringBuilder除去“+”号操作符，StringBuilder 的 append 方法就是第二个常用的字符串拼接姿势了。 先来看一下 StringBuilder 类的 append 方法的源码： public StringBuilder append(String str) { super.append(str); return this;}复制代码 这 3 行代码没啥可看的，可看的是父类 AbstractStringBuilder 的 append 方法： public AbstractStringBuilder append(String str) { if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this;}复制代码 1）判断拼接的字符串是不是 null，如果是，当做字符串“null”来处理。appendNull 方法的源码如下： private AbstractStringBuilder appendNull() { int c = count; ensureCapacityInternal(c + 4); final char[] value = this.value; value[c++] = 'n'; value[c++] = 'u'; value[c++] = 'l'; value[c++] = 'l'; count = c; return this;}复制代码 2）拼接后的字符数组长度是否超过当前值，如果超过，进行扩容并复制。ensureCapacityInternal 方法的源码如下： private void ensureCapacityInternal(int minimumCapacity) { // overflow-conscious code if (minimumCapacity - value.length > 0) { value = Arrays.copyOf(value, newCapacity(minimumCapacity)); }}复制代码 3）将拼接的字符串 str 复制到目标数组 value 中。 str.getChars(0, len, value, count)复制代码 03、StringBuffer先有 StringBuffer 后有 StringBuilder，两者就像是孪生双胞胎，该有的都有，只不过大哥 StringBuffer 因为多呼吸两口新鲜空气，所以是线程安全的。 public synchronized StringBuffer append(String str) { toStringCache = null; super.append(str); return this;}复制代码 StringBuffer 类的 append 方法比 StringBuilder 多了一个关键字 synchronized，可暂时忽略 toStringCache = null。 synchronized 是 Java 中的一个非常容易脸熟的关键字，是一种同步锁。它修饰的方法被称为同步方法，是线程安全的。 04、String 类的 concat 方法单就姿势上来看，String 类的 concat 方法就好像 StringBuilder 类的 append。 String chenmo = \"沉默\";String wanger = \"王二\"; System.out.println(chenmo.concat(wanger));复制代码 文章写到这的时候，我突然产生了一个奇妙的想法。假如有这样两行代码： chenmo += wangerchenmo = chenmo.concat(wanger)复制代码 它们之间究竟有多大的差别呢？ 之前我们已经了解到，chenmo += wanger 实际上相当于 (new StringBuilder(String.valueOf(chenmo))).append(wanger).toString()。 要探究“+”号操作符和 concat 之间的差别，实际上要看 append 方法和 concat 方法之间的差别。 append 方法的源码之前分析过了。我们就来看一下 concat 方法的源码吧。 public String concat(String str) { int otherLen = str.length(); if (otherLen == 0) { return this; } int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true);}复制代码 1）如果拼接的字符串的长度为 0，那么返回拼接前的字符串。 if (otherLen == 0) { return this;}复制代码 2）将原字符串的字符数组 value 复制到变量 buf 数组中。 char buf[] = Arrays.copyOf(value, len + otherLen);复制代码 3）把拼接的字符串 str 复制到字符数组 buf 中，并返回新的字符串对象。 str.getChars(buf, len);return new String(buf, true);复制代码 通过源码分析我们大致可以得出以下结论： 1）如果拼接的字符串是 null，concat 时候就会抛出 NullPointerException，“+”号操作符会当做是“null”字符串来处理。 2）如果拼接的字符串是一个空字符串（””），那么 concat 的效率要更高一点。毕竟不需要 new StringBuilder 对象。 3）如果拼接的字符串非常多，concat 的效率就会下降，因为创建的字符串对象越多，开销就越大。 注意了！！！ 弱弱地问一下啊，还有在用 JSP 的同学吗？EL 表达式中是不允许使用“+”操作符来拼接字符串的，这时候就只能用 concat 了。 ${chenmo.concat('-').concat(wanger)}复制代码 05、String 类的 join 方法JDK 1.8 提供了一种新的字符串拼接姿势：String 类增加了一个静态方法 join。 String chenmo = \"沉默\";String wanger = \"王二\";String cmower = String.join(\"\", chenmo, wanger);System.out.println(cmower);复制代码 第一个参数为字符串连接符，比如说： String message = String.join(\"-\", \"王二\", \"太特么\", \"有趣了\");复制代码 输出结果为：王二-太特么-有趣了 我们来看一下 join 方法的源码： public static String join(CharSequence delimiter, CharSequence... elements) { Objects.requireNonNull(delimiter); Objects.requireNonNull(elements); // Number of elements not likely worth Arrays.stream overhead. StringJoiner joiner = new StringJoiner(delimiter); for (CharSequence cs: elements) { joiner.add(cs); } return joiner.toString();}复制代码 发现了一个新类 StringJoiner，类名看起来很 6，读起来也很顺口。StringJoiner 是 java.util 包中的一个类，用于构造一个由分隔符重新连接的字符序列。限于篇幅，本文就不再做过多介绍了，感兴趣的同学可以去了解一下。 06、StringUtils.join实战项目当中，我们处理字符串的时候，经常会用到这个类——org.apache.commons.lang3.StringUtils，该类的 join 方法是字符串拼接的一种新姿势。 String chenmo = \"沉默\";String wanger = \"王二\"; StringUtils.join(chenmo, wanger);复制代码 该方法更善于拼接数组中的字符串，并且不用担心 NullPointerException。 StringUtils.join(null) = nullStringUtils.join([]) = \"\"StringUtils.join([null]) = \"\"StringUtils.join([\"a\", \"b\", \"c\"]) = \"abc\"StringUtils.join([null, \"\", \"a\"]) = \"a\"复制代码 通过查看源码我们可以发现，其内部使用的仍然是 StringBuilder。 public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) { if (array == null) { return null; } if (separator == null) { separator = EMPTY; } final StringBuilder buf = new StringBuilder(noOfItems * 16); for (int i = startIndex; i &lt; endIndex; i++) { if (i &gt; startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } } return buf.toString(); }复制代码 大家读到这，不约而同会有这样一种感觉：我靠（音要拖长），没想到啊没想到，字符串拼接足足有 6 种姿势啊，晚上回到家一定要一一尝试下。 07、给小菜一个答复我相信，小菜读到我这篇文章的时候，他一定会明白为什么阿里巴巴不建议在 for 循环中使用”+”号操作符进行字符串拼接了。 来看两段代码。 第一段，for 循环中使用”+”号操作符。 String result = \"\";for (int i = 0; i < 100000; i++) { result += \"六六六\";}复制代码 第二段，for 循环中使用 append。 StringBuilder sb = new StringBuilder();for (int i = 0; i < 100000; i++) { sb.append(\"六六六\");}复制代码 这两段代码分别会耗时多长时间呢？在我的 iMac 上测试出的结果是： 1）第一段代码执行完的时间为 6212 毫秒 2）第二段代码执行完的时间为 1 毫秒 差距也太特么大了吧！为什么呢？ 我相信有不少同学已经有了自己的答案：第一段的 for 循环中创建了大量的 StringBuilder 对象，而第二段代码至始至终只有一个 StringBuilder 对象。","link":"/2019/11/14/Java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E4%B8%80%E6%AC%A1%E5%AD%A6%E5%88%B0%E4%BD%8D/"},{"title":"JavaScript编码规范2","text":"JavaScript语法 缩进使用4个空格； 适合使用空格的地方 for循环中的分号之后，比如for (var i = 0; i &lt; 10; i ++ ) {…} 用于分隔数组元素的逗号之后，比如var a = [1, 2, 3]; 对象属性后的逗号以及名值对之间的冒号之后，比如var o = {a: 1, b: 2}; 函数参数中，比如myFunc(a, b, c); 在运算符和操作数之间也添加空格。也就是说在+、-、*、=、&lt;、&gt;、&lt;=、&gt;=、===、!==、&amp;&amp;、||、+= 符号前后都添加空格。 最外层使用单引号''； 12var div = '&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;'; 数组、对象：对象属性名不需要加引号；对象以缩进的形式书写，不要写在一行；数组、对象最后不要有逗号。 123456789101112131415161718// not goodvar a = { 'b': 1};var a = {b: 1};var a = { b: 1, c: 2,};// goodvar a = { b: 1, c: 2}; 命名规范 变量，使用驼峰命名法； 12var loadingModules = {}; 常量，字母大写，使用下划线连接_； 12var LOGIN_URL = '/login.do'; 私有属性、变量或方法，在变量名前加_下划线前缀； 1234567891011 var person = { getName: function () { return this._getFirst() + ' ' + this._getLast(); }, _getFirst: function () { // ... }, _getLast: function () { // ... }}; 全局变量，使用g作为前缀，如gUserName； ID在变量名中全大写； URL在变量名中全大写； Android在变量名中大写第一个字母； iOS在变量名中小写第一个，大写后两个字母； 构造函数首字母大写； boolean 类型的变量使用is或has开头； 123var isReady = false;var hasName = false; 声明变量 每个变量必须声明，并使用单var模式；变量声明必须放在函数顶部，避免声明提前的问题。 12345678910111213/* bad */var a = 1;function func(){ console.log(a); // undefinde var a = 2; // 声明提前了，但是赋值并没有提前}/* good */function func(){ var pageNum = 1, pageSize = 10, options = {};} 函数声明要用表达式，不使用直接声明； 除了构造函数和时间（Date）, 尽量不要用 new 来声明; 使用 {}, [] 替代 new Object(); new Array(); 12345678/* bad */function abs (){};var abc = new function(){};/* good */var abc = function(){}; 注释 单行注释；必须独占一行。// 后跟一个空格，缩进与下一行被注释说明的代码一致。 多行注释；最少三行, ‘*’后跟一个空格； 1234/* * 多行注释 */var x = 1; 建议在以下情况下使用： 难于理解的代码段 可能存在错误的代码段 浏览器特殊的HACK代码 业务逻辑强相关的代码 函数/方法注释1、函数/方法注释必须包含函数说明，有参数和返回值时必须使用注释标识。；2、参数和返回值注释必须包含类型信息和说明；3、当函数是内部函数，外部不可访问时，可以使用 @inner 标识； 123456789101112131415/* * 函数描述 * @param {element} tag 目标容器 * @param {number} sum 总金额 * @param {number} num 商品数量 * @return {Object} 返回值描述 */ function Cart(tag, sum, num) { return { tag: tag, sum: sum, num: num };} 事件注释必须使用 @event 标识事件，事件参数的标识与方法描述的参数标识相同； 123456789101112131415/** * 值变更时触发 * * @event Select#change * @param {Object} e e描述 * @param {string} e.before before描述 * @param {string} e.after after描述 */this.fire( 'change', { before: 'foo', after: 'bar' }); 杂项 拼接字符串，需根据实际情况进行合理的转义；123456789101112 // HTML 转义var str = '&lt;p&gt;' + htmlEncode(content) + '&lt;/p&gt;';// HTML 转义var str = '&lt;input type=&quot;text&quot; value=&quot;' + htmlEncode(value) + '&quot;&gt;';// URL 转义var str = '&lt;a href=&quot;/?key=' + htmlEncode(urlEncode(value)) + '&quot;&gt;link&lt;/a&gt;';// JavaScript字符串 转义 + HTML 转义var str = '&lt;_button onclick=&quot;check(\\'' + htmlEncode(strLiteral(name)) + '\\')&quot;&gt;提交&lt;/button&gt;';","link":"/2019/11/22/JavaScript%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%832/"},{"title":"Java编码规范2","text":"[TOC] 1 前言 2 代码风格 2.1 文件 2.2 结构 2.2.1 缩进 2.2.2 空格 2.2.3 空行 2.2.4 换行 2.3 命名 2.4 注释 3 语言特性 3.1 条件表达式 3.2 自增自减 3.3 位运算符 4 待办事项 5 最佳实践 1 前言Java编程必须遵守通用编程规范和本编程规范。 2 代码风格2.1 文件[建议] 源文件编码格式为UTF-8。2.2 结构2.3 命名2.3.2 特殊转义序列源文件结构一个源文件包含(按顺序地)： 许可证或版权信息(如有需要)package语句import语句一个顶级类(只有一个)以上每个部分之间用一个空行隔开。 3.2 package语句[强制] package语句不换行3.3 import语句[强制] import 语句不要使用通配符123456// goodimport java.util.Date;import java.util.Map;// badimport java.util.*; [强制] import语句不换行每个import语句独立成行。 [建议] import语句按照一定的规则分组import语句分为以下几组，按照这个顺序，每组由一个空行分隔： 所有的静态导入独立成组com.google imports(仅当这个源文件是在com.google包下)第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sunjava importsjavax imports组内不空行，按字典序排列。 3.4 类声明3.4.1 只有一个顶级类声明 每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。 例外：package-info.java，该文件中可没有package-info类。 [建议] 每个类应该以某种逻辑去排序它的成员新的方法不能总是习惯性地添加到类的结尾 推荐按照访问权限的大小分别排列属性和方法： public 数据成员 protected 数据成员 包级别(没有访问修饰符的，默认为friendly) 数据成员 private 数据成员 构造函数 public 方法 protected 方法 private 方法 包级别方法 [强制] 构造函数必须写在所有方法的前面[强制] 重载方法必须写在一起一个类的多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。 4.7 用小括号来限定组：推荐除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。 注解[建议] 一个注解独占一行。位于方法的前面，Javadoc（如果有的话）的后面。123@Override@Nullablepublic String getNameIfPresent() { ... } [建议] 单个注解可以和签名的第一行出现在同一行1@Override public int hashCode() { ... } [建议] 应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：1@Partial @Mock DataLoader loader; 2.3 命名5.1 对所有标识符都通用的规则[强制] 标识符只能使用ASCII字母和数字具体命名参照通用编程规范，这里不再赘述。 严格来说，遵守本规范的Java代码中，标识符只有三种形式：UpperCamelCase、lowerCamelCase 和 CONSTANT_CASE。 除了常量外，所有标识符只由字母和数字组成。 [建议] 不使用特殊前缀或后缀12345678// goodint count;String name;// badint iCount; // 常用 i 来表示整形String sName; // 常用 s 来表示字符串String nName; // 常用 m 来表示 数据成员 TODO 这条建议是否应该改成强制？ 12// good?Button btnClose; // 关闭按钮 包命名规范[强制] 包名全部小写，连续的单词只是简单地连接起来，不使用下划线123456// goodcom.google.util.imagetool// badcom.google.util.imageToolcom.google.util.image_tool [强制] 包名采用反域名命名规则，至少四级一、二级包名通常是域名的反写，因为域名不会重复。 如果有域名则采用域名的反写： 12chenjianhang.com =&gt; com.chenjianhangabc.net =&gt; net.abc 如果没有域名： 一级包名为域名后缀，如com、net、cn、me等。公司的项目通常是com，个人的项目可以选择me，团队的项目可以采用team，其他的也可以。 二级包名是公司、组织、机构、团队或者个人的名称。 三级包名是项目名。 四级包名为模块名或层级名。 123com.baidu.tieba.viewcom.sina.weibo.xxx 2.4 注释Javadoc7.1 格式[强制] Javadoc 格式必须正确只允许下面这两种形式 当整个 Javadoc 块能容纳于一行，且没有 Javadoc 标记 @XXX 时，可以使用单行形式。 1234567/** * 这是一个多行的 Javadoc 注释 * 这是一个多行的 Javadoc 注释 */public void foo() { ... }/** 这是一个单行的 Javadoc 注释 */ 7.1.2 段落 空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签，并且它和第一个单词间没有空格。 7.1.3 Javadoc标记 标准的Javadoc标记按以下顺序出现：@param, @return, @throws, @deprecated, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。 7.2 摘要片段 每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。 这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以A {@code Foo} is a…或This method returns…开头, 它也不会是一个完整的祈使句，如Save the record…。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。 Tip：一个常见的错误是把简单的Javadoc写成/** @return the customer ID */，这是不正确的。它应该写成/** Returns the customer ID. */。 需要 Javadoc 的情况[强制] 除了文档后面讲到的几个例外，每个 public 类及它的每个 public 和 protected 成员处必须使用 Javadoc[建议] getter 和 setter 方法，如果没必要，可以不写 Javadoc注释12345// bad/** 返回学生数量 */public int getStudentCount() { return studentCount;} 当然，如果方法名中有比较偏僻的英文词汇，或者有一些相关信息是需要读者了解的， Javadoc 注释不应该省略 1234/** 返回符合规范的名称 */public String getCanonicalName() {} [建议] 单元测试类中的测试方法很多时候不需要文档说明[建议] 如果一个方法重载了超类中的方法，那么Javadoc并非必需的[建议] 对于包外不可见的类、方法和数据成员，如有需要，也是要使用Javadoc的2 语言特性条件表达式[强制] 如果条件表达式是一个 boolean 类型的变量，禁止与 true 或 false 比较1234567891011121314151617181920boolean isOk = true; // good if (isOk) { } // goodif (!isOk) { }// badif (isOk == true) { }if (isOk == false) { } 自增自减[强制] 如果仅仅是自增或者自减，使用自增/自减表达式：1234567// goodi++;i--;// badi = i + 1;i = i - 1; [强制] 禁止自增表达式和其他运算符混合用123456// badi = i++; // Java 和 C 执行结果是不一样的if (c++ = d++) { ...} [强制] 禁止使用难以理解、容易混淆的表达式123456// gooda = b + c;d = a + r;// badd = (a = b + c) + r; 123if ((a == b) &amp;&amp; (c == d)) // goodif (a == b &amp;&amp; c == d) // 不反对 位运算符[建议] 除非是对性能要求极高，否则不允许使用位运算符来代替除法123456789// goodi /= 4;// badi = i &gt;&gt; 2;``` ### 返回语句 // goodreturn booleanExpression; // badif (booleanExpression) { return true;} else { return false;} 12345### 条件运算符##### [建议] 如果条件运算符 `?` 前面有二元运算符，条件表达式应该用括号扩起来 // goodi = (x &gt;= 0) ? x : -x; // badi = x &gt;=0 ? x : -x; 123##### [建议] 使用条件表达式增强代码的可读性 // goodreturn (condition ? x : y); // badif (condition) { return x;}return y; 1 // godi = (x &gt;= 0) ? x : -x; // badif (x &gt;= 0) { i = x;} else { i = -x;} 12345678910### switch语句##### [强制] switch 语句内的语句组必须正确的终止所有 case 语句和 default 语句必须满足三条规范之一：1. 语句通过break、continue、return 或抛出异常来终止。如示例的 `case 3`。2. 语句通过一条注释来说明程序将继续执行到下一个语句组。如示例的 `case 2`。3. 语句希望继续执行到下一个语句组，并且语句内不需要执行任何代码，此时语句内不允许任何空行。如示例的 `case 1`。 switch (input) { case 1: // 注意case 1 与 case 2 之间不能有空行 case 2: prepareOneOrTwo(); // 不用break case 3: handleOneTwoOrThree(); break; default: handleLargeNumber(input); break;} 123456789##### [强制] switch 语句必须包含 default 语句，并且写在所有 case 语句的后面即使 default 语句什么代码也不包含，你也必须这么做### 数组##### [建议] 数组初始化可写成块状结构 new int[] { 0, 1, 2, 3 }; new int[] { 0, 1, 2, 3}; new int[] { 0, 1, 2, 3}; new int[] { 0, 1, 2, 3}; new int[] {0, 1, 2, 3}; 12345##### [强制] 非C语言风格的数组声明中括号是类型的一部分。 // goodString[] args; // badString args[]; 1234567891011121314151617181920212223242526### 类##### [建议] 类和成员的修饰符应该按顺序出现推荐的顺序：public protected private abstract static final transient volatile synchronized native strictfp#### 枚举类枚举常量间用逗号隔开，换行可选。没有方法和文档的枚举类可写成数组初始化的格式：private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。## 3 待办事项##### [强制] TODO 前后保持一个空格类似的还有 XXX 和 FIXME。 // good// TODO 这是一句必要的说明 // bad//TODO 这是一句必要的说明 123##### [强制] 模块编码完成后，删除系统生成的 TODO // bad// TODO Auto-generated method stub 1234567##### [建议] 合理地使用待办事项标记* TODO：代码还未编写。一般会说明需要添加什么功能。* XXX：功能已实现，有待改进或优化。一般会说明要改进的地方。* FIXME：代码有错误，不能正常工作，需要修改。一般会说明如何修正。 // TODO 这里需要添加XXX功能 // XXX 建议这里使用的排序改成冒泡排序，效率更高 // FIXME 当用户没有输入时，这里有bug，需加个判断 1234567891011121314## 4 编程实践##### [强制] 只要是合法的，就把@Override注解给用上##### [强制] 捕获的异常必须处理常见的处理方式就是打印日志。如果它被认为是不可能的，则把它当作一个AssertionError重新抛出。如果它确实是不需要在catch块中做任何响应，需要做注释加以说明。 try { int i = Integer.parseInt(response); return handleNumericResponse(i);} catch (NumberFormatException ok) { // it’s not numeric; that’s fine, just continue}return handleTextResponse(response); 123例外：在测试中，如果一个捕获的异常被命名为expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。 try { emptyStack.pop(); fail();} catch (NoSuchElementException expected) {} 123##### [强制] 静态成员必须使用类进行调用 class Foo { public static void foo() { }} // goodFoo.foo(); // badnew Foo().foo(); ##### [强制] 禁止重载Object.finalize 如果你觉得非要重载Object.finalize不可，请先仔细阅读和理解《Effective Java》 第7条：“Avoid Finalizers”，然后不要使用它。 ## 编译器相关 ### 警告 ##### [建议] 认真对待代码中的警告，并尽可能处理掉 ##### [强制] 过时的方法和类应当不再使用，用新的方法替换 @Deprecated","link":"/2019/11/22/Java%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%832/"},{"title":"Java编码规范3","text":"API[建议] 多个字符串拼接时用StringBuilder避免频繁地通过 + 进行字符串拼接 **StringBuffer ** 线程线程池 [建议] 如果程序频繁创建线程，则可以考虑使用线程池[建议] 提倡run方法中使用无限循环的形式，然后使用一个布尔型标识控制循环的停止未整理[建议] 禁止随意使用静态变量举个不恰当的例子： 12345678910111213141516171819// goodclass Foo { String name; void sayHello() { System.out.println(&quot;My name is&quot; + name); }}// badclass Foo { static String name; static void sayHello() { System.out.println(&quot;My name is&quot; + name); }} 不可否认的是，很多刚学 java 的新手常常这么做。 [建议] 尽可能避免调用本类的getter、setter方法一是为了简洁、二是为了效率 123456789101112131415161718192021222324252627// goodclass Foo { String name; public String getName() { return name; } void sayHello() { System.out.println(&quot;My name is&quot; + name); }}// badclass Foo { String name; public String getName() { return name; } void sayHello() { System.out.println(&quot;My name is&quot; + getName()); }} [建议] 调用本类的属性和方法时一般不加this为了简洁。 如果和参数冲突，才加 this。 123456789101112131415161718192021222324252627// goodclass Foo { String name; public String getName() { return name; } public void setName(String name) { this.name = name; }}// badclass Foo { String name; public String getName() { return this.name; } public void setName(String name) { this.name = name; }} [建议] 用静态代替虚拟如果不需要访问某对象的字段，将方法设置为静态，调用会加速15%到20%。这也是一种好的做法，因为你可以从方法声明中看出调用该方法不需要更新此对象的状态。 [建议] 常量用 static final 修饰12345// goodstatic final String DATABASE_NAME = &quot;foo&quot;;// badfinal String DATABASE_NAME = &quot;foo&quot;; 常见缩写12345678910111213141516171819202122anim // animationavg // averagebg // backgroundbuf // bufferctrl // controldel // delete doc // documenterr // erroresc // escapeinc // incrementinfo // infomationinit // initialic // iconimg // imagelen // lengthlib // librarymsg // messagepwd // passwordpos // positionsrv // serverstr // stringtmp // temp lambda表达式[建议] 一般的程序没有用到 lambda 表达式的必要lambda 表达式可读性低。","link":"/2019/11/22/Java%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%833/"},{"title":"Java面试宝典300问 第一部分","text":"","link":"/2020/07/09/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8300%E9%97%AE-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"},{"title":"K 表示 Python 中的群集 - 分步指南","text":"K 表示聚类算法通常是学生将学习的第一个无监督机器学习模型。 它允许机器学习从业者在具有相似定量特征的数据集内创建数据点组。它对于解决诸如创建客户细分或识别犯罪率高的城市中的地方等问题非常有用。 在本教程中，您将学习如何在 Python 中构建第一个 K 表示聚类算法。 目录您可以使用下面的目录跳到此 Python K 的特定部分，即聚类算法： 我们将在本教程中使用数据集 我们将在本教程中使用导入 可视化我们的数据集 构建与训练我们的 K 意味着聚类模型 使用我们的 K 表示聚类模型进行预测 可视化模型的准确性 本教程的完整代码 最后的想法 我们将在本教程中使用数据集在本教程中，我们将使用 使用 生成的数据集。scikit-learn 让我们导入函数来创建此人工数据。打开犹太笔记本，用以下语句启动 Python 脚本：scikit-learn``````make_blobs from sklearn.datasets import make_blobs 现在，让我们使用函数创建一些人工数据！make_blobs 更具体地说，下面介绍如何创建具有功能和群集中心的示例的数据集。每个群集中的标准差将设置为 。200``````2``````4``````1.8 raw_data = make_blobs(n_samples = 200, n_features = 2, centers = 4, cluster_std = 1.8) 如果打印此对象，您会注意到它实际上是一个 Python元组。此元组的第一个元素是具有 200 个观测值的NumPy 数组。每个观察包含 2 个要素（就像我们用函数指定的一样！raw_data``````make_blobs 现在，我们的数据已经创建，我们可以继续将其他重要的开源库导入到我们的 Python 脚本中。 我们将在本教程中使用导入本教程将利用许多流行的开源Python库，包括熊猫，NumPy，和matplotlib。让我们通过添加以下导入来继续我们的 Python 脚本： import pandas as pd import numpy as np import seaborn import matplotlib.pyplot as plt %matplotlib inline 此代码块中的第一组导入用于操作大型数据集。第二组导入用于创建数据可视化效果。 接下来，让我们继续可视化数据集。 可视化我们的数据集在我们的函数中，我们为数据集指定了 4 个群集中心。验证正确处理这一点的最佳方法是创建一些快速数据可视化效果。make_blobs 首先，让我们使用以下命令根据数据集第二列中的所有行绘制数据集第一列中的所有行： 注意：您的数据集的显示方式与我的不同，因为这是随机生成的数据。 此图像似乎表明我们的数据集只有三个群集。这是因为两个群集彼此非常接近。 为了解决这个问题，我们需要引用元组的第二个元素，这是一个 NumPy 数组，其中包含每个观测点所属的群集。raw_data 如果我们使用每个观测值的聚类对数据集进行着色，则唯一的群集很快就会变得清晰。下面是执行此操作的代码： plt.scatter(raw_data[0][:,0], raw_data[0][:,1], c=raw_data[1]) 现在我们可以看到，我们的数据集有四个唯一的群集。让我们继续在 Python 中构建我们的 K 表示群集模型！ 构建与训练我们的 K 意味着聚类模型构建 K 意味着聚类算法的第一步是从 导入它。为此，请向 Python 脚本添加以下命令：scikit-learn from sklearn.cluster import KMeans 接下来，让我们创建一个包含 的参数并将其分配给变量的此类实例：KMeans``````n_clusters=4``````model model = KMeans(n_clusters=4) 现在，让我们通过调用模型上的方法并传入元组的第一个元素来训练模型：fit``````raw_data model.fit(raw_data[0]) 在下一节中，我们将探讨如何使用此 K 表示聚类模型进行预测。 在继续之前，我想指出一个区别，即您可能已经注意到构建此 K 意味着聚类算法（这是一种无监督机器学习算法）的过程与本课程中到目前为止使用的受监督机器学习算法之间的差异。 也就是说，我们不必将数据集拆分为训练数据和测试数据。这是一个重要的区别 - 事实上，在构建无监督机器学习模型时，您永远不需要在数据集上进行训练/测试拆分！ 使用我们的 K 表示聚类模型进行预测机器学习从业者通常使用 K 表示聚类算法进行两种类型的预测： 每个数据点所属的群集 每个群集的中心位于 现在，我们的模型已经过训练，因此很容易生成这些预测。 首先，让我们预测每个数据点属于哪个群集。为此，请使用点运算符从对象访问属性，如下所示：labels_``````model model.labels_ 这将生成一个 NumPy 数组，其中预测每个数据点如下所示： array([3, 2, 7, 0, 5, 1, 7, 7, 6, 1, 2, 4, 6, 7, 6, 4, 4, 3, 3, 6, 0, 0, 6, 4, 5, 6, 0, 2, 6, 5, 4, 3, 4, 2, 6, 6, 6, 5, 6, 2, 1, 1, 3, 4, 3, 5, 7, 1, 7, 5, 3, 6, 0, 3, 5, 5, 7, 1, 3, 1, 5, 7, 7, 0, 5, 7, 3, 4, 0, 5, 6, 5, 1, 4, 6, 4, 5, 6, 7, 2, 2, 0, 4, 1, 1, 1, 6, 3, 3, 7, 3, 6, 7, 7, 0, 3, 4, 3, 4, 0, 3, 5, 0, 3, 6, 4, 3, 3, 4, 6, 1, 3, 0, 5, 4, 2, 7, 0, 2, 6, 4, 2, 1, 4, 7, 0, 3, 2, 6, 7, 5, 7, 5, 4, 1, 7, 2, 4, 7, 7, 4, 6, 6, 3, 7, 6, 4, 5, 5, 5, 7, 0, 1, 1, 0, 0, 2, 5, 0, 3, 2, 5, 1, 5, 6, 5, 1, 3, 5, 1, 2, 0, 4, 5, 6, 3, 4, 4, 5, 6, 4, 4, 2, 1, 7, 4, 6, 6, 0, 6, 3, 5, 0, 5, 2, 4, 6, 0, 1, 0], dtype=int32)&lt;/code&gt; 要查看每个群集的中心位置，请使用点运算符访问属性，如下所示：cluster_centers_ model.cluster_centers_ 这将生成包含每个聚类中心的坐标的二维 NumPy 数组。如下所示： array([[ -8.06473328, -0.42044783], [ 0.15944397, -9.4873621 ], [ 1.49194628, 0.21216413], [-10.97238157, -2.49017206], [ 3.54673215, -9.7433692 ], [ -3.41262049, 7.80784834], [ 2.53980034, -2.96376999], [ -0.4195847 , 6.92561289]])&lt;/code&gt; 我们将在下一节中评估这些预测的准确性。 可视化模型的准确性在本教程中，我们要做的最后一件事就是可视化模型的准确性。您可以使用以下代码执行此操作： f, (ax1, ax2) = plt.subplots(1, 2, sharey=True,figsize=(10,6)) ax1.set_title(‘Our Model’) ax1.scatter(raw_data[0][:,0], raw_data[0][:,1],c=model.labels_) ax2.set_title(‘Original Data’) ax2.scatter(raw_data[0][:,0], raw_data[0][:,1],c=raw_data[1]) 这将并排生成两个不同的绘图，其中一个绘图根据实际数据集显示聚类，另一个绘图根据我们的模型显示聚类。以下是输出的外观： 尽管两个绘图之间的着色不同，但您可以看到，我们的模型在预测数据集中的聚类方面做得很好。您还可以看到模型并不完美 - 如果您查看群集边缘的数据点，则可以看到它偶尔会从我们的数据集中错误分类观测值。 关于测量模型的预测，还有最后一件事需要提及。在此示例中，我们知道每个观测值属于哪个群集，因为我们实际上自己生成了此数据集。 这是非常不寻常的。K 表示在事先不知道群集时，更频繁地应用聚类。相反，机器学习从业者使用 K 表示聚类来查找他们在数据集中尚未知道的模式。 本教程的完整代码您可以在此 GitHub 存储库中查看本教程的完整代码。下面还粘贴如下，供参考： #Create artificial data setfrom sklearn.datasets import make_blobs raw_data = make_blobs(n_samples = 200, n_features = 2, centers = 4, cluster_std = 1.8) #Data importsimport pandas as pd import numpy as np #Visualization importsimport seaborn import matplotlib.pyplot as plt %matplotlib inline #Visualize the dataplt.scatter(raw_data[0][:,0], raw_data[0][:,1]) plt.scatter(raw_data[0][:,0], raw_data[0][:,1], c=raw_data[1]) #Build and train the modelfrom sklearn.cluster import KMeans model = KMeans(n_clusters=4) model.fit(raw_data[0]) #See the predictionsmodel.labels_ model.cluster_centers_ #PLot the predictions against the original data setf, (ax1, ax2) = plt.subplots(1, 2, sharey=True,figsize=(10,6)) ax1.set_title(‘Our Model’) ax1.scatter(raw_data[0][:,0], raw_data[0][:,1],c=model.labels_) ax2.set_title(‘Original Data’) ax2.scatter(raw_data[0][:,0], raw_data[0][:,1],c=raw_data[1]) 最后的想法在本教程中，您将在 Python 中构建了第一个 K 表示聚类算法。 以下是您所学知识的简要摘要： 如何使用函数创建人工数据scikit-learn``````make_blobs 如何构建和训练 K 意味着聚类模型 这种无监督机器学习技术不需要将数据拆分为训练数据和测试数据 如何使用聚类模型构建和训练 Kscikit-learn 当您提前了解群集时，如何可视化 K 的性能意味着聚类算法","link":"/2020/06/21/K%20%E8%A1%A8%E7%A4%BA%20Python%20%E4%B8%AD%E7%9A%84%E7%BE%A4%E9%9B%86%20-%20%E5%88%86%E6%AD%A5%E6%8C%87%E5%8D%97/"},{"title":"Linux的du用法排除某个目录","text":"例如我想得到根目录下所有目录或文件的占用空间大小，并且想要排除名字中包含 proc 的文件或目录，可以使用如下命令 或使用 模糊匹配 都行 du -sh /* --exclude=&quot;*proc*&quot;``` * 1 * 2 * 3 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190415101755609.png) * 扩展内容，想要排除多个文件或文件夹，且只想看到空间大于 G 的结果 ```du -sh /* \\ --exclude=&quot;proc&quot; \\ --exclude=&quot;cgroup&quot; \\ --exclude=&quot;selinux&quot; \\ --exclude=&quot;*bin&quot; \\ --exclude=&quot;lib*&quot; \\ --exclude=&quot;etc&quot; \\ --exclude=&quot;sys&quot; \\ --exclude=&quot;boot&quot; \\ --exclude=&quot;data*&quot; | grep G``` * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190415101836497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FieXNsbGw=,size_16,color_FFFFFF,t_70)","link":"/2020/06/17/Linux%E7%9A%84du%E7%94%A8%E6%B3%95%E6%8E%92%E9%99%A4%E6%9F%90%E4%B8%AA%E7%9B%AE%E5%BD%95/"},{"title":"MQTT之Mosquitto源码分析","text":"一、 Mosquitto简介 mosquitto是一款实现了消息推送协议MQTT v3.1 的开源消息代理软件，提供轻量级的，支持可发布/可订阅的的消息推送模式，使设备对设备之间的短消息通信变得简单，例如现在应用广泛的低功耗传感器，手机、嵌入式计算机、微型控制器等移动设备。 Mosquitto采用出版/订阅的模式实现MQTT协议，这种设计模式将通信终端之间的关系统一到服务程序中进行管理，可极大减轻客户端的开发和维护工作。 1.1、 mqtt协议简介 MQTT（MessageQueuing Telemetry Transport，消息队列遥测传输）是IBM开发的一个即时通讯协议，有可能成为物联网的重要组成部分。在某些应用场合中，可通过该协议维持与客户端的长连接。关于mqtt协议更详细的介绍，请参考其官方网站：http://mqtt.org/ 其他版本源码下载位置：http://mosquitto.org/files/source/ 1.2、 出版/订阅模式简介 出版/订阅模式定义了如何向一个节点发布和订阅消息，这些节点被称作主题(topic)。主题可以被认为是消息的传输中介，发布者(publisher)发布消息到主题，订阅者(subscriber) 从主题订阅消息。这种模式使得消息订阅者和消息发布者保持互相独立，不需要接触即可保证消息的传送。 mosquitto github开源代码 mosquitto 官方网站 趁着年轻：《Mosquitto pub/sub服务实现代码浅析-主体框架》 小诺Z《Mosquitto集群搭建》 逍遥子《mosquitto源码分析（一）》简介 逍遥子《mosquitto源码分析（二）》数据结构 逍遥子《mosquitto源码分析（三）》订阅树 逍遥子《mosquitto源码分析（四）》订阅树 逍遥子《mosquitto源码分析（五）》Poll和消息收发 逍遥子《mosquitto源码分析（六）》日志 逍遥子《Mosquito的优化——epoll优化（七）》 逍遥子《Mosquito的优化——订阅树优化（八）》 逍遥子《Mosquito的优化——其他优化（九）》","link":"/2020/04/11/MQTT%E4%B9%8BMosquitto%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"title":"MQTT和WebSocket 对比","text":"MQTT跟WebSocket关系不大。他们不是在一个层级的。 MQTT和TCP、WebSocket的关系可以用下图一目了然： 参考资料： http://www.zhihu.com/question/21816631 WebSocket的优势以前，很多网站使用轮询实现推送技术。轮询是在特定的的时间间隔（比如1秒），由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给浏览器。轮询的缺点很明显，浏览器需要不断的向服务器发出请求，然而HTTP请求的header是非常长的，而实际传输的数据可能很小，这就造成了带宽和服务器资源的浪费。 Comet使用了AJAX改进了轮询，可以实现双向通信。但是Comet依然需要发出请求，而且在Comet中，普遍采用了长链接，这也会大量消耗服务器带宽和资源。 于是，WebSocket协议应运而生。 浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器通过 TCP 连接直接交换数据。WebSocket 连接本质上是一个 TCP 连接。 WebSocket在数据传输的稳定性和数据传输量的大小方面，具有很大的性能优势。Websocket.org 比较了轮询和WebSocket的性能优势： HTTP 轮训每次需要返回871个字节，websocket每次只需要2个字节 Use Case A： 1,000个客户端每秒接受一个message，网络吞吐量 （2*1,000）=2,000 bytes = 16,000 每秒bits Use Case B： 10,000个客户端每秒接受一个message，网络吞吐量 （2*10,000）=20,000 bytes = 160,000 每秒bits Use Case C： 100,000个客户端每秒接受一个message，网络吞吐量 （2*100,000）=200,000 bytes = 1,600,000 每秒bits 参考： http://segmentfault.com/a/1190000000382788 Spring 4.0 中的 WebSocket 架构http://www.oschina.net/translate/websocket-architecture-in-spring-4-0 MQTTMQTT 协议是为大量计算能力有限，且工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性： 非常小的通信开销（最小的消息大小为 2 字节），小型传输，开销很小（固定长度的头部是 2 字节），协议交换最小化，以降低网络流量。 支持各种流行编程语言（包括 C，Java，Ruby，Python 等等）且易于使用的客户端； 使用发布 / 订阅消息模式，提供一对多的消息发布，解除应用程序耦合。 对负载内容屏蔽的消息传输。 使用 TCP/IP 提供网络连接。 有三种消息发布服务质量，让消息能按需到达目的地，适应在不稳定工作的网络传输需求 ： “至多一次”，消息发布完全依赖底层 TCP/IP 网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。 “至少一次”，确保消息到达，但消息重复可能会发生。 “只有一次”，确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果。 使用 Last Will 和 Testament 特性通知有关各方客户端异常中断的机制。 参考： MQTT技术：为物联网而生http://www.leiphone.com/0828-danice-mqtt.html MQTT 折腾笔记—-协议简读http://www.cnblogs.com/youxilua/archive/2013/04/25/3041528.html 基于 WebSocket 的 MQTT 移动推送方案http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1308_xiangr_mqtt/1308_xiangr_mqtt.html","link":"/2020/04/13/MQTT%E5%92%8CWebSocket-%E5%AF%B9%E6%AF%94/"},{"title":"Markdown 编写规范","text":"此为前端开发团队遵循和约定的 Markdown 编写规范，意在提高文档的可读性。 说明文档中使用的关键字「MUST」,「MUST NOT」,「REQUIRED」,「SHALL」,「SHALLNOT」,「SHOULD」,「SHOULD NOT」,「RECOMMENDED」,「MAY」和「OPTIONAL」在 RFC2119 中有说明。 还未定稿，对规范中提及的点有不赞同的欢迎提出 issues（请添加 markdown 标签）讨论。 规则 后缀必须「MUST」使用 .md。 文件名必须「MUST」使用小写，多个单词之间使用-分隔。 文件编码必须「MUST」用 UTF-8。 文档标题应该「SHOULD」这样写。 12Markdown 编写规范========================== 章节标题必须「MUST」以 ## 开始，而不是 #。 章节标题必须「MUST」在 # 后加一个空格，且后面没有 #。 12345678// bad##章节1// bad## 章节1 ##// good## 章节1 章节标题和内容间必须「MUST」有一个空行。 1234567891011// bad## 章节1内容## 章节2// good## 章节1内容## 章节2 代码段的必须「MUST」使用 Fenced code blocks 风格，如下所示： 1console.log(&quot;&quot;); 表格的写法应该「SHOULD」参考 GFM，如下所示： 12345678910First Header | Second Header------------- | -------------Content Cell | Content CellContent Cell | Content Cell| Left-Aligned | Center Aligned | Right Aligned || :------------ |:---------------:| -----:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 中英文混排应该「SHOULD」采用如下规则： 英文和数字使用半角字符 中文文字之间不加空格 中文文字与英文、阿拉伯数字及 @ # $ % ^ &amp; * . ( ) 等符号之间加空格 中文标点之间不加空格 中文标点与前后字符（无论全角或半角）之间不加空格 如果括号内有中文，则使用中文括号 如果括号中的内容全部都是英文，则使用半角英文括号 当半角符号 / 表示「或者」之意时，与前后的字符之间均不加空格 其它具体例子推荐阅读这里 中文符号应该「SHOULD」使用如下写法： 用直角引号（「」）代替双引号（“”），不同输入法的具体设置方法请参考这里 省略号使用「……」，而「。。。」仅用于表示停顿 其它可以参考知乎规范 表达方式，应当「SHOULD」遵循《The Element of Style》： 使段落成为文章的单元：一个段落只表达一个主题 通常在每一段落开始要点题，在段落结尾要扣题 使用主动语态 陈述句中使用肯定说法 删除不必要的词 避免连续使用松散的句子 使用相同的结构表达并列的意思 将相关的词放在一起 在总结中，要用同一种时态（这里指英文中的时态，中文不适用，所以可以不理会） 将强调的词放在句末 扩展阅读 Google 后来也出了 Markdown 规范，很多和这里是一样的，但也增加了一些约定，可以参考","link":"/2019/11/22/Markdown-%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/"},{"title":"MySQL 上构造即时 Graphql API","text":"在本指南中，我将介绍如何在几分钟内使用空间云轻松为 MySQL 设置 GraphQL API 层。 此处要注意的关键字是即时的。这意味着您不必自己编写 GraphQL 后端。听起来像个魔法，对吗？让我在一分钟内给你解释一下。 目录 MySQL 和 GraphQL 简介 什么是空间云？ 如果我不使用 MySQL 怎么办？ 开始使用 GraphQL 和 MySQL 设置 创建 MySQL 架构 在空间云上运行 GraphQL 查询 结论 MySQL 和 GraphQL 简介MySQL是最受欢迎的 SQL 数据库之一，仅次于 Oracle。易于设置和学习 MySQL 使其成为大多数 Web 项目的热门选择。如果您是需要强大的数据库管理工具但预算之内的组织，那么 MySQL 可能是您的理想选择。 另一方面，GraphQL 是 API 的查询语言，逐渐取代 REST。它允许您精确描述数据需求，并为您提供所需的确切数据，解决提取下的旧数据以及过度提取问题。如果你是新到GraphQL，并希望了解更多关于它，看看它的官方网站。 但是，要利用这些出色的优势，您需要通过编写解析器在后端设置 GraphQL API。必须编写 GraphQL 服务器会增加其采用的摩擦。虽然许多工具可帮助您自动生成 Postgres 的 GraphQL API，但使用 MySQL 的图形数量并不多。这就是空间云进入图片的地方，它为您的MySQL提供GraphQL API，而无需编写后端。因此，让我们看看空间云是什么。 什么是空间云？为了简单化， Space Cloud 是一个开源 Web 服务器，可在您选择的数据库上提供即时 GraphQL 和 REST API。 关于空间云最酷的部分是所有的 API 都是实时的。您可以选择_订阅_数据库中的更改。此功能在制作实时应用时非常有用。 由于 Space Cloud 中还内置了一个强大的安全模块，因此可以直接从前端使用这些 API。因此，在大多数用例中，只需使用空间云 API 制作角或 React 应用程序，就应该是您编写的唯一代码！ 为了表示你的支持❤️， ️*你可以给它一个明星在Github。 如果我不使用 MySQL 怎么办？空间云为蒙戈DB、Postgres 和 MySQL（及其兼容数据库）提供开箱即用的 GraphQL API。如果您使用除 MySQL 之外的任何其他数据库，则这些指南可以帮助您入门： 开始使用 Postgres 开始使用蒙戈DB 酷，这足以记录历史和功能。让我们直接潜入它！ 开始使用 GraphQL 和 MySQL在本指南中，我们将在 MySQL 上构建一个简单的博客应用程序，该应用程序具有作者和帖子。 每个作者可以有多个帖子，而一个帖子只能属于一个作者。请注意，这是一对多关系。 注：如果你被困在某个地方，别担心。你总是可以在我们的不和频道上平我一声。 设置我们使用Docker Compose为我们运行空间云和 MySQL。 第 1 步：获取 Docker 组合文件空间技术/空间云/安装清单回购包含在任何地方部署空间云所需的所有安装清单。从那里获取 Docker 组合文件： wget https://raw.githubusercontent.com/spaceuptech/space-cloud/master/install-manifests/quick-start/docker-compose/mysql/docker-compose.yaml 您应该能够看到包含以下内容的文件：docker-compose.yaml version: '3.6'services: mysql: image: mysql restart: always space-cloud: image: spaceuptech/space-cloud ports: “4122:4122” “4126:4126” depends_on: “mysql” restart: always environment:The DEV environment lets you use Mission Control (Admin UI) without loginChange the dev mode to false if you want a login to your Mission Control UI DEV: “true”Uncomment next lines to change the login credentials of Mission Control UIADMIN_USER: “admin”ADMIN_PASS: “123”ADMIN_SECRET: “some-secret” # This is the JWT secret used for login authentication in Mission Control 第 2 步：运行空间云和 MySQL docker-compose up -d 检查容器是否正在运行： docker ps 第 3 步：配置空间云如果执行到空间云的 Docker 容器中，则可以在主目录中看到空间云生成的文件。config.yaml 空间云需要这个配置文件来运行。配置文件用于加载各种信息，例如要使用的数据库、其连接字符串和安全规则。 空间云有自己的任务控制（管理员 UI）来快速配置所有这些。 开放式任务控制： 前往http://localhost:4122/mission-control打开任务控制。 注：如果您不在本地运行空间云的地址，请替换为该地址。localhost 创建项目： 单击按钮可打开以下屏幕：Create a Project 给您的项目。name 按按按钮以创建项目。Create Project 将数据库添加到项目 创建项目后，下一步是向项目添加数据库： 选择作为数据库并复制粘贴以下连接字符串：MySQL root:my-secret-pw@tcp(mysql:3306)/ 按键。如果连接成功，您将获得成功连接的通知。Add database 创建 MySQL 架构空间云为您提供了一个整洁的GraphQL SDL来描述 MySQL 表的架构，如下所示： type author { id: ID! @primary name: String!} 空间云根据架构在 MySQL 中自动创建名为作者的表。因此，无需处理 SQL 语句来创建表。 最好的部分是空间云提供的架构SDL本质上是声明性的。 这意味着空间云总是试图通过只进行所需的更改来完成您提供的架构。例如，假设您向架构添加了一个字段，如下所示： type author { id: ID! @primary name: String! description: String} 注：空间云不会再创建整个表，因为它已经在那里。相反，它只是使用 语句添加列。空间云中的这种能力使我们能够专注于我们的应用程序，而不是数据库。ALTER TABLE 创建作者表前往该部分。Database 单击部分中的按钮以打开以下窗体：Add a table``````Database 将表名称命名为 。author 复制粘贴以下架构并点击保存： type author { id: ID! @primary name: String! posts: [post] @link(table: \"post\", from: \"id\", to: \"author_id\")} 此架构创建具有 ID 和名称字段的表作者。该类型只不过是自动生成的唯一 ID，而指令告诉空间云将字段作为表的主键。在空间云中签出数据建模以了解更多信息。ID``````@primary``````id 注：该字段不是表中的物理字段。它只是一个虚拟字段，链接到表，使 GraphQL 查询和突变从前端更简单。我们将在下面详细介绍它。posts``````author``````post 创建过帐表再次单击部分中的按钮。Add``````Database 将表名称命名为 。post 复制粘贴以下架构并点击保存： type post { id: ID! @primary title: String! author_id: ID @foreign(table: \"author\", field: \"id\")} 请注意该指令。它在作者表上创建一个外键，以保持关系的完整性。了解更多关于空间云建模关系的@foreign 伟大！我们创建了本指南所需的所有表。它使用自动生成的 GraphQL API 与 MySQL 一起玩的时间。 在空间云上运行 GraphQL 查询任务控制具有嵌入式 GraphiQL IDE，它允许我们触发查询，而无需构建前端。 前往该部分。Explorer 让我们从创建一些作者和帖子开始，这翻译为在 MySQL 中插入一些记录。 插入数据将数据插入 MySQL 非常简单，只需为我们触发 GraphQL 查询即可。因此，让我们尝试插入一些作者连同他们的帖子。下面是一个 GraphQL 查询，它帮助我们做到这一点。请尝试在 GraphiQL 编辑器中运行此 GraphQL 查询： mutation { insert_author( docs: [ { id: \"1\", name: \"Dan\", posts: [ { id: \"1\", title: \"Introducing Hooks\" }, { id: \"2\", title: \"React vs Vue\" } ] }, { id: \"2\", name: \"Ryan\", posts: [ { id: \"3\", title: \"Context API\" }, { id: \"4\", title: \"React + Redux\" } ] } ] ) @mysql { status }} 成功插入时，您应该能够看到状态，因为这意味着您已成功将文档插入 MySQL 中。200 参数只不过是要插入表中的记录数组。docs 如果您还记得，我们提到了表中字段的指令以及参数 - 。空间云使用此信息将帖子数组正确插入到表中。它还根据我们提到的外键自动插入该字段。@link``````posts``````author``````table: &quot;post&quot;``````post``````post.author_id 注：即使我们将字段留空，空间云也会自动生成一个唯一的随机字符串作为 id。id 如果您注意到，我们在上述查询中使用了指令。对于 MongoDB 或 Postgres，将其更改为或分别更改为或。就这个！@mysql``````@mongo``````@postgres 使用筛选器查询数据插入作者及其帖子后，让我们尝试查询特定作者的帖子。它只不过是一个筛选操作。 请尝试在 GraphiQL 编辑器中运行以下查询： query { post ( where: {author_id: \"1\"} ) @mysql { id title }} 正如您所看到的，我们只有属于author_id1的帖子。请查看本指南，了解筛选选项的完整列表。 更新数据更新需要两个信息 - 筛选要更新的文档的子句和至少一个更新运算符。where 假设您要更新 MySQL 中特定作者的名称。下面是一个 GraphQL 查询， 执行它： mutation { update_author ( where: { id: \"2\"}, set: {name: \"Ryan Florence\"} ) @mysql { status }} 您还可以执行各种操作，如递增、递减、乘法。请查看本指南，了解更新操作的完整列表。 获取嵌套/关系数据现在出现了有趣的部分，即从 MySQL 获取关系数据，作为前端的嵌套 JSON。 假设我们要显示作者列表以及他们的帖子标题。您可以通过空间云的简单 GraphQL 查询从 MySQL 轻松查询此类关系数据。请尝试运行以下 GraphQL 查询： query { author @mysql { id name posts { title } }} 响应应如下所示： { \"author\": [ { \"id\": \"1\", \"name\": \"Dan\", \"posts\": [ { \"title\": \"Introducing Hooks\" }, { \"title\": \"React vs Vue\" } ] }, { \"id\": \"2\", \"name\": \"Ryan Florence\", \"posts\": [ { \"title\": \"Context API\" }, { \"title\": \"React + Redux\" } ] } ]} 上面使用的查询在 条件 - 的和表之间的后端执行联接操作。此条件由指令的参数 （、 、 ） 派生，我们前面提到过。你可以从这里阅读更多关于指令。author``````post``````author.id == post.author_id``````table``````from``````to``````@link``````@link 结论在 MySQL 顶部设置 GraphQL 层并不难。只需将空间云指向 MySQL 实例，即可在应用程序中使用 GraphQL。 作为一种优势，GraphQL 开辟了大量新的可能性，如执行联接，使已经流行的 MySQL 更易于使用。我们对此非常兴奋，并且将加倍降低我们的 GraphQL 支持更加稳健。 MySQL 的声明性架构使我们能够将更多精力放在应用程序上，而不是数据库上。 然而，未来似乎是惊人的。能够与 MySQL 和其他 NoSQL 数据库进行跨数据库联接，这意味着我们可以构建企业级应用，利用两全其美的优势。 显示你的支持❤️给它一个明星在Github。","link":"/2020/06/12/MySQL%20%E4%B8%8A%E6%9E%84%E9%80%A0%E5%8D%B3%E6%97%B6%20Graphql%20API/"},{"title":"Nacos 集群部署","text":"阅读目录 准备数据库 准备nacos 观察集群 Nacos + Docker 集群 通过Nginx配置真正的集群 其他注意事项 关于nacos 集群部署，网上的示例往往不全或不可用，而官方的教程太简单了。官方也提供了一个 docker + nacos 的伪集群的 部署示例。但毕竟是 伪， 不能实际生产使用。 全网就几乎就没有一个 完整的教程？？？！！！ 怎么办呢？ 自己动手吧。 准备数据库数据库用了 mysql， 其实nacos 也是支持mysql 主从集群的，不过简单起见， 这里就只用了一个 mysql 节点。 mysql 是需要自己事先安装 配置的（需要执行 nacos 提供的 conf/nacos-mysql.sql 脚本） 这个其实很简单。schema 名字不重要，重要的是 执行 nacos 的sql 脚本就好了。 准备nacos一般集群需要至少3个节点。我们先准备3台机器： 192.168.11.200、192.168.11.196、192.168.11.126 nacos 的默认服务端口是 8848 ，但是由于 我们的机器上还有其他nacos 服务正在作用，所以， 我们这里把端口改为 8748， 如下： 192.168.11.200:8748192.168.11.196:8748192.168.11.126:8748 我们需要nacos-server 的安装包， 1.0.0.zip 版本并没有 集群的展示功能， 我们这里使用 nacos-server-1.1.0.zip， 这个也是最新的 nacos server 安装包。 （从github 上下载非常耗时， 最好把这个安装包 共享起来） 安装目录是 /app， 没有的话， 需要自己创建。 将nacos-server-1.1.0.zip 上传到 /app 目录， 然后进入cd /app, 执行下面的 shell （需要3个节点上都要执行！！）： unzip nacos-server-1.1.0.zip -d nacos-cluster &amp;&amp; cd nacos-cluster/nacos &amp;&amp; cp conf/cluster.conf.example conf/cluster.conf &amp;&amp; echo “192.168.11.200:8748192.168.11.196:8748192.168.11.126:8748” &gt; conf/cluster.conf &amp;&amp; sed -i s/server.port=8848/server.port=8748/ conf/application.properties &amp;&amp; echo “ spring.datasource.platform=mysql db.num=1db.url.0=jdbc:mysql://192.168.11.200:3316/test3?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=truedb.user=rootdb.password=123456” &gt;&gt; conf/application.properties &amp;&amp; sh bin/startup.sh 上面的脚本，需要按照情况修改， 主要是其中的 端口、 数据库配置。 上面的脚本 包括了 启动 nacos。 如果 3个节点都能正常访问了，那么就表明集群部署基本正常了，如果有问题， 那么可以查看nacos 的日志， 位于 logs目录， 主要 是下面几个日志文件： /app/nacos-cluster/nacos/start.out/app/nacos-cluster/nacos/nacos.out/app/nacos-cluster/nacos/naming-raft.out 观察集群3个节点都正常启动之后， 可以分别登录 各个web 界面查看 集群的节点、健康状态： http://192.168.11.126:8748/nacos/#/clusterManagement?dataId=&amp;group=&amp;appName=&amp;namespace=&amp;serverId= http://192.168.11.196:8748/nacos/#/clusterManagement?dataId=&amp;group=&amp;appName=&amp;namespace=&amp;serverId= http://192.168.11.200:8748/nacos/#/clusterManagement?dataId=&amp;group=&amp;appName=&amp;namespace=&amp;serverId= 最开始的时候， 所有节点都没有启动， 集群任期 应该都是0 （看到这个图片， 说明 3个节点都正常启动了， 否则请检查是否有步骤遗漏了！） 如果我们只启动一个节点，那么它的状态会是 candidate： 处于candidate 状态的 集群会一直进行选举， 从而任期也会一直增加： 最先启动的节点， 一般就是 leader ， 但这个时候还只是 准leader，需要至少多数节点都启动了， 才能做一个决断。如下面的 126： 在没有leader 产生之前， 集群会进行多次的选举。 每次的选举 任期会加1。 从而 最后会进行大概 2次的选举， 从而 126 的任期是2；最后加入的 节点已经没有了选举的机会， 故直接作为 follower 加入， 其任期默认是0； 如果某一个或某几个节点都挂了， 只要剩余节点不少于 1+ 1/N ，那么 集群仍然能够正常运行； 挂掉的节点重新加入集群后，如果此时集群已经有了leader， 那么它的角色一般是follower， 它的任期是0（ 就跟一个新节点一样的）； 当然，如果集群的剩余节点少于 1+ 1/N，集群仍然是可以工作的，只是已经无法保证 高可用了。 任期低节点一般是没有资格参与选举的，leader 一般是在 任期高的几个节点之中产生（至少会有2个节点）。 如果把126 的nacos 杀掉，我们会观察到 多个leader，其实这个时候的 126 已经死了， 至少集群保留它之前的状态。同时 集群会重新选举，如下，我们看到200 被选举为 leader，126 的状态被保留（其实他已经死掉了）， 同时任期 +1： 在已经存在leader 的集群中，如果挂掉的节点不是 leader，那么不会重新进行选举。 挂掉的节点虽不可用（其状态会一直保留直到重启）， 不会影响集群的使用。 如果我们又把 126 启动起来， 那么它的角色会是 follower，任期是0： 我们再把 200 的nacos 杀掉， 那么又会产生新的 leader： Nacos + Docker 集群nacos 官方 https://hub.docker.com/r/nacos/nacos-server 有提供docker 的镜像：nacos/nacos-server，我们拿来用即可： docker run –name nacos –net=host –env MODE=cluster –env NACOS_SERVERS=”192.168.11.126:8748 192.168.11.196:8748 192.168.11.200:8748” –env MYSQL_DATABASE_NUM=1 –env MYSQL_MASTER_SERVICE_HOST=192.168.11.200 –env MYSQL_MASTER_SERVICE_PORT=3316 –env MYSQL_MASTER_SERVICE_DB_NAME=test3 –env MYSQL_MASTER_SERVICE_USER=root –env MYSQL_MASTER_SERVICE_PASSWORD=123456 –env NACOS_SERVER_PORT=8848 -d -p 8748:8848 nacos/nacos-server 上面的语句即启动了 docker nacos ，同时通过env 设置了所有的相关的参数 比如数据库、端口等。 特别需要注意的是， 网络模式是 host，也就是使用直接宿主机的网络， 这个是最简单的nacos +docker 集群，否则我们可能需要做比较多的docker网络配置。 另外注意， –net=host 应该放在命令的前面， 不能放最后， 否则不会生效。 NACOS_SERVERS 是所有的节点+端口 配置，目前只能写死， nacos 不提供自动扩容等功能。 如果配置有误，我们只能删除nacos 容器，重新配置 ： docker stop nacos &amp;&amp; docker rm nacos 。 3个节点都执行上面的命令之后，我们的nacos 集群就做好了！ 通过Nginx配置真正的集群上面的集群，虽然可用， 但仍不是真正的集群， 我们一般不会这么用。官方推荐，nacos集群一般有3种方式： http://ip1:port/openAPI 直连ip模式，机器挂则需要修改ip才可以使用。 http://VIP:port/openAPI 挂载VIP模式，直连vip即可，下面挂server真实ip，可读性不好。 http://nacos.com:port/openAPI 域名 + VIP模式，可读性好，而且换ip方便，推荐模式 域名的方式比较麻烦，暂不考虑。vip 的方式也稍稍麻烦。 这里我使用 nginx 的方式。 nginx 做集群很简单， 只要 nginx.conf 做如下的配置就好了： upstream nacos_server {server 192.168.11.200:8748;server 192.168.11.196:8748;server 192.168.11.126:8748;} server {listen 8648;server_name localhost;#charset koi8-r;#access_log logs/host.access.log main;location / {proxy_pass http://nacos_server;index index.html index.htm;}} 8648 的nginx 提供的 nacos 服务接口，可以自定义。 我们访问 192.168.11.139:8648/nacos/#/clusterManagement?dataId=&amp;group=&amp;appName=&amp;namespace=&amp;serverId= ，就可以看到： 我们可以简单测试一下，杀掉 126 或 196 上的 nacos ，看服务是否正常。 后面，我们对微服务提供nacos服务的时候，只要配置这个nginx 端口就好了！！ 其他注意事项nacos 默认是需要登录， 有些麻烦，开发测试的时候，我们可以把它关闭，怎么办呢？ 修改 conf/application.properties 的相关配置即可： turn off securityspring.security.enabled=falsemanagement.security=falsesecurity.basic.enabled=falsenacos.security.ignore.urls=/** #nacos.security.ignore.urls=/,//.css,/**/.js,//.html,/**/.map,//.svg,/**/.png,//*.ico,/console-fe/public/,/v1/auth/login,/v1/console/health/,/v1/cs/,/v1/ns/,/v1/cmdb/,/actuator/,/v1/console/server/** 另外，我们发现 nacos 的日志实在增长太快， 可以tomcat.accesslog 关闭： server.tomcat.accesslog.enabled=true – 改为false 另外，我们可以把 日志级别调整一下，修改 conf/nacos-logback.xml 即可。 参考： https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html https://hub.docker.com/r/nacos/nacos-server","link":"/2020/07/16/Nacos%20%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"},{"title":"Nacos作为配置中心时，多个服务共用一个dataId的配置","text":"写在前面本文是对我之前一篇文章《Spring Cloud+nacos+Feign，实现注册中心及配置中心》的补充。此文章中简单写了如何将Nacos作为配置中心。在使用配置中心时，我们会遇到一种情况：多个微服务中有相同的配置，在配置中心中我们也就希望使用同一个dataId的配置。本文就是说明如何解决这个问题的。 多服务共用一个dataId关于dataId，Nacos官网是这么解释的： 在 Nacos Spring Cloud 中，dataId 的完整格式如下： ${prefix}-${spring.profile.active}.${file-extension} prefix 默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix来配置。 spring.profile.active 即为当前环境对应的 profile，详情可以参考 Spring Boot文档。 注意：当 spring.profile.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension} file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型 上面的这段写的明白，我们可以用spring.cloud.nacos.config.prefix来替代spring.application.name的值。看到这里，大家肯定会认为，如果要多个服务共用一个dataId的配置，我将多个服务的spring.cloud.nacos.config.prefix写成一样的不就可以了吗？然后兴高采烈的去配置文件里做了这个配置，再启动程序，然后测试，可郁闷的发现，没有起作用。。。。。。。。，是不是很伤心，官方文档明明这么写的，却不起作用。 之所以没有起作用，是因为官方文档里虽然写了用spring.cloud.nacos.config.prefix配置，但没有写在哪里写这个配置，大家往往根据经验，写在了application.properties中，不对的，文档里没写，这个配置是要写在bootstrap.properties中，工程中没有这个文件？那就自己新建一个，和application.properties在相同路径下。 下面是我代码中的配置，我用的yaml格式，其他代码，参照《Spring Cloud+nacos+Feign，实现注册中心及配置中心》 server: port: 7080 spring: cloud: nacos: discovery: server-addr: 127.0.0.1:8848 config: server-addr: 127.0.0.1:8848 prefix: chris file**-**extension: yaml application: name: demo2 Nacos对应的截图为： 上图中，两个箭头所指要注意：配置格式选择了YAML，配置内容就要按照YAML格式来写，配置格式选择了Properties，配置内容要按照Properties来写，不要搞错了。","link":"/2020/07/16/Nacos%E4%BD%9C%E4%B8%BA%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%97%B6%EF%BC%8C%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AAdataId%E7%9A%84%E9%85%8D%E7%BD%AE/"},{"title":"Neo4j系列：CentOS下Neo4j安装教程","text":"下载并安装neo4j下载地址 或者直接用wget命令 wget https://neo4j.com/artifact.php?name=neo4j-community-3.4.9-unix.tar.gz 然后解压 tar -zxvf artifact.php?name=neo4j-community-3.4.9-unix.tar.gz 然后将目录移动到/usr下 mv neo4j-community-3.4.9 /usr/neo4j 修改配置 cd /usr/neo4j/conf vim neo4j.conf 允许远程访问 后面导入数据到neo4j的时候可能会因为内存不足导致出错，可以将下面两项适当调大（不能超过实际内存大小） 保存退出 运行 /usr/neo4j/bin/neo4j start 或者进入到neo4j的bin目录下 cd /usr/neo4j/bin ./neo4j start 查看neo4j的状态 ./neo4j status 停止neo4j ./neo4j stop 此时在你的浏览器中输入网址http://:7474，即可看到如下页面 配置环境变量现在你是不是发现每次启动都要进入安装目录？太麻烦了 接下来我们进行环境变量的配置 vim /etc/profile 加入以下语句 NEO4J_HOME=/usr/neo4j PATH=$PATH:$NEO4J_HOME/bin export NEO4J_HOME PATH 然后重新加载 source /etc/profile 这时，只需输入neo4j start即可启动","link":"/2020/03/31/Neo4j%E7%B3%BB%E5%88%97%EF%BC%9ACentOS%E4%B8%8BNeo4j%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"title":"Node.js的替代者，初识Deno","text":"欢迎来到 Deno 世界 点击链接查看完整 Slides 2018年在 JSConf EU 上，被称为 Node.js 之父的 Ryan 发表主题为「10 Things I Regret About Node.js」的演讲，并向大家介绍了他的“新玩具” Deno，两年过去，Deno 已于2020年5月13日发布1.0版本。你可能会疑惑 Deno 到底是什么，Deno 和 Node 有什么关系？Deno 和我有什么关系？ 在这接近两年的日子里 Deno 又经历了些什么，从我们普通开发者角度来看，又有哪些值得了解的 Deno 概念呢？本次分享为团队内分享，通过介绍 Deno 的发展历史以及一些研发工程师值得了解的 Deno 特点，以期将读者初步带入 Deno 世界。 本次分享主要就三个问题展开： What is Deno? Why is Deno? How is Deno? 本文的各项内容也同时采编自社区各活跃开发者的布道文章、演讲与各类材料，所以也可将此 Slides 认为是图文简易版入门教程​。更多参考资料以及文中各类​片段与图片出处，见 Slides 末尾罗列。以下为 Slides 截图。 关于 Deno 如果你还想了解更多，可以参照如下内容与链接 deno.land https://deno.land/ Deno GitHub https://github.com/denoland/deno Deno API https://doc.deno.land/https/github.com/denoland/deno/releases/latest/download/lib.deno.d.ts https://www.youtube.com/watch?v=z6JRlx5NC9E https://www.youtube.com/watch?v=M3BM9TB-8yA https://tinyclouds.org/jsconf2018.pdf https://www.rust-lang.org/ https://v8.dev/ https://github.com/v8/v8 https://github.com/tokio-rs/tokio https://blog.logrocket.com/deno-1-0-what-you-need-to-know/ https://www.ruanyifeng.com/blog/2020/01/deno-intro.html https://zhuanlan.zhihu.com/p/141832695 https://zhuanlan.zhihu.com/p/140787128 https://zhuanlan.zhihu.com/p/142002526 https://github.com/dt-fe/weekly/issues/248 https://zhuanlan.zhihu.com/p/37637923 https://www.youtube.com/embed/5nmpokoRaZI https://zhuanlan.zhihu.com/p/42630183 https://zhuanlan.zhihu.com/p/38202123 原文地址 https://hijiangtao.github.io/2020/05/29/Welcome-to-Deno-World/ 个人公众号「黯晓」，微信搜索或扫这个二维码，交个朋友吧。 知乎专栏「初级前端工程师」，前端技术博客，欢迎投稿与关注。 生活中难免犯错，请多多指教！ 作者：hijiangtao","link":"/2020/05/30/Node.js%E7%9A%84%E6%9B%BF%E4%BB%A3%E8%80%85%EF%BC%8C%E5%88%9D%E8%AF%86Deno/"},{"title":"PHP编码规范","text":"1 前言阅读本规范需结合通用编码规范，里面讲到的规范这里不再赘述，此外，PHP代码里面出现的HTML编码需遵守HTML 编码规范。 2 代码风格2.1 文件[强制] 对于只含有 php 代码的文件，文件结尾处忽略掉 ?&gt;防止多余的空格或者其它字符影响到代码。 [强制] 不使用 php 短标签php 标签采用完整的形式 &lt;?php … ?&gt;，不使用短标签 &lt;? … ?&gt;，且保证在关闭标签后不要有任何空格。 2.2 结构2.3 命名[强制] 大小写不敏感的标识符，当做大小写敏感来使用所有标识符都当做是大小写敏感的，严格按照通用编程规范来定义，使用时使用与定义相同的名字。 [强制] 常量默认大小写敏感，按照规范，禁止开启大小写不敏感常量默认大小写敏感，也可以定义成不敏感，但不允许这么做。 123456```##### [强制] 魔术常量统一大写包括：__LINE__、__FILE__、__DIR__、__FUNCTION__、__CLASS__、__METHOD__、__NAMESPACE__。 // goodecho LINE; // badecho line; 123##### [强制] null、true、false 统一小写 // good$foo = null;$foo = true;$foo = false; // nad$foo = NULL;$foo = TRUE;$foo = FALSE; 123456789101112##### [强制] 类型强制转换统一小写包括：* (int)，(integer) – 转换成整型* (bool)，(boolean) – 转换成布尔型* (float)，(double)，(real) – 转换成浮点型* (string) – 转换成字符串* (array) – 转换成数组* (object) – 转换成对象 // good$foo = (string) 1; // bad$foo = (STRING) 1; 12345678910111213### 2.4 注释## 3 语言特性### 3.1 字符串##### [强制] 字符串使用单引号除非字符串里面有变量或者其他特殊情况不能使用单引号，否则使用单引号为了统一和效率。 // good$name = ‘MyName’; // bad$name = “MyName”; ### 3.2 条件 ##### [建议] 使用 `else...if` 而不是 `elseif` 没为什么，仅仅是为了统一而已。","link":"/2019/11/22/PHP%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"title":"Python 中的 K 最近邻居 - 分步指南","text":"K 近邻算法是世界上最流行的机器学习模型之一，用于解决分类问题。 对于探索机器学习的学生来说，一个常见的练习是将 K 近邻算法应用于数据集，无论这些类别是否为不知道。如果需要使用机器学习对一组机密政府信息进行预测，那么这方面的一个真实示例就是。 在本教程中，您将学习在 Python 中编写第一个 K 近邻机器学习算法。我们将使用类似于上述情况的匿名数据集。 目录您可以使用下面的目录跳到此 K 最接近邻居教程的特定部分： 本教程中所需的数据集 本教程中所需的库 将数据集导入我们的 Python 脚本 标准化数据集 将数据集拆分为训练数据和测试数据 训练 K 最近邻居模型 使用我们的 K 近邻算法进行预测 测量我们模型的准确性 使用弯头方法选择最佳K值 本教程的完整代码 最后的想法 本教程中所需的数据集您需要做的第一件事是下载我们将在本教程中使用的数据集。我已经上传文件到这个网站。您可以通过单击此处访问它。 下载数据集后，需要将文件移动到要处理的目录。之后，打开一个犹太笔记本，我们可以开始编写Python代码！ 本教程中所需的库为了编写一个K近邻算法，我们将利用许多开源Python库，包括NumPy，熊猫，和scikit-学习。 通过编写以下导入语句来开始 Python 脚本： import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns %matplotlib inline 将数据集导入我们的 Python 脚本我们的下一步是将文件导入到我们的 Python 脚本中。熊猫图书馆使将数据导入熊猫数据框架变得容易。classified_data.csv 由于数据集存储在文件中，我们将使用 方法执行此操作：csv``````read_csv raw_data = pd.read_csv('classified_data.csv') 在 Jupyter 笔记本中打印此 DataFrame 将让您了解数据的外观： 您会注意到，DataFrame 以一个未命名的列开头，该列的值等于 DataFrame 的索引。我们可以通过对将数据集导入到 Python 脚本的命令进行细微调整来解决此问题： raw_data = pd.read_csv('classified_data.csv', index_col = 0) 接下来，让我们看一下此数据集中包含的实际功能。您可以使用以下语句打印数据集的列名称列表： print(raw_data.columns) 这将返回： Index(['WTT', 'PTI', 'EQW', 'SBI', 'LQE', 'QWG', 'FDJ', 'PJF', 'HQE', 'NXJ', 'TARGET CLASS'], dtype='object')&lt;/code&gt; 由于这是一个分类数据集，我们不知道这些列中的任何一个意味着什么。就目前而言，它足以识别每个列都是数值的，因此非常适合使用机器学习技术进行建模。 标准化数据集由于 K 最近的邻域算法通过使用最接近数据的观测值对数据点进行预测，因此数据集中要素的比例很重要。 因此，机器学习从业者通常采用数据集，这意味着调整每个值，使其大致处于相同的规模。standardize``````x 幸运的是，包括一些优秀的功能，这样做很少头痛。scikit-learn 首先，我们需要从 导入 类。向 Python 脚本添加以下命令以执行此操作：StandardScaler``````scikit-learn from sklearn.preprocessing import StandardScaler 此函数的作用与本课程前面使用的 和 类类似。我们将要创建此类的实例，然后将该类的实例适合我们的数据集。LinearRegression``````LogisticRegression 首先，让我们创建一个用以下语句命名的类的实例：StandardScaler``````scaler scaler = StandardScaler() 现在，我们可以使用 方法在数据集上训练此实例：fit scaler.fit(raw_data.drop('TARGET CLASS', axis=1)) 现在，我们可以使用 该方法来标准化数据集中的所有要素，以便它们大致相同的比例。我们将这些缩放的要素分配给名为 ： 的变量：transform``````scaled_featuers scaled_features = scaler.transform(raw_data.drop('TARGET CLASS', axis=1)) 这实际上创建了一个NumPy数组的所有功能在数据集中，我们希望它是熊猫数据帧。相反。 幸运的是，这是一个简单的解决方法。我们只需将变量包装在方法中，并将此 DataFrame 分配给一个使用适当参数调用的新变量来指定列名称：scaled_features``````pd.DataFrame``````scaled_data scaled_data = pd.DataFrame(scaled_features, columns = raw_data.drop('TARGET CLASS', axis=1).columns) 现在，我们已经导入了数据集并标准化了数据集的功能，我们准备将数据集拆分为训练数据和测试数据。 将数据集拆分为训练数据和测试数据我们将使用与列表解包相结合的函数从机密数据集创建训练数据和测试数据。train_test_split``````scikit-learn 首先，您需要从 以下语句的模块导入：train_test_split``````model_validation``````scikit-learn from sklearn.model_selection import train_test_split 接下来，我们需要指定将传递到此函数的 和 值。x``````y``````train_test_split 这些值将是我们以前创建的 DataFrame。这些值将是原始数据帧的列。x``````scaled_data``````y``````TARGET CLASS``````raw_data 您可以使用以下语句创建这些变量： x = scaled_data y = raw_data[‘TARGET CLASS’] 接下来，您需要使用这两个参数和一个合理的 运行函数。我们将使用 30% 的 参数，为函数提供以下参数：train_test_split``````test_size``````test_size x_training_data, x_test_data, y_training_data, y_test_data = train_test_split(x, y, test_size = 0.3) 现在，我们的数据集已拆分为训练数据和测试数据，我们已准备好开始训练我们的模型！ 训练 K 最近邻居模型让我们从 导入 开始：KNeighborsClassifier``````scikit-learn from sklearn.neighbors import KNeighborsClassifier 接下来，让我们创建类的实例并将其分配给名为KNeighborsClassifier``````model 此类需要名为 的参数，该参数等于要构建的 K 最近邻域算法的值。首先，让我们指定 ：n_neighbors``````K``````n_neighbors = 1 model = KNeighborsClassifier(n_neighbors = 1) 现在，我们可以使用 该方法和我们的 和 变量训练我们的 K 最接近邻域模型：fit``````x_training_data``````y_training_data model.fit(x_training_data, y_training_data) 现在，让我们用我们新训练的K近邻算法进行一些预测！ 使用我们的 K 近邻算法进行预测我们可以用我们的K近邻算法进行预测，就像我们在本课程前面使用线性回归和逻辑回归模型一样：通过使用该方法并传入我们的变量。predict``````x_test_data 更具体地说，下面介绍如何进行预测并将其分配给一个变量，称为 ：predictions predictions = model.predict(x_test_data) 让我们在本教程的下一节中探讨我们的准确程度。predictions 测量我们模型的准确性我们在逻辑回归教程中看到了内置功能，便于测量机器学习分类模型的性能。scikit-learn 现在，让我们将其中两个函数 （ 和 ） 导入到我们的报告中：classification_report``````confuson_matrix from sklearn.metrics import classification_report from sklearn.metrics import confusion_matrix 让我们逐个完成这些工作，从 开始。您可以使用以下语句生成报表：classfication_report print(classification_report(y_test_data, predictions)) 这将生成： precision recall f1-score support 0 0.94 0.85 0.89 150 1 0.86 0.95 0.90 150 accuracy 0.90 300 macro avg 0.90 0.90 0.90 300 weighted avg 0.90 0.90 0.90 300 同样，您可以使用以下语句生成混淆矩阵： print(confusion_matrix(y_test_data, predictions)) 这将生成： [[141 12] [ 18 129]] 查看这些性能指标，我们的模型看起来已经相当高性能。它仍然可以改进。 在下一节中，我们将了解如何通过为 选择更好的值来提高 K 最接近邻域模型的性能。K 使用弯头方法选择最佳值K在本节中，我们将使用弯头方法为 K 最近的邻域算法选择 的优值。K 弯头方法涉及遍历不同的 K 值，并在应用于测试数据时选择误差率最低的值。 首先，让我们创建一个名为 的空列表。我们将循环遍历不同的值，并将其错误率追加到此列表中。error_rates``````K error_rates = [] 接下来，我们需要创建一个 Python 循环，循环遍历我们想要在每次迭代中测试和执行以下功能的不同值：K 从KNeighborsClassifier``````scikit-learn 使用我们的培训数据训练新模型 对我们的测试数据进行预测 计算每个错误预测的平均值差（这个预测越低，我们的模型越准确） 下面是对 和 之间的值执行此操作的代码：K``````1``````100 for i in np.arange(1, 101): new_model = KNeighborsClassifier(n_neighbors = i) new_model.fit(x_training_data, y_training_data) new_predictions = new_model.predict(x_test_data) error_rates.append(np.mean(new_predictions != y_test_data))&lt;/code&gt; 让我们使用快速 matplotlib 可视化来可视化错误率如何以不同值变化：K plt.plot(error_rates) 如您所见，我们的错误率往往最小化，值约为 50。这意味着，这是一个合适的选择，在简单性和预测能力之间取得平衡。K``````50``````K 本教程的完整代码您可以在此 GitHub 存储库中查看本教程的完整代码。下面还粘贴如下，供参考： #Common importsimport numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns %matplotlib inline #Import the data setraw_data = pd.read_csv(‘classified_data.csv’, index_col = 0) #Import standardization functions from scikit-learnfrom sklearn.preprocessing import StandardScaler #Standardize the data setscaler = StandardScaler() scaler.fit(raw_data.drop(‘TARGET CLASS’, axis=1)) scaled_features = scaler.transform(raw_data.drop(‘TARGET CLASS’, axis=1)) scaled_data = pd.DataFrame(scaled_features, columns = raw_data.drop(‘TARGET CLASS’, axis=1).columns) #Split the data set into training data and test datafrom sklearn.model_selection import train_test_split x = scaled_data y = raw_data[‘TARGET CLASS’] x_training_data, x_test_data, y_training_data, y_test_data = train_test_split(x, y, test_size = 0.3) #Train the model and make predictionsfrom sklearn.neighbors import KNeighborsClassifier model = KNeighborsClassifier(n_neighbors = 1) model.fit(x_training_data, y_training_data) predictions = model.predict(x_test_data) #Performance measurementfrom sklearn.metrics import classification_report from sklearn.metrics import confusion_matrix print(classification_report(y_test_data, predictions)) print(confusion_matrix(y_test_data, predictions)) #Selecting an optimal K valueerror_rates = [] for i in np.arange(1, 101): new_model = KNeighborsClassifier(n_neighbors = i) new_model.fit(x_training_data, y_training_data) new_predictions = new_model.predict(x_test_data) error_rates.append(np.mean(new_predictions != y_test_data)) plt.figure(figsize=(16,12)) plt.plot(error_rates) 最后的想法在本教程中，您学习了如何在 Python 中构建第一个 K 最接近邻居的机器学习模型。 以下是您在本教程中学到的内容的简要摘要： 分类数据如何是一种常见的工具，用于教学生如何解决他们的第一个K近邻问题 为什么在构建 K 近邻模型时标准化数据集很重要 如何使用 函数将数据组拆分为训练数据和测试数据train_test_split 如何训练你的第一个K最近的邻居模型，并与它作出预测 如何测量 K 近邻模型的性能 如何使用弯头方法在 K 最近邻域模型中选择 K 的最佳值","link":"/2020/06/21/Python%20%E4%B8%AD%E7%9A%84%20K%20%E6%9C%80%E8%BF%91%E9%82%BB%E5%B1%85%20-%20%E5%88%86%E6%AD%A5%E6%8C%87%E5%8D%97/"},{"title":"Python 中支持矢量机 - 分步指南","text":"支持向量机 （SVM） 是世界上最受欢迎的机器学习问题之一。 SVM 可用于分类问题或回归问题，这使得它们非常通用。 在本教程中，您将学习如何使用 附带的乳腺癌数据集从头开始构建第一个 Python 支持向量机模型。scikit-learn 目录您可以使用下面的目录跳到此 Python 机器学习教程的特定部分： 本教程中我们需要的 Python 库 我们将在本教程中使用数据集 将数据集拆分为训练数据和测试数据 训练支持向量机模型 使用我们的支持矢量机模型进行预测 评估我们支持向量机模型的性能 本教程的完整代码 最后的想法 本教程中我们需要的 Python 库在本教程中，您将使用许多开源 Python 库，包括NumPy、熊猫和 matplotlib。以下是在开始之前需要运行的一些导入： import pandas as pd import numpy as np import matplotlib.pyplot as plt %matplotlib inline import seaborn as sns 接下来，您将导入我们将在整个本教程中使用的数据集。 我们将在本教程中使用数据集本教程使用 附带的乳腺癌数据集。因此，我们现在会将该数据集导入到 Python 脚本中。scikit-learn 首先，使用以下命令从 模块导入 函数：load_breast_cancer``````datasets``````scikit-learn from sklearn.datasets import load_breast_cancer 接下来，您需要创建乳腺癌数据集的实例。以下语句应执行以下操作： cancer_data = load_breast_cancer() 此变量不仅包括乳腺癌数据集。例如，我们很快就会看到此数据结构中包含一个有用的描述。cancer_data``````raw_data 因此，在导入数据集时，我们需要执行的最后一步是将数据存储在它自己的数据帧中。下面是执行此操作的代码：raw_data raw_data = pd.DataFrame(cancer_data['data'], columns = cancer_data['feature_names']) 让我们来调查此数据集中实际包含的内容。 中包含的每个数据集都附带一个描述字段，可帮助您了解数据集描述的内容。scikit-learn 让我们打印此说明。以下语句应执行以下操作： print(raw_data['DESCR']) 这将生成： .. _breast_cancer_dataset: Breast cancer wisconsin (diagnostic) datasetData Set Characteristics: :Number of Instances: 569 :Number of Attributes: 30 numeric, predictive attributes and the class :Attribute Information: - radius (mean of distances from center to points on the perimeter) - texture (standard deviation of gray-scale values) - perimeter - area - smoothness (local variation in radius lengths) - compactness (perimeter^2 / area - 1.0) - concavity (severity of concave portions of the contour) - concave points (number of concave portions of the contour) - symmetry - fractal dimension (&quot;coastline approximation&quot; - 1) The mean, standard error, and &quot;worst&quot; or largest (mean of the three worst/largest values) of these features were computed for each image, resulting in 30 features. For instance, field 0 is Mean Radius, field 10 is Radius SE, field 20 is Worst Radius. - class: - WDBC-Malignant - WDBC-Benign :Summary Statistics: ===================================== ====== ====== Min Max ===================================== ====== ====== radius (mean): 6.981 28.11 texture (mean): 9.71 39.28 perimeter (mean): 43.79 188.5 area (mean): 143.5 2501.0 smoothness (mean): 0.053 0.163 compactness (mean): 0.019 0.345 concavity (mean): 0.0 0.427 concave points (mean): 0.0 0.201 symmetry (mean): 0.106 0.304 fractal dimension (mean): 0.05 0.097 radius (standard error): 0.112 2.873 texture (standard error): 0.36 4.885 perimeter (standard error): 0.757 21.98 area (standard error): 6.802 542.2 smoothness (standard error): 0.002 0.031 compactness (standard error): 0.002 0.135 concavity (standard error): 0.0 0.396 concave points (standard error): 0.0 0.053 symmetry (standard error): 0.008 0.079 fractal dimension (standard error): 0.001 0.03 radius (worst): 7.93 36.04 texture (worst): 12.02 49.54 perimeter (worst): 50.41 251.2 area (worst): 185.2 4254.0 smoothness (worst): 0.071 0.223 compactness (worst): 0.027 1.058 concavity (worst): 0.0 1.252 concave points (worst): 0.0 0.291 symmetry (worst): 0.156 0.664 fractal dimension (worst): 0.055 0.208 ===================================== ====== ====== :Missing Attribute Values: None :Class Distribution: 212 - Malignant, 357 - Benign :Creator: Dr. William H. Wolberg, W. Nick Street, Olvi L. Mangasarian :Donor: Nick Street :Date: November, 1995 This is a copy of UCI ML Breast Cancer Wisconsin (Diagnostic) datasets.https://goo.gl/U2Uwz2 Features are computed from a digitized image of a fine needleaspirate (FNA) of a breast mass. They describecharacteristics of the cell nuclei present in the image. Separating plane described above was obtained usingMultisurface Method-Tree (MSM-T) [K. P. Bennett, “Decision TreeConstruction Via Linear Programming.” Proceedings of the 4thMidwest Artificial Intelligence and Cognitive Science Society,pp. 97-101, 1992], a classification method which uses linearprogramming to construct a decision tree. Relevant featureswere selected using an exhaustive search in the space of 1-4features and 1-3 separating planes. The actual linear program used to obtain the separating planein the 3-dimensional space is that described in:[K. P. Bennett and O. L. Mangasarian: “Robust LinearProgramming Discrimination of Two Linearly Inseparable Sets”,Optimization Methods and Software 1, 1992, 23-34]. This database is also available through the UW CS ftp server: ftp ftp.cs.wisc.educd math-prog/cpo-dataset/machine-learn/WDBC/ .. topic:: References W.N. Street, W.H. Wolberg and O.L. Mangasarian. Nuclear feature extractionfor breast tumor diagnosis. IS&amp;T/SPIE 1993 International Symposium onElectronic Imaging: Science and Technology, volume 1905, pages 861-870,San Jose, CA, 1993. O.L. Mangasarian, W.N. Street and W.H. Wolberg. Breast cancer diagnosis andprognosis via linear programming. Operations Research, 43(4), pages 570-577,July-August 1995. W.H. Wolberg, W.N. Street, and O.L. Mangasarian. Machine learning techniquesto diagnose breast cancer from fine-needle aspirates. Cancer Letters 77 (1994)163-171. 此数据集描述中最重要的要点是： 数据集中有 569 个观测值 每个观察点有 30 个数字属性 现在，我们已经了解了数据集的结构，让我们继续将数据集拆分为训练数据和测试数据。 将数据集拆分为训练数据和测试数据要将数据集拆分为训练数据和测试数据，我们需要做的第一件事是指定我们和变量。x``````y 我们的变量将是我们之前创建的熊猫数据帧。我们的变量需要从我们之前创建的原始对象进行分析，其中存储在键下。x``````raw_data``````y``````cancer_data``````target 更具体地说，下面是创建我们和变量的代码：x``````y x = raw_data y = cancer_data[‘target’] 我们将使用’s 函数与列表解包相结合，将数据集拆分为训练数据和测试数据（就像我们在本课程前面之前所做的那样）。scikit-learn``````train_test_split 首先，您需要使用以下语句导入函数： from sklearn.model_selection import train_test_split 现在，您可以使用以下语句沿 和 轴创建训练数据和测试数据：x``````y x_training_data, x_test_data, y_training_data, y_test_data = train_test_split(x, y, test_size = 0.3) 这将拆分数据，以便测试数据是原始数据集的 30%（由 参数指示）。test_size = 0.3 现在，我们的数据被拆分了，让我们继续训练我们的第一个支持向量机模型。 训练支持向量机模型在训练第一个支持向量机模型之前，需要从 导入模型类。scikit-learn 类住在模块内。下面是用于导入它的语句：SVC``````scikit-learn``````svm from sklearn.svm import SVC 现在，让我们创建一个此类的实例并将其分配给变量：model model = SVC() 现在，我们可以使用与k 最近邻域模型和随机林模型相同的方法训练 SVM 模型：通过调用该方法，并传入 和 。fit``````x_training_data``````y_training_data 下面是执行此操作的代码： model.fit(x_training_data, y_training_data) 我们的模型现在已经接受培训。让我们在本教程的下一节中继续使用模型进行预测。 使用我们的支持矢量机模型进行预测使用创建的任何机器学习模型都可用于生成预测，只需调用方法并传入要从中生成预测的值数组。scikit-learn``````predict 在这种情况下，下面是 Python 语句，用于存储来自 名为 的变量中的预测：x_test_data``````predictions predictions = model.predict(x_test_data) 接下来我们将评估模型的性能。 评估我们支持向量机模型的性能我们将使用与本课程中构建的其他分类模型相同的支持向量机器模型的性能测量技术：a 和 。classification_report``````confusion_matrix 首先，让我们从 导入这些函数：scikit-learn from sklearn.metrics import classification_report from sklearn.metrics import confusion_matrix 首先，让我们生成我们的classification_report： print(classification_report(y_test_data, predictions)) 这将生成： precision recall f1-score support 0 1.00 0.84 0.91 67 1 0.90 1.00 0.95 104 accuracy 0.94 171 macro avg 0.95 0.92 0.93 171 weighted avg 0.94 0.94 0.93 171 接下来，让我们生成我们的混淆矩阵： print(confusion_matrix(y_test_data, predictions)) 这将生成： [[ 56 11] [ 0 104]] 本教程的完整代码您可以在此 GitHub 存储库中查看本教程的完整代码。下面还粘贴如下，供参考： #Data importsimport pandas as pd import numpy as np #Visualization importsimport matplotlib.pyplot as plt %matplotlib inline import seaborn as sns #Import the data set from scikit-learnfrom sklearn.datasets import load_breast_cancer cancer_data = load_breast_cancer() raw_data = pd.DataFrame(cancer_data[‘data’], columns = cancer_data[‘feature_names’]) print(cancer_data[‘DESCR’])#Split the data set into training data and test datax = raw_data y = cancer_data[‘target’] from sklearn.model_selection import train_test_split x_training_data, x_test_data, y_training_data, y_test_data = train_test_split(x, y, test_size = 0.3) #Train the SVM modelfrom sklearn.svm import SVC model = SVC() model.fit(x_training_data, y_training_data) #Make predictions with the modelpredictions = model.predict(x_test_data) #Measure the performance of our modelfrom sklearn.metrics import classification_report from sklearn.metrics import confusion_matrix print(classification_report(y_test_data, predictions)) print(confusion_matrix(y_test_data, predictions)) 最后的想法在本教程中，您学习了如何构建 Python 支持向量计算机模型。 以下是本教程中讨论的简要摘要： 如何导入和加载内置乳腺癌数据集scikit-learn 如何打印包含的内置数据集的说明。scikit-learn 如何使用如何将数据组拆分为训练数据和测试数据scikit-learn 如何从模块导入模型SVC``````scikit-learn``````svm 如何训练SVM模型 如何使用 Python 中的支持向量机模型进行预测 如何使用 和 函数测量支持向量机模型的性能classification_report``````confusion_matrix","link":"/2020/06/21/Python%20%E4%B8%AD%E6%94%AF%E6%8C%81%E7%9F%A2%E9%87%8F%E6%9C%BA%20-%20%E5%88%86%E6%AD%A5%E6%8C%87%E5%8D%97/"},{"title":"Python 中的主要组件分析 - 分步指南","text":"主要组件分析是一种无监督机器学习技术，用于探索性数据分析。 更具体地说，数据科学家使用主要组件分析来转换数据集并确定对数据集影响最大的因素。 本教程将教您如何在 Python 中执行主要组件分析。 目录您可以使用下面的目录跳到此 Python 主体组件分析教程的特定部分： 我们将在本教程中使用库 我们将在本教程中使用数据集 执行我们的第一个主要组件转换 可视化我们的主要组件 到底是主要组成部分是什么？ 在实践中如何使用主要组件分析 本教程的完整代码 最后的想法 我们将在本教程中使用库本教程将使用许多开源软件库，包括NumPy、熊猫和matplotlib。 因此，我们将通过添加以下导入来启动 Python 脚本： import pandas as pd import numpy as np import matplotlib.pyplot as plt import seaborn %matplotlib inline 接下来，让我们继续导入数据集。 我们将在本教程中使用数据集在本课程的早些时候，您学习了如何在内置乳腺癌数据集上构建支持载体机器。scikit-learn 我们将在本教程中使用相同的数据集来了解主要组件分析。 让我们通过加载函数开始导入此数据集。scikit-learn``````load_breast_cancer from sklearn.datasets import load_breast_cancer 运行此函数时，它将生成数据集。让我们将数据集分配给一个变量：：raw_data raw_data = load_breast_cancer() 如果运行以确定我们的变量是哪种类型的数据类型，它将返回 。这是属于 的特殊内置数据结构。type(raw_data)``````raw_data``````sklearn.utils.Bunch``````scikit-learn 幸运的是，此数据类型易于使用。事实上，它的行为类似于普通的Python 字典。 这个类似字典的对象的键之一是 。我们可以使用此键将数据集转换为熊猫数据帧，并具有以下语句：data raw_data_frame = pd.DataFrame(raw_data['data'], columns = raw_data['feature_names']) 让我们通过打印来调查数据集包含的功能。这将生成：raw_data_frame.columns Index(['mean radius', 'mean texture', 'mean perimeter', 'mean area', 'mean smoothness', 'mean compactness', 'mean concavity', 'mean concave points', 'mean symmetry', 'mean fractal dimension', 'radius error', 'texture error', 'perimeter error', 'area error', 'smoothness error', 'compactness error', 'concavity error', 'concave points error', 'symmetry error', 'fractal dimension error', 'worst radius', 'worst texture', 'worst perimeter', 'worst area', 'worst smoothness', 'worst compactness', 'worst concavity', 'worst concave points', 'worst symmetry', 'worst fractal dimension'], dtype='object')&lt;/code&gt; 正如您所看到的，这是一个非常功能丰富的数据集。 关于我们的数据集，最后需要注意的一个变量是，我们试图预测的变量——即特定的乳腺癌肿瘤是恶性还是良性——被放在关键项下的对象内。raw_data``````target 可以使用 访问目标值。值将用于恶性肿瘤和良性肿瘤。raw_data['target']``````1``````0 执行我们的第一个主要组件转换正如我们在打印阵列时所看到的，我们的数据集具有许多功能。这使得使用传统可视化技术对数据集执行探索性数据分析变得困难。raw_data_frame.columns 为了解决这个问题，我们需要执行一个主组件转换，将我们的数据集转换为一个只有两个功能的功能，其中每个功能都是主要组件。 首先，我们需要标准化我们的数据集。在机器学习中，仅指转换数据集中的所有观测值，使每个要素的大小大致相同的行为。standardization 我们使用 的类来执行此操作。我们需要做的第一件事是使用以下命令导入此类：scikit-learn``````StandardScaler``````scikit-learn from sklearn.preprocessing import StandardScaler 接下来，我们需要创建此类的实例。我们将新创建的对象分配给名为 ： 的变量：StandardScaler``````data_scaler data_scaler = StandardScaler() 现在，我们需要在本教程前面创建的数据集上训练变量。这让我们的对象能够观察数据集中每个要素的特征，以便它可以在本教程的后面部分将每个要素转换为相同的比例：data_scaler``````raw_data_frame``````data_scaler data_scaler.fit(raw_data_frame) 我们的最后一步是调用对象上的方法。这将创建一个新的数据集，其中观测值已标准化。我们将将其分配给一个称为 的变量。transform``````data_scaler``````scaled_data_frame scaled_data_frame = data_scaler.transform(raw_data_frame) 我们现在已经成功地标准化了乳腺癌数据集！ 现在是执行主要组件分析转换的时候了。 我们需要做的第一件事是从 导入必要的类。下面是执行此操作的命令：scikit-learn from sklearn.decomposition import PCA 现在我们需要创建此类的实例。为此，您需要指定主体组件的数量作为参数。我们将使用 2 个主要组件，因此类实例化命令如下所示：PCA``````n_components pca = PCA(n_components = 2) 接下来，我们需要使用方法将模型拟合：pca``````scaled_data_frame``````fit pca.fit(scaled_data_frame) 我们的主要组件分析模型现已创建，whch 意味着我们现在有一个模型，只需 2 个变量来解释原始数据集的一些方差。 要查看此主体在操作中，运行以下命令： x_pca = pca.transform(scaled_data_frame) print(x_pca.shape) print(scaled_data_frame.shape) 这将返回： (569, 2) (569, 30) 正如您所看到的，我们已经将原始数据集从具有 30 个要素的数据集缩减为仅具有 2 个功能的主要组件的简单模型。 可视化我们的主要组件正如我们在本教程前面讨论的那样，几乎不可能从具有 30 个功能的数据集生成有意义的数据可视化效果。 话虽如此，现在我们已经将数据集转换为 2 个主要组件，创建可视化效果非常简单。 下面介绍如何从本教程中到目前为止使用的两个主要组件创建简单的散点图： plt.scatter(x_pca[:,0],x_pca[:,1]) plt.xlabel(‘First Principal Component’) plt.ylabel(‘Second Principal Component’) 这将生成以下可视化效果： 此可视化显示每个数据点作为其第一个和第二个主要组件的函数。它不是非常有用的当前形式。 让我们添加一个配色方案，根据它是恶性肿瘤还是良性肿瘤来修改每个数据点的颜色。以下代码可以操作： plt.scatter(x_pca[:,0],x_pca[:,1], c=raw_data['target']) plt.xlabel(‘First Principal Component’) plt.ylabel(‘Second Principal Component’) 这将生成： 正如您所看到的，仅使用 2 个主要成分即可准确划分基于恶性和良性肿瘤的数据集。 换个说法，我们保持了对数据集进行准确预测的能力，但通过将原始数据集中的 30 个要素减少到现在的 2 个主要组件，大大提高了数据集的简单性。 到底是主要组成部分是什么？在本教程（和上一个教程）中，我经常提到”主要组件”，但您可能仍然不确定这意味着什么。因此，我想花一些时间更好地解释主要组成部分的实际是什么。 主要组件是数据集中原始要素的线性组合。换句话说，通过添加和减去数据集的原始特征来计算主体组件。 您可以使用 生成这些线性组合的系数。只需键入，它将生成类似这样的内容：scikit-learn``````pca.components_ array([[ 0.21890244, 0.10372458, 0.22753729, 0.22099499, 0.14258969, 0.23928535, 0.25840048, 0.26085376, 0.13816696, 0.06436335, 0.20597878, 0.01742803, 0.21132592, 0.20286964, 0.01453145, 0.17039345, 0.15358979, 0.1834174 , 0.04249842, 0.10256832, 0.22799663, 0.10446933, 0.23663968, 0.22487053, 0.12795256, 0.21009588, 0.22876753, 0.25088597, 0.12290456, 0.13178394], [-0.23385713, -0.05970609, -0.21518136, -0.23107671, 0.18611302, 0.15189161, 0.06016536, -0.0347675 , 0.19034877, 0.36657547, -0.10555215, 0.08997968, -0.08945723, -0.15229263, 0.20443045, 0.2327159 , 0.19720728, 0.13032156, 0.183848 , 0.28009203, -0.21986638, -0.0454673 , -0.19987843, -0.21935186, 0.17230435, 0.14359317, 0.09796411, -0.00825724, 0.14188335, 0.27533947]])&lt;/code&gt; 这是一个二维 NumPy 数组，包含 2 行和 30 列。更具体地说，每个主体组件都有一行，原始数据集中的每个要素都有一列。此 NumPy 数组中的每个项的值对应于数据集中该特定要素上的系数。 让我们以示例为例，调查第一个主体组件。它的前 2 个元素是 和 。这意味着用于计算此分量的方程看起来类似，并且此线性组合的其他系数可以在 NumPy 数组中找到。0.21890244``````0.10372458``````0.21890244x1 + 0.10372458x2 + …``````pca.components_ 总之，主要组件分析是简单性和可解释性之间的权衡。 使用它们大大提高了机器学习模型的简单性。 但是，它们也会增加解释每个变量含义的难度，因为主要组件是数据集中实际实际变量的线性组合。 在实践中如何使用主要组件分析到目前为止，在本教程中，您已经学习了如何执行主要组件分析，将多功能数据集转换为仅包含主要组件的较小数据集。我们已经看到，这增加了简单性，但降低了可解释性。 尽管您对主要组件分析有各种知识，但我们尚未对主要组件模型进行任何预测。 这是有原因的。也就是说，主组件分析_must _be与分类模型（如逻辑回归或 k 最近邻域）结合使用，以做出有意义的预测。 重要的是要牢记这一点向前发展。 本教程的完整代码您可以在此 GitHub 存储库中查看本教程的完整代码。下面还粘贴如下，供参考： import pandas as pdimport numpy as np import matplotlib.pyplot as pltimport seaborn%matplotlib inline from sklearn.datasets import load_breast_cancerraw_data = load_breast_cancer() raw_data_frame = pd.DataFrame(raw_data[‘data’], columns = raw_data[‘feature_names’])raw_data_frame.columns #Standardize the data from sklearn.preprocessing import StandardScalerdata_scaler = StandardScaler()data_scaler.fit(raw_data_frame)scaled_data_frame = data_scaler.transform(raw_data_frame) #Perform the principal component analysis transformation from sklearn.decomposition import PCApca = PCA(n_components = 2)pca.fit(scaled_data_frame) x_pca = pca.transform(scaled_data_frame) print(x_pca.shape)print(scaled_data_frame.shape) #Visualize the principal components plt.scatter(x_pca[:,0],x_pca[:,1])plt.xlabel(‘First Principal Component’)plt.ylabel(‘Second Principal Component’) #Visualize the principal components with a color scheme plt.scatter(x_pca[:,0],x_pca[:,1], c=raw_data[‘target’])plt.xlabel(‘First Principal Component’)plt.ylabel(‘Second Principal Component’) #Investigating at the principal components pca.components_[0] 最后的想法在本教程中，您学习了如何在 Python 中执行主体组件分析。 以下是我们讨论的主题的简要摘要： 主要组件分析如何减少数据集中的要素数量 主要组件如何是数据集原始特征的线性组合 该主要组件分析必须与其他机器学习技术相结合，以便对实际数据集进行预测","link":"/2020/06/21/Python%20%E4%B8%AD%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90%20-%20%E5%88%86%E6%AD%A5%E6%8C%87%E5%8D%97/"},{"title":"Python 中的决策树和随机林","text":"随机林是一种机器学习分类算法，由众多决策树组成。 随机林中的每个决策树都包含对数据集要素的随机采样。此外，在构建每个树时，算法使用数据点的随机采样来训练模型。 在本教程中，您将学习如何在 Python 中构建第一个随机林。如果想在完成后了解有关机器学习的更多信息，本文包括真实数据集、完整代码库以及进一步说明。 目录您可以使用下面的目录跳到此 Python 随机林教程的特定部分： 本教程所需的数据集 本教程所需的导入 将数据集导入到我们的 Python 脚本中 探索性数据分析 确定数据集的大小 可视化数据 构建和培训我们的决策树模型 使用我们的决策树模型进行预测 衡量我们决策树模型的性能 构建和培训我们的随机林模型 使用随机林模型进行预测 衡量我们决策树模型的性能 本教程的完整代码 最后的想法 本教程所需的数据集在本教程中，我们将使用一组基福症患者，并构建一个随机林算法来预测患者是否患有这种疾病。 您需要下载数据集，然后才能继续。我已经上传了数据集到我的网站，使这很容易为你。只需单击此处即可下载文件。下载后，将文件移动到相应的目录，然后打开Jupyter 笔记本。 本教程所需的导入我们将依靠一些开源软件库来构建我们的随机森林模型，包括NumPy，熊猫和matplotlib。让我们首先导入具有以下代码的这些库： #Numerical computing librariesimport pandas as pd import numpy as np #Visalization librariesimport matplotlib.pyplot as plt import seaborn as sns %matplotlib inline 现在，我们的导入已执行，我们已准备好将数据集导入到 Python 脚本中。 将数据集导入到我们的 Python 脚本中您可以使用熊猫的方法将 kyphosis 数据集导入到 Python 脚本中，如下所示：read_csv raw_data = pd.read_csv('kyphosis-data.csv') 让我们来看看此数据集中包含的功能： Raw_data.columns 这将返回： Index(['Kyphosis', 'Age', 'Number', 'Start'], dtype='object') 此数据集表示以前患有基福症的一组患者，然后在背部手术后再次进行测试。 该列包含或取决于他们是否患有 kyphosis 的值，而该列包含患者的年龄（以月为月）。该列指示操作中涉及的椎骨数。该列描述操作的顶级椎骨。Kyphosis``````present``````absent``````Age``````Number``````Start 现在我们已经导入了数据集，让我们继续执行一些探索性数据分析。 探索性数据分析探索性数据分析是在使用数据集构建机器学习模型之前了解有关数据集的更多知识的过程。它通常涉及计算聚合数据或构建可视化效果。 在构建和培训机器学习模型之前，让我们深入了解一些简短的探索性数据分析。 确定数据集的大小机器学习工程师在构建模型之前应始终了解的一个特征是其数据集的大小。 pandas使这很容易确定。只需调用熊猫数据帧上的方法，如下所示：info raw_data.info() 这将生成： RangeIndex: 81 entries, 0 to 80 Data columns (total 4 columns): Kyphosis 81 non-null object Age 81 non-null int64 Number 81 non-null int64 Start 81 non-null int64 dtypes: int64(3), object(1) memory usage: 2.7+ KB 如您所见，此数据集中有 81 个观测值。这是一个相对较小的数据集，用于执行机器学习预测，但由于这只是一个教育教程，我们还是可以继续。 可视化数据由于数据集相当小，我们可以使用库轻松可视化每个功能发生的情况。seaborn 下面是执行此操作的命令： sns.pairplot(raw_data, hue = 'Kyphosis') 下面是此命令生成的绘图：seaborn 现在，我们已经了解数据集的结构，让我们将数据集划分为训练数据和测试数据。 将数据集拆分为训练数据和测试数据 我们将使用’的功能与列表解包相结合，以创建我们的训练数据和测试数据。具体来说，我们将使用 30% 的测试大小。scikit-learn``````train_test_split 首先，让我们从 导入 函数：train_test_split``````scikit-learn from sklearn.model_selection import train_test_split 接下来，我们需要指定数据集中的 和 数据。数据将是除列之外的所有数据，而数据本身将是列。x``````y``````x``````Kyphosis``````y``````Kyphosis 下面是在数据集中创建此除法的 Python 语句： x = raw_data.drop('Kyphosis', axis = 1) y = raw_data[‘Kyphosis’] 最后，下面是创建训练测试拆分的命令： x_training_data, x_test_data, y_training_data, y_test_data = train_test_split(x, y, test_size = 0.3) 我们成功地将数据集划分为训练数据和测试数据。 接下来，我们将通过构建并训练此数据的决策树算法来继续本教程。 稍后，我们还将在相同的训练数据和测试数据上构建一个随机林模型，并查看其结果与更基本的决策树模型的比较情况。 构建和培训我们的决策树模型我们需要做的第一件事是从 模块导入类。运行以下命令以执行此操作：DecisionTreeClassifier``````tree``````scikit-learn from sklearn.tree import DecisionTreeClassifier 现在我们需要创建此类的实例并将其分配给变量：model model = DecisionTreeClassifier() 我们的模型已经创建。现在我们需要使用我们的培训数据来训练它。 这样做的方式与本课程前面线性回归、逻辑回归和K 最近邻域模型相同：通过使用 方法。fit 调用对象上的方法并传递 和 ，如下所示：fit``````model``````x_training_data``````y_training_data model.fit(x_training_data, y_training_data) 我们的基福西模型已经过培训。让我们使用此模型进行一些预测。 使用我们的决策树模型进行预测要使用对象进行预测，只需调用它上的方法并传递变量即可。您可以将这些预测分配给名为 的变量。model``````predict``````x_test_data``````predictions 更具体地说，下面是执行此操作的代码： predictions = model.predict(x_test_data) 现在，我们已经进行了预测，让我们使用一些内置功能来评估模型的准确性。scikit-learn 衡量我们决策树模型的性能我们将使用’’的内置函数，并评估我们决策树机器学习模型的性能。scikit-learn``````classification_report``````confusion_matrix 首先，让我们导入这些函数： from sklearn.metrics import classification_report from sklearn.metrics import confusion_matrix 接下来，让我们生成一个 ：classification_report print(classification_report(y_test_data, predictions)) 这将生成： precision recall f1-score support absent 0.85 0.89 0.87 19 present 0.60 0.50 0.55 6 accuracy 0.80 25 macro avg 0.72 0.70 0.71 25 weighted avg 0.79 0.80 0.79 25 我们可以以类似的方式生成：confusion_matrix print(confusion_matrix(y_test_data, predictions)) 这将生成： [[17 2] [ 3 3]] 总体而言，我们的模型似乎对测试数据进行预测方面做得相当不错。它只对 5 个数据点（2 个误报和 3 个假负数）进行不正确的预测，这一点如 所示。confusion_matrix 在下一节中，我们将开始构建一个随机林模型，在本教程的后面部分，我们将将其性能与对象进行比较。model 构建和培训我们的随机林模型要构建随机林模型，我们首先需要从 导入模型。下面是执行此操作的命令：scikit-learn from sklearn.ensemble import RandomForestClassifier 接下来，我们需要创建随机林模型。 由于我们不想覆盖我们之前创建的变量，我们不会命名它。相反，让我们命名它：model``````model``````random_forest_model random_forest_model = RandomForestClassifier() 请注意，类具有一个名为 的参数，该参数指定林中的树数。其默认值为 ，但如果需要，可以更改此值。我们将在本教程中使用 的默认值。RandomForestClassifier``````n_estimators``````100``````100 注意训练随机林模型的时间。为此，我们使用 的方法，就像以前一样：fit random_forest_model.fit(x_training_data, y_training_data) 我们的随机森林模型已经过训练。让我们继续用这个新的合奏模型做一些预测。 使用随机林模型进行预测让我们使用 方法使用对象计算一些预测，并将它们分配给名为 的变量：predict``````random_forest_model``````random_forest_predictions random_forest_predictions = random_forest_model.predict(x_test_data) 接下来我们将评估这些预测的准确性。 衡量我们决策树模型的性能正如我们使用基本决策树模型时所做的那样，让我们生成 和 。classification_report``````confusion_matrix 让我们从 开始：classification_report print(classification_report(y_test_data, random_forest_predictions)) 以下是此报告的输出： precision recall f1-score support absent 0.82 0.95 0.88 19 present 0.67 0.33 0.44 6 accuracy 0.80 25 macro avg 0.74 0.64 0.66 25 weighted avg 0.78 0.80 0.77 25 现在，让我们生成一个混淆矩阵： print(confusion_matrix(y_test_data, random_forest_predictions)) 下面是此混淆矩阵的输出： [[18 1] [ 4 2]] 在这种情况下，我们的随机林的表现没有明显优于我们的决策树模型。 这主要是因为我们的数据集很小。在几乎所有情况下，随机林的性能都会优于基本决策树，尤其是在您用于进行预测的数据集变得越来越大时。 本教程的完整代码您可以在此 GitHub 存储库中查看本教程的完整代码。下面还粘贴如下，供参考： #Numerical computing librariesimport pandas as pd import numpy as np #Visalization librariesimport matplotlib.pyplot as plt import seaborn as sns %matplotlib inline raw_data = pd.read_csv(‘kyphosis-data.csv’) raw_data.columns #Exploratory data analysisraw_data.info() sns.pairplot(raw_data, hue = ‘Kyphosis’) #Split the data set into training data and test datafrom sklearn.model_selection import train_test_split x = raw_data.drop(‘Kyphosis’, axis = 1) y = raw_data[‘Kyphosis’] x_training_data, x_test_data, y_training_data, y_test_data = train_test_split(x, y, test_size = 0.3) #Train the decision tree modelfrom sklearn.tree import DecisionTreeClassifier model = DecisionTreeClassifier() model.fit(x_training_data, y_training_data) predictions = model.predict(x_test_data) #Measure the performance of the decision tree modelfrom sklearn.metrics import classification_report from sklearn.metrics import confusion_matrix print(classification_report(y_test_data, predictions)) print(confusion_matrix(y_test_data, predictions)) #Train the random forests modelfrom sklearn.ensemble import RandomForestClassifier random_forest_model = RandomForestClassifier() random_forest_model.fit(x_training_data, y_training_data) random_forest_predictions = random_forest_model.predict(x_test_data) #Measure the performance of the random forest modelprint(classification_report(y_test_data, random_forest_predictions)) print(confusion_matrix(y_test_data, random_forest_predictions)) 最后的想法在本教程中，您了解了如何在 Python 中构建决策树和随机林。 以下是您在本文中学到的内容的简要摘要： 如何使用构建决策树模型scikit-learn 如何使用随机林模型scikit-learn 随机林通常比决策树更善于预测 ， 尤其是对于大型数据集","link":"/2020/06/21/Python%20%E4%B8%AD%E7%9A%84%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%9E%97/"},{"title":"Redis 集群演进探讨和总结","text":"Redis为什么需要集群？ 首先Redis单实例主要有单点，容量有限，流量压力上限的问题。 Redis单点故障，可以通过主从复制replication，和自动故障转移sentinel哨兵机制。 但Redis单Master实例提供读写服务，仍然有容量和压力问题，因此需要数据分区，构建多个Master实例同时提供读写服务（不仅限于从replica节点提供读服务）。 那么就需要一定的机制保证数据分区。这样能充分把容量分摊到多台计算机，或能充分利用多核计算机的性能。 并且数据在各个主Master节点间不能混乱，当然最好还能支持在线数据热迁移的特性。 探讨数据分区方案 针对数据分区，一般来说，分为两个大类： 逻辑拆分： 逻辑上能拆分，比如 Redis 中的 M1 节点 存储 A服务需要的业务数据，而 Redis 中的 M2 节点存储 B服务需要的业务数据。 数据分区： 当逻辑上不能拆分，那么只能按数据来拆分，需要保证客户端读和写数据一致。 因此需要一个高效快速的数据结构来路由对应的Master节点。 最容易想到的就是类比 Java 中的 HashMap， 采用 哈希算法，快速找到，快速设置。 这里有四种方式，分别是固定取模，随机，哈希一致性，哈希槽。 固定取模 假设有三个 Master，配置IP 和权重如下： Real Server IP weight 10.0.2.21 1 10.0.2.22 2 10.0.2.23 3 那么会根据每一个real Server 及其权重虚拟出对应权重 weight 个的虚拟vritual server节点，映射关系会是： Real Server IP virtual server 10.0.2.21 1 10.0.2.22 2,3 10.0.2.23 4,5,6 一个 key 存储在那个虚拟vritual server节点，通过哈希hash算法： virtual_server_index = hash(key) % (total_virtual_weight) 假设某个key，它的 hash 值是 10，那么以上： 10%6=4，将落到 10.0.2.23 这个真实的 Master上。 缺点 因为取模的模数是固定的，当新增或删除 master节点时，所有的数据几乎要全部洗牌，几乎需要重新迁移数据（而且相当麻烦），无法做到在线数据热迁移。 意味着Redis在此种用法下，只能当缓存，不能当存储数据库！ 随机 随机选取一个存储和访问。 一般结合 list，用于非顺序性要求的消息队列场景。 缺点： 使用场景比较单一。 并且由于随机性问题，导致持久化存在不可靠性。Redis在此种用法下，也只能当缓存，不能当存储数据库！ 一致性哈希一致性哈希算法（Consistent Hashing）最早在论文《Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web》中被提出。 简单来说，一致性哈希将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希空间环如下： 1.有一个HASH环，环上每个节点都是一个自然数，从0开始顺时针递增，直到2^32-1，最后回到0 2.真实节点 M1 M2 M3 通过 hash（IP 或主机名）确定在哈希环上的位置 3.当客户端请求时，首先 hash(key) 确定在哈希环上的位置，然后顺时针往后找，找到的第一个真实节点，就是客户端需要请求访问的真实主机 优点： 哈希一致性其实是对固定取模的一种优化。 （1）扩展性：当增加节点时，只会影响顺时针的真实节点（此部分数据比较难迁移），而不是影响全部的节点。 （2）容错性：当节点宕机或删除节点时，只会影响逆时针的真实节点，而不是影响全部的节点。 （3）平衡性：当哈希算法的节点过少时，会可能造成某些服务器的数据存储较多，而另外一些存储较少，造成数据倾斜，当节点足够多时，这种现象得以缓解。 因此虚拟节点个数较大的时候，数据的平衡性得以保证。 缺点： 因为当增删节点时，需要重新计算受影响部分的节点中的key全部找出来，才能迁移，这个很麻烦！！！ Redis在此种用法下，也只能当缓存，不能当存储数据库！ 哈希槽（PreSharding）这个跟哈希一致性很相似。 区别在于，它预先分配好真实节点管理的哈希槽（slot），并存储管理起来，我们可以预先知道哪个master主机拥有哪些哈希槽（slot）,这里总数是16384。 127.0.0.1:7001> cluster nodes2aaf59558f1b9f493a946a695e51711eb03d15f9 127.0.0.1:7002@17002 master - 0 1590126183862 2 connected 5461-109226439c3e9468fd2c545a63b3b9bfe658c5fc14287 127.0.0.1:7003@17003 master - 0 1590126181856 3 connected 10923-16383340d985880c23de9816226dff5fd903322e44313 127.0.0.1:7001@17001 myself,master - 0 1590126182000 1 connected 0-5460 我们可以清晰看到Redis Cluster中的每一个master节点管理的哈希槽。 比如 127.0.0.1:7001 拥有哈希槽 0-5460， 127.0.0.1:7002 拥有哈希槽 5461-10922， 127.0.0.1:7003 拥有哈希槽 10923-16383。 ➜ redis-cli -p 7001127.0.0.1:7001> set a 1(error) MOVED 15495 127.0.0.1:7003 ➜ redis-cli -p 7001 -c127.0.0.1:7001&gt; set a 1-&gt; Redirected to slot [15495] located at 127.0.0.1:7003OK 我们看到的是master节点在 Redis Cluster中的实现时，都存有所有的路由信息。 当客户端的key 经过hash运算，发送slot 槽位不在本节点的时候。 （1）如果是非集群方式连接，则直接报告错误给client，告诉它应该访问集群中那个IP的master主机。 （2）如果是集群方式连接，则将客户端重定向到正确的节点上。 注意这里并不是127.0.0.1:7001 帮client去连接127.0.0.1:7003获取数据的，而是将客户端请求重定向了。 优点： 继承并增强一致性哈希的容错性，扩展性，以及平衡性。 Redis在此种用法下，可以当缓存，也能当存储数据库！ 这里Redis给出更详细的说明：https://redis.io/topics/partitioning 具体方案以下列表为按照出现的先后顺序排列： 方案 描述 数据分区支持策略 分布式 在线数据热迁移 twemproxy twitter 开源的redis代理中间件，不修改redis源码 https://github.com/twitter/twemproxy 存在modula（固定取模）、 random （随机）、ketama（哈希一致性）三种可选的配置 本身是单点的，可以通过keepalived等保证高可用 不支持，无法平滑地扩容/缩容 Redis Cluster 官方提供的集群方案 采用预先分片（PreSharding），即哈希槽方式，存储在每一个master节点上 没有proxy代理层，客户端可以连接集群中的任意master节点 提供客户端命令redis-cli --cluster reshard ip port按哈希槽迁移指定节点的数据 codis 豌豆荚开源的redis代理中间件，修改了redis源码 https://github.com/CodisLabs/codis 采用预先分片（PreSharding），即哈希槽方式，存储在ZooKeeper上 集群部署，部署相对复杂 支持数据热迁移 Redis Cluster ：一般生产环境量不大，且采用 Spring 提供的 RedisTemplate 之类封装好的 fat client ，可以采用 redis6.0后，官方也推出Redis Cluster的proxy方案 （https://github.com/RedisLabs/redis-cluster-proxy），只是尚为新，且处于beta阶段（2020.5处于1.0beta版本），不成熟。但未来可期，毕竟是官方支持的。) 目前如果生产环境量大，但尚无研发能力，可以选用 codis @SvenAugustus(https://www.flysium.xyz/)更多请关注微信公众号【编程不离宗】，专注于分享服务器开发与编程相关的技术干货：","link":"/2020/05/24/Redis%20%E9%9B%86%E7%BE%A4%E6%BC%94%E8%BF%9B%E6%8E%A2%E8%AE%A8%E5%92%8C%E6%80%BB%E7%BB%93/"},{"title":"RxJava总体流程","text":"RxJava总体流程可以概括为以下三步，复杂的操作只是增加中间环节，以及中间环节的各种细化处理 第一步流程-从上往下，初始化操作符，对所有操作符进行初始化 第二步流程-从下往上，开始订阅，并连接操作符，对连接的操作符进行设置，此例中主要是异步请求时切换线程， subscribeOn()的设置只有第一次生效，因为在subscribeOn中会切换线程，然后进行订阅。这时的流程时从下往上，最终都会回到第一次的设置。所以之前不管切到哪个线程，最终又会由第一次的设置切回它所设置的线程。 第三步流程-从上往下，处理数据，获得数据后由各个操作符对数据进行加工处理，最终传递给最终的观察者。 observeOn()每次设置都会起效果，因为observeOn()发挥作用是最后一步从上往下的过程中，所以它每一次切完下次，然后再传递到下一层，下一次同样可以切线程操作。所以如果要对结果再次进行切线程操作，可多次使用observeOn()","link":"/2020/04/16/RxJava%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B/"},{"title":"Spring Cloud+nacos+Feign，实现注册中心及配置中心","text":"写在前面注册中心、配置中心的概念就不在这里解释了。发现服务原来一直用的是Eureka，因为这家伙闭源了，不爽。然后就发现了nacos，阿里巴巴的，好东西，一个搞定注册中心和配置中心。官网：https://nacos.io/en-us/。官网的手册比较入门可以，实用化还需要结合项目。接下来简单介绍下如何使用nacos搭建注册中心和服务中心。 在进行下面操作前，自己去git上下载一个打包发布后的nacos服务，地址：https://github.com/alibaba/nacos/releases。Linux下载第一个，windows下载第二个。后面两个是源码。如何启动使用nacos，nacos官网说的很详细，不再赘述。 注册中心服务提供者从https://start.spring.io/下载一个原始的spring boot工程，别忘了添加Web依赖，如何下载就不在这里说了。添加依赖： com.alibaba.cloud spring-cloud-starter-alibaba-nacos-discovery 2.2.1.RELEASE 配置文件application.properties添加配置： server.port=8070spring.application.name=service-providerspring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 启动类： ** 添加一个测试用的Controller：** 至此，服务提供者完成。 服务消费者同服务提供者操作，下载一个原始的spring boot工程，添加依赖，注意，因为要使用feign调用服务提供者，要添加相应依赖： com.alibaba.cloud spring-cloud-starter-alibaba-nacos-discovery 2.2.1.RELEASE org.springframework.cloud spring-cloud-starter-openfeign 2.2.2.RELEASE 配置文件application.properties添加配置： server.port=8080spring.application.name=service-consumerspring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 启动类： 添加feign的client： 添加测试controller： 准备工作完成，启动nacos、服务提供者，服务消费者。全部启动成功后，就可以在nacos的控制台界面里看到两个已经注册进去的服务： 直接使用浏览器访问：http://127.0.0.1:8080/consumer/hello-consumer。 配置中心直接在上面的服务提供者中使用nacos的配置中心。添加依赖： com.alibaba.cloud spring-cloud-starter-alibaba-nacos-config 2.2.1.RELEASE 在Controller添加以下注解及代码，并修改接口： 配置文件application.properties添加配置： spring.cloud.nacos.config.server-addr=127.0.0.1:8848 重启服务提供者。 在nacos控制台界面的【配置列表】中添加配置： 发布后，再访问http://127.0.0.1:8080/consumer/hello-consumer。 写在最后简单介绍了如何使用，至于用到的注解有什么用，大家自行百度。","link":"/2020/07/16/Spring%20Cloud+nacos+Feign%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"title":"Spring Cloud Gateway+Nacos，yml+properties两种配置文件方式搭建网关服务","text":"写在前面网关的作用不在此赘述，举个最常用的例子，我们搭建了微服务，前端调用各服务接口时，由于各服务接口不一样，如果让前端同事分别调用，前端同事会疯的。而网关就可以解决这个问题，网关屏蔽了各业务服务的端口，对前端同事来说，他们只负责调用网关服务端口下的服务就可以了。本文简单描述如何使用Spring Cloud全家桶中的网关服务，再配以Nacos。关于Nacos简单应用，可以看我其他博客。 服务提供者从https://start.spring.io/下载一个原始的spring boot工程，如何下载就不在这里说了。添加依赖： org.springframework.boot spring-boot-starter-web com.alibaba.cloud spring-cloud-starter-alibaba-nacos-config 2.2.1.RELEASE com.alibaba.cloud spring-cloud-starter-alibaba-nacos-discovery 2.2.1.RELEASE 分别添加了web依赖、配置中心依赖和注册中心依赖。 配置文件如下： server.port=8070spring.application.name=service-providerspring.cloud.nacos.config.server-addr=127.0.0.1:8848spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 启动类如下： package com.chris.springboot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @SpringBootApplication@EnableDiscoveryClient public class MySpringbootApplication { public static void main(String[] args) { SpringApplication.run(MySpringbootApplication.class, args); }} 接口类如下： package com.chris.springboot.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.context.config.annotation.RefreshScope; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController@RequestMapping(“/provider”)@RefreshScope public class ConfigController { @Value(value = &quot;${Hello:123}&quot;) private String hello; @GetMapping(&quot;/helloProvider&quot;) public String helloProvider(){ return hello; } } 此服务为我的博客：https://www.cnblogs.com/ncwuwsh/p/12732516.html中的服务，可参看。 网关服务从https://start.spring.io/下载一个原始的spring boot工程，如何下载就不在这里说了。添加依赖： org.springframework.cloud spring-cloud-starter-gateway com.alibaba.cloud spring-cloud-starter-alibaba-nacos-discovery 2.2.1.RELEASE 注意，千万不要添加web依赖。 配置文件可以使用properties，也可以使用yml格式。yml格式如下： server: port: 8080spring: application: name: api-gateway cloud: nacos: discovery: server-addr: 127.0.0.1:8848 gateway: discovery: locator: enabled: true #表明gateway开启服务注册和发现的功能，并且spring cloud gateway自动根据服务发现为每一个服务创建了一个router，这个router将以服务名开头的请求路径转发到对应的服务。 lower-case-service-id: true #是将请求路径上的服务名配置为小写（因为服务注册的时候，向注册中心注册时将服务名转成大写的了），比如以/service-hi/*的请求路径被路由转发到服务名为service-hi的服务上。 routes: - id: gateway-service uri: lb://service-provider #此配置的值注册到Nacos中服务提供者的spring.application.name的值 predicates: - Path=/provider/** 使用yml的同学，一定要去查下yml的一些规则，比如 ：后面，值的前面，一定要有空格，缩进不要使用tab键，而要用两个空格缩进等 下面是properties格式配置文件： server.port=8080spring.application.name=api-gatewayspring.cloud.nacos.discovery.server-addr=127.0.0.1:8848#表明gateway开启服务注册和发现的功能，并且spring cloud gateway自动根据服务发现为每一个服务创建了一个router，这个router将以服务名开头的请求路径转发到对应的服务。spring.cloud.gateway.discovery.locator.enabled=true#是将请求路径上的服务名配置为小写（因为服务注册的时候，向注册中心注册时将服务名转成大写的了），比如以/service-hi/*的请求路径被路由转发到服务名为service-hi的服务上。spring.cloud.gateway.discovery.locator.lower-case-service-id=truespring.cloud.gateway.routes[0].id=gateway-servicespring.cloud.gateway.routes[0].uri=lb://service-providerspring.cloud.gateway.routes[0].predicates[0]=Path=/provider/** 下面是网关的启动类： package com.chris.gatewayrouter; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.cloud.gateway.route.RouteLocator; import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder; import org.springframework.context.annotation.Bean; @SpringBootApplication@EnableDiscoveryClient public class GatewayrouterApplication { public static void main(String[] args) { SpringApplication.run(GatewayrouterApplication.class, args); } @Bean public RouteLocator myRoutes(RouteLocatorBuilder builder) { return builder.routes().build(); } } 然后启动Nacos，服务提供者和网关服务，使用浏览器访问：http://127.0.0.1:8080/provider/helloProvider 搞定。 网关服务的其他高级应用，自己去看官网吧。 官网是最好的老师","link":"/2020/07/16/Spring%20Cloud%20Gateway+Nacos%EF%BC%8Cyml+properties%E4%B8%A4%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BA%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1/"},{"title":"鉴权中心：Spring Boot v2.1.3 兼容鉴权中心Spring Boot v2.0.2","text":"背景鉴权中心使用的是 Spring Boot v2.0.2鉴权中心：Springboot+Springsecurity+Oauth2整合 鉴权中心 兼用Spring Boot v2.1.3鉴权中心 pom 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--排包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;!--排包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;!--排包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;!--添加Spring Boot 2.1.3 spring-security-core --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;version&gt;5.1.4.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 服务资源兼容鉴权中心添加 spring-security-oauth2-autoconfigure 1234567891011&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;--&gt;&lt;!-- &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-autoconfigure&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt;","link":"/2020/04/03/Spring-Boot-v2-1-3-%E5%85%BC%E5%AE%B9%E9%89%B4%E6%9D%83%E4%B8%AD%E5%BF%83Spring-Boot-v2-0-2/"},{"title":"SpringCloudAlibaba(一)：概述与重要组件","text":"SpringCloudAlibaba是什么？SpringCloud Alibaba是Alibaba结合自身的微服务实践开源的一套微服务全家桶，在SpringCloud项目中进行孵化并且毕业。既然是SpringCloud的项目那么阿里云其实包含其商业化的产品。 例如Nacos在阿里云就有其商业化的版本 MSE。 同时SpringCloud Alibaba的相关组件是经历过双十一大促考验的产品。稳定性较高。 SpringCloud Alibaba与SpringCloudSpringCloud Alibaba是SpringCloud的子项目，其实很多相关的文章都提到了SpringCloud Alibaba与SpringCloud的关系，其中有很多的论点都比较有意思。大家可以去搜索一下。SpringCloud Alibaba是依赖SpringCloud相关的标准实现的一套微服务的架构。结合阿里巴巴的相关实践与阿里云的相关服务实现的一些组件得以更快的实现相关产品业务。 SpringCloud Alibaba主要功能 分布式配置分布式系统的外部配置管理，配置中心可视化、分环境配置控制。配置动态更新能力。 服务注册与发现适配SpringCloud标准的服务注册与服务发现管理。 服务限流与降级可通过控制台进行实时的修改限流降级的规则，实时的Metrics监控。支持多种协议 消息驱动基于RocketMQ实现消息驱动的业务场景开发。 分布式事物 开源Seata使用@GlobalTransactional注解，零侵入的实现分布式事物的支持。 SpringCloud Alibaba核心组件Nacos (配置中心与服务注册与发现) Nacos实现了服务的配置中心与服务注册发现的功能，Nacos可以通过可视化的配置降低相关的学习与维护成本，实现动态的配置管理与分环境的配置中心控制。 同时Nacos提供了基于http/RCP的服务注册与发现功能。 Sentinel (分布式流控) Sentinel是面向分布式微服务架构的轻量级高可用的流控组件，以流量作为切入点，从流量控制，熔断降级，系统负载保护等维度帮助用户保证服务的稳定性。常用与实现限流、熔断降级等策略。 RocketMQ (消息队列) RocketMQ基于Java的高性能、高吞吐量的消息队列，在SpringCloud Alibaba生态用于实现消息驱动的业务开发，常见的消息队列有Kafka、RocketMQ、RabbitMQ等，相关的比较文档可以自行去翻阅。 Seata (分布式事物) 既然是微服务的产品，那么肯定会用到分布式事物。Seata就是阿里巴巴开源的一个高性能分布式事物的解决方案。 Dubbo (RPC) Dubbo已经在圈内很火了,SpringCloud Alibaba基于上面提到的Nacos服务注册中心也同样整合了Dubbo。 其他 SpringCloud Alibaba还有一些其他的组件选择，例如schedulerX、SMS、OSS等。但是由于其主要是阿里云的商业化产品就不再过多的进行介绍。集成其商业化产品时才能用到。 总结SpringCloud Alibaba是基于SpringCloud标准由阿里巴巴实现的微服务全家桶，可插拔的方式实现组件的替换，在某些场景中我们需要的组件可以自由进行选择。例如需要分布式链路跟踪我们可以增加sleuth组件用于实现分布式链路跟踪业务等。很多人提到SpringCloudAlibaba的商业问题，记得当年SpringCloudAlibaba推出第一版的时候我也评论了…卖产品全家桶。不可否认是有那么一些，但是其实它本身的很多组件又不一定非要选择商业版本。这个可以自由进行选择。","link":"/2020/07/16/SpringCloudAlibaba(%E4%B8%80)%EF%BC%9A%E6%A6%82%E8%BF%B0%E4%B8%8E%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6/"},{"title":"SpringCloudAlibaba(三)：使用Nacos作为配置中心","text":"之前提到了这次从php技术栈迁移到java技术栈要解决的一个问题就是集中化配置管理。 我们为什么会有配置中心的需求? 配置管理变更较为方便 合理控制配置的权限内容 Nacos 控制台增加配置文件 进入Nacos管理界面,在【配置管理】-【配置列表】功能页面点击右上角的 + 号。 进入 新建配置 页面，填写要新增的配置内容 WARN:Data ID的默认扩展名为properties,如果需要使用yaml格式则需要指明是 .yaml 发布配置 配置完成后点击发布,即可在配置列表中看到刚才新增的配置 创建Nacos Config客户端 新建项目,由于使用SpringCloudAlibaba直接引用相关依赖 ```xml com.alibaba.cloud spring-cloud-starter-alibaba-nacos-config org.springframework.boot spring-boot-starter-web 2. * 启动类 3. ```java 4. @SpringBootApplication 5. public class NacosConfigApplication { 6. public static void main(String[] args) { 7. SpringApplication.run(NacosConfigApplication.class,args); 8. } 9. }``` * Controller ```1. @RefreshScope 2. @RestController 3. @RequestMapping(&quot;/config&quot;) 4. public class ConfigController { 5. @Value(&quot;${useLocalCache:false}&quot;) 6. private boolean useLocalCache; 8. @Value(&quot;${name}&quot;) 9. private String name; 11. @RequestMapping(&quot;/get&quot;) 12. public boolean get() { 13. return useLocalCache; 14. } 16. @RequestMapping(&quot;/name&quot;) 17. public String name(){ 18. return name; 19. } 20. }``` **@RefreshScope**在这里的作用就是让配置内容支持动态刷新，也就是当应用运行中，我们在Nacos控制台修改了配置之后这里也会动态的更新。 1. 项目bootstrap.properties配置服务名称与Nacos地址 ```1. # 配置中心url 2. spring.cloud.nacos.config.server-addr=localhost:8848 3. # 配置中心展现的服务名称 4. spring.application.name=nacos-config-example 5. #配置文件类型[TEXT,JSON,XML,YAML,HTML,Properties] 6. spring.cloud.nacos.config.file-extension=properties 7. # 配置分组,当前的业务基本选择为某些的GROUP,可以基于业务来划分不同的分组. 8. spring.cloud.nacos.config.group=DEFAULT_GROUP 9. # 默认选择的配置环境,当前把环境划分为4套, dev[开发环境],test[测试环境],pre[预发环境],prod[生产环境] 10. spring.profiles.active=dev``` **WARN** 多环境配置中需要指定Nacos namespace的id，而不是指定namespace的名称 2. 启动应用程序并进行验证 * 启动应用 ![](https://img-blog.csdnimg.cn/20200509214405511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1MzIxMDU=,size_16,color_FFFFFF,t_70) * 发送请求测试配置是否生效 ![](https://imgconvert.csdnimg.cn/aHR0cDovL2NhaW5nYW8uYW55ZGF0YS50b3AvYXNzZXRzL2ltZy9zcHJpbmdjbG91ZGFsaWJhYmEvMy9uYWNvc193ZWJfY29uZmlnX3Rlc3QucG5n?x-oss-process=image/format,png) * 修改配置进行进行动态刷新 进入Nacos控制台修改配置信息,name修改为bigData 再次进行测试 ![](https://imgconvert.csdnimg.cn/aHR0cDovL2NhaW5nYW8uYW55ZGF0YS50b3AvYXNzZXRzL2ltZy9zcHJpbmdjbG91ZGFsaWJhYmEvMy9uYWNvc193ZWJfY29uZmlnX3JlZnJlc2gucG5n?x-oss-process=image/format,png) 再次发送请求 ![](https://imgconvert.csdnimg.cn/aHR0cDovL2NhaW5nYW8uYW55ZGF0YS50b3AvYXNzZXRzL2ltZy9zcHJpbmdjbG91ZGFsaWJhYmEvMy9uYWNvc193ZWJfY29uZmlnX3Rlc3RfcmVmcmVzaC5wbmc?x-oss-process=image/format,png) 至此使用Nacos作为配置中心已经完全搞定,并且也实现了多环境的配置。多环境有几种方式实现，但是我依然习惯使用namespace的方式来实现。 **源码:** ```1. github: https://github.com/CainGao/SpringCloudAlibabaExample 3. 码云: https://gitee.com/CainGao/SpringCloudAlibabaExample```","link":"/2020/07/16/SpringCloudAlibaba(%E4%B8%89)%EF%BC%9A%E4%BD%BF%E7%94%A8Nacos%E4%BD%9C%E4%B8%BA%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"title":"SpringCloudAlibaba(二)：Nacos介绍与环境安装","text":"SpringCloud alibaba在之前已经进行了大概的介绍,在微服务环境下对于大量存在的服务管理等肯定需要一个统一的服务注册中心，同时也由于之前提到的集中式配置中心的需求。那么在SpringCloud alibaba中最优的选择就是Nacos。 什么是Nacos?Nacos用于服务的注册发现与服务的配置管理。Nacos提供了简单易用的Web Console。可以帮助开发者快速的实现服务发现、服务配置管理、服务元数据等需求。它类似于Dubbo的zookeeper注册中心、SpringCloud 的Eureka等。同时又支持了分布式服务配置管理等特点。 Nacos的关键特性 服务注册发现与健康检查 动态配置管理，可视化管理界面 动态DNS 服务及元数据管理 Nacos 地图 Nacos生态图 Nacos基础架构与概念 服务 (Service)服务是指一个或一组软件功能（例如特定信息的检索或一组操作的执行），其目的是不同的客户端可以为不同的目的重用（例如通过跨进程的网络调用）。Nacos 支持主流的服务生态，如 Kubernetes Service、gRPC|Dubbo RPC Service 或者 Spring Cloud RESTful Service. 服务注册中心 (Service Registry)服务注册中心，它是服务，其实例及元数据的数据库。服务实例在启动时注册到服务注册表，并在关闭时注销。服务和路由器的客户端查询服务注册表以查找服务的可用实例。服务注册中心可能会调用服务实例的健康检查 API 来验证它是否能够处理请求。 服务元数据 (Service Metadata)服务元数据是指包括服务端点(endpoints)、服务标签、服务版本号、服务实例权重、路由规则、安全策略等描述服务的数据 服务提供方 (Service Provider)是指提供可复用和可调用服务的应用方 服务消费方 (Service Consumer)是指会发起对某个服务调用的应用方 配置 (Configuration)在系统开发过程中通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在。目的是让静态的系统工件或者交付物（如 WAR，JAR 包等）更好地和实际的物理运行环境进行适配。配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成这个步骤。配置变更是调整系统运行时的行为的有效手段之一。 配置管理 (Configuration Management)在数据中心中，系统中所有配置的编辑、存储、分发、变更管理、历史版本管理、变更审计等所有与配置相关的活动统称为配置管理。 名字服务 (Naming Service)提供分布式系统中所有对象(Object)、实体(Entity)的“名字”到关联的元数据之间的映射管理服务，例如 ServiceName -&gt; Endpoints Info, Distributed Lock Name -&gt; Lock Owner/Status Info, DNS Domain Name -&gt; IP List, 服务发现和 DNS 就是名字服务的2大场景。 配置服务 (Configuration Service)在服务或者应用运行过程中，提供动态配置或者元数据以及配置管理的服务提供者。 安装Nacos1. 预备环境准备nacos是依赖Java环境运行的,如果使用源码来编译运行Nacos那么需要首先准备Apache Maven环境。 2. 64 bit JDK1.8+； 3. Maven 3.2+;``` ### &lt;a name=&quot;t8&quot;&gt;&lt;/a&gt;&lt;a name=&quot;t8&quot;&gt;&lt;/a&gt;2\\. 下载源码或安装包 可以选择使用源码或直接使用安装包的方式获取Nacos ```1. 从Github下载源码的方式 2. git clone https://github.com/alibaba/nacos.git 3. cd nacos/ 4. mvn -Prelease-nacos -Dmaven.test.skip=true clean install -U 5. ls -al distribution/target/ 7. // change the $version to your actual path 8. cd distribution/target/nacos-server-$version/nacos/bin 10. 下载编译后的压缩包方式 11. unzip nacos-server-$version.zip 或者 tar -xvf nacos-server-$version.tar.gz 12. cd nacos/bin``` ### &lt;a name=&quot;t9&quot;&gt;&lt;/a&gt;&lt;a name=&quot;t9&quot;&gt;&lt;/a&gt;3.配置MySql服务器 Nacos可以通过两种方式进行数据的持久化管理,1.JDK自带的Derby DB内存数据库 2.使用MySql数据库. 由于DerbyDB对于数据的展现不是很友好,所以我们选择MySql数据库。 ```##初始化MySql数据库.``````下载解压Nacos后可以在 /conf目录下找到 nacos-mysql.sql 文件用于初始化MySql数据库.``````##修改Nacos连接配置``````选择 /conf/application.properties配置文件.``````找到 If user MySQL as datasource 修改如下配置信息``` ```spring.datasource.platform=mysql``` ```### Count of DB:``````db.num=1``` ```### Connect URL of DB:``````db.url.0=jdbc:mysql://localhost:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true``````db.user=XXX``````db.password=XXXXXXX``` ### &lt;a name=&quot;t10&quot;&gt;&lt;/a&gt;&lt;a name=&quot;t10&quot;&gt;&lt;/a&gt;4\\. 启动服务器 Linux/Unix/Mac 启动命令(Standalone代表单机模式,非集群模式): ```sh startup.sh -m standalone``` 如果您使用的是ubuntu系统，或者运行脚本报错提示[[符号找不到，可尝试如下运行 ```bash startup.sh -m standalone``` Windows 启动命令 ```cmd startup.cmd``` ### &lt;a name=&quot;t11&quot;&gt;&lt;/a&gt;&lt;a name=&quot;t11&quot;&gt;&lt;/a&gt;5\\. Web Console Nacos的默认端口为8848，启动完成后可以通过访问 http://localhost:8848/nacos 进入web控制台,默认帐号密码为 nacos/nacos ### &lt;a name=&quot;t12&quot;&gt;&lt;/a&gt;&lt;a name=&quot;t12&quot;&gt;&lt;/a&gt;6\\. 服务注册发现管理 * 服务注册 _curl -X POST 'http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=8080'_ * 服务发现 _curl -X GET 'http://127.0.0.1:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName'_ * 发布配置 _curl -X POST &quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld&quot;_ * 获取配置 _curl -X GET &quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&quot;_ ### &lt;a name=&quot;t13&quot;&gt;&lt;/a&gt;&lt;a name=&quot;t13&quot;&gt;&lt;/a&gt;7\\. 关闭服务器 Linux/Unix/Mac ```sh shutdown.sh``` Windows ```cmd shutdown.cmd``` 或者双击shutdown.cmd运行文件。","link":"/2020/07/16/SpringCloudAlibaba(%E4%BA%8C)%EF%BC%9ANacos%E4%BB%8B%E7%BB%8D%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"},{"title":"Vertx系列一、简述","text":"1. 简述让我们从一开始…vert.x. 什么是 Vert.x？这是一个很好的问题，也许是个好开始。如果转到Vert.x 网站，Vert.x 定义为_”在 JVM 上构建无功应用程序的工具包”。_这个描述相当不清楚，对吗？什么是_工具包_？什么是_反应_应用程序？在本实验中，我们将解释这些单词，并使用 Vert.x 构建一个应用程序，说明什么是 Vert.x。此应用程序将由_微服务_组成。另一个流行语，目前的趋势，对不对？实际上，Vert.x 已经在其他人之前推广_微服务_。 开发的应用程序将是： 基于 Vert.x（这就是为什么你在这里，对吗？ 分布式 作为反应系统构建 （一点）乐趣 本实验为与会者提供与 Vert.x 的介绍级动手会话，从第一行代码到制作服务，到使用服务，最后在一致的被动系统中组装所有内容。它说明了什么是反应系统，什么是反应式编程，以及如何基于反应微服务构建应用程序（和s很重要）。 这是 BYOL（自带笔记本电脑）会话，因此请携带 Windows、OSX 或 Linux 笔记本电脑。你需要JDK 8+在你的机器，和阿帕奇马文（3.3+）。 您将学习到： 什么是 Vert.x 以及如何使用其异步非阻塞开发模型 如何使用 Vert.x 开发具有多种类型的服务和服务发现的微服务 什么是以及如何使用它们verticles 如何使用 Vert.x 事件总线发送和接收消息 如何使用 Vert.x 公开 HTTP 终结点，以及如何使用它们 如何组合异步操作 如何在同一应用程序中使用多种语言 如何使用具有 Vert.x 的数据库 如何管理故障与异步结果，期货，异常处理程序和断路器 如何使用 Vert.x 与 RxJava","link":"/2020/04/13/Vertx%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%8C%E7%AE%80%E8%BF%B0/"},{"title":"Vertx系列三、揭开微服务的神秘面纱","text":"揭开微服务的神秘面纱除了你去年在一个山洞里度过，你可能听说过_微服务_。那么什么是_微服务_呢？要回答这个问题，让我们引用一位资深人士的话： 微服务体系结构样式是一种将单个应用程序开发为一组小型服务的方法，每个应用程序在自己的进程中运行，并与轻量级机制（通常是 HTTP 资源 API）通信。这些服务围绕业务功能构建，并通过全自动部署机制独立部署。这些服务的集中管理是最低限度的，这些服务可能用不同的编程语言编写，并使用不同的数据存储技术。 • 马丁·福勒http://martinfowler.com/articles/microservices.html 微服务_是一种_体系结构样式_，这意味着它是_元素和关系类型的专门化，以及约束以及如何使用它们 [4]。我相信到现在为止，在开始之前，我已经让你比你更困惑了。 不用担心。让我们采取另一种方法。为什么我们需要_微服务_？用一个词：敏捷[5]。让我们想象一下，我们有一个应用程序，相当大。作为一个大型应用程序，维护是一个噩梦，添加功能需要太多的时间，使用的技术是非常过时的（什么？Corba 不再酷了？），任何更改都需要通过 50 个步骤流程，并由 5 级管理层进行验证。显然，应用程序上有几个团队有不同的要求和议程。嗯，我们有一个_这样的怪物应用程序_。如何有效地开发和维护此应用程序？微服务是这个问题的一个答案。它的目的是减少_生产时间_。 为此，_微服务_体系结构样式建议： 将应用程序拆分为一组提供定义的分离组件（使用已知接口或 API_定义的_表示）1services 允许组件与选择的任何协议（通常 REST）通信，但不一定 允许组件使用他们想要的任何语言和技术 允许独立开发、发布和部署每个组件 允许在自己的_管道_中_自动_部署 允许将整个应用程序的业务流程减少到最低最 bar 在本实验中，我们不会处理点 5，但您应该知道 Vert.x 不会限制部署组件的方式。您可以采用任何技术最好的套件您的环境。无论是ssh，云，甚至软盘。 然而，第6点是有趣的，而且经常被误解。开发独立的软件片段在运行时神奇地交互是很酷的。是的，我_神奇地说，_但在科技方面，我们不相信魔法。要做到这一点，我们需要的是某种形式的服务_发现_在运行时。服务发现机制可以通过任意数量的适当方法实现其目标。这些范围从：对代码中的服务位置进行硬编码（这通常是一个坏主意）、使用 DNS 查找服务或一些更高级的技术。 拥有服务发现机制允许我们的系统组件彼此透明地交互，而不考虑位置或环境。它还允许我们通过循环 alogorithm 轻松地在组件之间实现负载平衡，从而使我们的系统更加容错（通过在发生故障时查找另一个服务提供商）。 尽管根据定义，微服务应用程序不需要分发，但在实践中通常存在。这附带了所有分布式应用程序优势和约束：共识计算 （FLP）、CAP 定理、一致性、监视和许多其他失败原因。因此，需要设计微服务应用程序，以适应早期实施阶段的失败。 在我们更进一步之前，我想提几点。_微服务_并不新鲜，概念也不为火箭科学。70年代和80年代的学术论文已经定义（使用不同的词）建筑风格非常接近这一点。还有一个非常重要的理解点是：微服务不是一颗银弹。（除非管理良好），否则它有能力增加应用程序的复杂性，因为它的分布式性质。最后，微服务体系结构无法解决您的所有问题。 在微服务方面，主要关心的是快速交付、适应、独立和可替换性。每个微服务都由另一个提供相同_服务/API / 接口_（在核心，它基本上是利斯科夫替代原则的应用）来替代。 如果您已经是开发人员大约 10 年，您可能需要询问微服务和SOA之间的区别。对很多人来说，它的大小。这并不总是正确的，因为服务不一定很小，这使得”微服务”一词相当具有误导性。微服务和SOA的目的不同，但基本概念相似： 服务：由 API、客户端、代理、任何内容访问的已定义功能 服务提供者：实现服务的组件 服务使用者：使用服务的组件 服务发现：使用者用于查找提供程序的机制 这两种方法都继承了_面向服务的计算_，旨在分解和管理独立的软件片段。即使您使用它，您可能从未听说过这一点：COM、Corba、Jini、OSGi 和 Web 服务都是_面向服务计算_的不同实现。 最后，有一种常见的误解，即微服务的性质必须是RESTful的。这不可能离事实更遥远。微服务可以使用任何最适合其用途的数字交互样式：RPC、事件、消息、流等。在本实验中，我们将使用 RESTful 服务、异步 RPC 和消息源。","link":"/2020/04/13/Vertx%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%8F%AD%E5%BC%80%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/"},{"title":"Vertx系列二、vert.x","text":"2. vert x我们将尝试用几行来解释 Vert.x。请记住，我们在上一节中说过，Vert.x 是“在 JVM 上构建无功应用程序的工具包”。 此描述中有三个要点：工具包、反应和“JVM”。 首先，Vert.x 是一个工具包。也就是说，Vert.x 不是应用程序服务器、容器或框架。它也不是 JavaScript 库。Vert.x 是一个普通的旧文件，因此 Vert.x 应用程序是使用此文件的应用程序。Vert.x 不定义打包模型，所有 Vert.x_组件_都是普通的_枯燥_文件。这对您和您的应用程序有什么影响？假设您正在使用生成工具（如 Maven 或 Gradle）来使应用程序成为 Vert.x 应用程序，只需添加依赖项。想要使用其他 Vert.x 组件，只需将其添加为依赖项。很简单，没有负担。启动应用程序是具有入口点的简单类。没有要安装的特定 IDE 或插件开始使用 Vert.x。 1jar vertx-core public static void main(String[] args) 因此，要使用 Vert.x 提供的令人敬畏性，只需在代码中使用它，但要耐心等待，稍后将介绍这一点。 其次，Vert.x 是反应性的。它是专门用来构建反应应用程序，或者更恰当地，系统。反应系统[1]已在《反应宣言》中定义。虽然文档阅读时间并不长，但我们会进一步将其减少到以下 4 个要点： 响应式：反应系统需要在_合理_的时间内处理请求（我让您定义_合理的_）。 弹性：反应系统必须在_发生故障_（崩溃、超时、错误…）时保持响应，因此必须_针对故障进行设计_并妥善处理。500 弹性：反应系统必须在各种负载下保持响应。因此，它必须向上和向下扩展，并能够以最少的资源处理负载。 消息驱动：来自反应系统的组件使用异步消息传递进行交互。 此外，Vert.x 是事件驱动的，也是非阻塞的。事件在事件_循环_中传递，绝不能阻止。让我们解释一下原因。与传统不同，假设”企业”系统，Vert.x 使用很少的线程。其中一些线程是_事件循环_，它们负责在 中调度事件。如果阻止此线程，则事件不再传递。此执行模型会影响代码的编写方式，而不是_传统的_阻止代码模型，您的代码将是异步的[2]和非阻塞 [ 3]。 1Handlers 例如，如果我们想要从 URL 检索 resoure，我们会执行如下操作： 1234567URL site = new URL(&quot;http://vertx.io/&quot;);BufferedReader in = new BufferedReader(new InputStreamReader(site.openStream()));String inputLine;while ((inputLine = in.readLine()) != null) { System.out.println(inputLine);} in.close(); 但是，使用 Vert.x，我们更有可能做到： 12vertx.createHttpClient().getNow(80, &quot;vertx.io&quot;, &quot;&quot;, response -&gt; { response.bodyHandler(System.out::println);}); 这两个代码之间的主要区别是： 第一个是同步的，并且可能阻塞：指令_按顺序_执行，并可能长时间阻止线程（因为网站可能很慢或别的什么）。 Vert.x 一个是异步的和非阻塞的：线程（事件循环）在建立与 HTTP 服务器的连接时被释放，因此可以执行其他操作。收到响应后，同一事件循环调用_回调_。大多数 Vert.x 组件都是单线程的（仅由单个线程访问），因此不再承担并发负担。顺便说一下，对于 Vert.x，即使是 DNS 解析也是异步的和非阻塞的（而 Java DNS 解析是阻塞的）。 最后，Vert.x 应用程序_运行”JVM”Java_虚拟机 （8+）。这意味着可以使用在 JVM 上运行的任何语言开发 Vert.x 应用程序。包括Java（当然），格洛维，锡兰，红宝石，JavaScript，科特林和斯卡拉。我们甚至可以混合和匹配所有这些语言的任意组合。Vert.x 应用程序的多面体特性允许您为任务使用最合适的语言。 Vert.x 允许您通过使用内置 TCP 和 HTTP 服务器和客户端实现分布式应用程序，但也使用 Vert.x 事件总线（一种用于发送和接收消息的轻量级机制）。使用事件总线，您将消息发送到 。它支持三种分发模式： 1addresses 点对点_：消息发送到侦听地址的单个_使用者 _发布/订阅_：所有收听该地址_的消费者_都收到该消息 _请求/回复_：邮件发送给单个_使用者_，并让它通过向初始发件人发送另一_条消息_来_回复_邮件 哇！那是很多要处理的信息…但是，您可能仍要问：我可以为哪类应用程序使用 Vert.x？我们说，Vert.x 非常灵活 - 无论是简单的网络实用程序、复杂的现代 Web 应用程序、HTTP/REST 微服务、大容量事件处理还是完全成熟的后端消息总线应用程序，Vert.x 都非常适合。它速度快，不会约束您。最后但并非最不重要的一点是，Vert.x 提供了适当的工具来构建反应系统;系统：_响应式、弹性、弹性和异步_！","link":"/2020/04/13/Vertx%E7%B3%BB%E5%88%97%E4%BA%8C%E3%80%81vert-x/"},{"title":"Vertx系列四、实例微型交易系统","text":"微交易者应用程序现在，我们更多地了解了 Vert.x 和微服务，是时候讨论我们将在本实验中开发的应用程序了。 这将是一个假的金融应用程序，我们将在那里赚钱（虚拟）的钱。该应用程序由一组微服务组成： 报价生成器 - 这是一个绝对不现实的模拟器，生成报价3虚构的公司_MacroHard, Divinator, and Black Coat。市场数据在 Vert.x 事件总线上发布。 交易者 - 这些是一组组件，从报价生成器接收报价，并决定是否买入或卖出特定股票。为了做出这个决定，他们依赖于另一个称为_组合_服务组件。 投资组合 - 这项服务管理我们投资组合中的股票数量及其货币价值。它作为_服务代理_公开，即 Vert.x 事件总线顶部的异步 RPC 服务。对于每个成功操作，它都会在事件总线上发送一条消息，描述该操作。它使用报价生成器来评估投资组合的当前价值。 审计 - 这是法律方面，你知道…我们需要保留一份我们所有操作的列表日志。审核组件通过事件总线和地址从项目组合服务接收操作。然后，它将这些存储在数据库中。它还提供 REST 终结点来检索最新的操作集。 仪表板 - 一些 UI，让我们知道当我们变得富有。 让我们来看看体系结构： 应用程序使用多种类型的服务： HTTP 终结点 （_即_REST API） - 此服务使用 HTTP URL 定位。 服务代理 - 这些是使用 RPC 交互机制在事件总线上公开的异步服务，服务使用（事件总线）地址定位。 消息源 - 这些是在事件总线上发布消息的组件，服务使用（事件总线）地址定位。 这些组件在同一网络中运行（在本实验中，它们将位于同一台计算机上，但在不同的进程中）。 仪表板显示可用服务、每个公司报价的价值、交易者的最新操作集以及我们投资组合的当前状态。它还显示不同断路器的状态。 我们将实现此应用程序的关键部分。但是，提供代码的其余部分是为了说明一些其他的 Vert.x 功能。需要我们编写的代码使用TODO指示，包装如下： 1234 //TODO// ----// your code here// ----","link":"/2020/04/13/Vertx%E7%B3%BB%E5%88%97%E5%9B%9B%E3%80%81%E5%AE%9E%E4%BE%8B%E5%BE%AE%E5%9E%8B%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F/"},{"title":"Vue.js 和 Angular 比 jQuery 有什么好处","text":"想象一下，你正在建设一个美丽的天气应用程序。 您希望允许用户检查当天、周和当前月份的预测。 显然，您不是天气人，因此您必须为此使用外部数据 - 天气 API。 现在，您需要决定如何构建 UI - 用户必须能够单击每日、每周和每月的选项卡，并更改他位于的城市，同时始终查看最准确的数据。 JQuery 驱动的项目如下所示： 构建 HTML/CSS 视图 将点击事件附加到每日、每周、每月天气选项卡和城市菜单 为每个单击事件编写函数： 调用 API 获取最新预测 使用 jQuery 根据收到的数据更新 HTML 视图 当您将人员带上板来帮助您扩展应用时，请确保他们都知道 jQuery 代码需要哪些元素类才能工作 - 如果您在 HTML 中更改类，一切都会中断 总体而言，这种方法没有错。但是，如果您想象一个 Web 应用程序是十倍大，您将开始看到这是多么混乱。 使用角或 Vue，您的方法将完全不同： 构建 HTML/CSS 视图 在这些视图中，声明数据所在的位置以及哪些数据 在单击选项卡或更改城市时，还要声明要调用的函数 在函数中，只需加载新数据即可。角或 Vue 将自动为您更新 HTML 视图。 您还可以自由修改 HTML 的任何你喜欢的方式，您的应用程序不会中断 - 角或 Vue 跟踪所有元素的内部。 正如您所看到的，虽然您需要采取的步骤数量没有太大差异，但在系统设计上存在很大差异： 使用 jQuery 时，您需要处理每次数据更改时更新视图的艰苦而脆弱的过程。 使用 Angular 或 Vue，您可以小心 - 您只需担心更新基础数据，您的视图将自动更新 最后一点或功能是所有模型视图框架（如”角”或”Vue”）的精髓。 它们可帮助您保持 UI 与数据同步，而无需过多挣扎和意大利面条代码。 jQuery 不会开箱即用，只是因为它是为更广泛和更通用的目的而构建的。 这就是为什么jQuery真的不是这些产品的竞争对手，如果你愿意，你可以并排使用它们 -虽然你很少需要这样做。","link":"/2020/06/25/Vue.js%20%E5%92%8C%20Angular%20%E6%AF%94%20jQuery%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84/"},{"title":"Vue.js——60分钟快速入门","text":"Vue.js——60分钟快速入门 Vue.js介绍Vue.js是当下很火的一个JavaScript MVVM库，它是以数据驱动和组件化的思想构建的。相比于Angular.js，Vue.js提供了更加简洁、更易于理解的API，使得我们能够快速地上手并使用Vue.js。 如果你之前已经习惯了用jQuery操作DOM，学习Vue.js时请先抛开手动操作DOM的思维，因为Vue.js是数据驱动的，你无需手动操作DOM。它通过一些特殊的HTML语法，将DOM和数据绑定起来。一旦你创建了绑定，DOM将和数据保持同步，每当变更了数据，DOM也会相应地更新。 当然了，在使用Vue.js时，你也可以结合其他库一起使用，比如jQuery。 本文的Demo和源代码已放到GitHub，如果您觉得本篇内容不错，请点个赞，或在GitHub上加个星星！ v-for Demo v-bind Demo Page Demo GitHub Source MVVM模式下图不仅概括了MVVM模式（Model-View-ViewModel），还描述了在Vue.js中ViewModel是如何和View以及Model进行交互的。 MVVM ViewModel是Vue.js的核心，它是一个Vue实例。Vue实例是作用于某一个HTML元素上的，这个元素可以是HTML的body元素，也可以是指定了id的某个元素。 当创建了ViewModel后，双向绑定是如何达成的呢？ 首先，我们将上图中的DOM Listeners和Data Bindings看作两个工具，它们是实现双向绑定的关键。从View侧看，ViewModel中的DOM Listeners工具会帮我们监测页面上DOM元素的变化，如果有变化，则更改Model中的数据；从Model侧看，当我们更新Model中的数据时，Data Bindings工具会帮我们更新页面中的DOM元素。 Hello World示例了解一门语言，或者学习一门新技术，编写Hello World示例是我们的必经之路。这段代码在画面上输出”Hello World!”。 &lt;body&gt; &lt;!--这是我们的View--&gt; &lt;div id=&quot;app&quot;&gt; {{ message }} &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 这是我们的Model var exampleData = { message: 'Hello World!' } // 创建一个 Vue 实例或 &quot;ViewModel&quot; // 它连接 View 与 Model new Vue({ el: '#app', data: exampleData }) &lt;/script&gt; 使用Vue的过程就是定义MVVM各个组成部分的过程的过程。 定义View 定义Model 创建一个Vue实例或”ViewModel”，它用于连接View和Model 在创建Vue实例时，需要传入一个选项对象，选项对象可以包含数据、挂载元素、方法、模生命周期钩子等等。 在这个示例中，选项对象的el属性指向View，el: '#app'表示该Vue实例将挂载到&lt;div id=&quot;app&quot;&gt;...&lt;/div&gt;这个元素；data属性指向Model，data: exampleData表示我们的Model是exampleData对象。Vue.js有多种数据绑定的语法，最基础的形式是文本插值，使用一对大括号语法，在运行时{{ message }}会被数据对象的message属性替换，所以页面上会输出”Hello World!”。 Vue.js已经更新到2.0版本了，但由于还不是正式版，本文的代码都是1.0.25版本的。 双向绑定示例MVVM模式本身是实现了双向绑定的，在Vue.js中可以使用v-model指令在表单元素上创建双向数据绑定。 {{ message }} 将message绑定到文本框，当更改文本框的值时，&lt;p&gt;{{ message }}&lt;/p&gt; 中的内容也会被更新。 反过来，如果改变message的值，文本框的值也会被更新，我们可以在Chrome控制台进行尝试。 Vue实例的data属性指向exampleData，它是一个引用类型，改变了exampleData对象的属性，同时也会影响Vue实例的data属性。 Vue.js的常用指令上面用到的v-model是Vue.js常用的一个指令，那么指令是什么呢？ Vue.js的指令是以v-开头的，它们作用于HTML元素，指令提供了一些特殊的特性，将指令绑定在元素上时，指令会为绑定的目标元素添加一些特殊的行为，我们可以将指令看作特殊的HTML特性（attribute）。 Vue.js提供了一些常用的内置指令，接下来我们将介绍以下几个内置指令： v-if指令 v-show指令 v-else指令 v-for指令 v-bind指令 v-on指令 Vue.js具有良好的扩展性，我们也可以开发一些自定义的指令，后面的文章会介绍自定义指令。 v-if指令v-if是条件渲染指令，它根据表达式的真假来删除和插入元素，它的基本语法如下： v-if=\"expression\" expression是一个返回bool值的表达式，表达式可以是一个bool属性，也可以是一个返回bool的运算式。例如： Hello, Vue.js! Yes! No! Age: {{ age }} Name: {{ name }} var vm = new Vue({ el: '#app', data: { yes: true, no: false, age: 28, name: 'keepfool' } }) &lt;/script&gt; 注意：yes, no, age, name这4个变量都来源于Vue实例选项对象的data属性。 这段代码使用了4个表达式： 数据的yes属性为true，所以”Yes!”会被输出； 数据的no属性为false，所以”No!”不会被输出； 运算式age &gt;= 25返回true，所以”Age: 28”会被输出； 运算式name.indexOf('jack') &gt;= 0返回false，所以”Name: keepfool”不会被输出。 注意：v-if指令是根据条件表达式的值来执行元素的插入或者删除行为。 这一点可以从渲染的HTML源代码看出来，面上只渲染了3个元素，v-if值为false的元素没有渲染到HTML。 为了再次验证这一点，可以在Chrome控制台更改age属性，使得表达式age &gt;= 25的值为false，可以看到&lt;h1&gt;Age: 28&lt;/h1&gt;元素被删除了。 age是定义在选项对象的data属性中的，为什么Vue实例可以直接访问它呢？这是因为每个Vue实例都会代理其选项对象里的data属性。 v-show指令v-show也是条件渲染指令，和v-if指令不同的是，使用v-show指令的元素始终会被渲染到HTML，它只是简单地为元素设置CSS的style属性。 Hello, Vue.js! Yes! No! Age: {{ age }} Name: {{ name }} var vm = new Vue({ el: '#app', data: { yes: true, no: false, age: 28, name: 'keepfool' } }) &lt;/script&gt; 在Chrome控制台更改age属性，使得表达式age &gt;= 25的值为false，可以看到&lt;h1&gt;Age: 24&lt;/h1&gt;元素被设置了style=”display:none”样式。 v-else指令可以用v-else指令为v-if或v-show添加一个“else块”。v-else元素必须立即跟在v-if或v-show元素的后面——否则它不能被识别。 &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1 v-if=&quot;age &gt;= 25&quot;&gt;Age: {{ age }}&lt;/h1&gt; &lt;h1 v-else&gt;Name: {{ name }}&lt;/h1&gt; &lt;h1&gt;---------------------分割线---------------------&lt;/h1&gt; &lt;h1 v-show=&quot;name.indexOf('keep') &gt;= 0&quot;&gt;Name: {{ name }}&lt;/h1&gt; &lt;h1 v-else&gt;Sex: {{ sex }}&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: '#app', data: { age: 28, name: 'keepfool', sex: 'Male' } }) &lt;/script&gt; v-else元素是否渲染在HTML中，取决于前面使用的是v-if还是v-show指令。这段代码中v-if为true，后面的v-else不会渲染到HTML；v-show为tue，但是后面的v-else仍然渲染到HTML了。 v-for指令v-for指令基于一个数组渲染一个列表，它和JavaScript的遍历语法相似： v-for=\"item in items\" items是一个数组，item是当前被遍历的数组元素。 &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles/demo.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;th&gt;Sex&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;person in people&quot;&gt; &lt;td&gt;{{ person.name }}&lt;/td&gt; &lt;td&gt;{{ person.age }}&lt;/td&gt; &lt;td&gt;{{ person.sex }}&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: '#app', data: { people: [{ name: 'Jack', age: 30, sex: 'Male' }, { name: 'Bill', age: 26, sex: 'Male' }, { name: 'Tracy', age: 22, sex: 'Female' }, { name: 'Chris', age: 36, sex: 'Male' }] } }) &lt;/script&gt; 我们在选项对象的data属性中定义了一个people数组，然后在#app元素内使用v-for遍历people数组，输出每个person对象的姓名、年龄和性别。 View Demo v-bind指令v-bind指令可以在其名称后面带一个参数，中间放一个冒号隔开，这个参数通常是HTML元素的特性（attribute），例如：v-bind:class v-bind:argument=\"expression\" 下面这段代码构建了一个简单的分页条，v-bind指令作用于元素的class特性上。这个指令包含一个表达式，表达式的含义是：高亮当前页。 {{ n + 1 }} var vm = new Vue({ el: '#app', data: { activeNumber: 1, pageCount: 10 } }) 注意v-for=&quot;n in pageCount&quot;这行代码，pageCount是一个整数，遍历时n从0开始，然后遍历到pageCount –1结束。 作者：永恒之魂","link":"/2020/05/30/Vue.js%E2%80%94%E2%80%9460%E5%88%86%E9%92%9F%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"title":"WebRTC系列：WebRTC M81 发行说明","text":"总结 WebRTC M81 目前在 Chrome 的测试版版版版中提供，它包含 3 个新功能和 20 多个错误修复、增强功能以及稳定性/性能改进。与以前的版本一样，我们鼓励所有开发人员在金丝雀、开发人员和 Beta 频道上频繁运行 Chrome 版本，并快速报告发现的任何问题。请查看此页面，了解有关如何提交良好 Bug 报告的一些提示。我们得到的帮助是无价的！ Chrome 发布时间表可在此处找到。 PSA 如果未授予使用设备的权限，则枚举设备不会公开设备指示 在 Chrome M81 之前，枚举设备 Web API 返回的结果包含系统中所有设备的设备 ID，即使未授予权限也是如此。从 Chrome M81 开始，如果未授予使用设备的权限，则枚举设备现在最多包含每种设备类型的一个条目，并且设备 Id 字段将为空。此更改可能会影响某些现有应用程序，但只需对应用程序的最小更改即可轻松适应它。此更改的目的是提高用户隐私，并与最新版本的规范保持一致。更多细节https://crbug.com/1019176 。 弃用 功能和错误修复 https://e7d0e4c4.wiz03.com/wapp/pages/view/share/s/3DQej43hAN7x2EyM0z1ZXVvc1jLRTz1_ZQDR2bGIxa1hZ2NA","link":"/2020/03/22/WebRTC%E7%B3%BB%E5%88%97%EF%BC%9AWebRTC-M81-%E5%8F%91%E8%A1%8C%E8%AF%B4%E6%98%8E/"},{"title":"WebRTC系列：WebRTC 将一统实时音视频天下？","text":"WebRTC 的前世 无论是在 PC 互联网时代、移动互联网时代，还是当下以云计算、人工智能、IoT 为主导的万物互联时代，WebRTC 的到来都是实时互联网技术标准演进过程中至关重要的一个节点。 回忆 Web 的早期发展，设备和 Web 服务器之间的通信非常有限。在访问网站时，只有当用户在地址栏中输入新地址或点击超链接时，浏览器才能与存储网站的网络服务器进行通信。而这就是静态网页需要运行的全部内容。 但是彼时的一些开发者意识到 Web 应该能以更具吸引力的方式实践应用。正因此，为了使各大网站更具动态性和响应性，诸如 Ajax 类似的框架最终在 90 年代后期被相继开发，从而浏览器也能够实时地与 Web 服务器通信、允许创建适当的 Web 应用程序或即时响应用户操作。不过，彼时的实时通信技术在 Web 浏览器和服务器之间仍存在很大的局限性。 具体而言，过去，两个不同用户的 Web 浏览器之间的通信速度很慢，因为其二者之间的所有流量都必须通过中间的服务器，这产生了明显的延迟。但是，我们也发现直接收发消息之类的延迟并不算是真正的问题。这是因为发送消息的一个用户和接收消息的另一个用户之间几秒钟的差异并没有真正影响到整体的传输效果。但是，服务器延迟导致了一系列的连接延迟，不过如果没有这种延迟则无法实现用户之间互相呼叫等实时视频的服务。 如今 WebRTC 的出现，可以完全实现桌面和基于移动的多人多媒体聊天应用程序。 WebRTC 的今生 那具体而言，到底何为 WebRTC？ WebRTC（Web Real-Time Communication，网页即时通信），是一个支持网页浏览器进行实时语音对话或视频对话的技术。它的起源，要从 2010 年 Google 以 6820 万美元收购 VoIP 软件开发商 Global IP Solutions 的 GIPS 引擎谈起，在经过收购之后没多久，Google 将该引擎改名为“WebRTC”，并宣布向开发者们开源了源代码。 2012 年，Google 将 WebRTC 集成到 Chrome 浏览器中。随后，在它的带动下，Mozilla、Opera、Ericsson 等 PC 浏览器以及手机浏览器均开始支持 WebRTC 技术。 2017 年，苹果在 WWDC17 上正式宣布其浏览器内核 WebKit 也正式支持 WebRTC。 如今，继去年微软宣布 Edge 将采用 Chromium 开源项目之后，就 WebRTC 技术应用而言，Bernard Aboba 表示，“基于 Chromium 的新版 Edge 现在可在预览版中使用。新版本的 Edge 提供了 WebRTC 开发者常用的许多功能，如支持数据通道、RTCPeerConnection 中的 Strem、VP9 编解码器和 MediaStream Recording。” 事实上，除了以上的浏览器以及文章伊始提及国内主流的应用程序之外，在 Discord、Google Hangouts 和 Facebook Messenger 等一些国内的多媒体网络应用中，也都需要 WebRTC 才能实现。 WebRTC 一统浏览器、移动端的实时音视频天下？ 按照这样的发展趋势，WebRTC 能否一举成功夺下各层面的实时音频霸主之位？ 其实，在 WebRTC 的全名——Web Real Time Communication 中，我们从 Web 一词就可以看出，最初这项技术是为浏览器量身打造用以实时音视频能力而准备的。而 WebRTC 项目一开始的初衷也是让 Web 开发者能够基于如 Chrome、Edge、Firefox 等浏览器平台轻易快捷开发出丰富的实时多媒体应用，而无需下载安装任何插件，Web 开发者也仅需关注多媒体的数字信号处理过程，只需编写简单的 JavaScript 程序即可实现。 不过，就浏览器应用而言，WebRTC 的发展还面临着诸多的挑战。对此，Bernard Aboba 表示： 浏览器面临的主要挑战是完成 WebRTC 1.0 API 的实现，以及消除实现差异。为了达到提议标准，WebRTC 工作组需要记录每个功能的两个实现，并通过 Web 平台测试（WPT）的结果展示互操作性。当下，W3C 在实现这一目标方面一直在稳步前进，但在 WebRTC 以及 WebRTC-Stats 等相关规范方面仍有许多工作要做。其次，就 WebRTC 自身的发展而言，WebRTC API 在其历史中经历了三次主要迭代，最后一次迭代是 addTransceiver API，这是 WebRTC 1.0 候选推荐中的首选 API。随着浏览器现在实施候选推荐标准并融合“Unified Plan”SDP，WebRTC 工作组正在为开发人员一直要求的互操作性方面而努力，并且 W3C 需要将规范推进到推荐的标准中。就需要改进的领域而言，W3C 仍然需要改进同步广播等高级功能的测试覆盖率，并将 WebRTC-Statistics 规范纳入候选推荐标准中。当前实时音视频通信领域，也并不只有 WebRTC 一种可供选择的技术。事实上，在 WebRTC 诞生之前，很多领域的公司都有自己自研的通信协议。而如何保证自研协议与 WebRTC 协议在 Windows、Mac 等平台上做到互通？Bernard Aboba 建议道，专有的自研协议和 WebRTC 的互操作性通常使用网关实现。使用 Janus 等工具，开发人员可以通过在已建立的框架内构建模块。但是，在各种情况下测试兼容性的任务仍然很困难。对此，Bernard Aboba 也表示，由 Cosmo Consulting 开发的测试框架（如 KITE）可能会有所帮助。然而，除此之外，WebRTC 在移动端的应用也一直被开发者所诟病。针对这一点，Bernard Aboba 坦言道，“对移动或嵌入式设备优化 WebRTC，是一项重大的挑战，尤其是在内存、应用程序大小，以及连接性和功耗等方面。” 不过当下，W3C 组织为了解决这些难题，该团队的开发者们经常需要创建自定义构建，其中包含了许多更改改进，举例说明，例如，Ortc Lib 创建了 OpenPeer Foundation 的 Robin Raymond，支持使用 ORTC API 在移动设备上进行开发，同时允许开发人员自定义库，以便仅包含所需的功能。 事实证明这种方法非常成功。","link":"/2020/03/22/WebRTC%E7%B3%BB%E5%88%97%EF%BC%9AWebRTC-%E5%B0%86%E4%B8%80%E7%BB%9F%E5%AE%9E%E6%97%B6%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%A9%E4%B8%8B%EF%BC%9F/"},{"title":"WebRTC系列：WebRTC介绍","text":"一、 WebRTC是什么 WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的API。它于2011年6月1日开源并在Google、Mozilla、Opera支持下被纳入万维网联盟的W3C推荐标准。 简单说就是一个音视频处理+及时通讯的开源库。 二、WebRTC 有哪些优点 Google开源的框架（背景强大） 跨平台（适合当下软件开发的趋势） 用于浏览器 实时传输 音视频引擎（迎合当下的发展趋势） 三、WebRTC应用场景 音视频会议 在线教育 照相机 音乐播放器 共享远程桌面 录制 即时通讯工具 P2P网络加速 文件传输工具 游戏 实时人脸识别 由上方列出的条目可以看出，WebRTC的应用场景十分广泛，尤其是在网路越来越发达的当下，音视频会议、在线教育、即时通讯工具、游戏、人脸识别一定是当下和未来的发展方向，跟上时代的步伐才不至于死在沙滩上。 四、 WebRTC的愿景 网络传输 音视频引擎 内网链接 音频引擎 P2P传输 视频引擎 TURN中转 五、 WebRTC运行机制 轨与流 Track（一路音频/视频就是一路轨） MediaStream （媒体流包含很多轨） WebRTC的重要类 MediaStream RTCPeerConnection（该类很重要，提供了应用层的调用接口） RTCDataChannel （非音视频数据通过它传输） 六、 WebRTC目前支持的浏览器 Chrome（谷歌） Safari（苹果） Firefox Edge （微软） 七、学习WebRTC的难点 WebRTC庞大、烦杂门槛高，全是英文文档，对学习者是一个挑战 客户端与服务器分离，增加学习难度 网络屏蔽/系统的学习资料少（这个是因为一些大家都懂的原因，对学习者是一个障碍，需要翻墙） 网上虽然有demo，但是网上demo错误多，难以调试通","link":"/2020/03/22/WebRTC%E7%B3%BB%E5%88%97%EF%BC%9AWebRTC%E4%BB%8B%E7%BB%8D/"},{"title":"WebRTC系列：getUserMedia API及HTML5 调用手机摄像头拍照","text":"getUserMedia API简介HTML5的getUserMedia API为用户提供访问硬件设备媒体（摄像头、视频、音频、地理位置等）的接口，基于该接口，开发者可以在不依赖任何浏览器插件的条件下访问硬件媒体设备。getUserMedia API最初是navigator.getUserMedia，目前已被最新Web标准废除，变更为navigator.mediaDevices.getUserMedia（），但浏览器支持情况不如旧版API普及。MediaDevices.getUserMedia（）方法提示用户允许使用一个视频和/或一个音频输入设备，例如相机或屏幕共享和/或麦克风。如果用户给予许可，就返回一个Promise对象，MediaStream对象作为此Promise对象的Resolved［成功］状态的回调函数参数，相应的，如果用户拒绝了许可，或者没有媒体可用的情况下PermissionDeniedError或者NotFoundError作为此Promise的Rejected［失败］状态的回调函数参数。注意，由于用户不会被要求必须作出允许或者拒绝的选择，所以返回的Promise对象可能既不会触发resolve也不会触发 reject。 浏览器兼容性 语法navigator.mediaDevices.getUserMedia(constraints).then(function(mediaStream) { ... }).catch(function(error) { ... }) 参数**containers：**指定请求的媒体类型，主要包含video和audio，必须至少一个类型或者两个同时可以被指定。如果浏览器无法找到指定的媒体类型或者无法满足相对应的参数要求，那么返回的Promise对象就会处于rejected［失败］状态，NotFoundError作为rejected［失败］回调的参数。 【例】同时请求不带任何参数的音频和视频： { audio: true, video: true } 【例】使用1280x720的摄像头分辨率： { audio: true, video: { width: 1280, height: 720 }} 【例】要求获取最低为1280x720的分辨率： { audio: true, video: { width: { min: 1024, ideal: 1280, max: 1920 }, height: { min: 776, ideal: 720, max: 1080 } }} 当请求包含一个**ideal**（应用最理想的）值时，这个值有着更高的权重，意味着浏览器会先尝试找到最接近指定的理想值的设定或者摄像头（如果设备拥有不止一个摄像头）。 【例】优先使用前置摄像头（如果有的话）： { audio: true, video: { facingMode: \"user\" } } 【例】强制使用后置摄像头： { audio: true, video: { facingMode: { exact: \"environment\" } } } 成功回调函数seccessCallback的参数**stream**：stream是MediaStream的对象，表示媒体内容的数据流，可以通过URL.createObjectURL转换后设置为Video或Audio元素的src属性来使用，部分较新的浏览器也可以直接设置为srcObject属性来使用。 失败回调函数errorCallback的参数**error**，可能的异常有： AbortError：硬件问题 NotAllowedError：用户拒绝了当前的浏览器实例的访问请求；或者用户拒绝了当前会话的访问；或者用户在全局范围内拒绝了所有媒体访问请求。 NotFoundError：找不到满足请求参数的媒体类型。 NotReadableError：操作系统上某个硬件、浏览器或者网页层面发生的错误导致设备无法被访问。 OverConstrainedError：指定的要求无法被设备满足。 SecurityError：安全错误，在getUserMedia() 被调用的 Document上面，使用设备媒体被禁止。这个机制是否开启或者关闭取决于单个用户的偏好设置。 TypeError：类型错误，constraints对象未设置［空］，或者都被设置为false。 示例：HTML 5调用媒体设备摄像头这个例子中，请求访问用户硬件设备的摄像头，并把视频流通过Video元素显示出来。网页中提供一个”拍照”的按钮，通过Canvas将Video的画面截取并绘制，核心代码如下： HTML 12345678&lt;!--video用于显示媒体设备的视频流，自动播放--&gt;&lt;video id=&quot;video&quot; autoplay style=&quot;width: 480px;height: 320px&quot;&gt;&lt;/video&gt;&lt;!--拍照按钮--&gt;&lt;div&gt;&lt;button id=&quot;capture&quot;&gt;拍照&lt;/button&gt;&lt;/div&gt;&lt;!--描绘video截图--&gt;&lt;canvas id=&quot;canvas&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt; JavaScript 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 //访问用户媒体设备的兼容方法function getUserMedia(constrains,success,error){ if(navigator.mediaDevices.getUserMedia){ //最新标准API navigator.mediaDevices.getUserMedia(constrains).then(success).catch(error); } else if (navigator.webkitGetUserMedia){ //webkit内核浏览器 navigator.webkitGetUserMedia(constrains).then(success).catch(error); } else if (navigator.mozGetUserMedia){ //Firefox浏览器 navagator.mozGetUserMedia(constrains).then(success).catch(error); } else if (navigator.getUserMedia){ //旧版API navigator.getUserMedia(constrains).then(success).catch(error); }}var video = document.getElementById(&quot;video&quot;);var canvas = document.getElementById(&quot;canvas&quot;);var context = canvas.getContext(&quot;2d&quot;);//成功的回调函数function success(stream){ //兼容webkit内核浏览器 var CompatibleURL = window.URL || window.webkitURL; //将视频流设置为video元素的源 video.src = CompatibleURL.createObjectURL(stream); //播放视频 video.play();}//异常的回调函数function error(error){ console.log(&quot;访问用户媒体设备失败：&quot;,error.name,error.message);}if (navigator.mediaDevices.getUserMedia || navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia){ //调用用户媒体设备，访问摄像头 getUserMedia({ video:{width:480,height:320} },success,error);} else { alert(&quot;你的浏览器不支持访问用户媒体设备&quot;);}//注册拍照按钮的单击事件document.getElementById(&quot;capture&quot;).addEventListener(&quot;click&quot;,function(){ //绘制画面 context.drawImage(video,0,0,480,320);}); 进阶对本示例进行功能加强，比如使用CSS 3 的滤镜实现模糊、黑白等效果。","link":"/2020/03/22/WebRTC%E7%B3%BB%E5%88%97%EF%BC%9AgetUserMedia-API%E5%8F%8AHTML5-%E8%B0%83%E7%94%A8%E6%89%8B%E6%9C%BA%E6%91%84%E5%83%8F%E5%A4%B4%E6%8B%8D%E7%85%A7/"},{"title":"bulma和bootstrap等前端框架我应该选择哪个？","text":"没听过 bulma 的人的回答可以忽略了，仅仅根据一种CSS Framework就开始给指导性建议的人, 请提升自己的认知。 首先这个问题 题的很好，bulma和bootstrap选择哪个，前端CSS框架很多比如 Bootstrap、 Bulma、Foundation、Milligram、Pure、Semantic、 UIKit。你很难区分一个好坏，说Bootstrap经过4个版本迭代稳定，但是以上的大部分哪个不是？哪个不稳定？ Bulma 和 Bootstrap4 之间有很多的相似点，在功能上几乎没有任何差别，没必要纠结选择哪一个 都是基于flexbox实现的网格布局 Grid System 都是移动优先的响应式布局 Mobile first 文档很丰富 组件很丰富 如果用来做 prototype 基本所有需求都能满足 那么Bulma存在的意义是什么？ 引用 Bulma的作者 Jeremy Thomas 的话就是 Simple to learn. Simple to use 因此如果初学者，建议学习 bulma，会有更好的开发体验. 对于前端开发人员，学习使用CSS框架并不是目的，它只是一个提升生产力的工具 前端人员要更加注重的是如何利用这些 CSS framework 提升自己的 CSS水平，尽可能的100%还原设计图才是目的。因此在使用这些class时，可以猜下框架是如何实现的，然后对照源码验证一下。","link":"/2020/05/24/bulma%E5%92%8Cbootstrap%E7%AD%89%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E6%88%91%E5%BA%94%E8%AF%A5%E9%80%89%E6%8B%A9%E5%93%AA%E4%B8%AA%EF%BC%9F/"},{"title":"canvas 折线","text":"canvas 画一条折线 - Panax - 博客园 2019年4月19日 - canvas 画一条折线 设置画布对象 canvas id=”my_Canvas_” ref=”canvas“ //获取Canvas_对象(画布) var _canvas = document.getElementById(“my_Canvas_”) ? d… _Canvas_之绘制_折线_图_Python_Welkin_qing的博客-CSDN博客 2018年11月27日 - 利用_canvas_绘制_折线_图的一种方法 利用_canvas_绘制_折线_图效果:思路:1)给出来的数值和横坐标数据整体是没有规律的,分别将它们保存在数组nums和datas中。并2)只有两… 【自己的整理】【jQuery插件】 使用_canvas_创建_折线_图…_CSDN博客 2017年12月5日 - 使用_canvas_创建_折线_图一个网友的很常规的需求,要根据数据在一个_canvas_画布元素上画一个_折线_图 _canvas_图表详解系列(2):_折线_图 - 苏天天 - 博客园 2017年10月16日 - 学习目标:此教程将教会大家如何使用canvas_绘制各种图表,详细分解步骤,本次讲解_折线_图。 源文件下载地址:https://github.com/sutianbinde/charts _折线… canvas 画出动态_折线_图 - 简书 canvas 是 html5 支持的一个标签,用于图形的绘制。canvas 标签仅仅提供了图形的容器,必须通过 js 脚本来绘制。 比如,绘制一个简单的矩形: 矩形.png &lt;canvas id… _Canvas_绘制线条(直线、_折线_等) - 全栈笔录 - ITeye博客 Canvas_绘制线条(直线、_折线_等) 博客分类: _canvas canvas 使用html5 _Canvas_绘制直线所需的_Canvas_RenderingContext2D对象的主要属性和方法(有”()”者为方法)如下:… canvas_画_折线 - 简书 2019年6月28日 - 后来觉得这样的画绘制一个_折线_还需要两个div太麻烦了,于是决定用&lt;_canvas_&gt;标签进行绘图,_canvas_的基本原理是展开一个画布,然后你可以用这个画布画各种线… 使用HTML5 Canvas_绘制直线或_折线_等线条的方法讲解__html5_教程技巧… 2016年3月14日 - 这篇文章主要介绍了使用HTML5 Canvas_绘制直线或_折线_等线条的方法讲解,通过_Canvas API我们便可以轻松地使用JavaScript来操作图形的位置坐标,需要的朋友… HTML5 _Canvas_两点之间的_折线_连接动画 - 踏得网 7 ctx.canvas.width = window.innerWidth; 8 ctx.canvas.height = window.innerHeight; 9 ​ 10 c.addEventListener(‘click’, addDot); 11 ​ 12 let … _canvas_绘制经典_折线_图(一) 2015年12月6日 - * 定义绘制_折线_图的关键数据(12个月的消费记录-金额) * 封装函数专门用于绘制_折线_图 recordPaint(Elem,Data)方法 * Elem - 表示&lt;_canvas_&gt;元素 * Data -… 微信小程序内使用_canvas_绘制自定义_折线_图表 - smallhuifei的技术… 2019年4月10日 - 0 : hei / arrMax let len = this.value.length - 1 ctx.beginPath(); /* 折线 */ for (let i = 0; i &lt; len; i++) { let x1 = this.x… _canvas折线_图绘制-前端ABC 2017年5月21日 - 折线_图 _canvas{ border: 1px solid #000; } … HTML5+_Canvas_微信运动_折线_图-百度经验 2018年1月20日 - HTML5+_Canvas_微信运动_折线_图 工具/原料 adobe dreamweaver 方法/步骤 1 新建html文档。 步骤阅读 2 准备好需要用到的图标。 步骤阅读 3 书写hmtl代… 【_Canvas_】如何用_Canvas_绘制_折线_图-布布扣-bubuko.com 2018年10月1日 - 标签:borde 线图 显示 bubuko img 折线 技术 技术分享 效果 ①设置构造函数 ②显示在画布上 ③为该构造函数添加方法 ④初始化 效果图: 【_Canvas_】如何用… _canvas_绘制_折线_图(仿echarts) 2018年5月7日 - 标签:压缩 close _折线_图 fill net ring charset new width 遇到的问题:Retina屏上字体线条模糊问题 解决方案:放大_canvas_的大小,然后用css压缩回原大… HTML5-_canvas_实例:2D_折线_数据图 2014年12月25日 - &lt;_canvas_ id=”demo” width=”400” height=”400”&gt;&lt;/_canvas_&gt; 在页面上创建_canvas_标签,然后获取_canvas_这个元素,因为是画2D图,所以是调用.getContext(‘2d’) … _canvas_画一个_折线_图,怎么把数据反过来显示,从小到大上升?_慕课猿问 2019年2月19日 - _canvas_默认坐标轴 X向右为正,Y向下为正。 手动对数据取反,然后坐标轴整体往左下角移动———获取容器的高度,用tranlate这个API移动坐标原点到左下角。… HTML5 Canvas 3D_折线_图表 2014年7月7日 - HTML5 Canvas 3D_折线_图表是一款基于_canvas_的3D_折线_图表,图表在初始化的时候会根据数据点把_折线_分割成多条线段,然后线段将逐渐悬浮到数据点对应数值的… 超酷HTML5 _Canvas_图表应用Chart.js_折线_图 Line Chart Line Chart with custom tooltips Bar Chart Doughnut Chart Pie Chart Pie Chart with custom tooltips Polar Area Chart Radar Area Chart … HTML5 Canvas_动画_折线_图 一款基于_HTML5 _Canvas_的_折线_图表 - 下载… 2018年9月25日 - HTML5 Canvas_动画_折线_图 一款基于_HTML5 _Canvas_的_折线_图表,这款_HTML5折线_图表的特点有两个,一个是图表是有动画效果的,即在图表初始化的时候带有动画特…","link":"/2020/05/29/canvas%20%E6%8A%98%E7%BA%BF/"},{"title":"centos虚拟内存设置","text":"centos虚拟内存设置 查看内存 1free -m 查看文件系统 1df -h 增加虚拟内存 开始设置#if 表示infile，of表示outfile，bs=1024代表增加的模块大小，count=16384000代表16384000个模块，也就是16G空间 1234dd if=/dev/zero of=/var/swap bs=1024 count=16384000mkswap /var/swapmkswap -f /var/swapswapon /var/swap 修改文件1vim /etc/fstab 添加一行1/var/swap swap swap defaults 0 0 清除设置1swapoff /var/swap 删除/etc/fstab文件里上次添加的","link":"/2019/11/12/centos%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE/"},{"title":"dubbo go 初步使用","text":"dubbo-go 可信 RPC 调用实现_阿里巴巴中间件-CSDN博客 2020年5月21日 - Apache Dubbo/Dubbo-Go 作为阿里巴巴开源的一款服务治理框架,因其适应 Java/Go 开发者面向接口的编程习惯、完全透明的调用方式、优越的性能以及强大的… _Dubbo-go_k8s注册中心设计方案与实现_阿里云云栖号-CSDN博客 5天前 - Dubbo-go_k8s注册中心设计方案与实现随着云原生的推广,越来越多的公司或组织将服务容器化,并将容器化后的服务部署在k8s集群中。今天这篇文章将会介绍_du… 涂鸦智能 dubbo-go 亿级流量的实践与探索 - dubbo-go - 博客园 4天前 - dubbo 是一个基于 Java 开发的高性能的轻量级 RPC 框架,dubbo 提供了丰富的服务治理功能和优秀的扩展能力。而 dubbo-go 在 java 与 golang 之间提供统一的服务化… …Dubbo 生态一周年:已和 Spring Cloud、gRPC 互通 - dubbo-go… 2020年6月6日 - 去年5月,阿里开源的高性能 RPC 框架 Dubbo 从 ASF 毕业并晋升顶级项目,同时,还宣布 Go 语言版本的 Dubbo-go… 曹大谈 dubbo mesh : 在 MOSN 中玩转 dubbo-go - _dubbo-go_开源… 3天前 - 为了避免这些隐式的 init 行为,我们实际上是 fork 了 dubbo-go 并进行了少量修改的。当然,改动并不多,未来如果 dubbo-go 有更好的模块化方法的话,我们… dubbo-go (dubbo-go) · GopherChina 2020年6月2日 - 回帖 JulAugSepOctNovDecJanFebMarAprMayJun 热门话题 最近回帖 原创分享 记一次在 mosn 对 dubbo、dubbo-go-hessian2 的性能优化 0 个赞 / 0 条回复… dubbo-go 可信 RPC 调用实现-云栖社区-阿里云 2020年5月28日 - Apache Dubbo/Dubbo-Go 作为阿里巴巴开源的一款服务治理框架,因其适应 Java/Go 开发者面向接口的编程习惯、完全透明的调用方式、优越的性能以及强大的… khmsa21136:关于_Dubbo-go_在Java和Go运行时毖永_联商专栏 2020年5月31日 - 关于_Dubbo-go_在Java和Go运行时毖永 05月31日 22:47 浏览数(0) 评论数(0) 好评数(0) 沈向洋的新工作:美国最火新闻资讯平台董事长前微软全球执行副总裁… Dubbo-go k8s注册中心设计方案与实现 - 教程文章 - 时代Java,与您… 5天前 - Dubbo-go k8s注册中心设计方案与实现主要内容是随着云原生的推广,越来越多的公司或组织将服务容器化,并将容器化后的服务部署在k8s集群中。 _Dubbo_泛化调用入门到精通_汪小哥-CSDN博客 2020年6月3日 - Dubbo_泛化调用、阿里的好舒服的泛化调用都是类似的功能。最近给同事排查一个_dubbo-admin控制台调用报错的问题的小研究,为此还给社区提了一个issue,具… 首页- _Go_语言中文网 - _Go_lang中文社区 5天前 - Go_语言中文网,中国 _Go_lang 社区,_Go_语言学习园地,致力于构建完善的 _Go_lang 中文社区,_Go_语言爱好者的学习家园。分享 _Go 语言知识,交流使用经验 GitHub - apache/dubbo-samples: samples for Apache Dubbo 2020年5月18日 - samples for Apache Dubbo. Contribute to apache/dubbo-samples development by creating an account on GitHub. _Go_CN每日新闻(2020-06-11) - 哔哩哔哩 1天前 - ## Go_CN每日新闻(2020-06-11)1. _Go 字符串和转换优化 https://medium.com/a-journey-with-_go_/_go_-string-conversion-optimization-767… 阿里巴巴_dubbo_服务-Java代码类资源-CSDN下载 5天前 - _dubbo_jdk1.8root/root更多下载资源、学习资料请访问CSDN下载频道…. 下载 java并发编程阿里巴巴-梁飞_Dubbo_作者 下载 _dubbo_x 2.8.4 版本 maven 依赖 … Go 版本入 Dubbo 生态一周年:已和 Spring Cloud、gRPC 互…_博客园 2020年5月29日 - 去年5月,阿里开源的高性能RPC框架Dubbo从ASF毕业并晋升顶级项目,同时,还宣布Go语言版本的_Dubbo-go_正式加入Dubbo官方生态。经过一年的发展,_Dubbo-go_在… Go 版本入 Dubbo 生态一周年:已和 Spring Cloud、gRPC 互通 顶… 2020年5月29日 - 去年5 月,阿里开源的高性能 RPC 框架 Dubbo 从 ASF 毕业并晋升顶级项目,同时,还宣布 Go 语言版本的 Dubbo-go 正式加入 Dubbo 官方生态。经过一年… 涂鸦智能 dubbo-go 亿级流量的实践与探索_ITPUB博客 1天前 - dubbo 是一个基于 Java 开发的高性能的轻量级 RPC 框架,dubbo 提供了丰富的服务治理功能和优秀的扩展能力。而 dubbo-go 在 java 与 golang 之间提供统… 涂鸦智能 dubbo-go 亿级流量的实践与探索 - 云+社区 - 腾讯云 4天前 - dubbo 是一个基于 Java 开发的高性能的轻量级 RPC 框架,dubbo 提供了丰富的服务治理功能和优秀的扩展能力。而 dubbo-go 在 java 与 golang 之间提供统… 涂鸦智能 dubbo-go 亿级流量的实践与探索-alibabass的博客-51CTO… 1天前 - dubbo 是一个基于 Java 开发的高性能的轻量级 RPC 框架,dubbo 提供了丰富的服务治理功能和优秀的扩展能力。而 dubbo-go 在 java 与 golang 之间提供统… dubbo-go 可信 RPC 调用实现-云栖社区 2020年5月28日 - Apache Dubbo/Dubbo-Go 作为阿里巴巴开源的一款服务治理框架,因其适应 Java/Go 开发者面向接口的编程习惯、完全透明的调用方式、优越的性能以及强大的… _dubbo-go_K8s注册中心的设计方案与实现_阿里云技术-CSDN博客 6天前 - _Dubbo-go_k8s注册中心设计方案与实现随着云原生的推广,越来越多的公司或组织将服务容器化,并将容器化后的服务部署在k8s集群中。今天这篇文章将会介绍_dubbo-go_将k8s… 涂鸦智能 dubbo-go 亿级流量的实践与探索 - 阿里巴巴云原生 - 博… 1天前 - dubbo 是一个基于 Java 开发的高性能的轻量级 RPC 框架,dubbo 提供了丰富的服务治理功能和优秀的扩展能力。而 dubbo-go 在 java 与 golang 之间提供统一的服务化… _Go_版本入_Dubbo_生态一周年:已和SpringCloud、gRPC互通_j…_CSDN博客 2020年6月6日 - 去年5月,阿里开源的高性能RPC框架Dubbo从ASF毕业并晋升顶级项目,同时,还宣布Go语言版本的Dubbo-go(https://github.com/apache/_dubbo-go_)正式加入Dubbo官方生态。… 涂鸦智能_dubbo-go_亿级流量的实践与探索_Go中国-CSDN博客 5天前 - dubbo是一个基于Java开发的高性能的轻量级RPC框架,dubbo提供了丰富的服务治理功能和优秀的扩展能力。而_dubbo-go_在java与golang之间提供… 记一次在MOSN对Dubbo、Dubbo-go-hessian2的性能优化_金…_CSDN博客 6天前 - 我们发现在支持 Dubbo 协议过程中,经过 Mesh 流量代理后,性能有非常大的性能损耗,在大商户落地 Mesh 中也对性能有较高要求,因此本文会重点描述在基于 Go 语言库… 记一次在 MOSN 对 Dubbo、Dubbo-go-hessian2 的性能优…_CSDN博客 5天前 - dubbo 的 body 可以获得以下信息,调用的目标接口(interface)和调用方法的服务分组(group)等信息,但是需要跳过所有业务方法参数,目前使用开源的 hessia… dubbo-go K8s 注册中心的设计方案与实现 - osc_gh0ost1g的个人… 2020年5月20日 - 可是dubbo现有方案为每个_dubbo-go_进程独立注册,因此_dubbo-go_选择将该进程具有的独有的元数据写入运行该_dubbo-go_进程的Pod在k8s中的Pod资源对象的描述… _Go_版本入_Dubbo_生态一周年:已和SpringCloud、gRPC互通_G…_CSDN博客 2020年6月4日 - 去年5月,阿里开源的高性能RPC框架Dubbo从ASF毕业并晋升顶级项目,同时,还宣布Go语言版本的_Dubbo-go_正式加入Dubbo官方生态。经过一年的发展,… 涂鸦智能_dubbo-go_亿级流量的实践与探索_joke59的博客-CSDN博客 5天前 - 涂鸦智能dubbo-go_亿级流量的实践与探索dubbo是一个基于Java开发的高性能的轻量级RPC框架,dubbo提供了丰富的服务治理功能和优秀的扩展能力。而_dubbo-go… 曹大谈_dubbo_mesh:在MOSN中玩转_dubbo-go__joke59的博客-CSDN博客 3天前 - 除了依赖问题以外,dubbo-go 最初的设计大量使用了 init 函数。init 函数用来实现一些初始化和依赖注入确实比较方便,但如果一个项目中的模块会被其它外部项目依赖时… 记一次在mosn对dubbo、dubbo-go-hessian2的性能优化_jo…_CSDN博客 2020年6月2日 - 我们发现在支持 dubbo 协议过程中,经过 Mesh 流量代理后,性能有非常大的性能损耗,在大商户落地 Mesh 中也对性能有较高要求,因此本文会重点描述在基于 … 曹大谈_dubbo_mesh:在MOSN中玩转_dubbo-go__joke59的博客-CSDN博客 3天前 - MOSN 是蚂蚁金服出品的用 Go 语言实现的 service mesh 数据面,在蚂蚁内部已大规模落地,在开源过程中我们了解到外部用户有较多的 dubbo 用户,这些 dubb… 涂鸦智能_dubbo-go_亿级流量的实践与探索_joke59的博客-CSDN博客 5天前 - 涂鸦智能_dubbo-go_亿级流量的实践与探索dubbo是一个基于Java开发的高性能的轻量级RPC框架,dubbo提供了丰富的服务治理功能和优秀的扩展能力。而_dubbo-go_在java与golang… 记一次在 MOSN 对 Dubbo、Dubbo-go-hessian2 的性能优化-云海天教程 6天前 - 蚂蚁金服内部对 Service Mesh 的稳定性和性能要求是比较高的,内部 MOSN 广泛用于生产环境。在云上和开源社区,RPC 领域 Dubbo 和 Spring Cloud 同样… [斗鱼]没人比我更懂微服务–Go 微服务框架 Jupiter - V2EX 2020年6月1日 - • 与 Java Dubbo 流量互通。dubbo 支持 gRPC 协议,因此在协议层,dubbo 与 grpc-go 是可以流量互通的。Jupiter 通过增加一个基于接口(dubbo 的默认注… CSDN-个人空间 5天前 - dubbo 是一个基于 Java 开发的高性能的轻量级 RPC 框架,dubbo 提供了丰富的服务治理功能和优秀的扩展能力。而 dubbo-go 在 java 与 golang 之间提供… 营口_Dubbo_培训短期培训 -上海曙海信息网络科技 2020年5月31日 - 营口_Dubbo_培训短期培训编码器端与PLC输端连接,A、B…“”移动到选中的方式上,然后再按【_GO_】键,就进入 Go Web框架-_Go_语言中文社区-_Go_lang中文网-_Go_lang程序员社区 2020年6月6日 - 大家好,我是Dubbo!我是阿里开源的分布式服务框架,最大的特点是按照分层的方式来…如何使用 Go_lang 日志监控你的应用程序? 推荐 java是否会被取代?_Go… 【社招】【网联清算】测试岗位/业务测试/性能测试 - 社会招聘… 20小时前 - 4、熟悉Java/python等至少一种编程语言,Java,python,shell,JS,_GO_语言优先考虑; 5、理解性能相关的Linux,nginx,Java,JVM,MySQL ,HTTP,_dubbo_等知识,具… 记一次在 mosn 对 dubbo、dubbo-go-hessian2 的性能优…_CSDN博客 2020年6月2日 - 我们发现在支持 dubbo 协议过程中,经过 Mesh 流量代理后,性能有非常大的性能损耗,在大商户落地 Mesh 中也对性能有较高要求,因此本文会重点描述在基于 Go 语言库…","link":"/2020/06/16/dubbo%20go%20%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/"},{"title":"golang gateway 从零开始","text":"_从零开始_搭建创业公司后台技术栈_MarkerHub的博客-CSDN博客 2020年5月30日 - 以上的这些内容都需要我们从零开始_搭建,在创业公司,…的分布式的 RPC 服务框架,基于 _Golang net/rpc …Push Gateway 支持临时性 Job 主动推送指标的中间网关… goku-api-gateway: A Powerful HTTP API Gateway in pure golang… 2020年5月31日 - Goku API Gateway (中文名:悟空 API 网关)是一个基于 Golang 开发的微服务网关,能够实现高性能 HTTP API 转发、多租户管理、API 访问权限控制等目的,… 开源项目 - _Go_语言中文网 - _Golang_中文社区 2020年5月13日 - 7天用Go_从零_实现系列 7days-golang 7天能写什么呢?类似 gin 的 web 框架…Goku API Gateway (中文名:悟空 API 网关)是一个基于 _Golang_开发的微服务网关… Springcloud之_Gateway_组件_u014042372的专栏-CSDN博客 2020年6月2日 - Spring Cloud Gateway_网关_从零开始_搭建之路 1.网关…异常信息:java._lang.IllegalArgumentException: Unable…_Go_语言 R语言 Assembly language Swift Ruby MATLAB … Golang 性能优化实战 | 码农网 2020年5月11日 - 在golang 中,遇到不需要解析的 json 数据,可以将其类型声明为 json.RawMessage . 即,可以将上述 2 个方法优化为 type _Gateway_ReqBody struct { Heade… Golang - 连接数据库| 阿里云 2020年5月29日 - 本文介绍如何使用_Golang_连接AnalyticDB for MySQL。 …//理论上,ConnMaxLifetime越短,_从0开始_创建连接的 micro_gateway_ 一些参考资料 - 荣锋亮 - 博客园 2020年5月31日 - micro_gateway_ 是apigee 开源的自家edgemicro gateway,…10.golang_几个不错的运行_golang 应用为系统服务的…@ 鱼络您好,从官方文档的配置说明了解到… _Golang_热更新原理 – CoLaBug.com 2020年5月27日 - Golang_如何做热更新 主动流量调度 一般的做法是 Api_Gateway + CD, 发布的时候…3. 将socket“交给”新进程,新进程开始接受新连接请求 4. 旧进程处理… go - 504 Gateway Time-out on GRPC - Stack Overflow 2020年5月26日 - handshake, response: &quot;HTTP/1.0 504 Gateway Time-out\\r\\nConnection: …But when i learn rpc in golang, use my intranet ip in the server an… _Golang_、python中登录开源中国,并发表博客? 400 报错-问答-阿里云… 2020年6月1日 - {“channelstr”:”从安全型到内存型、从进阶型到入门型的云服务器”,”tce_rule…api_gateway_”,”title”:”api网关”},{“channelstr”:”从代码到应用的持续集… 基于_go_语言的开源网关GokuAPI_Gateway_CE部署指南__Go__调试吧 2020年5月22日 - 1.控制台docker:https://hub.docker.com/r/eolinker/goku-api-_gateway_-ce-console 2.网关节点docker:https://hub.docker.com/r/eolinker/goku-api-_gat_… go - 504 Gateway Time-out on GRPC - Stack Overflow 2020年5月26日 - handshake, response: &quot;HTTP/1.0 504 Gateway Time-out\\r\\nConnection: …But when i learn rpc in golang, use my intranet ip in the server an… _Golang_、python中登录开源中国,并发表博客? 400 报错-问答-阿里云… 2020年6月1日 - {“channelstr”:”从安全型到内存型、从进阶型到入门型的云服务器”,”tce_rule…api_gateway_”,”title”:”api网关”},{“channelstr”:”从代码到应用的持续集… 几种部署GokuAPI_Gateway_的方式,最快一分钟可使用上网关__Go__调试吧 2020年5月22日 - Goku API Gateway (中文名:悟空 API 网关)是一个基于 Golang 开发的运行在企业系统服务边界上的微服务网关。当您构建网站、App、IOT甚至是开放API交易… prometheus client__golang_使用_园荐_博客园 2020年5月20日 - 2017-11-04 11:07 − 针对_golang_的 kafka client 有很多开源package,例如sarama…子包(promhttp)允许通过HTTP来暴露注册的metric或将注册的metric推… [求职] Golang/ Python /DevOps/运维/网络 4 年经验 求职远程兼职… 2020年5月19日 - 使用golang,python 等语言进行不同组件的开发; 使用Grpc,NATS 等技术进行组件间的调度联动,使用 grpc-gateway 进行 restapi 的接口实现; * 产品基于 k… micro_gateway_-core 简单试用 - 荣锋亮 - 博客园 2020年5月30日 - micro_gateway_-core 是micro_gateway_ 的一个组件,主要…7.基于_golang_的一些表达式引擎 8._golang_几个不错…@ 鱼络您好,从官方文档的配置说明了解到的,… _Gateway_全局异常 - 编程客栈 2020年5月28日 - Golang Erlang 其它脚本 网页制作 HTML/Xhtml html5 CSS XML/XSLT Dreamweaver…这篇文章主要介绍了Spring Cloud _Gateway_全局通用异常处理的实现,文… php-_Gateway_Worker 使用大佬写的 global-timer 包做进程间创建… 2020年5月29日 - 从00:00:00开始要求有start stop和reset功能使用timer类解决![图片说明](http:…//_golang_.org/doc/go1.6#runtime, 4th paragraph), where the Window… 使用云效将_Golang_、Node.js、Python和PHP应用部署至EDAS_使用常见… 2020年5月14日 - {“channelstr”:”从安全型到内存型、从进阶型到入门型的云服务器”,”tce_rule…api_gateway_”,”title”:”api网关”},{“channelstr”:”从代码到应用的持续集… Golang 消费 Restful Api_neweastsun的专栏-CSDN博客 2020年5月19日 - _Golang_使用http包调用Restful API,http给服务器发送请求并获得响应,响应格式可能为JSON、XML。我们这里使用json类型作为返回值。为了演示这里使用http… 通过Nginx请求到api服务器(Golang)失败并返回404错误-问答-阿里云… 2020年5月23日 - ・client: react/axios ・api: golang/gin ・web server: nginx ・db…Also when accessing to actual deployed url, it returns 502 Bad Gateway 遇… 初入golang gRPC_wanmei002的博客-CSDN博客 2020年5月21日 - gateway/protoc-gen-grpc-gateway_go get -u github…_golang GRPC文档(1) go语言小白,最近开始接触grpc…我原以为从学校出来之后,除了找工作有测试… _golang__weichuangxxb的博客_BGBiao-CSDN博客 2020年5月30日 - AUBREY_CR7:请问下 自定义 exporter 和 push_gateway_ 应该如何选型?感谢感谢 kefu…CloudNative,Kubernetes,DevOps,SRE,热衷于使用_Golang_语言在整个工… SpringCloud项目从零开始(六)—msc-consumer调用msc-p…_CSDN博客 2020年5月14日 - 以后_Gateway_要向server拉取消费者实例 register-with-eureka: true #从eureka …_Golang_之消息队列——RabbitMQ的使用 消息队列的使用场景异步处理 … Grpc-Gateway - Grpc兼容HTTP协议文档自动生成网关 _HTTP_好机友 2020年5月15日 - 编写_gateway_服务 vim grpc__gateway_.go package main import ( “flag” “net/http” “log” “github.com/golang/glog” “golang.org/x/net/context” “githu… “study_golang_.com”的360移动权重查询结果 - 站长工具 2020年5月13日 - Macaron首页、文档和下载 Web 框架 Go语言中文网 Golang_中文… macaron 4 第10 Macaron首页、文档和下载 Web 框架 Go语言中文网 _Golang_中文… _gatew… 分别以google.golang.org/grpc和net/rpc简单理解RPC 2020年6月1日 - 特别提醒(踩坑后可以返回来再看):如果没有用go module模式,那么需要在src下手动创建google.golang.org目录并进入该目录手动执行git clone https://e.c… 使用go-micro 的时候 etcd,grpc-gateway 产生冲突 | Go 技术论坛 2020年5月23日 - golang.org/grpc@v1.27.0 运行grpc-gateway (http) 服务端,没问题。眼看…protoc –grpc-_gateway__out= 生成出来的 pb.go 代码需要 grpc 1.27.0,而 … _Golang_中Context包深入浅出__golang__混血王子的博客-CSDN博客 2020年5月15日 - golang 中想要并发运行业务时会直接开goroutine,关键…方式访问,v3则也可以通过部署一个grpc-_gateway_实现…_从0开始_写前端UI框架:概述 缘起经常听说… [求职贴] Golang/Python/DevOps/运维/网络 4年经验 求职远程兼职/… 2020年5月20日 - 使用java,golang,python等语言进行不同组件的开发; 使用Grpc,NATS等技术进行组件间的调度联动,使用grpc-_gateway_进行restapi的接口实现; * 产品基于kub… golang swagger注解说明__golang__mctlilac的博客-CSDN博客 2020年5月18日 - golang_上传excel文件api实例 _golang post json数据…_gateway_和 swagger -ui界面 文章目录本文目的:集成…好了我的青春痘——这玩意从高一下半学期就开始… springcloud项目优雅重启(一):问题和gateway-ribbon流程_JAVA… 7天前 - spring.cloud.gateway.discovery.locator.enabled: …·_从零开始_实现一个消息提示框 ·学习笔记之Lambda表达式…·_golang_数据结构 ·#_golang_数据结… 关于_golang_在字符串中替换网址的实现? 400 报错-问答-阿里云开发… 2020年6月2日 - {“channelstr”:”从安全型到内存型、从进阶型到入门型的云服务器”,”tce_rule…api_gateway_”,”title”:”api网关”},{“channelstr”:”从代码到应用的持续集… _Golang_下的unicode与字符编码__golang_,unicode_weichuan…_CSDN博客 2020年5月30日 - 请问下 自定义 exporter 和 push_gateway_ 应该如何…背景: 在我们使用_Golang_进行开发过程中,总是绕不开…而 Go 语言从 1.10 版本开始,已经对 Unicode 的… _golang_路由拦截器_向宪章的博客-CSDN博客 1天前 - 在golang_中实现路由拦截有多种方法,比如一般来说…双十一大考蚂蚁金服很早开始关注 service mesh,并在…615 grpc开发(9)-grpc服务开发-grpc-_gateway… spring boot - API Gateway for gRpc services - Stack Overflow 2020年5月27日 - 1How to access request headers in grpc service proxied by. grpc-gateway in golang _0_GRPC REST channel implementationHot Network Questions Ho… 通过grpc-_gateway_对外提供基于grpc的http接口API__Go__调试吧 2020年5月29日 - grpc优点不再多叙述,但如何对外提供Restful接口的,而又不希望重复开发相同的功能可以使用grpc-gateway_将grpc转换为对外的Restful API。 安装 _go get -… KongAPI_gateway_的部署及使用__Go__调试吧 2020年6月2日 - 我实践了一下这个API gateway,然后发现确实是不错的…·GOVSCODE环境搭建 ·野子数据分析概述 ·_Golang_中 _Golang_toml完全解析示例_布史之铭-CSDN博客__golang_tomlmap类型 2020年5月13日 - _Golang_实现简化版解析TOML格式 TOML的由来配置文件的使用由来已久,从.ini、XML…源码地址loraserver lorawan netserver,和 _gateway_通信 与app serve…","link":"/2020/06/11/golang%20gateway%20%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"},{"title":"golang regexp.Compile 正则表达式","text":"_Golang_中的_RegExp正则表达式_用法指南 - sunsky303 - 博客园 2019年6月19日 - (相当于 \\x07) 注意:正则表达式_中不能使用 \\b 匹配退格符,因为 \\b 被用来…123 _Go. // 查找连续的小写字母 reg := _regexp_.Must_Compile_([a-z]+`… Golang 正则表达式(regexp) - weixin_33916256的博客 - CSDN博客 2019年2月22日 - Go内置了(regexp_包)对_正则表达式_的支持,这里是一般的_正则表达式_常规用法的例子。…reg = _regexp.Must_Compile_((\\w+),(\\w+)) src := []byte(“Golang,… Golang 正则表达式(regexp) - 无风的雨_CSDN博客 2019年2月22日 - Go_内置了(_regexp_包)对_正则表达式的支持,这里是一般的_正则表达式_常规用法的例子。示例: packagemainimport( “bytes” “fmt” “… golang 正则表达式 - 浊浊然 - 博客园 2015年4月20日 - golang 正则表达式 package main import “bytes” import “fmt” import “regexp…r = regexp.Must_Compile_(“p([a-z]+)ch”) fmt.Println(r) //regexp 包… golang 中_regexp_包用法 - Go语言中文网 - _Golang_中文社区 2014年11月10日 - 本文转自Go_love博客:http://www.cnblogs.com/_go_love/p/3270918.html _regexp …// Compile 用来解析正则表达式 expr 是否合法,如果合法,则返回一个 Re… Golang 正则表达式(regexp) - _golang_开发笔记 - SegmentFault 思否 2019年2月23日 - _Go_内置了(_regexp_包)对_正则表达式_的支持,这里是一般的_正则表达式_常规用法的例子。 示例: {代码…} 小结: 1、 {代码…} 可用一下代替 {代码…} 两者… Golang 正则表达式 - 简书 golang_正则使用总结 //MatchString返回的第一个参数是bool类型即匹配结果,第二个…_Compile_函数或Must_Compile_函数是将_正则表达式_进行编译,返回优化的 _Regexp 结构体 … Golang _正则_匹配 – _regexp__园荐_博客园 2019年5月28日 - Golang 正则_匹配 – _regexp 2019-05-28 20:07 − 匹配特殊字符 ``` //re :=regexp.Must_Compile_(“[~!@#$%^&amp;*(){}|\\/+\\-【】:&quot;?’:;‘… 004-golang _正则表达式_的使用 - 云+社区 - 腾讯云 2018年9月28日 - 004-golang 正则表达式_的使用 2018-09-28阅读600 获取包名 func my_Regexp(text string,regs string) string { reg := regexp.Must_Compile_(regs) arr … golang 正则表达式 - 脚本之家 2019年7月21日 - 脚本之家收集整理的这篇文章主要介绍了golang 正则表达式,脚本之家小编觉得挺不…re,_ := regexp.Compile(a=(\\d+),b=(\\d+)) c := re.ReplaceAll… _golang_使用_正则表达式_使用-xingzhehxiang的博客-51CTO博客 2019年7月30日 - -1)) reg = regexp.Must_Compile_([a-zA-Z0-9]) fmt.Println(reg.Find…d:_go_projects\\src\\day1_正则_\\exp2&gt;go run main.go[$ # % * &amp; @ @ … _golang_使用_正则表达式_解析网页__Golang__脚本之家 2015年3月20日 - 这篇文章主要介绍了_golang_使用_正则表达式解析网页,需要的朋友可以参考下… 这篇文章主要介绍了_golang_使用_正则表达式_解析…re, = regexp.Compile(“]… 用Golang_替换_正则表达式 - IT屋-程序员软件开发技术分享社区 2018年5月2日 - var re = regexp.Must_Compile_((^|[^_])\\bproducts\\b([^_]|$)) s…本文地址:IT屋 » 用_Golang_替换_正则表达式_regex go 将代字符展开到主目录 … regex-Must_Compile_中的_Golang正则表达式_参考(查找重复字符… 2016年4月10日 - Go的regexp_与Python或Java有所不同。请访问play._golang.org/p/4kDJMbT1jH,…dqce48404 Must_Compile_类似于Compile,但如果无法解析该表达式,则会发生恐… Golang_系列文章:_正则表达式 2018年9月7日 - 在上面几段代码中,都使用了regexp.Compile(regexpString)方法对正则字符串进行预…关于正则表达式,就先写这么多,其实还有很多内容,后续再做总结。 Go… golang 正则表达式 | 学步园 2013年10月23日 - func main() { re, _ := regexp.Compile(a=(\\d+),b=(\\d+)) c…转载请注明: golang 正则表达式 | 学步园 +复制链接抱歉!评论已关闭.书签… golang-正则表达式 | Golang | 张文兵博客 2019年3月8日 - 正则表达式_是对字符串操作的一种逻辑公式,就是用事先定义好的一些特定字符、及…reg = _regexp.Must_Compile_(\\Q_Go_.\\E) fmt.Printf(“%q\\n”, reg.Find… 求助:GO_语言的_正则表达式_问题 - _Golang 中国 2019年11月14日 - 我写了一个正则表达式_”^((?!等于).)$“,目的是让字符串任何位置有“等于”不匹配,用的是系统_regexp_包。reg := _regexp.Must_Compile_(“^((?!等于).)$”… regex-获取_Golang正则表达式_中括号内的所有子字符串——CSDN问答… 2016年11月14日 - 获取Golang正则表达式_中括号内的所有子字符串 I want to get all the sub…{ var re = _regexp.Must_Compile_(\\((.*?)\\)) var str = `foo(bar)… _golang正则表达式_示例 - ByteLang字节社 2017年3月1日 - 标签:golang,正则表达式// 示例 func main() { text := Hello 世界!123 Go. // 查找连续的小写字母 reg := regexp.Must_Compile_([a-z]+) fmt… Golang 正则表达式(regexp)_weixin_33904756的博客-CSDN博客 2019年2月22日 - Go_内置了(_regexp_包)对_正则表达式_的支持,这里是一般的_正则表达式_常规用法的例子。示例:… _Go_内置了(_regexp_包)对_正则表达式_的支持,这里是一般的_正则表… 基础知识 - Golang 中的正则表达式 - GoLove - 博客园 2013年8月19日 - (相当于 \\x07) 注意:正则表达式_中不能使用 \\b 匹配退格符,因为 \\b 被用来…123 _Go. // 查找连续的小写字母 reg := _regexp_.Must_Compile_([a-z]+`… Golang 正则表达式(regexp)_weixin_34179968的博客-CSDN博客 2019年2月22日 - Go_内置了(_regexp_包)对_正则表达式_的支持,这里是一般的_正则表达式_常规用法的例子。示例:… _Go_内置了(_regexp_包)对_正则表达式_的支持,这里是一般的_正则表… Golang 正则表达式(regexp) - weixin_34239592的博客 - CSDN博客 2019年2月22日 - Go内置了(regexp_包)对_正则表达式_的支持,这里是一般的_正则表达式_常规用法的例子。…reg = _regexp.Must_Compile_((\\w+),(\\w+)) src := []byte(“Golang,… Golang 正则表达式(regexp)_weixin_33735077的博客-CSDN博客 2019年2月22日 - Go_内置了(_regexp_包)对_正则表达式_的支持,这里是一般的_正则表达式_常规用法的例子。示例:… _Go_内置了(_regexp_包)对_正则表达式_的支持,这里是一般的_正则表… _Golang_中的_RegExp正则表达式_用法指南_dianfu2892的博客-CSDN博客 2019年6月19日 - (相当于 \\x07) 注意:正则表达式_中不能使用 \\b 匹配退格符,因为 \\b 被用来…123 _Go. // 查找连续的小写字母 reg := _regexp_.Must_Compile_([a-z]+`… _Golang_中的_正则表达式___golang__菜的抠脚的博客-CSDN博客 2017年4月12日 - (相当于 \\x07) 注意:正则表达式_中不能使用 \\b 匹配退格符,因为 \\b 被用来…reg = _regexp.Must_Compile_(\\Q_Go_.\\E) fmt.Printf(“%q\\n”, reg.FindAll… Golang 正则表达式 - 寻觅beyond - 博客园 2018年6月11日 - Golang 正则表达式 go语言的_正则表达式匹配,可以使用go语言的regexp包。 go语言…demo, _ := _regexp.Compile(foo) fmt.Println(demo.FindStringSub… _golang_使用_正则表达式_使用 - Go语言中文网 - _Golang_中文社区 2019年7月30日 - (s1, -1)) reg = regexp.Must_Compile_([a-z]) fmt.Println(reg.Find…查看原文:_golang_使用_正则表达式_使用入群交流(和以上内容无关):加入Go大咖交流… _golang正则表达式_的使用详解_TigerwolfC的博客-CSDN博客 2018年11月24日 - 使用正则表达式_需引入”_regexp“包,通常还需与”strings”包配合使用,推荐一篇《Go strings 字符串处理包常用方法详解》链接地址 本文主要介绍_regexp_包下…","link":"/2020/06/04/golang%20regexp.Compile%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"golang 正则表达式 过滤手机号带有字符串，特殊符号","text":"过滤手机号带有字符串，特殊符号问题 123456func findNum(mobile string) string { reg := regexp.MustCompile(`[\\d]+`) allString := reg.FindAllString(mobile, -1) arrString := strings.Join(allString , &quot;&quot;) return arrString}","link":"/2020/06/04/golang%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%20%E8%BF%87%E6%BB%A4%E6%89%8B%E6%9C%BA%E5%8F%B7%E5%B8%A6%E6%9C%89%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/"},{"title":"macaca doctor之Android证书Not accepted Android SDK license agreements","text":"简单介绍在搭建macaca环境的过程中出现关于Android的”Not accepted Android SDK license agreements：…..”问题。 解决如下：1、找到环境变量中”ANDROID_HOME”使用”which Android”找到目录路径 2、创建license mkdir “/Users/april_chou/Library/Android/sdk/licenses” echo -e “\\n8933bad161af4178b1185d1a37fbf41ea5269c55” &gt; “/Users/april_chou/Library/Android/sdk/licenses/android-sdk-license” echo -e “\\n84831b9409646a918e30573bab4c9c91346d8abd” &gt; “/Users/april_chou/Library/Android/sdk/licenses/android-sdk-preview-license”","link":"/2020/04/09/macaca-doctor%E4%B9%8BAndroid%E8%AF%81%E4%B9%A6Not-accepted-Android-SDK-license-agreements/"},{"title":"springboot + spring security验证token进行用户认证","text":"核心组件SecurityContextHolderSecurityContextHolder是spring security最基本的组件。用于存储安全上下文（security context）的信息。当前操作的用户是谁，该用户是否已经被认证，他拥有哪些角色权限等这些都被保存在SecurityContextHolder中。SecurityContextHolder默认是使用ThreadLocal实现的，这样就保证了本线程内所有的方法都可以获得SecurityContext对象。 可以通此方法过来获取当前操作用户信息： SecurityContextHolder.getContext().getAuthentication().getPrincipal(); 默认返回的对象是UserDetails实例，其中包含了username，password和权限等信息，当然，我们也可以通过实现这个接口自定义我们自己的UserDetails实例，给我们自己的应用使用，以符合需要的业务逻辑。比如下面只对token进行操作就可以吧token作为属性放入UserDetails实现类中。 AuthenticationAuthentication是Spring Security方式的认证主体。 &lt;1&gt; Authentication是spring security包中的接口，直接继承自Principal类，而Principal是位于java.security包中的。可以见得，Authentication在spring security中是最高级别的身份/认证的抽象。&lt;2&gt; 由这个顶级接口，我们可以得到用户拥有的权限信息列表，密码，用户细节信息，用户身份信息，认证信息。authentication.getPrincipal()返回了一个Object，我们将Principal强转成了Spring Security中最常用的UserDetails，这在Spring Security中非常常见，接口返回Object，使用instanceof判断类型，强转成对应的具体实现类。接口详细解读如下： getAuthorities()，权限信息列表，默认是GrantedAuthority接口的一些实现类，通常是代表权限信息的一系列字符串。 getCredentials()，密码信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全。 getDetails()，细节信息，web应用中的实现接口通常为 WebAuthenticationDetails，它记录了访问者的ip地址和sessionId的值。 getPrincipal()，最重要的身份信息，大部分情况下返回的是UserDetails接口的实现类，也是框架中的常用接口之一。 AuthenticationManagerAuthenticationManager（接口）是认证相关的核心接口，也是发起认证的出发点，因为在实际需求中身份认证的方式有多种，一般不使用AuthenticationManager，而是使用AuthenticationManager的实现类ProviderManager ,ProviderManager内部会维护一个List列表，存放多种认证方式，实际上这是委托者模式的应用（Delegate）。也就是说，核心的认证入口始终只有一个：AuthenticationManager，不同的认证方式对应不同的AuthenticationProvider。 总结： SecurityContextHolder：存放身份信息的容器 Authentication：用户信息的抽象 AuthenticationManager：身份认证器 认证流程1、通过过滤器过滤到用户请求的接口，获取身份信息（假如有多个认证方式会配置provider的顺序） 2、一般将身份信息封装到封装成Authentication下的实现类UsernamePasswordAuthenticationToken中 3、通过AuthenticationManager 身份管理器（通过配置找到对应的provider）负责验证这个UsernamePasswordAuthenticationToken 4、认证成功后（认证逻辑一般在service中），AuthenticationManager身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除）Authentication实例。 5、SecurityContextHolder安全上下文容器将第2步填充了信息的UsernamePasswordAuthenticationToken，通过SecurityContextHolder.getContext().setAuthentication(…)方法，设置到其中来建立安全上下文（security context)。 结合springboot实现对token验证1、场景拦截api/的所有接口进行验证，验证token用户与id用户是否一致，不一致或token过期则没有权限访问 2、实现1、添加security相关依赖：spring-boot-starter-security spring-security-oauth2 2、全局配置类，根据不同需求配置不同的过滤器和provider（代码片段） 2. @EnableWebSecurity 3. public class SecurityConfiguration extends WebSecurityConfigurerAdapter { 6. @Autowired 7. private RedisTemplate redisTemplate; 9. @Autowired 10. private SecurityOrgPeopleMapper securityOrgPeopleMapper; 12. @Autowired 13. private ImCheckTokenFactory imCheckTokenFactory; 16. // oauth2 server 18. @Override 19. protected void configure(AuthenticationManagerBuilder auth) { 20. addProvider(auth); 21. } 23. //指定provider 24. private void addProvider(AuthenticationManagerBuilder auth) { 25. auth.authenticationProvider(imAuthenticationProvider()); 26. } 28. @Override 29. protected void configure(HttpSecurity http) throws Exception { 30. // 请求过滤 对api/对所有接口都验证 31. http 32. .authorizeRequests() 33. .antMatchers(&quot;/api/**&quot;).access(&quot;@permissionChecker.hasPermission(authentication,request)&quot;) 34. .anyRequest().authenticated(); 36. registerFilter(http); 37. } 39. //指定filter过滤器 40. private void registerFilter(HttpSecurity http) throws Exception { 41. http 42. .addFilterBefore(new ImAuthenticationFilter(authenticationManager()), UsernamePasswordAuthenticationFilter.class); 43. } 46. private ImAuthenticationProvider imAuthenticationProvider() { 47. return new ImAuthenticationProvider(imCheckTokenFactory, securityOrgPeopleMapper); 48. } 51. }``` 过滤器： ```1. public class ImAuthenticationFilter extends GenericFilterBean { 3. private AuthenticationManager authenticationManager; 5. public ImAuthenticationFilter(AuthenticationManager authenticationManager) { 6. this.authenticationManager = authenticationManager; 7. } 9. @Override 10. public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { 12. // 其他过滤器已经认证通过了 13. Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); 14. if (authentication != null &amp;&amp; authentication.isAuthenticated()) { 15. chain.doFilter(request, response); 16. return; 17. } 18. HttpServletRequest httpRequest = asHttp(request); 19. HttpServletResponse httpResponse = asHttp(response); 21. //获取接口中都用户信息 22. String userId = obtainUserId(httpRequest); 23. String token = obtainToken(httpRequest); 24. String client = obtainClient(httpRequest); 26. try { 27. checkToken(token); 28. imProcessTokenAuthentication(Integer.parseInt(userId), token, client); 29. chain.doFilter(request, response); 30. } catch (UserAuthenticationException userAuthenticationException) { 31. logger.warn(userAuthenticationException.getMessage()); 32. httpResponse.setStatus(userAuthenticationException.getStatus()); 33. } catch (AuthenticationException authenticationException) { 34. chain.doFilter(request, response); 35. } 37. } 39. private String obtainToken(HttpServletRequest request) { 40. String tokenParameter = &quot;F-Session&quot;; 41. String token = request.getHeader(tokenParameter); 42. if (Objects.isNull(token)) { 43. token = request.getParameter(tokenParameter); 44. } 45. return token; 46. } 48. private String obtainUserId(HttpServletRequest request) { 49. String userIdParameter = &quot;userId&quot;; 50. return request.getParameter(userIdParameter); 51. } 53. private String obtainClient(HttpServletRequest request) { 54. String clientParameter = &quot;client&quot;; 55. return request.getParameter(clientParameter); 56. } 58. private HttpServletRequest asHttp(ServletRequest request) { 59. return (HttpServletRequest) request; 60. } 62. private HttpServletResponse asHttp(ServletResponse response) { 63. return (HttpServletResponse) response; 64. } 66. private void checkToken(String token) { 67. if (StringUtils.isEmpty(token)) { 68. throw new UserAuthenticationException(SecurityHttpServletResponse.TOKEN_INVALID, &quot;authenticate.fail&quot;); 69. } 70. } 72. //im//将用户信息封装到ImTokenAuthentication（自定义用户信息类）中 73. private void imProcessTokenAuthentication(Integer userId, String token, String client) { 75. Authentication resultOfAuthentication = imTryToAuthenticateWithToken(userId, token, client); 76. SecurityContextHolder.getContext().setAuthentication(resultOfAuthentication); 77. } 79. private Authentication imTryToAuthenticateWithToken(Integer userId, String token, String client) { 80. ImTokenAuthentication imTokenAuthentication = new ImTokenAuthentication(userId, token, client); 81. return tryToAuthenticate(imTokenAuthentication); 82. } 85. private Authentication tryToAuthenticate(Authentication requestAuthentication) throws AuthenticationException { 86. //找到配置的authenticationManager实现类provider进行验证返回充满信息的Authentication 87. Authentication responseAuthentication = authenticationManager.authenticate(requestAuthentication); 88. if (responseAuthentication == null || !responseAuthentication.isAuthenticated()) { 89. throw new InternalAuthenticationServiceException(&quot;Unable to authenticate for provided credentials&quot;); 90. } 91. logger.debug(&quot;User successfully authenticated&quot;); 92. return responseAuthentication; 93. } 94. }``` 自定义authentication（一般继承UsernamePasswordAuthenticationToken，此项目是在前任的项目基础上写的） ```1. public class ImTokenAuthentication extends TokenAuthenticationToken { 3. private Integer userId; 4. private String client; 6. public ImTokenAuthentication(Integer userId, String token, String client) { 7. super(token); 8. this.userId = userId; 9. this.client = client; 10. } 12. public ImTokenAuthentication(Integer userId, String token, String client, SecurityUserDetails details) { 13. super(token); 14. this.userId = userId; 15. this.client = client; 16. setDetails(details); 17. } 19. public Integer getUserId() { 20. return userId; 21. } 23. public String getClient() { 24. return client; 25. } 26. }``` provider ```1. public class ImAuthenticationProvider implements AuthenticationProvider { 3. private SecurityOrgPeopleMapper securityOrgPeopleMapper;//根据项目需求注入 5. private ImCheckTokenFactory imCheckTokenFactory;//根据项目需求注入 7. public ImAuthenticationProvider(ImCheckTokenFactory imCheckTokenFactory, SecurityOrgPeopleMapper securityOrgPeopleMapper) { 8. this.securityOrgPeopleMapper = securityOrgPeopleMapper; 9. this.imCheckTokenFactory = imCheckTokenFactory; 10. } 13. @Override 14. public Authentication authenticate(Authentication authentication) throws AuthenticationException { 15. //自定义的装载用户信息的类 16. ImTokenAuthentication imTokenAuthentication = (ImTokenAuthentication) authentication; 17. //获取在过滤器中放入authentication的用户信息 18. String token = authentication.getPrincipal().toString(); 19. Integer userId = Integer.parseInt(imTokenAuthentication.getUserId().toString()); 20. String client = imTokenAuthentication.getClient(); 22. //获取验证token所在的sevice 23. ImCheckTokenService imCheckTokenService = imCheckTokenFactory.getService(client); 25. if (Objects.isNull(imCheckTokenService)) { 26. authentication.setAuthenticated(false); 27. throw new UserAuthenticationException(SecurityHttpServletResponse.TOKEN_INVALID, &quot;authenticate.fail&quot;); 28. } 29. //验证token逻辑 30. Object object = imCheckTokenService.checkToken(userId, token); 31. if (Objects.isNull(object)) { 32. throw new BadCredentialsException(&quot;&quot;); 33. } 35. OrgPeople orgPeople = securityOrgPeopleMapper.getPeopleBySystemUserId(userId); 37. imTokenAuthentication.setDetails(new SecurityUserDetails((Account) ； 38. //在servcice中验证不通过就已经抛出异常了，此处正常运行则设置验证通过 39. authentication.setAuthenticated(true); 40. return authentication; 41. } 43. @Override 44. public boolean supports(Class&lt;?&gt; authentication) { 45. return (ImTokenAuthentication.class.isAssignableFrom(authentication)); 46. } 47. }``` ### &lt;a name=&quot;t8&quot;&gt;&lt;/a&gt;&lt;a name=&quot;t8&quot;&gt;&lt;/a&gt;参考： [spring security架构](https://zshipu.com/t?url=http://www.importnew.com/26712.html) [https://www.cnblogs.com/shiyu404/p/6530894.html](https://zshipu.com/t?url=https://www.cnblogs.com/shiyu404/p/6530894.html) [https://blog.csdn.net/ro_wsy/article/details/44341547](https://zshipu.com/t?url=https://blog.csdn.net/ro_wsy/article/details/44341547) [官方文档](https://zshipu.com/t?url=https://docs.spring.io/spring-security/site/docs/4.2.2.RELEASE/reference/htmlsingle/)","link":"/2020/06/09/springboot%20+%20spring%20security%E9%AA%8C%E8%AF%81token%E8%BF%9B%E8%A1%8C%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/"},{"title":"公众号","text":"","link":"/2020/04/19/test/"},{"title":"vert x入门系列: 02 vertx的Http服务器入门","text":"vert.x是什么 事件驱动，非阻塞 基于多语言实现 响应式编程 快速入门","link":"/2020/03/26/vert-x%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97-02-vertx%E7%9A%84Http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%A5%E9%97%A8/"},{"title":"vert x入门系列: 01 reactive编程介绍","text":"80年度：90年度：oop 00年度：mvc 10年度：Reactive Reactive特点一、事件驱动没有轮询消耗CPU 二、异步处理 数据交互 响应时间 维护成本 数据的体量","link":"/2020/03/26/vert-x%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97-01-reactive%E7%BC%96%E7%A8%8B%E4%BB%8B%E7%BB%8D/"},{"title":"vert x入门系列: 03 vertx详细介绍","text":"1. 概述在本文中，我们将讨论Vert.x，介绍其核心概念，并使用它创建一个简单的 RESTfull Web 服务。 我们将首先介绍有关工具包的基本概念，慢慢前进到 HTTP 服务器，然后构建 RESTfull 服务。 2. 关于顶点Vert.x 是 Eclipse 开发人员的开源、反应式和多面体软件开发工具包。 反应式编程是一种编程范例，与异步流相关联，这些异步流响应任何更改或事件。 同样，Vert.x 使用事件总线，与应用程序的不同部分通信，并在事件可用时异步传递给处理程序。 我们称之为多面体，因为它支持多个 JVM 和非 JVM 语言，如 Java、Groovy、Ruby、Python 和 JavaScript。 3. 设置要使用 Vert.x，我们需要添加 Maven 依赖项： 123456789&lt;dependency&gt;&lt;groupId&gt;io.vertx&lt;/groupId&gt;&lt;artifactId&gt;vertx-core&lt;/artifactId&gt;&lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt; 可在此处找到依赖项的最新版本。 3. 韦尔蒂克斯Verticles 是 Vert.x 引擎执行的代码段。该工具包为我们提供了许多抽象的格威乐类，可以根据需要扩展和实现。 作为多面体，可以用任何支持的语言编写紫光片。应用程序通常由在同一 Vert.x 实例中运行的多个 verticles 组成，并使用事件总线的事件相互通信。 要在 JAVA 中创建一个维特，类必须实现_io.vertx.core.Verticle_接口或其任何子类。 4. 事件总线它是任何Vert.x应用的神经系统。 反应性，在收到消息或事件之前，它们一直处于休眠状态。通过活动总线相互通信。消息可以是从字符串到复杂对象的任何内容。 消息处理是理想的异步处理，消息排队到事件总线，并将控制权返回到发送方。后来，它去排队听的道。使用“未来”和“回调“方法发送响应。 5. 简单的顶点应用程序让我们创建一个简单的应用程序与verticle，并使用_顶点_实例部署它。为了创建我们的韵味，我们将扩展 为了创建我们的 verticle，我们将扩展_io.vertx.core.AbstractVerticle_类并重写_start（）_方法： 12345678910111213public class HelloVerticle extends AbstractVerticle {@Overridepublic void start(Future&lt;Void&gt; future) {LOGGER.info(&quot;Welcome to Vertx&quot;);}} 在部署 verticle 时，_顶点_实例将调用_start（）_方法。该方法采用_io.vertx.core.Future_作为参数，可用于发现该凉道异步部署的状态。 现在，让我们部署这些功能： 123456789public static void main(String[] args) {Vertx vertx = Vertx.vertx();vertx.deployVerticle(new HelloVerticle());} 同样，我们可以重写_AbstractVerticle_类中的_stop（）_方法，该方法将在关闭 verticle 时调用： 12345678@Overridepublic void stop() {LOGGER.info(&quot;Shutting down application&quot;);} 6. HTTP 服务器现在，让我们使用 verticle 启动 HTTP 服务器： 12345678910111213141516171819202122232425262728@Overridepublic void start(Future&lt;Void&gt; future) {vertx.createHttpServer().requestHandler(r -&gt; r.response().end(&quot;Welcome to Vert.x Intro&quot;);}).listen(config().getInteger(&quot;http.port&quot;, 9090),result -&gt; {if (result.succeeded()) {future.complete();} else {future.fail(result.cause());}});} 我们已经重写了_start（）_方法来创建一个 HTTP 服务器，并将请求处理程序附加到它。每次服务器收到请求时都会调用_请求Handler（）_方法。 最后，服务器绑定到端口，如果出现任何错误，无论连接或服务器启动是否成功_，AsyncResult_处理程序都传递给_listen（）_方法。 请注意_：config.getInteger（）_方法正在读取从外部_conf.json_文件加载的 HTTP 端口配置的值。 让我们测试我们的服务器： 12345678910111213141516171819202122@Testpublic void whenReceivedResponse_thenSuccess(TestContext testContext) {Async async = testContext.async();vertx.createHttpClient().getNow(port, &quot;localhost&quot;, &quot;/&quot;, response -&gt; {response.handler(responseBody -&gt; {testContext.assertTrue(responseBody.toString().contains(&quot;Hello&quot;));async.complete();});});} 对于测试，让我们使用顶点单元和 JUnit： 123456789101112&lt;dependency&gt;&lt;groupId&gt;io.vertx&lt;/groupId&gt;&lt;artifactId&gt;vertx-unit&lt;/artifactId&gt;&lt;version&gt;3.4.1&lt;/version&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 我们可以在这里得到最新版本。 在单元测试的_setup（）_方法中，在_顶点_实例中部署 verticle： 12345678910111213@Beforepublic void setup(TestContext testContext) {vertx = Vertx.vertx();vertx.deployVerticle(SimpleServerVerticle.class.getName(),testContext.asyncAssertSuccess());} 同样，在_@AfterClass拆解（）_方法中闭合_了顶点_实例： 12345678@Afterpublic void tearDown(TestContext testContext) {vertx.close(testContext.asyncAssertSuccess());} 请注意_，@BeforeClass setup（）_方法采用_TestContext_参数。这有助于控制和测试测试的异步行为。例如，威风部署是异步的，因此基本上，除非部署正确，否则我们无法测试任何内容。 我们有第二个参数到_部署Verticle（）_方法_，testContext.异步断言成功（）。__T_他用于了解服务器部署正确或发生任何故障。它等待_将来。_如果失败，它将通过测试。 7. RESTful 网络服务我们已经创建了一个 HTTP 服务器，现在让我们使用它来托管 RESTfull Web 服务。为此，我们需要另一个称为vertx-web 的Vert.x 模块。这为顶点核心之上的 Web 开发提供了许多附加功能。 让我们将依赖项添加到pom.xml： 1234567891011&lt;dependency&gt;&lt;groupId&gt;io.vertx&lt;/groupId&gt;&lt;artifactId&gt;vertx-web&lt;/artifactId&gt;&lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt; 我们可以在这里找到最新版本。 7.1.路由器_和_路由让我们_为_Web 服务创建路由器。此路由器将采取 GET 方法的简单路由，处理程序方法_get Artilces（）_： 1234567Router router = Router.router(vertx);router.get(&quot;/api/baeldung/articles/article/:id&quot;).handler(this::getArticles); _get她（）_方法是一种返回新_文章_对象的简单方法： 123456789101112131415161718192021private void getArticles(RoutingContext routingContext) {String articleId = routingContext.request().getParam(&quot;id&quot;);Article article = new Article(articleId,&quot;This is an intro to vertx&quot;, &quot;baeldung&quot;, &quot;01-02-2017&quot;, 1578);routingContext.response().putHeader(&quot;content-type&quot;, &quot;application/json&quot;).setStatusCode(200).end(Json.encodePrettily(article));} _路由器_在收到请求时，会查找匹配路由，并进一步传递请求。具有与其关联的处理程序方法的_路由_对请求执行总和。 在我们的案例中，处理程序调用_getA（）_方法。它将_路由上下文_对象作为参数接收。派生路径参数_ID，_并使用它创建_一个文章_对象。 在方法的最后一部分中，让我们调用_路由上下文_对象上的_响应（）_方法，并放置标头，设置 HTTP 响应代码，并使用 JSON 编码_的文章_对象结束响应。 7.2. 将_路由器_添加到服务器现在，让我们将上一节中创建的_路由器_添加到 HTTP 服务器： 123456789101112131415161718192021vertx.createHttpServer().requestHandler(router::accept).listen(config().getInteger(&quot;http.port&quot;, 8080),result -&gt; {if (result.succeeded()) {future.complete();} else {future.fail(result.cause());}}); 请注意，我们已经向服务器添加了请求处理程序（路由器：：接受）。 _这指示服务器在收到任何请求时调用_路由器_对象的_accept（）。 现在，让我们测试我们的 Web 服务： 1234567891011121314151617181920212223242526@Testpublic void givenId_whenReceivedArticle_thenSuccess(TestContext testContext) {Async async = testContext.async();vertx.createHttpClient().getNow(8080, &quot;localhost&quot;, &quot;/api/baeldung/articles/article/12345&quot;,response -&gt; {response.handler(responseBody -&gt; {testContext.assertTrue(responseBody.toString().contains(&quot;\\&quot;id\\&quot; : \\&quot;12345\\&quot;&quot;));async.complete();});});} 8. 包装顶点应用程序要将应用程序打包为可部署的 Java 存档 （.jar），我们使用 Maven Shade 插件_和执行_标记中的配置： 123456789101112131415161718192021222324252627282930&lt;configuration&gt;&lt;transformers&gt;&lt;transformerimplementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;&lt;manifestEntries&gt;&lt;Main-Class&gt;io.vertx.core.Starter&lt;/Main-Class&gt;&lt;Main-Verticle&gt;com.baeldung.SimpleServerVerticle&lt;/Main-Verticle&gt;&lt;/manifestEntries&gt;&lt;/transformer&gt;&lt;/transformers&gt;&lt;artifactSet /&gt;&lt;outputFile&gt;${project.build.directory}/${project.artifactId}-${project.version}-app.jar&lt;/outputFile&gt;&lt;/configuration&gt; 在清单条目_中_，Main-Verticle_指示应用程序的起点，_主类_是 Vert.x 类，它创建_顶点_实例并部署_主 Verticle。 9. 结论在本介绍性文章中，我们讨论了 Vert.x 工具包及其基本概念。了解如何创建和 HTTP 服务器，使用 Vert.x 和 RESTFull Web 服务，并演示如何使用_顶点单元_对其进行测试。 最后将应用程序打包为可执行的 jar。 代码段的完整实现可在GitHub 上完成。","link":"/2020/04/08/vert-x%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97-03-vertx%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/"},{"title":"zk 启动异常 Unable to read additional data from server sessionid 0x0, likely server has","text":"在zoo.cfg中配置了3台机器，但是只启动了1台，zookeeper就会认为服务处于不可用状态。zookeeper有个选举算法，当整个集群超过半数机器宕机，zookeeper会认为集群处于不可用状态。 …read additional data from server sessionid _0x0_问…_CSDN博客 2017年10月23日 - (localhost:2181):ClientCnxn$SendThread@1183] - Unable to read additional data from server sessionid 0x0, likely server has closed socket, cl… …read additional data from server sessionid 0x0…_CSDN博客 2018年10月15日 - 省略若干信息 [2018-06-15 11:33:26,693] INFO Unable to read additional data from server sessionid 0x0, likely server has closed socket, closi… …read additional data from server sessionid 0x0, li…_博客园 2017年5月19日 - Unable to read additional data from server sessionid 0x0, likely server has …(xx)的问题,登录上去也各种错误,zk_Server_.sh …server.1=xx:2888… …read additional data from server sessionid 0x0…_博客园 2015年5月25日 - (127.0.0.1:4083):ClientCnxn$SendThread@1098] - Unable to read additional data from server sessionid 0x0, likely server has closed socket, cl… Unable to read additional data from server sessionid-云栖社区… 2018年8月1日 - (localhost:2181):ClientCnxn$SendThread@1158] - Unable to read additional data from server sessionid 0x0, likely server has closed socket, cl… …Unable to read additional data from client sessionid _0x_00… 2018年4月18日 - - caught end of stream exception EndOfStreamException: Unable to read additional data from client sessionid 0x_6362257b44e5068d_, likely clien… …连接报错:Unable to read additional data from client_百度知道 2015年11月9日 - 回答：zookeeper服务端和客户端的jar版本不一致导致的 从zookeeper服务端安装目录的根目录复制zookeeper-xxx.jar到客户端即可 Unable to read additional data from client sessionid 0x0… 2017年9月28日 - read additional data from client sessionid 0x0, likely client has closed …zook 报错 Unable to read additional data from server sessionid 0… .c-group-top{margin-bottom:0!important;padding:10px 10px 11px;border-top:1px solid #E3E3E3;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3}.c-group-middle{margin-bottom:0!important;padding:0 10px 11px;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3}.c-group-bottom{padding:0 10px 10px;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3;border-bottom:1px solid #E3E3E3}.c-group-title{margin-bottom:5px;font-size:16px}.c-group{width:516px!important} …Unable to read additional data from server sessionid 0x0 2017年9月29日 - (localhost:2181):ClientCnxn$SendThread@1183] - Unable to read additional data from server sessionid 0x0, likely server has closed socket, cl… …Unable to read additional data from server sessionid 0x0… 2016年3月7日 - INFO [main-SendThread(192.168.1.42:2181):ClientCnxn$SendThread@1158] - Unable to read additional data from server sessionid 0x0, likely serv… Unable to read additional data from server sessionid… 2014年4月9日 - Unable to read additional data from server sessionid… Hi, I have a problem in zookeeper, after the session has been established, it will l… kafka集群,第二节点启动报错 - 小象问答-hadoop,spark,storm,R… 2016年6月26日 - [2016-06-25 12:25:25,014] INFO Unable to read additional data from server sessionid 0x0, likely server has closed socket, closing socket con… Solved: FATAL ha.ZKFailoverController: Unable to start fai… 2014年7月29日 - Unable to read additional data from server sessionid 0x0, likely server has closed socket, closing socket connection and attempting reconnec… [2016-11-21 14:50:22,326 - info nio_server_cxn.factory:0.0.0.0/… 2016年11月21日 - EndOfStreamException: Unable to read additional data from client sessionid 0x0, likely client has closed socket at org.apache.zookeeper.serv… EndOfStreamException: Unable to read additional data from… EndOfStreamException: Unable to read additional data from client sessionid 0x_13af9131eee0000, _likely client has closed socket at org.apache.zookeeper.server… …Unable to read additional data from client sessionid _0x_00… 2019年6月9日 - Unable to read additional data from client sessionid 0x_6362257b44e5068d, _likely client has closed socket at org.apache.zookeeper.server.NIO_S_… …to read additional data from server sessionid 0x0, likely… zookeeper报Unable to read additional data from server sessionid 0x0, likely server has closed socket, closing socket connection and attempting reconnect的解决… …Unable to read additional data from server sessionid 0x0… 2019年11月7日 - 0.1:2181):ClientCnxn$SendThread@1158] - Unable to read additional data from server sessionid 0x0, likely server has closed socket, closing s… …Unable to read additional data from client sessionid 0x… 2017年6月10日 - 查看zk日志,发现Unable to read additional data from client sessionid 0x_15c92bd1fca0003_, likely client has closed socket 原文:http://www.cnblo… …Unable to read additional data from client sessionid 0x… 2017年6月10日 - Master is initializing 查看zk日志,发现Unable to read additional data from client sessionid 0x_15c92bd1fca0003_, likely client has closed socke… …to read additional data from server sessionid 0x…_CSDN博客 2019年10月29日 - (127.0.0.1:4083):ClientCnxn$SendThread@1098] - Unable to read additional data from server sessionid 0x0, likely server has closed socket, cl… …read additional data from server sessionid _0x0_问题的解决… 2019年11月7日 - (172.0.0.1:2181):ClientCnxn$SendThread@1158] - Unable to read additional data from server sessionid 0x0, likely server has closed socket, cl… Unable to read additional data from client sessionid 0x0… 2015年5月8日 - EndOfStreamException: Unable to read additional data from client sessionid 0x0, likely client has closed socket (org.apache.zookeeper.server… …to read additional data from server sessionid 0x0, likely… 2017年5月19日 - 【Linux-zookeeper】Unable to read additional data from client sessionid 0x_00_, likely client has closed 阅读数 282 内部维护一个zookeeper集群… …to read additional data from server sessionid 0x…_博客园 2018年1月17日 - (10.10.16.151:2181):ClientCnxn$SendThread@1161] - Unable to read additional data from server sessionid 0x0, likely server has closed socket,… Unable to read additional data from client sessionid 0x0, l… 2019年1月21日 - EndOfStreamException: Unable to read additional data from client sessionid 0x_167e90bd7b1000b, _likely client has closed socket at org.apache… Unable to read additional data from client sessionid 0x0, l… 2019年3月28日 - Unable to read additional data from client sessionid 0x0, likely client has closed socket 1.有可能是因为zoo.cfg 中设置2000太小,设置成10000 … 报错:Unable to read additional data from client sessi…_博客园 2019年5月21日 - Unable to read additional data from client sessionid 0x_36ab52d38c20b20, _likely client has closed socket at org.apache.zookeeper.server.NIO_Se_… _Unabletoreadadditionaldatafrom_client_sessionid0x0,_li…_CSDN博客 2015年5月8日 - EndOfStreamException: Unable to read additional data from client sessionid 0x0, likely client has closed socket (org.apache.zookeeper.server…","link":"/2020/06/08/zk%20%E5%90%AF%E5%8A%A8%E5%BC%82%E5%B8%B8%20Unable%20to%20read%20additional%20data%20from%20server%20sessionid%200x0,%20likely%20server%20has/"},{"title":"与 REST API 相比，GraphQL 有哪些优势","text":"GraphQL 充当”编织”图层。 您拥有所有 API 的终结点，GraphQL 允许您同时调用多个终结点并将它们编织在一起。 GraphQL 方法的问题是，对于调用的每个终结点，它都会发出单独的请求/响应，而不是重用一个内部请求/响应。这是因为 GraphQL 基于旧 api 模式其中通信逻辑/数据绑定到业务逻辑创建交叉切割问题在你的架构中。 在 REST 中，您可以执行与 GraphQL 完全相同的操作，除非通过实现新的 API 模式并从业务逻辑中抽象通信逻辑。 这反过来又允许您实现API 链接（tm） 模式它做完全相同的事情与GraphQL（即编织api调用在一起），除了它使用一个请求/响应，从而节省大量的开销。 • 性能注意事项### 如果将常规 api 调用视为基准，GraphQL 将始终变慢（因为所有附加处理），因为它必须为每个附加资源分别进行 REQUEST/响应并将其编织在一起。 如果您考虑使用常规 api 调用旧的 api 模式与新的 api 模式，新的 api 模式将始终更快，因为它减少了代码膨胀和需要完成的处理量。 如果您考虑API 链接vs 图形 QL，API 链接会一直更快，因为它只需要一个请求/响应任何给定的呼叫 总之…GraphQL 是那些无法编写解决方案代码的用户的解决方案。而那些能够编写代码的人，拥有更可扩展、更快速的东西。不要粗鲁，但GraphQL只是猴子谁需要一个UI比devops或外壳的工具。 但不要听我的话…下面是一个 100K 请求，在 1.8ghz 计算机上完成 80 个并发，4 个内核和 1GB 专用 RAM，显示 API 的速度： 这是4700个reqs/秒的东西，实际上是一个树莓派的强大。","link":"/2020/06/25/%E4%B8%8E%20REST%20API%20%E7%9B%B8%E6%AF%94%EF%BC%8CGraphQL%20%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF/"},{"title":"为什么选择go-kit","text":"用什么框架之前团队有人仿造内部php框架开发过一个golang框架，有人提议将其直接拿过来用，有人说找个开源的如beego，gin，martini等这类流行的框架。我个人当时不太赞同使用自研的框架，主要有以下几点原因：1 文档少，漏洞多；2 需要投入人力去开发和维护，在当时人力极其紧缺的情况下是不现实的。另外，当时社区流行的框架也比较多，但是最终也没有选择那些流行的框架，主要是出于以下考虑：时间短，任务重，没有精力去辨别各个框架的优劣，适用场景以及性能如何。万一冒然使用一个还没有深入了解的框架，线上出问题咋办！尤其在当时系统频繁出问题，顶着各种压力的情况下。 虽说，我们无法在短时间内选一个合适的框架，但是能够确定的是：我们的需求是什么？ 1 只做高性能的HTTP 接口； 2 需要完整的单元测试体系； 3 可扩展，组件化； 基于以上三点，可以发现，go语言自带的特性就可以满足这些需求。于是，我们开始决定裸写。 此外，还有一个裸写的原因就是：没想好将来想要什么！当然，每个团队的背景不一样，业务场景也不同，在人力和时间充裕的情况下，还是需要选择一个合适的框架比较好。 裸写不是乱写裸写不是乱写。众说周知，用框架的其中一个好处就是保证团队代码风格的一致性，当然，目前市面上除了beego外的大多数框架，在代码风格上也并没有做约束。为了保证团队go代码的规范性和一致性，按照经典的分层架构和过往的经验，我们制定了一套go编程模版，由上向下：Router层，Service层，Dao层，还有贯穿这三层的Entity层，架构图如图1所示。其中，Router层负责处理与http handler逻辑,请求参数以及response格式相关的处理工作；Service层处理业务逻辑；Dao层处理数据访问逻辑；Entity层负责实体定义相关的逻辑，并贯穿Router，Service，Dao这三层。层与层之间不直接进行耦合，高层模块不直接依赖与低层模块，它们都依赖于所定义的抽象接口。 Booch曾经说过：“所有结构良好的面向对象构架都具有清晰的层次定义，每个层次通过一个定义良好的，受控的接口向外提供了一组内聚的服务”。 除此之外，我们还维护了一套常用的公共组件库，如：日志库，各种数据库driver等。 图1 分层构架如何重构当我们制定好编程模版后，我们就开始进行项目重构工作。由于，业务任务重，人手少，所以，重构的基本方向就是：根据业务需求，结合接口重要性进行重构。只有这样，才能保证在业务需求不停的情况下，进行系统重构。所以，在此期间，有相当长的一段时间是处于php＋go进行混合编程，混合部署的状态，如图2所示，重构完的接口，通过nginx代理到新接口，这种状态一直持续了一年。采取混合编程的思路在重构初期，可能会遇到一些问题，比如：同一段业务逻辑，需要用go写一遍，用php写一遍，无疑增加了一定的工作量，当然这也是避免不了的。 注意，有些同学在重构的时候容易走到一个误区：一口气把整个项目都重构了，或者说重构大部分内容。从时间成本和系统稳定性上来讲，这种方式风险比较大，不推荐。推荐的思路：一个接口一个接口进行重构。 图2 php＋go混合架构最终，为何想引入go-kit之前这套东西，基本上可以满足大部分的业务场景，但随着随着业务的发展，请求量越来越大，同时，有些请求的链路也变长了，为了继续保证接口的高并发和低时延特性，团队有少量业务开始尝试GRPC。根据测试，压测一个空接口，GRPC的性能大约是HTTP＋JSON的2～3倍，在这里推荐一个压测框架fperf 。 但是，针对GRPC的使用，不要盲目“求新”。以本人经验，HTTP＋JSON的模式基本上可以满足大部分的业务开发场景了，针对小部分对接口时延和并发量要求极高的场景可以考虑使用GRPC。因为，GRPC本身还是不利于调试，且会在一定程度上增加调用方和服务方的耦合性，所以，最后的传输协议和格式建议还是以HTTP＋JSON为主，以GRPC为辅。 另外，我们还是需要标准化一些中间件的使用，如回路断流，rate limit等，来保障系统的稳定性。这次的思考，时间比较充分，所以有精力去研究一些新的东西。最后，框架抉择的思路和最初是一样的，就是，明确我们的需求是什么？ 1 需要一个同时支持多种传输协议，不论是现在的http，thrift，grpc，还是将来出现的某种新协议，要有良好扩展性的框架； 2 框架本身和业务代码保持一种低耦合的状态； 3 需要一套通用的middleware，使之与http，grpc等传输协议无关。 目前市面上流行的框架都是围绕着http协议而展开的，包括gin，beego等。经调研，我们发现go-kit能够满足我们的需求。 go-kit本身不是一个框架，而是一套微服务工具集。其设计思想跟我们初期go编程模版制定的思想也算是不谋而合——分层设计，组件化，可扩展。go-kit的架构如图3所示，分为三层结构：Transport层，Endpoint层，Service层。Transport层主要负责与传输协议HTTP，GRPC，THRIFT等相关的逻辑，Endpoint层主要负责request／response格式的转换，以及公用拦截器相关的逻辑；Service层则专注于业务逻辑。go-kit除了经典的分层架构外，还在endpoint层提供了很多公用的拦截器，如log，metric，tracing，circuitbreaker，rate-limiter等，来保障业务系统的可用性。它们在设计上有一个共同特点：都是同传输协议无关的。在之前的一些http框架中，这些拦截器同传输协议是紧紧耦合在一起的，如果，此时我需要将某些HTTP接口改造成GRPC协议的接口，那么这些拦截器我还得再基于grpc再实现一遍，设计上存在一定的冗余。因此，借助go-kit这套工具集，我们就能很好的对transport协议，middleware进行扩展，且不会影响到业务本身的设计。 图3 go-kit架构图怎样將go-kit集成到现有的业务系统中我们找到了心仪的开源工具后，那么我们怎样以较低的成本将其引入到我们业务系统中呢？之前我们有提到，我们的go模版是分为三层：router，service和dao。而go-kit也分为三层，我们可以根据每层职责的不同进行重新组合，如图4所示，从上到下依次为：transport层，endpoint层，service层，dao层。这样就能很轻易的將go-kit集成进来，当然你如果哪天因为某种原因，不想再继续使用go-kit这套东西，直接將endpoint层和Transport层移除即可。在集成的过程中，需要注意一点：之前的代码中router层不能包含任何业务逻辑，否则就无法集成。 图4 架构的演进如何高效的使用go-kit前面有提到，go-kit本身分为三层，针对这点有同学会提出：“每次新建项目，都需要手动写下go-kit的这三层逻辑，有点浪费时间，不够简洁”，这确实是一个共性问题，从go-kit的github的issue中可以发现，也有不少人反馈过类似问题。很庆幸的是，有人给我们铺好了路，详见GoKit CLi，其主要功能如图5所示。 图5 GoKit CLi功能模块这个工具可以根据我们的需求自动生成service，transport和endpoint模版，以及生成供调用方的使用的client library，节省我们大量的时间，提高我们的生产效率。具体操作步骤，可以参考GoKit CLi的说明，这里不再赘述。","link":"/2020/04/11/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9go-kit/"},{"title":"了解 JAVASCRIPT 中的一等公民函数和匿名函数","text":"目录 函数和对象 JavaScript 函数的剖析 语句、表达式和匿名函数 一等功能 结束想法 1. 函数和对象你可能会有点惊讶这个副标题。这是因为在JavaScript 函数中是对象。它们实际上是一种特殊的对象，其中具有一些独特的属性。它通常是 JavaScript 中关于在函数和对象之间首先教授的内容的争论主题。我校认为，两者应该同时教授。这是因为在JavaScript中，函数和对象非常交织在一起，在许多方面它们非常相似。话虽如此，我想在继续函数之前对 JavaScript 中的对象进行快速复习。 JavaScript 中的对象它们只是键值对的集合。 1234567{ key: value, key: value, key: value } // a dummy example ``` 对象属性的值可以是 JavaScript 中的任何原始数据类型，例如：字符串、数字、布尔。它甚至可以是另一个对象。在所有这些情况下，它们被称为对象属性。在某些情况下，该值可以是函数。当值是函数称为方法的函数时。我们可以通过将密钥传递给 JavaScript 中的特殊运算符（即**_成员访问运算符和计算的成员访问运算符_**）来访问对象属性的值。让我们快速看看这个。 const dog = {}; // creates an empty dog objectdog.legs = 4; // adds a leg property using member access operatordog[“bark”] = “woaf woaf”; // adds a bark property using computed member access operatordog.details = {owner: “Tim”, name: “Jack”} // adds details property which is another object using the member access operatordog[“run”] = function(){ console.log(“running dog”) } // adds a method using the computed member access operatorconsole.log(dog) // returns{ legs: 4, bark: “woaf woaf”, details: { owner: “Tim”, name: “Jack” }, run: function() { console.log(“running dog”) }} 123456在上面的示例中，我使用成员访问运算符（这只是点）和计算的成员访问运算符（方形大括号 *）向对象添加属性和方法。两个运算符都查找要添加到对象中的属性，如果他们找不到该属性，他们将在那里创建该属性。_需要注意和携带的一个关键点是，我们可以很容易地创建狗对象与所有属性在动态。_喜欢这个： const dog = { legs: 4, bark: “woaf woaf”, details: { owner: “Tim”, name: “Jack” }, run: function() { console.log(“running dog”) }}console.log(dog) // returns{ legs: 4, bark: “woaf woaf”, details: { owner: “Tim”, name: “Jack” }, run: function() { console.log(“running dog”) }}// we still get the same result but this is faster. 12345_需要注意和携带的另一个重要事项是，对象在计算机的内存中保存其所有属性和方法的引用（地址）。它知道他们都坐在内存_中因此，我们可以使用这些相同的运算符访问它们。因此： console.log(dog[“legs”]) // returns 4console.lg(dog[“details”] // returns { owner: “Tim”, name: “Jack” }console.log(dog.bark) // returns “woaf woaf”console.log(dog.run) // return function(){console.log(“running dog”) } 1234567891011#### 2\\. JAVASCRIPT 功能的解剖Javascript 函数是特殊对象。它们具有与其他对象相同的属性，但具有一些额外的属性，使它们成为**_一等对象_**或**_一等的公民_**，因为有些人称之为它。其中两个是：1. 名称属性2. 代码属性函数对象具有名称和代码属性。 function ageTeller(age){ console.log(my age is ${age});}console.log(ageTeller.name) //returns ageTellerconsole.log(ageTeller.length) // returns length of the function 12345678910函数的代码属性是一个对象，它保存您编写的函数的所有代码。它不公开访问，并且存储在内部属性**[代码]**中。[换句话说 ecma-international.org，](https://zshipu.com/t?url=http://www.ecma-international.org/ecma-262/5.1/#sec-13.2)**_您编写的代码不是函数本身，而是函数的代码属性中。函数只是 JavaScript 中的特殊对象_**##### 两个重要提示：* 函数的此代码属性是不可访问。_这就是在 JavaScript 中调用或调用函数的方式。_* JavaScript 中的函数不一定具有名称。因此，我们可以创建一个函数，而不给它一个名称。在这种情况下，该函数被认为是_匿名_的。 const anonymousAgeTeller = (age){ console.log(my age is ${age});}// A function without a name!? const es6AnonymousAgeTeller = age =&gt; console.log(my age is ${age});// An es6 arrow function without a name!? 12345678910#### 3\\. 声明、表达和匿名功能上述函数没有名称。两者相同，但后者_es6AnonymousAgeTeller，_使用现代JavaScript语法。而这正是我们继续前进将使用的。有趣的是，我们正在为变量_es6AnonymousAgeTeller_分配一个函数表达式。这是完全有效的JavaScript，它打开了一些非常强大的编码模式的大门。表达式是返回值的代码单位。 2 + 2 // returns 4 because the + operator is a function and it returns a value 3 &gt; 2 // returns true because as above the &gt; operator is a function and it returns a boolean value. 1234我们可以在变量中捕获此返回的值。因此 const sumOfTwo = 2 + 2console.log(sumOfTwo) // returns 4 1234另一方面，语句是一个确实工作的代码单元。它不返回值。**请注意。** function sumOfTwo () { console.log(2 + 2);}// a function statement does not return a value.// A value is only returned when the function is invoked/calledsumOfTwo() // returns 4 1234我们不能将语句分配给变量，因为它不返回任何内容。 const result = if(3 &gt; 2) { return “the result is true”}// wrong JavaScript code and should not be done!!! 1234但是我们可以这样做， 相反： const sumOfTwo = () =&gt; console.log(2 + 2);console.log(sumOfTwo); // returns 4 1234上面我写了一个函数表达式，它是一个没有名称的函数，因为它是一个表达式，它返回该函数的引用（其地址在计算机的内存中，此时不调用函数，因此返回引用），并且存储在变量**_sumOfTwo_**中。我们现在可以使用**_sumOfTwo_**变量调用/调用此函数的代码属性，因为此变量现在包含对内存中函数的引用。因此： console.log(sumOfTwo); // returns 4 1234567891011**_在 JavaScript 中没有名称的这些类型的函数称为匿名函数。_**#### 4\\. 一等功能**_匿名函数可以存储在变量、对象或数组中，作为参数传递给函数，甚至可以从函数返回。因此，它们被称为一等函数或一等对象，或者作为 Javascript_**中某些类公民，**_简而言之，它们可以像使用任何基元 JavaScript 数据类型一样处理和使用_**这使得 JavaScript 非常强大。下面是支持这一想法的一些示例。function logItem (item) { if(typeof item === “function”) { console.log(item()); }else { console.log(item); }} console.log(logItem(“Lawrence Eagles”)) // returns “Lawrence Eagles”console.log(logItem({name : “Lawrence Eagles”, location: “Earth”})) // returns {name : “Lawrence Eagles”, location: “Earth”}console.log(logItem(()=&gt; { console.log(“I am a first-class citizen in JavaScript!”)})) // returns “I am a first-class citizen in JavaScript!” 1234567##### 让我们细分上面的函数。* 函数名称是_logItem，_它采用一个称为_项_的参数* 我们使用**_运算符的类型_**获取参数的数据类型。**_类型运算符_**返回一个字符串，指示未计算的操作数的类型。 typeof item// this is an expression so it returns a value depending on the data type of item. 1234* 我们采用返回的数据类型，并检查它是否等于&quot;函数&quot; typeof item === “function”// take note typeof returns it’s result as string. so we check if the result is equal to a “function”.// This is another expression and it would return true or false in this case. 1234如果_为 true，_我们知道已传递一**_个一等的匿名函数_**，其引用现在将存储在_logItem 函数的参数_中。因此，我们使用_logItem 参数_调用该第一类函数 item()// item is going to hold any argument passed to the function.// If a primitive is passed it would hold that primitive but if a function is passed it would hold a reference to the function in memory.// So we can invoke the code property of that function using this parameter. 12* 如果数据类型不是函数，我们会将该项目记录到控制台。 console.log(item) #### 5\\. 结束想法 这种一等函数的概念在JavaScript中开辟了一个全新的编程范式，称为**_函数编程_**。这给JavaScript提供了超能力，并使其成为函数式编程的一种非常好的语言。我确实希望您从这篇文章得到一两件事情，我非常期待您在下面的评论部分添加或问题。","link":"/2020/04/14/%E4%BA%86%E8%A7%A3-JAVASCRIPT-%E4%B8%AD%E7%9A%84%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%E5%87%BD%E6%95%B0%E5%92%8C%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"},{"title":"从0到1，Vue大牛的前端搭建——异常监控系统","text":"从0到1，Vue大牛的前端搭建——异常监控系统本篇文章读后，你将GET的技能： ●收集前端错误（原生、React、Vue） ●编写错误上报逻辑 ●利用Egg.js编写一个错误日志采集服务 ●编写webpack插件自动上传sourcemap ●利用sourcemap还原压缩代码源码位置 ●利用Jest进行单元测试 有没有心动的感觉？赶紧学起来吧！ （1）如何捕获异常JS异常： js异常的特点是,出现不会导致JS引擎崩溃 最多只会终止当前执行的任务。 比如一个页面有两个按钮，如果点击按钮发生异常页面，这个时候页面不会崩溃。 只是这个按钮的功能失效，其他按钮还会有效☟ “ data-caption=”” data-size=”normal” data-rawwidth=”1080” data-rawheight=”201” class=”origin_image zh-lightbox-thumb lazy” width=”1080” data-original=”https://pic3.zhimg.com/v2-3c609d95941c98dafb11da8e67b9e1de_r.jpg&quot; data-actualsrc=”https://pic3.zhimg.com/v2-3c609d95941c98dafb11da8e67b9e1de_b.jpg&quot;&gt; 上面的例子我们用setTimeout分别启动了两个任务。 虽然第一个任务执行了一个错误的方法。程序执行停止了。但是另外一个任务并没有收到影响。 其实如果你不打开控制台都看不到发生了错误。好像是错误是在静默中发生的。 有意向深入了解 Vue，点击下方查看资料包括 web 全栈和 web 架构师的学习资料以及大厂面试指南等，点击即可 1 毛钱购买。 开课吧 的推荐 2020 Vue 资料+最新面试大厂面试题，入手不亏！ 点击购买 下面我们来看看这样的错误该如何收集。 try-catch： JS作为一门高级语言我们首先想到的使用try-catch来收集。 “ data-caption=”” data-size=”normal” data-rawwidth=”400” data-rawheight=”144” class=”content_image lazy” width=”400” data-actualsrc=”https://pic1.zhimg.com/v2-51eb4ad932ae4db5517168839c931c4c_b.jpg&quot;&gt;&quot; data-caption=”” data-size=”normal” data-rawwidth=”1080” data-rawheight=”212” class=”origin_image zh-lightbox-thumb lazy” width=”1080” data-original=”https://pic4.zhimg.com/v2-f60fcaaf37f634c7e21840fddcbc0bcb_r.jpg&quot; data-actualsrc=”https://pic4.zhimg.com/v2-f60fcaaf37f634c7e21840fddcbc0bcb_b.jpg&quot;&gt; 如果在函数中错误没有被捕获，错误会上抛。 “ data-caption=”” data-size=”normal” data-rawwidth=”404” data-rawheight=”189” class=”content_image lazy” width=”404” data-actualsrc=”https://pic2.zhimg.com/v2-363e6cbca691e973af69bf2023740615_b.jpg&quot;&gt;&quot; data-caption=”” data-size=”normal” data-rawwidth=”1068” data-rawheight=”246” class=”origin_image zh-lightbox-thumb lazy” width=”1068” data-original=”https://pic2.zhimg.com/v2-eb1f32f0859ff9b1d7e173440a33ef79_r.jpg&quot; data-actualsrc=”https://pic2.zhimg.com/v2-eb1f32f0859ff9b1d7e173440a33ef79_b.jpg&quot;&gt; 控制台中打印出的分别是错误信息和错误堆栈。 读到这里大家可能会想那就在最底层做一个错误try-catch不就好了吗。 确实作为一个从java转过来的程序员也是这么想的。 但是理想很丰满，现实很骨感。我们看看下一个例子。 “ data-caption=”” data-size=”normal” data-rawwidth=”401” data-rawheight=”213” class=”content_image lazy” width=”401” data-actualsrc=”https://pic1.zhimg.com/v2-3009ca23cd31746edc60dfccb214dd58_b.jpg&quot;&gt;&quot; data-caption=”” data-size=”normal” data-rawwidth=”1080” data-rawheight=”243” class=”origin_image zh-lightbox-thumb lazy” width=”1080” data-original=”https://pic1.zhimg.com/v2-ee34d182fd272a2c7416846eda3a3598_r.jpg&quot; data-actualsrc=”https://pic1.zhimg.com/v2-ee34d182fd272a2c7416846eda3a3598_b.jpg&quot;&gt; 大家注意运行结果，异常并没有被捕获。 这是因为JS的try-catch功能非常有限一遇到异步就不好用了。 那总不能为了收集错误给所有的异步都加一个try-catch吧，太坑爹了。 其实你想想异步任务其实也不是由代码形式上的上层调用的就比如本例中的settimeout。 大家想想eventloop就明白啦，其实这些一步函数都是就好比一群没娘的孩子出了错误找不到家大人。 当然我也想过一些黑魔法来处理这个问题比如代理执行或者用过的异步方法。 算了还是还是再看看吧。 （2）异常任务捕获window.onerror: window.onerror 最大的好处就是可以同步任务还是异步任务都可捕获。 “ data-caption=”” data-size=”normal” data-rawwidth=”401” data-rawheight=”187” class=”content_image lazy” width=”401” data-actualsrc=”https://pic4.zhimg.com/v2-24bed8baa980bec00959fe02855f2d77_b.jpg&quot;&gt;&quot; data-caption=”” data-size=”normal” data-rawwidth=”1080” data-rawheight=”642” class=”origin_image zh-lightbox-thumb lazy” width=”1080” data-original=”https://pic3.zhimg.com/v2-1a4bb9c84271b5b25b242ea463b3d89e_r.jpg&quot; data-actualsrc=”https://pic3.zhimg.com/v2-1a4bb9c84271b5b25b242ea463b3d89e_b.jpg&quot;&gt; onerror返回值 onerror还有一个问题大家要注意 如果返回返回true 就不会被上抛了。 不然控制台中还会看到错误日志。 监听error事件: 文件中的位置☟ window.addEventListener(‘error’,() =&gt; {}） 其实onerror固然好但是还是有一类异常无法捕获。这就是网络异常的错误。 比如下面的例子。 试想一下我们如果页面上要显示的图片突然不显示了，而我们浑然不知那就是麻烦了。 addEventListener就是☟ “ data-caption=”” data-size=”normal” data-rawwidth=”402” data-rawheight=”128” class=”content_image lazy” width=”402” data-actualsrc=”https://pic4.zhimg.com/v2-dcde4d67a39d808a95ec2cf3d6837563_b.jpg&quot;&gt; 运行结果如下☟ “ data-caption=”” data-size=”normal” data-rawwidth=”1080” data-rawheight=”579” class=”origin_image zh-lightbox-thumb lazy” width=”1080” data-original=”https://pic2.zhimg.com/v2-dfd4f570225685b4ff0d45b59c60af49_r.jpg&quot; data-actualsrc=”https://pic2.zhimg.com/v2-dfd4f570225685b4ff0d45b59c60af49_b.jpg&quot;&gt; Promise异常捕获： Promise的出现主要是为了让我们解决回调地域问题。基本是我们程序开发的标配了。 虽然我们提倡使用es7 async/await语法来写。 但是不排除很多祖传代码还是存在Promise写法。 new Promise((resolve, reject) => { abcxxx()}); 这种情况无论是onerror还是监听错误事件都是无法捕获的。 “ data-caption=”” data-size=”normal” data-rawwidth=”401” data-rawheight=”119” class=”content_image lazy” width=”401” data-actualsrc=”https://pic3.zhimg.com/v2-bb38e70990a048e6daefd6f83e60a0f2_b.jpg&quot;&gt; 除非每个Promise都添加一个catch方法。 但显然，我们不能这样做。 window.addEventListener(\"unhandledrejection\", e => { console.log('unhandledrejection',e)}); “ data-caption=”” data-size=”normal” data-rawwidth=”1080” data-rawheight=”809” class=”origin_image zh-lightbox-thumb lazy” width=”1080” data-original=”https://pic4.zhimg.com/v2-86c91b28e3e98d398cd111059a539053_r.jpg&quot; data-actualsrc=”https://pic4.zhimg.com/v2-86c91b28e3e98d398cd111059a539053_b.jpg&quot;&gt; 我们可以考虑将unhandledrejection事件捕获错误抛出交由错误事件统一处理就可以了。 “ data-caption=”” data-size=”normal” data-rawwidth=”464” data-rawheight=”58” class=”origin_image zh-lightbox-thumb lazy” width=”464” data-original=”https://pic4.zhimg.com/v2-095d67f6d6f509372148f50f03ad138f_r.jpg&quot; data-actualsrc=”https://pic4.zhimg.com/v2-095d67f6d6f509372148f50f03ad138f_b.png&quot;&gt; async/await异常捕获： “ data-caption=”” data-size=”normal” data-rawwidth=”406” data-rawheight=”160” class=”content_image lazy” width=”406” data-actualsrc=”https://pic3.zhimg.com/v2-40721f7dcef91b6583c9a553a77692e6_b.jpg&quot;&gt; 实际上async/await语法本质还是Promise语法。 区别就是async方法可以被上层的try/catch捕获。 “ data-caption=”” data-size=”normal” data-rawwidth=”1072” data-rawheight=”206” class=”origin_image zh-lightbox-thumb lazy” width=”1072” data-original=”https://pic4.zhimg.com/v2-202ea279c17b8bff96079be9b3810363_r.jpg&quot; data-actualsrc=”https://pic4.zhimg.com/v2-202ea279c17b8bff96079be9b3810363_b.jpg&quot;&gt; 如果不去捕获的话就会和Promise一样，需要用unhandledrejection事件捕获。 这样的话我们只需要在全局增加unhandlerejection就好了。 “ data-caption=”” data-size=”normal” data-rawwidth=”1080” data-rawheight=”547” class=”origin_image zh-lightbox-thumb lazy” width=”1080” data-original=”https://pic2.zhimg.com/v2-76208837a31c285e2edcc0695fda0641_r.jpg&quot; data-actualsrc=”https://pic2.zhimg.com/v2-76208837a31c285e2edcc0695fda0641_b.jpg&quot;&gt; 小结： “ data-caption=”” data-size=”normal” data-rawwidth=”803” data-rawheight=”194” class=”origin_image zh-lightbox-thumb lazy” width=”803” data-original=”https://pic4.zhimg.com/v2-42c036f0328fb65eb3336fb5501b5fbb_r.jpg&quot; data-actualsrc=”https://pic4.zhimg.com/v2-42c036f0328fb65eb3336fb5501b5fbb_b.jpg&quot;&gt; 实际上我们可以将unhandledrejection事件抛出的异常再次抛出就可以统一通过error事件进行处理了。 最终用代码表示如下： “ data-caption=”” data-size=”normal” data-rawwidth=”421” data-rawheight=”141” class=”origin_image zh-lightbox-thumb lazy” width=”421” data-original=”https://pic4.zhimg.com/v2-abcb7cdcbe9b20a82f85ce1bc0d2f2f3_r.jpg&quot; data-actualsrc=”https://pic4.zhimg.com/v2-abcb7cdcbe9b20a82f85ce1bc0d2f2f3_b.jpg&quot;&gt; 想更深入了解 Vue ，来 1 毛钱带走前端资料，包括 web 全栈和 web 架构师的学习资料以及大厂面试指南等，点击即可购买。 开课吧 的推荐 2020 Vue 资料+最新面试大厂面试题，入手不亏！ 点击购买 （3）前端工程化Webpack工程化： 现在是前端工程化的时代,工程化导出的代码一般都是被压缩混淆后的。 比如： setTimeout(() => { xxx(1223)}, 1000) “ data-caption=”” data-size=”normal” data-rawwidth=”1080” data-rawheight=”211” class=”origin_image zh-lightbox-thumb lazy” width=”1080” data-original=”https://pic2.zhimg.com/v2-c3d782d2032237beaa2d48c68c633691_r.jpg&quot; data-actualsrc=”https://pic2.zhimg.com/v2-c3d782d2032237beaa2d48c68c633691_b.jpg&quot;&gt; 出错的代码指向被压缩后的JS文件，而JS文件长下图这个样子。 “ data-caption=”” data-size=”normal” data-rawwidth=”1080” data-rawheight=”538” class=”origin_image zh-lightbox-thumb lazy” width=”1080” data-original=”https://pic1.zhimg.com/v2-2faf801967fa4b332ac2913d1fdd7230_r.jpg&quot; data-actualsrc=”https://pic1.zhimg.com/v2-2faf801967fa4b332ac2913d1fdd7230_b.jpg&quot;&gt; 如果想将错误和原有的代码关联起来，那就需要sourcemap文件的帮忙了。 sourceMap是什么？ 简单说，sourceMap就是一个文件，里面储存着位置信息。 仔细点说，这个文件里保存的，是转换后代码的位置，和对应的转换前的位置。 那么如何利用sourceMap对还原异常代码发生的位置这个问题，我们到异常分析这个章节再讲。 （4）VUE创建工程利用vue-cli工具直接创建一个项目。 “ data-caption=”” data-size=”normal” data-rawwidth=”402” data-rawheight=”156” class=”content_image lazy” width=”402” data-actualsrc=”https://pic1.zhimg.com/v2-4c139c35f19d7081d0c686370146677c_b.jpg&quot;&gt; 为了测试的需要我们暂时关闭eslint 这里面还是建议大家全程打开eslint。 在vue.config.js进行配置 “ data-caption=”” data-size=”normal” data-rawwidth=”400” data-rawheight=”159” class=”content_image lazy” width=”400” data-actualsrc=”https://pic4.zhimg.com/v2-b4565492dc4f22c5fc96ca97e4bcc617_b.jpg&quot;&gt; 我们故意在（文件位置☟） src/components/HelloWorld.vue “ data-caption=”” data-size=”normal” data-rawwidth=”401” data-rawheight=”306” class=”content_image lazy” width=”401” data-actualsrc=”https://pic3.zhimg.com/v2-bfb5e58e71842af9349958f3eaf4a09e_b.jpg&quot;&gt; 这个时候 错误会在控制台中被打印出来,但是错误事件并没有监听到。 “ data-caption=”” data-size=”normal” data-rawwidth=”1074” data-rawheight=”560” class=”origin_image zh-lightbox-thumb lazy” width=”1074” data-original=”https://pic2.zhimg.com/v2-dd07b60c535c7926772a5a2655040561_r.jpg&quot; data-actualsrc=”https://pic2.zhimg.com/v2-dd07b60c535c7926772a5a2655040561_b.jpg&quot;&gt; handleError： 为了对Vue发生的异常进行统一的上报，需要利用vue提供的handleError句柄。 一旦Vue发生异常都会调用这个方法。 我们在src/main.js “ data-caption=”” data-size=”normal” data-rawwidth=”447” data-rawheight=”55” class=”origin_image zh-lightbox-thumb lazy” width=”447” data-original=”https://pic1.zhimg.com/v2-7704644c5b12b7114531809d5ebf7770_r.jpg&quot; data-actualsrc=”https://pic1.zhimg.com/v2-7704644c5b12b7114531809d5ebf7770_b.png&quot;&gt;&quot; data-caption=”” data-size=”normal” data-rawwidth=”1080” data-rawheight=”531” class=”origin_image zh-lightbox-thumb lazy” width=”1080” data-original=”https://pic3.zhimg.com/v2-268cfccd057a38248c873ff9c4fd4a3a_r.jpg&quot; data-actualsrc=”https://pic3.zhimg.com/v2-268cfccd057a38248c873ff9c4fd4a3a_b.jpg&quot;&gt; React： npx create-react-app react-sample cd react-sample yarn start 我们l用useEffect hooks 制造一个错误： “ data-caption=”” data-size=”normal” data-rawwidth=”402” data-rawheight=”275” class=”content_image lazy” width=”402” data-actualsrc=”https://pic1.zhimg.com/v2-a58566e129b9e03f2bef7941925cc49c_b.jpg&quot;&gt; 并且在src/index.js中增加错误事件监听逻辑： window.addEventListener('error', args => { console.log('error', error)}) 但是从运行结果看虽然输出了错误日志但是还是服务捕获。 “ data-caption=”” data-size=”normal” data-rawwidth=”1060” data-rawheight=”488” class=”origin_image zh-lightbox-thumb lazy” width=”1060” data-original=”https://pic1.zhimg.com/v2-e5a572825df118a6444194ae2c506e54_r.jpg&quot; data-actualsrc=”https://pic1.zhimg.com/v2-e5a572825df118a6444194ae2c506e54_b.jpg&quot;&gt; （5）Error Boundary 标签错误边界仅可以捕获其子组件的错误。 错误边界无法捕获其自身的错误。 如果一个错误边界无法渲染错误信息，则错误会向上冒泡至最接近的错误边界。 这也类似于 JavaScript 中 catch {} 的工作机制。 创建ErrorBoundary组件 “ data-caption=”” data-size=”normal” data-rawwidth=”476” data-rawheight=”235” class=”origin_image zh-lightbox-thumb lazy” width=”476” data-original=”https://pic2.zhimg.com/v2-789d41b2f1068569f70388bc6dcb0655_r.jpg&quot; data-actualsrc=”https://pic2.zhimg.com/v2-789d41b2f1068569f70388bc6dcb0655_b.jpg&quot;&gt; 在src/index.js中包裹App标签☟ “ data-caption=”” data-size=”normal” data-rawwidth=”401” data-rawheight=”114” class=”content_image lazy” width=”401” data-actualsrc=”https://pic4.zhimg.com/v2-52d556688681a17b90127876ac7c580f_b.jpg&quot;&gt; 最终运行的结果： “ data-caption=”” data-size=”normal” data-rawwidth=”1080” data-rawheight=”579” class=”origin_image zh-lightbox-thumb lazy” width=”1080” data-original=”https://pic4.zhimg.com/v2-8f9aa3b565509c8b90e148e297c812d7_r.jpg&quot; data-actualsrc=”https://pic4.zhimg.com/v2-8f9aa3b565509c8b90e148e297c812d7_b.jpg&quot;&gt; 关于Ajax的异常上报、搭建eggis工程、深度解析Error Staack等等操作，我正在拼命制作中，感兴趣的朋友记得关注我，产出后我会第一时间发出来~ 以上，希望能够帮助到各位。 有意向深入了解 Vue，点击下方查看资料包括 web 全栈和 web 架构师的学习资料以及大厂面试指南等，点击即可 1 毛钱购买。 开课吧 的推荐 2020 Vue 资料+最新面试大厂面试题，入手不亏！ 点击购买 作者：不露脸的web侠","link":"/2020/05/30/%E4%BB%8E0%E5%88%B01%EF%BC%8CVue%E5%A4%A7%E7%89%9B%E7%9A%84%E5%89%8D%E7%AB%AF%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"},{"title":"从0到1，Vue大牛的前端搭建——异常监控系统（下篇来啦）","text":"从0到1，Vue大牛的前端搭建——异常监控系统（下篇来啦）上一篇我们主要谈到的JS错误如何收集？ 在这一篇里，我们就说说： 异常如何上报和分析。 异常上报如何选择通讯方式动态创建img标签： 其实上报就是要将捕获的异常信息发送到后端。最常用的方式首推动态创建标签方式。 因为这种方式无需加载任何通讯库，而且页面是无需刷新的。 基本上目前包括百度统计 Google统计都是基于这个原理做的埋点。 new Image().src='http://localhost:7001/monitor/error'+ '?info=xxxxxx' 通过动态创建一个img,浏览器就会向服务器发送get请求。 可以把你需要上报的错误数据放在querystring字符串中，利用这种方式就可以将错误上报到服务器了。 Ajax上报： 实际上我们也可以用ajax的方式上报错误，这和我们再业务程序中并没有什么区别。 上报哪些数据： “ data-caption=”” data-size=”normal” data-rawwidth=”1080” data-rawheight=”700” class=”origin_image zh-lightbox-thumb lazy” width=”1080” data-original=”https://pic3.zhimg.com/v2-b8de774864e230bbf85c6c44bd054dbe_r.jpg&quot; data-actualsrc=”https://pic3.zhimg.com/v2-b8de774864e230bbf85c6c44bd054dbe_b.jpg&quot;&gt; 上报哪些数据： 我们先看一下error事件参数： “ data-caption=”” data-size=”normal” data-rawwidth=”803” data-rawheight=”309” class=”origin_image zh-lightbox-thumb lazy” width=”803” data-original=”https://pic2.zhimg.com/v2-ac12925067562caf7159baed43ce9665_r.jpg&quot; data-actualsrc=”https://pic2.zhimg.com/v2-ac12925067562caf7159baed43ce9665_b.jpg&quot;&gt; 其中核心的应该是错误栈，其实我们定位错误最主要的就是错误栈。 错误堆栈中包含了绝大多数调试有关的信息。其中包括了异常位置（行号，列号），异常信息 上报数据序列化： 由于通讯的时候只能以字符串方式传输，我们需要将对象进行序列化处理。 大概分成以下三步： 1、将异常数据从属性中解构出来，存入一个JSON对象 2、将JSON对象转换为字符串 3、将字符串转换为Base64 当然在后端也要做对应的反向操作 这个我们后面再说。 “ data-caption=”” data-size=”normal” data-rawwidth=”560” data-rawheight=”472” class=”origin_image zh-lightbox-thumb lazy” width=”560” data-original=”https://pic3.zhimg.com/v2-afb07a49d28e20520cfc894443d52a7e_r.jpg&quot; data-actualsrc=”https://pic3.zhimg.com/v2-afb07a49d28e20520cfc894443d52a7e_b.jpg&quot;&gt; Vue更多知识点，点击查看下方查料（web全栈和web架构师的学习资料以及大厂面试指 南等等） 开课吧 的推荐 2020 Vue 资料+最新面试大厂面试题，立即入手！ 点击领取 异常上报的后端服务器 搭建eggis工程： 异常上报的数据一定是要有一个后端服务接收才可以。 我们就以比较流行的开源框架eggjs为例来演示 # 全局安装egg-clinpm i egg-init -g 创建后端项目egg-init backend –type=simplecd backendnpm i 启动项目npm run dev 编写error上传接口： 首先在app/router.js添加一个新的路由 “ data-caption=”” data-size=”normal” data-rawwidth=”459” data-rawheight=”101” class=”origin_image zh-lightbox-thumb lazy” width=”459” data-original=”https://pic2.zhimg.com/v2-128f70174b809ceaddb81142d67b0b89_r.jpg&quot; data-actualsrc=”https://pic2.zhimg.com/v2-128f70174b809ceaddb81142d67b0b89_b.jpg&quot;&gt; 创建一个新的： controller (app/controller/monitor) “ data-caption=”” data-size=”normal” data-rawwidth=”582” data-rawheight=”283” class=”origin_image zh-lightbox-thumb lazy” width=”582” data-original=”https://pic4.zhimg.com/v2-26f9e7a58358077de836c22a090eddff_r.jpg&quot; data-actualsrc=”https://pic4.zhimg.com/v2-26f9e7a58358077de836c22a090eddff_b.jpg&quot;&gt; 看一下接收后的结果☟ “ data-caption=”” data-size=”normal” data-rawwidth=”1080” data-rawheight=”354” class=”origin_image zh-lightbox-thumb lazy” width=”1080” data-original=”https://pic1.zhimg.com/v2-5aa82e793c5661eb52d976aec33a96c4_r.jpg&quot; data-actualsrc=”https://pic1.zhimg.com/v2-5aa82e793c5661eb52d976aec33a96c4_b.jpg&quot;&gt; 记入日志文件： 下一步就是讲错误记入日志。实现的方法可以自己用fs写，也可以借助log4js这样成熟的日志库。 当然在eggjs中是支持我们定制日志那么我么你就用这个功能定制一个前端错误日志好了。 在/config/config.default.js中增加一个定制日志配置 “ data-caption=”” data-size=”normal” data-rawwidth=”450” data-rawheight=”95” class=”origin_image zh-lightbox-thumb lazy” width=”450” data-original=”https://pic1.zhimg.com/v2-c9c0922d431e2ded98ccf65d9b14171c_r.jpg&quot; data-actualsrc=”https://pic1.zhimg.com/v2-c9c0922d431e2ded98ccf65d9b14171c_b.jpg&quot;&gt; 在/app/controller/monitor.js中添加日志记录： “ data-caption=”” data-size=”normal” data-rawwidth=”590” data-rawheight=”145” class=”origin_image zh-lightbox-thumb lazy” width=”590” data-original=”https://pic4.zhimg.com/v2-1c256425af4fbd26428c8c2bfa711c3f_r.jpg&quot; data-actualsrc=”https://pic4.zhimg.com/v2-1c256425af4fbd26428c8c2bfa711c3f_b.jpg&quot;&gt; 最后实现的效果： “ data-caption=”” data-size=”normal” data-rawwidth=”1080” data-rawheight=”415” class=”origin_image zh-lightbox-thumb lazy” width=”1080” data-original=”https://pic3.zhimg.com/v2-1a128ab81a7b67021abbd292df361cde_r.jpg&quot; data-actualsrc=”https://pic3.zhimg.com/v2-1a128ab81a7b67021abbd292df361cde_b.jpg&quot;&gt; Webpack插件实现SourceMap上传谈到异常分析最重要的工作其实是将webpack混淆压缩的代码还原。 创建Webpack插件： /source-map/plugin（文件位置） “ data-caption=”” data-size=”normal” data-rawwidth=”522” data-rawheight=”266” class=”origin_image zh-lightbox-thumb lazy” width=”522” data-original=”https://pic3.zhimg.com/v2-624225838d67d27056b9766621214f26_r.jpg&quot; data-actualsrc=”https://pic3.zhimg.com/v2-624225838d67d27056b9766621214f26_b.jpg&quot;&gt; 加载webpack插件： webpack.config.js（文件位置） “ data-caption=”” data-size=”normal” data-rawwidth=”610” data-rawheight=”156” class=”origin_image zh-lightbox-thumb lazy” width=”610” data-original=”https://pic1.zhimg.com/v2-32e3b453e7a30615dbd516ffbdc80e18_r.jpg&quot; data-actualsrc=”https://pic1.zhimg.com/v2-32e3b453e7a30615dbd516ffbdc80e18_b.jpg&quot;&gt; 添加读取sourcemap读取逻辑： 在apply函数中增加读取sourcemap文件的逻辑 /plugin/uploadSourceMapWebPlugin.js “ data-caption=”” data-size=”normal” data-rawwidth=”731” data-rawheight=”203” class=”origin_image zh-lightbox-thumb lazy” width=”731” data-original=”https://pic1.zhimg.com/v2-afeae8bf0159256c13a60090762a413c_r.jpg&quot; data-actualsrc=”https://pic1.zhimg.com/v2-afeae8bf0159256c13a60090762a413c_b.jpg&quot;&gt; 实现http上传功能： “ data-caption=”” data-size=”normal” data-rawwidth=”428” data-rawheight=”380” class=”origin_image zh-lightbox-thumb lazy” width=”428” data-original=”https://pic4.zhimg.com/v2-13d6b02b2c05e7f6e18a43f925c39353_r.jpg&quot; data-actualsrc=”https://pic4.zhimg.com/v2-13d6b02b2c05e7f6e18a43f925c39353_b.jpg&quot;&gt; 服务器端添加上传接口： /backend/app/router.js（文件位置） “ data-caption=”” data-size=”normal” data-rawwidth=”610” data-rawheight=”156” class=”origin_image zh-lightbox-thumb lazy” width=”610” data-original=”https://pic1.zhimg.com/v2-32e3b453e7a30615dbd516ffbdc80e18_r.jpg&quot; data-actualsrc=”https://pic1.zhimg.com/v2-32e3b453e7a30615dbd516ffbdc80e18_b.jpg&quot;&gt; 添加sourcemap上传接口： /backend/app/controller/monitor.js “ data-caption=”” data-size=”normal” data-rawwidth=”456” data-rawheight=”221” class=”origin_image zh-lightbox-thumb lazy” width=”456” data-original=”https://pic1.zhimg.com/v2-b360e3d0ba1ee3c5757b32f74a861a14_r.jpg&quot; data-actualsrc=”https://pic1.zhimg.com/v2-b360e3d0ba1ee3c5757b32f74a861a14_b.jpg&quot;&gt; 最终效果： 执行webpack打包时调用插件sourcemap被上传至服务器。 “ data-caption=”” data-size=”normal” data-rawwidth=”1080” data-rawheight=”559” class=”origin_image zh-lightbox-thumb lazy” width=”1080” data-original=”https://pic2.zhimg.com/v2-d33c3a88a2945588cba260e1f2884ffd_r.jpg&quot; data-actualsrc=”https://pic2.zhimg.com/v2-d33c3a88a2945588cba260e1f2884ffd_b.jpg&quot;&gt; 解析ErrorStack考虑到这个功能需要较多逻辑,我们准备把他开发成一个独立的函数并且用Jest来做单元测试： 先看一下我们的需求☟ “ data-caption=”” data-size=”normal” data-rawwidth=”803” data-rawheight=”168” class=”origin_image zh-lightbox-thumb lazy” width=”803” data-original=”https://pic4.zhimg.com/v2-972186b50128c8230a7425ee8f451b07_r.jpg&quot; data-actualsrc=”https://pic4.zhimg.com/v2-972186b50128c8230a7425ee8f451b07_b.jpg&quot;&gt; 搭建Jest框架： “ data-caption=”” data-size=”normal” data-rawwidth=”575” data-rawheight=”258” class=”origin_image zh-lightbox-thumb lazy” width=”575” data-original=”https://pic4.zhimg.com/v2-d1d2c200f13d59660a7d48f83bd5874b_r.jpg&quot; data-actualsrc=”https://pic4.zhimg.com/v2-d1d2c200f13d59660a7d48f83bd5874b_b.jpg&quot;&gt; 首先创建一个/utils/stackparser.js文件☟ “ data-caption=”” data-size=”normal” data-rawwidth=”400” data-rawheight=”100” class=”content_image lazy” width=”400” data-actualsrc=”https://pic1.zhimg.com/v2-f8b097f840e8d9a542788a35d4355658_b.jpg&quot;&gt; 在同级目录下创建测试文件stackparser.spec.js 以上需求我们用Jest表示就是 “ data-caption=”” data-size=”normal” data-rawwidth=”645” data-rawheight=”354” class=”origin_image zh-lightbox-thumb lazy” width=”645” data-original=”https://pic1.zhimg.com/v2-a4cb609dc27aa76c66ec511773424174_r.jpg&quot; data-actualsrc=”https://pic1.zhimg.com/v2-a4cb609dc27aa76c66ec511773424174_b.jpg&quot;&gt; 整理如下: 下面我们运行Jest npx jest stackparser –watch “ data-caption=”” data-size=”normal” data-rawwidth=”1080” data-rawheight=”536” class=”origin_image zh-lightbox-thumb lazy” width=”1080” data-original=”https://pic4.zhimg.com/v2-72fe4b69948f5e336f9c67dceb27ade3_r.jpg&quot; data-actualsrc=”https://pic4.zhimg.com/v2-72fe4b69948f5e336f9c67dceb27ade3_b.jpg&quot;&gt; 显示运行失败，原因很简单因为我们还没有实现对吧。 “ data-caption=”” data-size=”normal” data-rawwidth=”1024” data-rawheight=”512” class=”origin_image zh-lightbox-thumb lazy” width=”1024” data-original=”https://pic1.zhimg.com/v2-4f84c659a06f94f4a9c2c93b5ffe4c7c_r.jpg&quot; data-actualsrc=”https://pic1.zhimg.com/v2-4f84c659a06f94f4a9c2c93b5ffe4c7c_b.jpg&quot;&gt; 下面我们就实现一下这个方法 ☟ 反序列Error对象： 首先创建一个新的Error对象 将错误栈设置到Error中。 然后利用error-stack-parser这个npm库来转化为stackFrame “ data-caption=”” data-size=”normal” data-rawwidth=”438” data-rawheight=”166” class=”origin_image zh-lightbox-thumb lazy” width=”438” data-original=”https://pic4.zhimg.com/v2-97256ed38b3aa6c86a975db496f50b13_r.jpg&quot; data-actualsrc=”https://pic4.zhimg.com/v2-97256ed38b3aa6c86a975db496f50b13_b.jpg&quot;&gt; 运行效果如下☟ “ data-caption=”” data-size=”normal” data-rawwidth=”1080” data-rawheight=”326” class=”origin_image zh-lightbox-thumb lazy” width=”1080” data-original=”https://pic2.zhimg.com/v2-d83fe6020f684a8b64e1e5b9c049f789_r.jpg&quot; data-actualsrc=”https://pic2.zhimg.com/v2-d83fe6020f684a8b64e1e5b9c049f789_b.jpg&quot;&gt; 解析ErrorStack： 下一步我们将错误栈中的代码位置转换为源码位置 “ data-caption=”” data-size=”normal” data-rawwidth=”724” data-rawheight=”545” class=”origin_image zh-lightbox-thumb lazy” width=”724” data-original=”https://pic1.zhimg.com/v2-db1383d25c6e03c74fb10f9eecebe29c_r.jpg&quot; data-actualsrc=”https://pic1.zhimg.com/v2-db1383d25c6e03c74fb10f9eecebe29c_b.jpg&quot;&gt; 我们再用Jest测试一下☟ “ data-caption=”” data-size=”normal” data-rawwidth=”598” data-rawheight=”306” class=”origin_image zh-lightbox-thumb lazy” width=”598” data-original=”https://pic3.zhimg.com/v2-2f2d53d85087053fc9577ce987669236_r.jpg&quot; data-actualsrc=”https://pic3.zhimg.com/v2-2f2d53d85087053fc9577ce987669236_b.jpg&quot;&gt; 这时我们再看一下结果： “ data-caption=”” data-size=”normal” data-rawwidth=”1080” data-rawheight=”462” class=”origin_image zh-lightbox-thumb lazy” width=”1080” data-original=”https://pic4.zhimg.com/v2-e73787735ce60a95063e6e6afa1bb22b_r.jpg&quot; data-actualsrc=”https://pic4.zhimg.com/v2-e73787735ce60a95063e6e6afa1bb22b_b.jpg&quot;&gt; 这样一来测试就通过啦~ 将源码位置记入日志： “ data-caption=”” data-size=”normal” data-rawwidth=”627” data-rawheight=”232” class=”origin_image zh-lightbox-thumb lazy” width=”627” data-original=”https://pic4.zhimg.com/v2-811462bf53efa61b2e008775e83107d3_r.jpg&quot; data-actualsrc=”https://pic4.zhimg.com/v2-811462bf53efa61b2e008775e83107d3_b.jpg&quot;&gt; 记录完成后，我们再来看一下运行效果： “ data-caption=”” data-size=”normal” data-rawwidth=”1080” data-rawheight=”398” class=”origin_image zh-lightbox-thumb lazy” width=”1080” data-original=”https://pic4.zhimg.com/v2-7222105d2b04d4f3fc6d9d542d901203_r.jpg&quot; data-actualsrc=”https://pic4.zhimg.com/v2-7222105d2b04d4f3fc6d9d542d901203_b.jpg&quot;&gt; 结束了这一步，我们的ErrorStack工作就完成了。 需要运用的两种开源框架Fundebug： Fundebug专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有阳光保险、荔枝FM、掌门1对1、核桃编程、微脉等众多品牌企业。 Sentry： Sentry 是一个开源的实时错误追踪系统，可以帮助开发者实时监控并修复异常问题。 它主要专注于持续集成、提高效率并且提升用户体验。 Sentry 分为服务端和客户端 SDK，前者可以直接使用它家提供的在线服务，也可以本地自行搭建； 后者提供了对多种主流语言和框架的支持，包括 React、Angular、Node、Django、RoR、PHP、Laravel、Android、.NET、JAVA 等。 同时它可提供了和其他流行服务集成的方案，例如 GitHub、GitLab、bitbuck、heroku、slack、Trello 等。 目前公司的项目也都在逐步应用上 Sentry 进行错误日志管理。 总结： 截止到目前为止，我们把前端异常监控的基本功能算是形成了一个MVP(最小化可行产品)。 后面需要升级的还有很多，对错误日志的分析和可视化方面可以使用ELK。 发布和部署可以采用Docker。对eggjs的上传和上报最好要增加权限控制功能。 关于这一期的VUE异常处理课程我们就讲到这里啦。 推荐一份Vue前端资料，包括web全栈和web架构师的学习资料以及大厂面试指南等，点 击下方即可购买。 开课吧 的推荐 2020 Vue 资料+最新面试大厂面试题，立即入手！ 点击领取 如果同学们有需要提问和讨论的问题，可以在评论区留言，我会一一为大家回复哈~ 作者：不露脸的web侠","link":"/2020/05/30/%E4%BB%8E0%E5%88%B01%EF%BC%8CVue%E5%A4%A7%E7%89%9B%E7%9A%84%E5%89%8D%E7%AB%AF%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%E7%AF%87%E6%9D%A5%E5%95%A6%EF%BC%89/"},{"title":"从零开始实现一个RPC框架（零）","text":"从零开始实现一个RPC框架（零）前言背景最近决心开始学习go语言，但是苦于没有实际的应用场景，学习始终停留在hello world层面，看过的教程和资料印象也不深刻。于是决定从go自带的rpc实现开始切入，了解一下go语言在实际场景下是如何使用的，包括异常处理、代理和过滤、go routine的用法等等，同时也简单了解了一下其他rpc的go语言实现，比如thrift和grpc等等。一阵走马观花，稍微加深了印象，也开始慢慢体会到go语言和java语言的种种差异和共性。接下来，为了进一步巩固学习效果，也算是为了对自己目前为止的职业生涯做一次复习和汇报，决定使用go语言从零开始构建一个比较完整的RPC（或者说是微服务）框架。 微服务框架和RPC框架 本文中提到RPC框架，指的是提供基础的RPC调用支持的框架；而本文中提到的微服务框架，指的是包含一些服务治理相关的功能（比如服务注册发现、负载均衡、链路追踪等）的RPC框架。 调研在动手开始做之前，需要先了解学习一下其他现有的产品，可以从中学习一下优秀的经验和方法，这里列举一下初步了解到的几个框架： grpc google推出的微服务框架，支持10种语言，支持基于http2的双向的流式通讯 go-micro 一个开源的微服务框架，比较独特的是支持Async Messaging，像是mq一样的subpub功能 thrift-go thrift是facebook捐献给apache的rpc框架（不包含服务治理相关的功能），根据官方文档，thrift支持20种语言的RPC调用 rpcx rpcx是一个国人开发并开源的微服务框架，宣传的特性是“快、易用却功能强大”，官网上的介绍提到性能是grpc的两倍。这里附上作者（应该是）的博客 以上就是目前了解过的几个已有的框架，比较惭愧的是了解得都不够深入，后续还要持续学习。 Pluggable Interfaces 值得一提的是除了thrift，其他三个称得上微服务框架的产品，其特性都包含Pluggable Interfaces，也就是可以通过插件替换部分功能。通过插件实现可替换的功能，实际上在一个微服务框架中基本是最低要求了，否则后续的功能扩展将会变得十分困难，相信我，这里是饱含血泪的经验之谈。 需求分析在开始着手设计甚至是编写代码以前，我们首先分析一下我们的需求（来自学习软件工程中的成果）。同时对于一部分可能不太熟悉RPC相关细节的同学来说，对我们后面要做的事情心中也能够有一个大致的概念。这里就直接列举几个功能性需求： 支持RPC调用，包括同步调用和异步调用 支持服务治理的相关功能，包括： 服务注册与发现 服务负载均衡 限流和熔断 身份认证 监控和链路追踪 健康检查，包括端到端的心跳以及注册中心对服务实例的检查 支持插件，对于有多种实现的功能（比如负载均衡），需要以插件的形式提供实现，同时需要支持自定义插件 至于非功能性需求比如性能要好，要够稳定这类的暂时不重点关注。 系统设计分层有了大致的需求，接下来就可以开始着手设计了。首先我们将框架划分为若干层，层与层之间约定通过接口交互。这里就不要问为什么需要分层了，非要问就是经验。分层作为一种经典到不能在经典的设计模式，几乎在软件开发过程中无处不在，在RPC框架当中也十分适用，下面画出大致的层次图： service 是面向用户的接口，比如客户端和服务端实例的初始化和运行等等 client和server表示客户端和服务端的实例，它们负责发出请求和返回响应 selector 表示负载均衡，或者叫做loadbanlancer，它负责决定具体要向哪个server发出请求 registery 表示注册中心，server在初始化完毕甚至是运行时都要向注册中心注册自身的相关信息，这样client才能从注册中心查找到需要的server codec 表示编解码，也就是将对象和二进制数据互相转换 protocol 表示通信协议，也就是二进制数据是如何组成的，RPC框架中很多功能都需要协议层的支持 transport 表示通讯，它负责具体的网络通讯，将按照protocol组装好的二进制数据通过网络发送出去，并根据protocol指定的方式从网络读取数据 上面提到的各个层，除了service，实际上可以提供多种实现，所以应该都以plugin的方式实现。 这样一来按照我们划分的层次，一个客户端从发出请求到收到响应的流程大概就是这样： 服务端的逻辑比较类似，这里就不画图了。 过滤器链通过上面的层次划分可以看到，一个请求或者响应实际上会依次穿过各个层然后通过网络发送或者到达用户逻辑，所以我们采用类似过滤器链一样的方式处理请求和响应，以此来达到对扩展开放，对修改关闭的效果。这样一来对于一些附加功能比如熔断降级和限流、身份认证等功能都可以在过滤器中实现。 消息协议接下来设计具体的消息协议，所谓消息协议大概就是两台计算机为了互相通信而做的约定。举个例子，TCP协议约定了一个TCP数据包的具体格式，比如前2个byte表示源端口，第3和第4个byte表示目标端口，接下来是序号和确认序号等等。而在我们的RPC框架中，也需要定义自己的协议。一般来说，网络协议都分为head和body部分，head是一些元数据，是协议自身需要的数据，body则是上一层传递来的数据，只需要原封不动的接着传递下去就是了。 接下来我们就试着定义自己的协议： 12345|2byte|1byte |4byte |4byte | header length |(total length - header length - 4byte)|-------------------------------------------------------------------------------------------------|magic|version|total length|header length| header | body | 根据上面的协议，一个消息体由以下几个部分严格按照顺序组成： 两个byte的magic number开头，这样一来我们就可以快速的识别出非法的请求 一个byte表示协议的版本，目前可以一律设置为0 4个byte表示消息体剩余部分的总长度（total length） 4个byte表示消息头的长度（header length） 消息头（header），其长度根据前面解析出的长度（header length）决定 消息体（body），其长度为前面解析出的总长度减去消息头所占的长度（total length - 4 - header length) 协议中消息头的数据主要是RPC调用过程中的元数据，元数据跟方法参数和响应无关，主要记录额外的信息以及实现附属功能比如链路追踪、身份认证等等；消息体的数据则是由实际的请求参数或者响应编码而来。 在实际的处理中，消息头在发送端通常是一个结构体，在发送时会被编码成二进制添加在消息头的前面，在接收端接收时又解码成一个结构体，交给程序进行处理。这里试着列举消息头包含的各个信息： 123456789101112type Header struct { Seq uint64 //序号, 用来唯一标识请求或响应 MessageType byte //消息类型，用来标识一个消息是请求还是响应 CompressType byte //压缩类型，用来标识一个消息的压缩方式 SerializeType byte //序列化类型，用来标识消息体采用的编码方式 StatusCode byte //状态类型，用来标识一个请求是正常还是异常 ServiceName string //服务名 MethodName string //方法名 Error string //方法调用发生的异常 MetaData map[string]string //其他元数据} 结语第一篇文章就到此为止了，主要先做一下准备，整理一下思路，如果有不正确或者不合理的部分还请大家多多指教。","link":"/2020/04/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AARPC%E6%A1%86%E6%9E%B6%EF%BC%88%E9%9B%B6%EF%BC%89/"},{"title":"公众号 H5 分享","text":"微信_公众号h5_页面自定义_分享__网络_bill的博客-CSDN博客 2018年8月24日 - 在一个h5_页面添加微信,_分享_给微信好友、朋友圈、腾讯微博下面来实现。需要:1、需要一个企业版的微信_公众号(认证过的)2、一台服务器企业版的微信公众号… 实现_h5公众号分享_功能(vue项目也适用) - 菜鸟的编程VLOG - 博客园 2019年1月22日 - 实现_h5公众号分享_功能(vue项目也适用) 1 在vue项目中我们先npm install weixin-js-sdk –save下载下来在main.js文件中引入 import wx from ‘weixin-js… 怎么能把做好的_h5_发到_公众号_呢 ? - 知乎 2019年11月7日 - 将你制作的h5_页面,链接放到阅读原文哪里,只要别人点击阅读原文,就可以看到你的_H5_页面了。 2、_公众号_群发 进入到微信_公众平台,进入到群发功能的菜单,输… _公众号h5_页面_分享_并监测_分享_事件_qq_26715417的博客-CSDN博客 2020年4月29日 - _公众号H5_中需要做_分享_任务,需要监听_分享_成功事件,实现代码 &lt;div @click=toShare&gt;111import wx from weixin-js-sd... 微信_公众号H5_网页_分享_调用不了 | 微信开放社区 2018年8月13日 - 最近在做微信分享,wx.config配置好后,在ready里的_分享_接口没任何反应,checkApi是正常的,config也是ok,配置也是正常的,link路径也是安全域名下的,图片… 微信_公众号H5_之微信_分享_常见错误和问题(小结)_javascript技巧_脚… 2019年11月14日 - 这篇文章主要介绍了微信_公众号H5_之微信_分享_常见错误和问题(小结),文中通过示例代码介绍的非常详细,对大家的学习或者工作具有一定的参考学习价值,需要… _H5_网页实现微信_分享_功能 - 简书 2019年6月15日 - _H5_网页实现微信_分享_功能 一,首先在_公众号_管理后台“_公众号_设置”的“功能设置”里填写JS接口安全域名,域名需要通过ICP备案,没有备案域名可以用SAE、BA… _H5_微信_分享_配置 - 朱为鹏 - 博客园 2018年3月16日 - _H5_微信_分享_配置 前言 一般情况下编写_H5_页面是要考虑微信内置浏览器的兼容性及…这里的appid我们可以在微信_公众平台_的管理界面中‘开发者中心’ &gt; ‘… 微信公众号h5_页面自定义_分享 - 码农教程 2019年8月29日 - 本文章向大家介绍微信公众号h5_页面自定义_分享,主要包括微信_公众号h5_页面自定义_分享_使用实例、应用技巧、基本知识点总结和需要注意事项,具有一定的参考… 怎么能把做好的_h5_发到_公众号_呢 ? - 知乎 2019年12月18日 - ​分享_​收藏​喜欢 更多回答 秀小雅 游离在世界尽头…… 3 人赞同了该回答 用_公众号_推送_H5,总得来说有四种方法~ 1、阅读原文中添加链接 将你制作的h5… javascript - 微信_公众号h5_怎么监控到调用了_分享_功能? - Segment… 微信_分享_给好友或者朋友圈,updateAppMessageShareData和updateTimelineShareData没有回调函数,那么怎么才能知道我调用了_分享_呢? 微信_公众号_中_H5_页面中如何实现直接_分享_图片到微信朋友圈? | 微信… 2019年8月1日 - 类似用户自己发送的图片,比如游戏的荣耀截图可以直接发到微信朋友圈,现在我想在微信_公众号_服务器的_H5_页面实现类似的_分享_图片的行为能提问不能成功,能… uni-app中公众号h5_端_分享 - 个人文章 - SegmentFault 思否 开始我以为在公众号_端,也是和微信小程序一样,可以使用button来进行我的朋友或者群的_分享 要使用js-sdk才能进行分享,但是,一直使用小程序的_分享_都是点击后就能够进入… 怎么把_H5_放到微信_公众号_上-百度经验 2019年10月25日 - 怎么把H5_放到微信_公众号_上,_H5_想要放到微信_公众号_上,首先需要制作完成_H5,然后生成可_分享_的二维码或链接,然后把链接通过自定义菜单,自动回复等方式添加… 秀米做的h5_怎么_分享_到_公众号 - 卡饭网 2019年3月6日 - 秀米做的_h5_怎么_分享_到_公众号_来源:本站整理 作者:东城影 时间:2019-03-06 相信很多小伙伴都有在使用秀米,在其中如何才能制作及发布_H5_秀呢?方法很简单,下面小编… _公众号H5_源码 – 资源_分享_网 标签:公众号H5_源码程序源码 80套微信_公众号H5_游戏源码 80 套微信_公众号 H5 游戏源码安装说明:通过附带的批量修改工具把网址,公众号,头像等换成你的即可下载… UNI-APP 开发微信公众号(H5)JSSDK _分享_到微信中详解 - DCloud问答 2019年8月16日 - 2、在需要转发的页面onshow()里添加分享_代码 复制代码// #ifdef _H5 var jweixin = require(‘jweixin-module’) //npm安装的引用 var surl = encodeURIC… 麻烦咨询个问题!我用秀米H5_做的图文,怎么_分享_到微信_公众号? 1楼: …个问题！我用秀米_H5_做的图文，怎么_分享_到微信_公众号_？ 2楼: _H5_是不能直接_分享_到_公众号_的，要用二维码或者原文链接 实现_h5公众号分享_功能(vue项目也适用) / cecdns.com 2020年5月18日 - 实现_h5公众号分享_功能(vue项目也适用) 在vue项目中我们先npm install weixin-js-sdk –save下载下来在main.js文件中引入 import wx from ‘weixin-js-s… _h5公众号分享_群聊变成文本链接 | 微信开放社区 _h5公众号分享_群聊变成文本链接 小救星小渡星期五 14:40121浏览问题模块: Bug反馈appid:wx101bf89d8f140021 链接:https://fx.wxbjq.net.cn/preview/3pGP(域名… 微信_公众号H5_开发笔记 - rentian1的博客 - CSDN博客 2018年9月3日 - _公众号_的_分享_给朋友、朋友圈、QQ空间等方法在微信js中是可以直接调用的,_分享_的…在这个_H5_页面的js代码中做一个跳转就好啦(但是如果你_分享_出去的是支… 怎么把_h5_放到微信_公众号_上-百度经验 2016年11月10日 - 把_h5_页面放在微信_公众号_里其实很简单。 方法/步骤 1 先在微信图文区域编写好自己的活动推荐图文 步骤阅读 2 二维码,一般_H5_页面都有属于自己的一个唯… javascript - 微信_公众号h5_怎么监控到调用了_分享_功能? - Segment… 2019年8月2日 - 微信_公众号h5_怎么监控到调用了_分享_功能?html5 javascript 微信_分享_给好友或者朋友圈,updateAppMessageShareData和updateTimelineShareData没有回调函… 实现_h5公众号分享_功能(vue项目也适用) / cecdns.com 2020年5月18日 - 实现_h5公众号分享_功能(vue项目也适用) 在vue项目中我们先npm install weixin-js-sdk –save下载下来在main.js文件中引入 import wx from ‘weixin-js-s… 诱导_分享_彻底凉了!小程序、_H5_、_公众号_、APP_分享_都要受限了! 2018年7月7日 - 微信分享_功能调整了哪些方面内容? 1. _H5 、公众号_、APP、小游戏_分享_受限 此次微信的无差别_分享_调整对待,将会导致_H5_、_公众号_、APP在内,包括小游戏的_分… 新榜:_公众号【_H5_案例_分享_】的2019__H5_案例_分享 2020年1月8日 - 案例:_公众号_【_H5_案例_分享_】的2019 品牌:新榜 技术实现: html5 亮点: 1、创意定位年度总结2019年_公众号_数据,用科幻的形式还原数据。 2、策划逻辑以_公众号_数据为… 微信公众号_点击多图文,打开就是_H5,这是怎么做到的? - 知乎 2019年7月24日 - 微信公众号_点击多图文,打开就是_H5,这是怎么做到的? 小懒猫 计算机点击多图文,打开就是H5,这是如何实现的呢? 我们先看看如何操作的吧:在鱼塘软件素材库… 微信_公众号H5_之微信_分享_常见错误和问题(小结) - javascript - 谷… 2020年3月28日 - 这篇文章主要介绍了微信_公众号H5_之微信_分享_常见错误和问题(小结),文中通过示例代码介绍的非常详细,对大家的学习或者工作具有一定的参考学习价值,需要的朋友们下面随着… 公众号_点开_h5,_分享_文案不对 on 线上问题跟进 蒋秋丹 moved 公众号_点开_h5,分享_文案不对 lower 蒋秋丹 moved _公众号_点开_h5,分享_文案不对 from 本周解决问题 to 已解决 蒋秋丹 on _公众号_点开_h5,_分享_文案… 微信_公众号_里的_H5_页面返回至_公众号_首页 | ZPY博客 2018年12月10日 - 微信公众号_里的_H5_页面返回至_公众号_首页 发表评论 浏览量:329 次 A+ 所属分类:微信_公众号 今天项目中需要在_公众号_的页面里加一个返回button,点返回后… 公众号_内 _H5_页面授权_分享 翻牌抽奖__h5公众号_抽奖,_h5_抽奖页面写入… 2020年3月27日 - _公众号_内 _H5_页面授权_分享_引流 卡牌式抽奖 _H5_引流小页面 UI页面完整可直接打开 _H5分享_授权 _h5公众号_抽奖更多下载资源、学习资料请访问CSDN下载频道. 微信_公众号h5_怎么监控到调用了_分享_功能?汗血宝马 2019年10月26日 - 微信_分享_给好友或者朋友圈,updateAppMessageShareData和updateTimelineShareData没有回调函数,那么怎么才能知道我调用了_分享_呢? Warning: Illegal str… 公众号分享 · 有奖答题H5 · 看云 提交结果积分(已完成) 个人中心 修改地址信息(已完成) 获得积分记录(已完成) 获取地址(已完成) 排行榜(已完成) 公众号_授权登录 _公众号分享 单位排行榜… 如何用200个粉丝的公众号,创造出10w+刷屏_H5_的? | 梅花网 2018年2月1日 - 可以看下我们另外的几个文案,一个是_H5分享_页面的logo,另两个是_公众号_推广文案。 我相信参与过我们这个游戏的很多人一开始差点就信了这真的是考试。 什么?还要考… 关于从微信_公众号_发送一篇文章,让用户点击后进入自己的_H5_页面微信分享_功能大调整:小程序、App、_公众号_、_H5 将全面受限 | 爱范儿 2018年5月18日 - 「分享_功能调整」的公示图在朋友圈广泛传播,其中提及微信将对_分享_功能做出的多项调整,全面涉及小程序、小游戏、微信内的网页(_公众号_、_H5)以及 App 等… 微信分享_功能大调整:小程序、App、_公众号_、_H5 将全面受限_详细… 2018年5月18日 - 5月 17 日晚,微信官方发布了小程序分享_功能将进行多项调整的预告,全面涉及小程序、小游戏、微信内的网页(_公众号_、_H5)以及 app 等。这将在很大的程… h5_嫁接到微信_公众号_里怎么_分享 2016年1月6日 - h5_嫁接到微信_公众号_里怎么_分享 最佳答案 本回答由提问者推荐 匿名用户 1级 2016-01-06 回答右上角点击0 其他回答(1)你想知道的这里都有 已解决问题:26… 园荐-公众,号,vue-相关博文:实现_h5公众号分享_功能(vue项目也适用) 公众号‘; le… 实现h5公众号分享_功能(vue项目也适用) 2019-01-22 14:13 − _公众号‘; let imgUrl = ‘http://wx…","link":"/2020/05/27/%E5%85%AC%E4%BC%97%E5%8F%B7%20H5%20%E5%88%86%E4%BA%AB/"},{"title":"初创团队选择 Vert.x","text":"（2019-12-04更新：增加 REST 一篇教程） （2019-01-02更新：增加采用 Vert.x 和 RxJava 不用 Redis 做数据缓存的做法，进阶阅读 （2018-06-05更新：增加对Real World demo评述，增加一篇 Clement Escoffier 的教程 （2018-04-17更新：修正关于 Vert.x - From zero to (micro)-hero 的评述） （2018-02-22更新：增加关于多语言选择内容，增加一篇教程） 最近需要做一个可穿戴 IoT 的全栈应用，决定采用关注了很久的 Vert.x 框架。 团队只有不到3人，之前的项目经历多是 C/C++, Clojure 和 Python，所以迁移到 Vert.x 有些学习成本。一方面是对概念和工具不熟悉，另一方面则是希望了解 Vert.x 在项目中的最佳实践，尽量少踩坑。 这篇文章列出一些我们在技术选型时的考虑，以及觉得很有启发的参考项目或教程，希望对于其他迁移型 Vert.x 初学者有所帮助。 Vert.x 能解决的问题开源的 Vert.x 其实不是一个框架，而是一个以“异步非阻塞”编程模型为核心思想的工具集。它基本上囊括了开发网络应用时需要用到的所有组件，不管是搭建服务、路由管理、用户权限理、数据库对接、网络通讯、集群管理……都可以用 Vert.x 搞定。 Vert.x 的另一个重要特性是支持7种编程语言，需要糙快猛时可以用脚本语言（如 Ruby/Groovy，可惜暂不支持 Python），需要专注数据处理则可以用函数式语言（如 Scala/Kotlin，后面有望加入 Haskell 和 Clojure），需要兼顾前后端时可以用 Javascript（最近还推出了基于 GraalVM 的 es4x）. 支持7种开发语言是 Vert.x 主打的一项特性 而且，Vert.x 允许同一个项目的不同模块用不同语言来开发，也就是 polyglot. 考虑到初创团队成员加入时的自带技能往往并不一致，所以 polyglot 也是一个对初创团队很友好的特性。 截至2019年12月4日， Vert.x 发布了3.8.4 版本，接下来会有一个大版本号4.0的升级。目前Github 星标超过 1w，充分显示了这个工具集的健壮程度。值得一提的是，Vert.x 的好几位贡献者来自中国。一项重要功能——对 kotlin-coroutine 的支持——就是出自上海网友 steam1984 之手。 补充一段知乎 Vert.x 著名答主 @圆胖肿 的评论，Vert.x 应该使用那种语言开发？ 如果之前熟悉c/c++的，直接上java如果之前熟悉python的，用groovy，groovy跟python很接近，是java化的python如果之前熟悉clojure的，那就用我们提供的支持这样三个人都学点新的东西，就可以通过vert.x整合起来了，具体的整合可以参考专栏之前的文章：Vert.x的一个常见问题以及多语言制霸环境配置 初创团队为什么选择 Vert.x初创阶段，由于 Vert.x 功能全面、允许用多种语言开发，所以对初创小团队而言能够激发出较高的生产力。而且开发者社区活跃，所以技术虽新，却也不至于掉到坑里没人捞。 等到用户规模上去以后，Vert.x 具有 JVM 娘胎里带来的稳定性优势，而又通过类似 Node.js 的异步范式保证了多用户性能和可扩展性。据此分析，采用 Vert.x 做的软件项目如果一不小心起飞了，不用经历“脚本 -&gt; Java”这种互联网业常见的转平台之痛。 总结一下，我们认为： Vert.x 是一个不管“从0到1”还是“从1到N”阶段都适用的工具集。 Vert.x 参考项目及上手资料（不断更新中）官方的 vertx-examples 应该是上手的最佳资料了。它与 Vert.x 同步更新，所有例子都给出了直接可以运行的工程文件，用 Intellij IDEA 等 IDE 可以直接跑。不过， vertx-examples 里面给出的都是一个个小品级的例程，拿来作为项目的参考还是零散了一点。 此外，由于Vert.x 不是框架，所以对代码的组织结构没有什么限制。这对于项目经验丰富的开发者而言是加分项，但对于初学者来说太 free style 了也会增加上手难度。 还有一点比较遗憾的是，Vert.x 还没有一套比较完整的 RealWorld demo. 基本上现在能找到的流行框架都把这个 Medium 的克隆项目写了一遍（ Github 链接），方便大家上手和比较。但至今为止 Vert.x 的克隆还基本等于没有，有兴趣的同学可以追踪一下这个 repo。 下面把网上能够找到的 Vert.x 参考项目和教程汇总一下，方便初学者们找到一款与自己需求类似的原型，目的是通过阅读和重构来上手。评述部分比较侧重我们的可穿戴 IoT 需求，即数据实时性要求较高，几乎类似于网络游戏。 1）官方的用 Vert.x 搭建 Wiki 教程: 网址：教程，GitHub repo 要点：前后端通信，Verticle 间通信，异步模型 评述：如果做对实时性要求没有那么高的应用（非游戏、非 IoT），那么这个教程就非常够用了。 2）A multi-user realtime game by Burr Sutter: 网址：Youtube 视频，GitHub repo 要点：Reactive 编程，eventbus 通信 评述：非常惊艳的现场演示，服务器—客户端实时互动，玩家间实时互动，绝对的一 demo 胜千言。不过除了几个视频以外没找到任何的文字教程，Github 上的文档也写的比较简单，所以没有实际测试过。但 Burr Sutter 的几次演讲视频的确是我们最初对 Vert.x 动心的原因。 3）Vert.x console: 网址：GitHub repo，Youtube 演示视频 要点：Vue.js，docker，实时监控 评述：由英语很棒的青年开发者 Yunyu Li 在 GSoC 2017 中贡献，由于 Vert.x 3.5.1 刚刚修复了此前 web client 的一个 bug，新版 vertx-console 还没来得及测试。整体上是一个完成度相当高的全栈项目，尤其是监控部分对于 IoT 应用非常关键。 4）InMood4Life: 网址：博客文章，GitHub Repo 要点： Gradle 项目，完全 Groovy 开发，IoT，外设协同 评述：众多上手项目中唯一一个不用 Java 开发的，使用了 Gradle + Groovy 这个组合。同时这个项目桥接了蓝牙设备，体现了 Vert.x 在软硬件协同项目中的前景。这类项目常见的上手难度在于没有那几样外设则无法跑起来，只能看看代码过过干瘾。 5）Vert.x starter: 网址：https://vertx-starter.jetdrone.xyz/, 视频演示 要点：增减组件、配置依赖关系、前后端匹配 评述：Vert.x 主程之一 pmlopes 做的最小项目生成器，点点按钮就能生成工程文件。我们主要研究了一下用 Maven (Java/Kotlin)+ Vue.js 配置出来的起步工程，觉得是很好的全栈上手参考。Java + Maven 组合应该是作者主要精力所在，经测可用; Java + Gradle 的可配置项少一点，但也经测可用。Kotlin + Maven 生成项目有 bug，反映给作者后打了补丁，但也可以看出可能暂时不是维护重点。添加 Vert.x 的模块很方便，但只是添加了 maven 包依赖，没有起始代码。相比之下， Clojure 的 Luminus 项目功能与之类似，但每加一个包都会生成相应的起始代码，大大降低了上手难度。另外一个问题是几乎没有文档，牵涉到前端的运行过程要看上面的视频演示。Vert.x 官方也有一个 starter，与 pmlopes 自己的私房 xyz starter 功能类似，但是要简单一点。猜测两个 starter 同源，应该会合并。 5）一个基于 microservice 的实时商品报价平台样例 网址：Vert.x - From zero to (micro)-hero 要点：分布式、微服务 microservice、RxJava、实时监控 评述：重点推荐。Vert.x 主创人员 Clement Escoffier 和 Julien Viet 创作的一个内容翔实的教程，把框架代码写好了，让初学者把核心业务代码填到需要的地方去。提供了懒人式打开即用的源代码，最终的效果是一个有前后端、实时曲线、服务追踪的比较全面的样例工程。 6）Vertx Blueprint (三个项目）： 网址：博客文章，GitHub repo (Todo, Kue, Micro Shop) 要点： 前后端全栈、Eventbus 通信、微服务 microservice 架构、docker 评述： 由杭州网友 sczyh30 在 GSoC 2016 中贡献，三个例子循序渐进，质量很高。第三个 Micro Shop 的例子是一个全栈的电子商务网站，全部 docker 部署，啃下来就基本上明白 Vert.x microservice 在生产中怎么做了。不过 Micro Shop 跑起来需要自己配置 docker-machine 环境。在测试中发现代码与最新版本的 Keycloak 用户权限管理模块有点冲突，作者正在修改中。 7）VertxUp / VertxZero: 网址：Vertx Zero Up Framework 要点：Dependency Injection、与 Spring 的对应理解、复杂项目组织方式 评述：我们之前没有 Spring 开发经验，这个项目理解起来有些困难。但对于熟悉 Spring 的开发者是很好的迁移途径，由重庆网友 silentbalanceyh 开发。 8）基于Vert.x和RxJava 2构建通用的爬虫框架 网址：文章，GitHub repo 要点：爬虫、http client 评述：爬虫功能与我们这次的 IoT 应用稍有不同，但也是web app 中的一个常见需求。由网友沈哲开发。 9）另一个基于微服务的例子 网址：文章，GitHub repo 要点：异步与 MongoDB 通信，vertx-config，Consul 服务发现 评述：主要阅读了教程文章，测试环境介绍得不太全所以没有实际测试。但项目就两个模块，结构比较清晰，适合初学时阅读理解。 10）Clement Escoffier 写的又一套新手教程 网址：文章，GitHub repo 要点： web app 入门，异步通讯，简单 REST，RxJava 解决 callback hell 评述：主要开发者 Clement 可谓在 Vert.x 的教学推广上不遗余力。可惜的是仍然没有一个完整的类似 RealWorld demo (conduit) 的例子。不过 vertx-examples 里面的例子是很全的，对于不想当伸手党的新手来说，其实弹药充足的很。 11）采用 Vert.x 和 RxJava 做数据缓存 网址：文章，Github repo 要点： vert.x 做缓存，适用场合类似 Redis 但据说性能更高，原因是节省了很多 IO 评述：新手如果学做 Hello world 应用应该不需要这篇教程。然而缓存是任何严肃应用很早期就会遇到的问题。个人认为如果在 vert.x 中再开设一个 redis，好处是搭积木起应用快，坏处是需要多维护一个 redis 服务。这对初创团队来说增加了部署复杂度，也分散运维精力。考虑到 vert.x+postgres 几乎是可以标配到所有初创应用，只依赖这2个标配工具如果能顺带做起高性能缓存，那么对初创团队而言是节省精力的。 12）在 Vert.x 上面做 REST 的一个教程 网址：文章，GitHub repo 要点：平实的一篇 Vert.x + REST 的教程，不多不少 评述：难得有一篇从 Maven 配置开始讲起，小白友好，尤其是对非 Java 生态转过来的开发者友好。有项目以后自己从头开始建 Maven 工程的情况并不多，但是这种手把手的教程对于新手是非常有意义的。","link":"/2020/06/20/%E5%88%9D%E5%88%9B%E5%9B%A2%E9%98%9F%E9%80%89%E6%8B%A9%20Vert.x%20/"},{"title":"初学者的 Docker","text":"每家公司都依赖软件进行创新，软件开发领域最大的创新之一是容器的发明。这些容器已经改变了软件的构建和发货方式。Docker 公司走这条路，为每个人提供集装箱。它让开发人员无忧无虑，因为它惊人的功能。Docker 还通过消除通常用于发生冲突的开发人员和运营团队之间的差距，在企业中采用 DevOps。今天，我们将介绍 Docker 的一些基础知识等。 码头集装箱现在，我们将查看一个高级概述，了解为什么需要 Docker，以及它可以为您做些什么。让我首先分享我是如何被介绍给Docker的。在以前的项目中，我要求设置一个端到端堆栈，包括各种不同的技术，如使用节点 js 的 Web 服务器，以及像 Redis 这样的消息传递系统以及像 Ansible 这样的业务流程工具等数据库。使用所有这些不同的组件开发此应用程序时，我们有很多问题。首先，要处理的是它们与底层操作系统的兼容性，我们必须确保所有不同的服务都与我们计划使用的操作系统版本兼容。 有时，这些服务的某些版本与操作系统不兼容。我们必须回去寻找另一个与所有这些不同服务兼容的操作系统。其次，我们必须检查服务与库之间的兼容性以及操作系统的依赖项。我们曾出现问题，一个服务需要一个版本的从属库，而另一个服务需要另一个版本。 应用程序的体系结构随时间而变化，我们不得不升级到这些组件的较新版本或更改数据库等。每次发生某些变化时，我们都必须经历相同的过程来检查这些不同的公司和底层基础架构之间的兼容性。此兼容性矩阵问题通常称为来自地狱的矩阵。 接下来，每次我们有一个新的开发人员，我们发现设置一个新的环境真的很难，新的开发人员必须遵循一大组指令，并运行数百个命令，最终设置他们的环境。他们必须确保他们使用正确的操作系统，即每个组件的正确版本。每个开发人员每次都必须自己设置这一切。我们还有不同的开发测试和生产环境。 一个开发人员可能愿意使用一个操作系统，而另一个开发人员可能使用另一个操作系统。因此，我们不能保证我们正在构建的应用程序在不同的环境中以相同的方式运行。因此，这一切使我们的生活真的很难。因此，我需要一些可以帮助我们解决兼容性问题的东西，这样可以让我们修改或更改这些组件，而不会影响其他组件，甚至根据需要修改底层操作系统。那次搜索把我落在了Docker身上 使用 Docker，我能够在具有其自己的库和自己的依赖项的单独容器中运行每个组件，所有这些组件都位于相同的 VM 和操作系统上，但都在单独的环境或容器中运行。我们只需要构建一次 Docker 配置，并且我们所有的开发人员现在都可以开始使用简单的 Docker 运行命令，而不管他们运行的是什么基础操作系统。他们只需要确保他们的系统上安装了 Docker。 那么什么是容器？容器是完全隔离的环境。就像他们可以有自己的进程或服务，他们自己的网络接口，他们自己的装载就像虚拟机一样，除了他们都共享相同的操作系统内核。我们将稍微看看这意味着什么。但同样重要的是要注意，容器不是新的Docker。 集装箱已经存在了大约10年。一些不同类型的容器是LXC、LXD、LXCFS等。码头使用 LXC 容器。设置这些容器环境非常困难，因为它们级别非常低。这就是 Docker 提供具有多种强大功能的高级工具，使像我们这样的最终用户能够真正轻松。 Docker 是如何工作的？为了了解 Docker 的工作原理，让我们首先重新审视操作系统的一些基本概念。如果你看看像Ubuntu，Fedora，CentOS等操作系统。它们都由两样东西组成：一个操作系统内核和一组软件。操作系统内核负责与底层硬件交互，而操作系统内核保持不变，在这种情况下，这是 Linux，它上面的软件使这些操作系统与众不同。 该软件可能由不同的用户界面驱动程序、编译器、文件管理器、开发人员工具等组成。因此，您拥有跨所有操作系统共享的通用 Linux 内核和一些自定义软件，这些软件将操作系统彼此区分开来。我们前面说过 Docker 容器共享底层内核。分享内核实际上意味着什么？假设我们有一个系统，其中安装了 Docker 的 Ubuntu 操作系统。Docker 可以在它上面运行任何版本的操作系统。只要它们都基于同一个内核，在这种情况下，Linux。如果基础操作系统是 Ubuntu Docker，则可以基于另一个发行（如 Debian、Fedora、Susi 或 CentOS）运行容器。每个 Docker 容器只有我们前面刚刚讨论过的附加软件，这使得这些操作系统与众不同。 Docker 利用 Docker 主机的基础内核，该内核适用于上述所有操作系统。因此，什么是操作系统，没有共享相同的内核，这些，窗口。因此，您将无法在带有 Linux 操作系统的 Docker 主机上运行基于 Windows 的容器。为此，您需要在 Windows 服务器上使用 Docker。 你可能会问，那不是个缺点吗？无法在操作系统上运行另一个内核？答案是否定的，因为与虚拟机管理程序不同，Docker 并不是要在同一硬件上虚拟化和运行不同的操作系统和内核。Docker 的主要目的是对应用程序进行容器化并运送和运行它们。 虚拟机和容器之间的差异因此，这让我们认识到虚拟机和容器之间的差异，我们倾向于这样做，尤其是来自虚拟化背景的虚拟机和容器。如您右图，在 Docker 的情况下，我们有底层的硬件基础结构，然后在操作系统上安装操作系统和 Docker。然后，Docker 可以单独管理仅使用库和依赖项运行的容器。 对于虚拟机，我们在基础硬件上拥有操作系统，然后是虚拟机（如 ESX）或某种虚拟化的虚拟机，然后是虚拟机。正如您所看到的，每个虚拟机都拥有自己的操作系统。然后是依赖项，然后是应用程序。由于有多个虚拟操作系统和内核在运行，因此此开销导致基础资源的利用率更高。虚拟机还消耗较高的磁盘空间，因为每个 VM 都很重，并且其大小通常为千兆字节，而 Docker 容器是轻量级的，并且它们的大小通常为兆字节。这允许 Docker 容器更快地启动，通常只需几秒钟，而我们知道的虚拟机需要几分钟才能启动，因为它需要启动整个操作系统。 还必须注意，由于在内核等容器之间共享的资源越多，而 VM 彼此完全隔离，因此 Docker 的隔离更少。由于 VM，不要依赖底层操作系统或内核。您可以基于 Linux 或基于 Windows 的基于同一虚拟机管理程序的不同类型的操作系统。而在单个 Docker 主机上是不可能的。因此，这些都是两者之间的一些区别。 那么，它是如何做到的呢？目前有很多容器化版本的应用程序。因此，大多数组织都将其产品容器化，并且已在称为 Docker Hub 或 Docker 存储的公共 Docker 注册表中可用。例如，您可以查找最常见的操作系统、数据库和其他服务和工具的图像。识别所需的映像后，在主机上安装 Docker。启动应用程序堆栈与使用映像名称运行 Docker run 命令一样简单。 在这种情况下，运行 Docker 运行 Ansible 命令将在 Docker 主机上运行 Ansible 的实例。同样，使用 Docker Hub 命令运行 MongoDB Redis 和节点 js 的实例。运行节点 js 时，只需指向主机上代码存储库的位置。如果需要运行 Web 服务的多个实例，只需根据需要添加尽可能多的实例，并在前面配置某种负载均衡器。如果其中一个实例想要失败，只需销毁该实例并启动新实例即可。还有其他解决方案可用于处理此类案件，我们稍后将研究。我们一直在谈论图像和容器。 让我们了解两者的区别。映像是一个包或模板，就像您可能在虚拟化世界中处理过的 VM 模板一样。它用于创建一个或多个容器。容器正在运行隔离映像的实例，这些映像具有自己的环境和进程集。正如我们以前所看到的，很多产品已经多克。如果您找不到要查找的内容，可以自己创建映像并将其推送到 Docker Hub 存储库，使其可供公众使用。 如果你看看它，传统上，开发人员开发了应用程序。然后，他们将其交给 Ops 团队，用于在生产环境中部署和管理它。他们通过提供一组说明来做到这一点，例如有关如何设置主机的信息、要在主机上安装哪些先决条件以及如何配置依赖项等。由于 Ops 团队没有自行开发应用程序，因此他们很难设置应用程序。当他们出现问题时，他们与开发人员一起解决问题。使用 Docker 时，设置基础结构所涉及的大部分工作现在以 Dockerfile 的形式掌握在开发人员手中。开发人员以前为设置基础结构而构建的指南现在可以轻松地放在 Dockerfile 中，为应用程序创建映像。 此映像现在可以在任何容器平台上运行，并且保证在任何地方以相同的方式运行。因此，Ops 团队现在只需使用映像来部署应用程序。由于映像已在工作，当开发人员生成映像时，并且操作没有修改它，因此在生产中部署映像时，它将继续以相同的方式工作。要了解有关容器的更多，请查看我的其他课程“Docker 绝对初学者“ 在 YouTube 上观看”初学者 Docker：完整课程“的视频。","link":"/2020/05/31/%E5%88%9D%E5%AD%A6%E8%80%85%E7%9A%84%20Docker/"},{"title":"初学者，学习vue应该从何下手？","text":"（如果你从没学过框架，那么跳过这一段直接看下面）你培训有没有学习框架这方面的知识？如果有其他框架的使用经验，那么学vue和其他框架一样学就行了，所谓一通百通。 （由于你说你培训过，所以假设你有还行的js基础，熟悉es6语法，不然先学好这些）如果vue是你第一个接触的框架，你可以先去慕课网上看一个免费的vue基础教学，讲的比较基础，但足够让你对这个框架的使用有个大致的概念了。2小时不到看完，然后去vue官网看官网文档，因为vue开发者是中国人，所以中文文档做的还不错。19年的官方文档好像改变了不少，我感觉和我18年看的有很多不同，你就看最新的好了。像文档说的那样，在学到“深入了解组件”之前，你就已经掌握了vue基础知识了（你会觉得内容很短是吧），这时候文档会建议你先停下来，弄个简单的小demo做做，你听他的。把基础知识熟悉一点之后，再继续学下去。 文档中有些地方可能讲的比较晦涩，你看不懂可以先跳过，并不影响使用，等你以后深入框架原理，再回头看看就茅塞顿开了。vue偏向新手，vue的使用就记住一点，多练练、熟悉各种api、语法规则 就行了。 如果你以前没有接触过webpack、npm、模块化，你先不用看vue-cli，包括文档开头的vue npm安装。像文档建议的那样，先学好vue本身，然后去了解了解webpack、npm，再去学vue-cli，不然你会感觉怀疑人生的。 学完vue和vue-cli（如果感觉vue-cli的一些配置理解不了，那么先尝试记住它们，等你以后工程化基础好了，会明白的。你到公司第一要务是快速上手出活，所以先不用太纠结一些东西），你可以找个小项目练练手，这里我还是推荐慕课网上的vue项目，我做过仿饿了么的SPA，感觉挺有帮助的。只不过由于这些课程是几年前的，所以可能和最新的vue语法不一样，全家桶也不一样。比如仿饿了么是vue1.0写的，ajax用的是vue-resource（vue2.0后已弃用），我是用vue2.x + axios + vue-cli3.0重写的。用最新的vue重写老vue项目，不也是一个锻炼吗。 然后随着你接触的项目越来越复杂，组件通信越来越让你无从下手，你自然而然就知道有vuex这个东西了，那时由于你一路自学过来，已经掌握了一些学习方法，学习vuex也不算难事了 ps：再过几个月，说不定你能用vue3.0写了…… 再ps：我写过vue对象、数组响应，双向绑定的源码，欢迎有缘人给star。 HiWayne/Self-Vue​github.com 再再ps：另外还有一个有趣的js特效插件，其中的过渡动画使用风格有些类似vue，有兴趣的可以看看readme中的lazyfade教程，也欢迎有缘人给star。 HiWayne/jsAnimate​github.com&gt; 作者：雨过天晴","link":"/2020/05/30/%E5%88%9D%E5%AD%A6%E8%80%85%EF%BC%8C%E5%AD%A6%E4%B9%A0vue%E5%BA%94%E8%AF%A5%E4%BB%8E%E4%BD%95%E4%B8%8B%E6%89%8B%EF%BC%9F/"},{"title":"微服务限流与降级","text":"一、 微服务的雪崩效应除了对服务可用性的追求，微服务架构一个绕不过去的问题就是服务雪崩。 在一个调用链路上，微服务架构各个服务之间组成了一个松散的整体，牵一发而动全身， 服务雪崩是一个多级传导的过程，首先是某个服务提供者不可用，由于大量超时等待，继而导致服务调用者不可用，并且在整个链路上传导，继而导致系统瘫痪。 二、限流降级怎么做如同上面我们分析的，在大规模微服务架构的场景下，避免服务出现雪崩，要减少停机时间，要尽可能的提高服务可用性。 提高服务可用性，可以从很多方向入手，比如缓存、池化、异步化、负载均衡、队列和降级熔断等手段。 缓存以及队列等手段，增加系统的容量 限流和降级则是关心在到达系统瓶颈时系统的响应，更看重稳定性 缓存和异步等提高系统的战力，限流降级关注的是防御。 限流和降级，具体实施方法可以归纳为八字箴言，分别是限流，降级，熔断和隔离。 2.1 限流和降级限流顾名思义，提前对各个类型的请求设置最高的QPS阈值，若高于设置的阈值则对该请求直接返回，不再调用后续资源。 限流需要结合压测等，了解系统的最高水位，也是在实际开发中应用最多的一种稳定性保障手段。 降级则是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。 从降级配置方式上，降级一般可以分为主动降级和自动降级。 主动降级是提前配置，自动降级则是系统发生故障时，如超时或者频繁失败，自动降级。 其中，自动降级，又可以分为以下策略： 超时降级 失败次数降级 故障降级 在系统设计中，降级一般是结合系统配置中心，通过配置中心进行推送，下面是一个典型的降级通知设计 2.2 熔断隔离如果某个目标服务调用慢或者有大量超时，此时熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。 熔断一般需要设置不同的恢复策略，如果目标服务情况好转则恢复调用。 服务隔离与前面的三个略有区别，我们的系统通常提供了不止一个服务，但是这些服务在运行时是部署在一个实例，或者一台物理机上面的， 如果不对服务资源做隔离，一旦一个服务出现了问题，整个系统的稳定性都会受到影响！ 服务隔离的目的就是避免服务之间相互影响。 一般来说，隔离要关注两方面，一个是在哪里进行隔离，另外一个是隔离哪些资源。 何处隔离 一次服务调用，涉及到的是服务提供方和调用方，我们所指的资源，也是两方的服务器等资源，服务隔离通常可以从提供方和调用方两个方面入手。 隔离什么 广义的服务隔离，不仅包括服务器资源，还包括数据库分库，缓存，索引等，这里我们只关注服务层面的隔离。 2.3 降级和熔断的区别服务降级和熔断在概念上比较相近，通过两个场景，谈谈我自己的理解。 熔断，一般是停止服务 典型的就是股市的熔断，如果大盘不受控制，直接休市，不提供服务，是保护大盘的一种方式。 降级，通常是有备用方案 从北京到济南，下雨导致航班延误，我可以乘坐高铁，如果高铁票买不到，也可以乘坐汽车或者开车过去。 两者的区别 降级一般是主动的，有预见性的，熔断通常是被动的， 服务A降级以后，一般会有服务B来代替，而熔断通常是针对核心链路的处理。 在实际开发中，熔断的下一步通常就是降级。 三、常用限流算法设计刚才讲了限流的概念，那么怎样判断系统到达设置的流量阈值了？ 这就需要一些限流策略来支持，不同的限流算法有不同的特点，平滑程度也不同。 3.1 计数器法计数器法是限流算法里最简单也是最容易实现的一种算法。 假设一个接口限制一分钟内的访问次数不能超过100个，维护一个计数器，每次有新的请求过来，计数器加一，这时候判断，如果计数器的值小于限流值，并且与上一次请求的时间间隔还在一分钟内， 允许请求通过，否则拒绝请求，如果超出了时间间隔，要将计数器清零。 计数器限流可以比较容易的应用在分布式环境中，用一个单点的存储来保存计数值，比如用Redis，并且设置自动过期时间，这时候就可以统计整个集群的流量，并且进行限流。 计数器方式的缺点是不能处理临界问题，或者说限流策略不够平滑。 假设在限流临界点的前后，分别发送100个请求，实际上在计数器置0前后的极短时间里，处理了200个请求，这是一个瞬时的高峰，可能会超过系统的限制。 计数器限流允许出现 2*permitsPerSecond 的突发流量，可以使用滑动窗口算法去优化，具体不展开。 3.2 漏桶算法假设我们有一个固定容量的桶，桶底部可以漏水（忽略气压等，不是物理问题），并且这个漏水的速率可控的，那么我们可以通过这个桶来控制请求速度，也就是漏水的速度。 我们不关心流进来的水，也就是外部请求有多少，桶满了之后，多余的水会溢出。 将算法中的水换成实际应用中的请求，可以看到漏桶算法从入口限制了请求的速度。使用漏桶算法，我们可以保证接口会以一个常速速率来处理请求，所以漏桶算法不会出现临界问题。 这里简单实现一下，也可以使用Guava的SmoothWarmingUp类，可以更好的控制漏桶算法， 3.3 令牌桶算法漏桶是控制水流入的速度，令牌桶则是控制留出，通过控制token，调节流量。 假设一个大小恒定的桶，桶里存放着令牌（token）。桶一开始是空的，现在以一个固定的速率往桶里填充，直到达到桶的容量，多余的令牌将会被丢弃。 如果令牌不被消耗，或者被消耗的速度小于产生的速度，令牌就会不断地增多，直到把桶填满。后面再产生的令牌就会从桶中溢出。最后桶中可以保存的最大令牌数永远不会超过桶的大小， 每当一个请求过来时，就会尝试从桶里移除一个令牌，如果没有令牌的话，请求无法通过。 这两种算法的主要区别在于漏桶算法能够强行限制数据的传输速率，而令牌桶算法在能够限制数据的平均传输速率外，还允许某种程度的突发传输。 在令牌桶算法中，只要令牌桶中存在令牌，那么就允许突发地传输数据直到达到用户配置的门限，因此它适合于具有突发特性的流量。 3.4 漏桶和令牌桶的比较漏桶和令牌桶算法实现可以一样，但是方向是相反的，对于相同的参数得到的限流效果是一样的。 主要区别在于令牌桶允许一定程度的突发，漏桶主要目的是平滑流入速率，考虑一个临界场景，令牌桶内积累了100个token，可以在一瞬间通过，但是因为下一秒产生token的速度是固定的， 所以令牌桶允许出现瞬间出现permitsPerSecond的流量，但是不会出现2*permitsPerSecond的流量，漏桶的速度则始终是平滑的。 3.5 使用RateLimiter实现限流Google开源工具包Guava提供了限流工具类RateLimiter，该类基于令牌桶算法实现流量限制，使用方便。 RateLimiter使用的是令牌桶的流控算法，RateLimiter会按照一定的频率往桶里扔令牌，线程拿到令牌才能执行，比如你希望自己的应用程序QPS不要超过1000，那么RateLimiter设置1000的速率后，就会每秒往桶里扔1000个令牌RateLimter提供的API可以直接应用，其中acquire会阻塞，类似JUC的信号量Semphore，tryAcquire方法则是非阻塞的：","link":"/2019/11/14/%E5%8A%A1%E9%99%90%E6%B5%81%E4%B8%8E%E9%99%8D%E7%BA%A7/"},{"title":"同心管家-专业心脏病医疗服务平台","text":"同心管家 专业心脏病医疗服务平台 “爱心脏”是致力于心脏病领域的云平台,提供冠心病及相关慢性病患者的院外健康管理、术后随访服务和搭建良好的医患沟通渠道。“爱心脏”拥有强大的心血管疾病现役… .c-group-top{margin-bottom:0!important;padding:10px 10px 11px;border-top:1px solid #E3E3E3;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3}.c-group-middle{margin-bottom:0!important;padding:0 10px 11px;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3}.c-group-bottom{padding:0 10px 10px;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3;border-bottom:1px solid #E3E3E3}.c-group-title{margin-bottom:5px;font-size:16px}.c-group{width:516px!important} 同心管家 2019年9月18日 - “_同心管家_”旨在搭建支架术后康复服务平台,可为用户提供各类优质服务,包括一站式医生咨询、活动交流、术后每日康复方案及康复百科知识等,使用户在支… 乐普 同心管家(Checkme Lite)掌上心脏AI智能分析心电图机多参数… 京东JD.COM是国内专业的网上购物商城,为您提供乐普 同心管家(Checkme Lite)掌上心脏AI智能分析心电图机多参数便携式家用心电监测监护仪价格、图片、品牌、评论、… _同心管家_app下载-_同心管家_下载v5.1.2安卓版-西西软件下载 2018年4月19日 - 同心管家,_同心管家_是一款相当实用的医疗服务软件,_同心管家_提供医疗咨询、社区互动,康复治疗以及百科知识等特色,能够更好的帮助病人快速康复,有需要的… _同心管家_app下载-_同心管家_v6.0.3 安卓版-腾牛安卓网 2020年5月19日 - _同心管家_是一款专注于医疗售后服务的软件,使用_同心管家_app,就能让你在术后恢复的更加快,同时软件还提供一站式的医生交流活动,帮助你更加科学的恢复你… _同心管家app下载|_同心管家_下载v2.1.0.0 安卓版 绿色资源网 2015年6月30日 - 绿色资源网收集的_同心管家_app是一款不错的医疗服务软件。主要为患者用户提供丰富的心脏疾病资讯信息,患者用户可以通过“_同心管家_app”在线预约专家坐… 同心管家_app下载-_同心管家 安卓版v6.0.3-PC6安卓网 2019年9月19日 - _同心管家_app下载-_同心管家_app是一款术后康复应用,提供各种康复应用,能实时和医师在线咨询,了解各种康复知识,更有贴心的用药提醒功能,是您康复医疗的首… _同心管家_iPhone版免费下载__同心管家_app的ios最新版2019.7.26下载… 2019年10月22日 - 多特苹果应用下载为您提供同心管家 2019.7.26苹果手机版下载,_同心管家_免费iphone/ipod/下载安装到手机,让你尽享好玩的苹果手机软件下载. _同心管家_的个人展示页 05-14 09:59 0 5_同心管家_ 0 总阅读量 1378 总内容量致力打造冠心病、三高人群、支架术后康复管理平台。专注为支架手术患者提供术后康复服务。","link":"/2020/07/02/%E5%90%8C%E5%BF%83%E7%AE%A1%E5%AE%B6-%E4%B8%93%E4%B8%9A%E5%BF%83%E8%84%8F%E7%97%85%E5%8C%BB%E7%96%97%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0/"},{"title":"哈勃拍摄唯美宇宙","text":"","link":"/2020/04/11/%E5%93%88%E5%8B%83%E6%8B%8D%E6%91%84%E5%94%AF%E7%BE%8E%E5%AE%87%E5%AE%99/"},{"title":"团队管理：打造高绩效团队","text":"打造高绩效团队","link":"/2020/03/28/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86%EF%BC%9A%E6%89%93%E9%80%A0%E9%AB%98%E7%BB%A9%E6%95%88%E5%9B%A2%E9%98%9F/"},{"title":"在 JAVASCRIPT 中揭开声明倒置的神秘面纱","text":"内容表： 在 JavaScript 世界中，回调和普遍的误解 JavaScript 如何在胡德下工作 提升的真正概念 起重的危险 结束想法 1. 声明倒置和JAVASCRIPT世界中的普遍误解什么是在 Javascript 中声明倒置？作为 JavaScript 开发人员，您真正了解升升非常重要，这不仅是因为它让您更好地了解语言，还因为它可以轻松地在面试部分赚取或花费您一分。 请注意：我会打字相当快，因为我只能一次倒出一个按键的想法，JavaScript似乎是一个相当长的单词打字。所以，请允许我使用JS的地方，我认为适合。感谢您的理解 首先调用12345678logName() // calls functionconsole.log(coderName); // logs coderName to the consolevar coderName = &quot;Lawrence Eagles&quot;; // declares the coderName variablefunction logName () { // declares the logName function console.log(&quot;Brendan Eich&quot;)} 乍一看，您肯定会相信这个定义（_相反，提升是 JavaScript 将声明移动到顶部的默认行为。）_是正确的。然而，让我们通过消化这些示例来揭开这一点，以揭开提升的神秘面纱。代码结果如下： 12logName() // returns Brendan Eich console.log(coderName); // returns undefined 理解这一点的关键是记录变量的结果。函数调用最肯定地像向上移动一样。在这种情况下，处理的代码将是： 123456var coderName = &quot;Lawrence Eagles&quot;; // declares the coderName variablefunction logName () { // declares the logName function console.log(&quot;Brendan Eich&quot;)}logName() // calls functionconsole.log(coderName); // logs coderName to the console 但是，如果是这种情况，结果应该是： 1// logName() returns Brendan Eich 1// console.log(coderName) returns Lawrence Eagles (not undefined) 为了了解这里发生的情况，我们需要了解 JavaScript 如何真正工作。 2. JAVASCRIPT 如何在引擎盖下工作我们从上面的小捏造示例中确立了一个事实，即如果变量和函数确实被 JS 引擎移动到_顶部_，那么结果应该是： 1// logName() returns Brendan Eich 1// console.log(coderName) returns Lawrence Eagles 而不是 12logName() // returns Brendan Eichconsole.log(coderName); // returns undefined 您可能在线对此行为有一个花哨的解释，但事情是这样的，代码的提升版本的行为不像变量移动到_顶部_，而是就好像它是在没有值的情况下声明的一样。因此，它的行为就像代码是： 123456var coderName; // declares the coderName variable without a valuefunction logName () { // declares the logName function console.log(&quot;Brendan Eich&quot;)}logName() // calls functionconsole.log(coderName); // logs coderName to the console 在这里，我们确实得到了一个与代码的提升版本一致的结果。 12logName() // returns Brendan Eichconsole.log(coderName); // returns undefined 引擎盖下的JavaScript。当 JS 引擎处理代码时，它会创建称为执行上下文的内容。这是围绕当前正在运行的代码的包装。它由全局变量、此对象（_您可能知道它为此关键字_）以及该执行上下文的变量环境组成。我们不会深入地进入执行环境，但我们会充分地讨论它，因为这里埋藏的宝藏。 创建执行上下文涉及两个过程，即： 创建阶段：在此期间，变量和函数将添加到内存中。在这里，JS 引擎逐行执行代码，将所有变量添加到内存中，但它尚未分配它们值，而对于函数，它们被添加到整个内存中。这是整个函数（名称和代码块）在此阶段添加到内存。 第二阶段是执行阶段：在此阶段将值分配给变量并调用函数。因此，即使您用值初始化变量，该值也处于第二阶段。在第一阶段，该值不会分配给变量。它被添加到内存中，并初始化了_未定义的_。 3. 提升的真正概念如果您尚未看到它，则整个误解的发生是因为执行上下文的第一个（创建）阶段。在函数最终执行之前，它们已在执行上下文的创建阶段内存中，因此 Javascript 引擎知道该函数的全部位置位于内存中。它没有移动到顶部。因此： 1234logName()function logName () { // declares the logName function console.log(&quot;Brendan Eich&quot;)} 1// returns Brendan Eich 工作正常，就像函数声明移动到顶部一样。但事实并非如此。在执行上下文的创建阶段，整个函数已添加到内存中。因此，在执行阶段，JS 引擎已经知道函数位于内存中并调用它的位置。 变量呢？过程是相同的，但实现有点不同。与上面提到的变量在执行上下文的创建阶段也添加到内存中，但没有为其分配任何值。在 javascript 中，当变量声明没有值时，JS 引擎会自动向其添加未定义的占位符值。这解释了为什么： 12console.log(coderName); // logs coderName to the consolevar coderName = &quot;Lawrence Eagles&quot;; // declares the coderName variable 和 12var coderName; // declares the coderName variable without a valueconsole.log(coderName); // logs coderName to the console 具有相同的结果：未定义 JavaScript 中未定义未定义是 JavaScript 中的原始类型，就像字符串、布尔和数字一样。这意味着您尚未显式为该变量分配任何值。进一步你读在MDN注意这不是一个错误注意它不是空阅读关于空在这里我们可以使这一点更清晰，通过运行 1console.log(coderName) 不声明变量。这是没有以下任何代码。 12var coderName;var coderName = &quot;Lawrence Eagles&quot; 这将引发错误。 1console.log(coderName) // returns VM275:1 Uncaught ReferenceError: coderName is not defined 请注意，这与未定义不同。这是一个错误，告诉您正在尝试记录未在任何地方定义的变量。JavaScript解释器说我在内存中根本不看到这个变量。但是，在提升变量的情况下，变量在内存中，但由于在执行上下文的创建阶段，它被置于此阶段，JS 引擎会为它分配一个称为未定义的值。正是整个过程被许多人感到困惑和误解，他们认为JS引擎实际上会将它们的变量或函数声明移到顶部。 4. 提升的危险声明倒置提供了虚假的安全性。许多开发人员认为 JS 引擎会将其功能和变量声明向上移动，从而有意识地编写错误代码。但实际上，JavaScript引擎不这样做，我们现在可以清楚地看到，JavaScript引擎只是根据我们的代码是如何实现的。这可能非常危险，因为当一个实际值是预料之中时，人们可能会变得未定义，这可能是一个非常讨厌的错误，很难跟踪，我相信在完成调试时，你不会喜欢图片。：三思而后行，编写一次代码，为自己节省调试压力 现代Javascript和回调从es6和上面有新的方法来声明JavaScript中的变量，这使得语言现在更安全，因为让和const（_在Javascript中声明变量的新方法_）不支持提升。 123console.log(coderName); // logs coderName to the consolelet coderName = &quot;Lawrence Eagles&quot;; // declares the coderName variable// returns VM269:1 Uncaught ReferenceError: coderName is not defined 和 123console.log(coderName); // logs coderName to the consoleconst coderName = &quot;Lawrence Eagles&quot;; // declares the coderName variable// returns VM397:1 Uncaught ReferenceError: Cannot access 'coderName' before initialization 不会工作。他们都犯了错误。因此，我们鼓励您编写良好的代码。","link":"/2020/04/14/%E5%9C%A8-JAVASCRIPT-%E4%B8%AD%E6%8F%AD%E5%BC%80%E6%8F%90%E5%8D%87%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/"},{"title":"学习 JavaScript 的最佳方式","text":"您的第一个 JavaScript 教程 ———————————————————————————————————— 假设您使用第一个 JavaScript 教程表示，该教程显示当前日期。 为此，JavaScript 代码是： Click me to display Date and Time 阅读本教程后，您应该在自己的计算机上实现它。以下是您应该遵循的实现步骤： 创建新网页。 将按钮和单击事件添加到该按钮中。 添加警报以显示日期。 在浏览器上运行网页以测试您刚刚创建的功能。 现在，您知道如何实现代码。 我应该使用哪个编辑器进行 JavaScript ———————————————————————————————————— 作为初学者，您还会询问如何编写 JavaScript 代码？您可以使用窗口记事本，也可以下载记事本*，这是一个非常好的编辑器。 然而，根据我最好的编辑将是视觉工作室代码 这是非常轻量级的只有45MB的大小，非常非常强大。它完全免费，并运行在每个操作系统 - 窗口，linux和mac。 JavaScript 的初学者级别应介绍哪些内容 您应该涵盖的主题是 | 1. JavaScript 语法 -JavaScript 语法 2. 变量 -JavaScript 变量 3. 数据类型 -JavaScript 数据类型 4. 操作员 -JavaScript 运算符 5. 算术运算 -JavaScript 算术 6. 分配 -JavaScript 分配 7. JS 输出 -JavaScript 输出 8. 对象 -JavaScript 对象 9. 循环 -在 jQuery JavaScript 中循环循环数组的多种方法 10. 休息并继续 -JavaScript 中断并继续 适合初学者的 JavaScript 程序示例 我还想列出一些初学者应该执行的方案。 1. 创建一个程序，用户在 2 个输入框中输入 2 int 值，并在单击按钮时在警报框中显示其中最大的值。 2. 创建一个程序，用户在文本框中输入数字，并且应在 div 上显示其表（最多 10）。应在按钮单击事件上创建该表。还防止用户在文本框中输入字符串（当输入为字符串时，在警报框上给出相应的错误）。 3.为作业申请创建一个小窗体。它应该有5个字段 - 姓名，年龄，教育，地址和预期工资。这 5 个字段应具有 HTML 控件，其中用户输入其信息，单击时应显示 div 控件上的用户信息的按钮。 4. 查找数字是否为正数。 5. 创建具有共同功能的计算器 – 添加、减去、除法和乘法 JavaScript 的中间级别应涵盖哪些内容 1. 阿贾克斯 a.AJAX 简介 B。AJAX数据库 C。XML 应用程序 2. 功能 a.参数对象 B。箭头函数 C。默认参数 D。方法定义 e.休息参数 F。吸气 G。Setter H。异步函数 3. 使用课程 a.类 B。构造 函数 C。延伸 D。静态 4. JavaScript 饼干 JavaScript 的高级级别应介绍哪些内容 当您处于高级级别时，这意味着您基本上知道如何处理 JavaScript。在高级级别中，您必须处理 JavaScript 与在 Python、Ruby、PHP、ASP NET 等上创建的应用程序的集成。 Here your job would be to make features on JavaScript that communicate efficiently with the Server technology like databases, Python, Ruby, PHP,ASP.NET核心等 使用 JavaScript 制作的高级功能的一些示例包括： 1. 使用 AJAX 每隔几秒钟从数据库部分更新网页部分。 2. 获取并在页面上显示实时股票价格。您可以通过使用 JavaScript 代码实现 API 来获得股票价格。 3.在您的网站中创建交互式功能，以便提高转化率。示例可以是自动完成可以使用 JavaSript 创建的功能。 4. 外部 API 实现，如TMDB API在 JavaScript 中，帮助用户获取任何电影、演员和系列的详细信息 5.无限滚动或自动分页功能 结论 我只想直接指出你的权利，这样你就可以有效地学习JavaScript，同时你也喜欢这个网络语言。 你需要一个良好的耐心来学习JavaScript，就像这个家伙： 我希望你喜欢我的回答，我希望你给我一个赞成票，这样我就能知道我是否有帮助。 谢谢你奈娜","link":"/2020/06/25/%E5%AD%A6%E4%B9%A0%20JavaScript%20%E7%9A%84%E6%9C%80%E4%BD%B3%E6%96%B9%E5%BC%8F/"},{"title":"学习Go 第一周","text":"这是一个博客系列的开始，我每周发布一次。当我学会使用 Go 编程语言时， 我将写我的经验和发现。我正在学习使用一些媒体形式：视频、书籍和讲座。本周， 我将讨论我学到了什么， 完成了托德 · 麦克劳德课程的 25个视频片段。 为什么要去？除了我对编程和计算机科学的热情，我会完全诚实 - 我没有令人信服的答案， 这一个。以下是我最初感兴趣的原因： 由 Google 创建并大量使用 我听说它非常有效 科技行业的需求相当旺盛 它被许多公司使用 社区保持创新，参与 历史去， 或_戈朗_是由罗布派克， 罗伯特格里塞默和肯汤普森在 2009 年创建。那些名字对你意义可能并不大;然而，他们都为软件开发行业贡献了大量。 Rob Pike - 核心 Unix 团队成员，并创建了 UTF-8 编码方案 罗伯特·格里塞默 - 与编程语言的创造者、帕斯卡的创造者尼克劳斯·沃斯密切合作 Ken Thompson - 设计和实现了原始的 Unix 系统，并帮助发明了 C 编程语言 它是编译的、并发的、垃圾回收的和静态的。 你为什么要在乎？问得好我发现托德 · 麦克劳德说的很有见地： 高效编译 高效执行 易于编程 又短又甜。效率与轻松搭配？很好交易 在学习 Go 的第一周， 我已经可以谈谈它是多么令人愉快。我很高兴能深入到更多。 你能用 Go 做什么？我发现，Go可用于很多不同的应用程序，其中一些包括： 命令行工具 密码 图像处理 Http / UDP / TCP 并发（兴奋地了解更多关于这个！ 类型是国王Go 是一种静态类型语言 - 类型很重要，在此之前，我主要使用 Javascript，一种动态类型语言。诚实时间：_我很少_从类型上考虑;但是，我知道使用静态类型语言会使_我_成为一个更好的开发人员。 思维成语在上这门课之前，我不可能告诉你”习惯”是什么意思。我听到 “习惯去” 这句话， 我惊慌失措的一刻 — — 我脑子里在吗？听起来太聪明了_习语_来自”习_语”_这个词，这个词就不那么吓人了： id - i - om 用法确立为具有个别词中不可理解的一组词 从本质上讲，”习惯性去”是一种约定的风格和方法，用被创作者_祝福_的语言写作。 更小的东西来制造更大的事物Go 应用程序由包组成。我习惯于从文件及其各自的文件夹的角度考虑应用程序。相比之下， 去更干净， 被剥下来。 我接触过的第一批”Go”是传统的”你好世界”节目。我知道有时很容易认为这些例子 “太琐碎”， 但是， 我觉得它们很有帮助。你跑步前必须走路，对吗？ 1234567891011package mainimport ( &quot;fmt&quot;)func main() { fmt.Println(&quot;Hello world&quot;)} 很简单吧？让我来引导你了解一下发生了什么。首先，每个_Go 应用程序都必须_有一个包。这些通常在应用程序中的文件中找到。很多包，包括 ，都是从所谓的 Go ，它们轻量级和快速。 123456789mainmain.goROOTfmtStandard Library 所有 Go_应用程序的入口_点是函数。这是运行应用程序的所有代码的地方。执行代码后，此函数完成，程序即完成。 1main 从包的角度思考Go 是专为在创建应用程序时_考虑_包而设计的。包非常简单的是包含功能的源文件。Unix显然对 Go 的创作有很大的影响，正因为如此，他们有着相同的理念——_更小的东西来制造更大的事物_。 小，简洁，咬大小。 变量Go 有一些很酷的内置行为与变量。我最喜欢的是：你不能_声明一个变量，不能使用它_。这回回到 Go 性能的校长和目标之一.通过强制使用所有声明，有助于保持内存效率。 变量的另一个很酷的功能是能够”扔掉”返回值。可以这样进行： 1234567891011package mainimport ( &quot;fmt&quot;)func main() { id, _ := ReturnId()} 在函数内部，我预期从函数接收 2 个返回值;但是，在这种情况下，我只关心 的值。通过使用我”扔掉”第二个返回值。 1234567mainReturnIdid_ 短声明运算符到目前为止，我已经了解了在 Go 中声明变量的两种常见方法，尽管它们非常相似，但显著的区别是它们_的范围_。 短期声明运算符 1:= &lt;—-声明运算符（看起来像妖精） 在编写 Go 程序时，这种声明变量的方法似乎是最常见的。我相信一个主要原因是它在。使变量与正在执行的工作保持接近，可降低变量的副作用或更改的风险。 1function scope 必须声明在函数体内部 无法使用类型声明 var 关键字声明变量的另一种常见方式是使用 关键字。关于关键字差异的一些注意事项是： 123varvar 可以在函数体外部声明 可以使用类型 （、等） 声明123intstringmap 重申一点：最好尽可能使用简短的声明运算符。 类型我还没有在 Go 中深入类型， 但我知道这些类型： 原始数据类型：布尔、数字（浮动、int 等）和字符串 复合数据类型：数组、结构、指针、函数、接口、切片、地图和通道 零值关于使用 关键字，我学到的一个很酷的事情是，当您声明一个没有初始值的变量时，Go 编译器会自动分配所谓的 。以下是常见数据类型的零值： 12345678910111213var zero valuevar y string// &quot;&quot;var z int// 0var z bool// false// nil for pointers, functions, interfaces,// slices, channels, maps 创建您自己的类型除了在 Typescript 中使用接口之外，我在创建自己的类型方面也没有太多的经验。我发现 Go 让这一切变得非常简单。 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot;)var a int = 42type midichlorian intvar b midichlorianfunc main() { fmt.Print.ln(a) // 42 fmt.Printf(&quot;%T\\n&quot;, a) // int b = 43 fmt.Print.ln(b) // 43 fmt.Printf(&quot;%T\\n&quot;, b) // main.midichlorian} 如上所示，我声明一个变量，名称为 类型 。接下来，我使用 关键字定义具有 名称 的新类型。这里需要注意的是，虽然我声明了一种称为 的新类型，但它的基础_类型_是 。 1a int type int midichlorian midichlorian int “转换”而不是”强制”只有由于 Go 的强、静态类型的精神， 转换值将是一个完全深思熟虑的行动， 这才有意义。在 JavaScript 中，这称为_类型转换，并不完全可靠。Go 采用另一种方法-_转换值的类型，不_强制转换类型_。我将演示下面。 12345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;fmt&quot;)var a int = 42type midichlorian intvar b midichlorianfunc main() { a = 42 fmt.Println(a) // 42 fmt.Printf(&quot;%T\\n&quot;, a) // int b = 43 fmt.Println(b) // 43 fmt.Printf(&quot;%T\\n&quot;, b) // main.midichlorian // CONVERSION &lt;&lt;&lt;&lt;&lt;&lt; a = int(b) fmt.Println(a) // 43 fmt.Printf(&quot;%T\\n&quot;, a) // int} 如您所见，我们将变量与 类型 的值一起声明。然后，使用变量上的转换函数的返回值重新分配变量。很酷吧？使用 Go 时，您使用的类型没有不确定性。 1b 43 midichlorian a int() b 总之","link":"/2020/07/04/%E5%AD%A6%E4%B9%A0Go%20%E7%AC%AC%E4%B8%80%E5%91%A8/"},{"title":"学习使用 webpack（1）---简介","text":"webpack这东西其实使用上已经用了一两年的时间了，不过都是在VUE中进行使用，基本处于傻瓜式使用，对其实现原理以及配置细节不是很熟悉。说来也巧，最近也正打算使用ES6原生开发仿google earth项目，这方面也就提上了日程需要强化学习一下。简单地说webpack是JavaScript静态模块打包工具，支持以ES6、CommonJs、CMD、AMD等模块规范对项目进行打包。当然webpack不仅仅是打包js文件，也可以对CSS、图片文件等进行打包。","link":"/2020/04/16/%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8-webpack%EF%BC%881%EF%BC%89-%E7%AE%80%E4%BB%8B/"},{"title":"学习使用 webpack（2）---环境搭建","text":"在使用_webpack_前首先需要安装 _Node.js_环境。进入_Node.js_官网下载最新长期维护版本即可1.安装webpack Sh 1npm install webpack webpack -D 这里不推荐全局安装 2.构建项目 Sh 1npm init -y 在生成的package.json中，添加 “private”: true(私有)， 若项目不作为模块供外部调用则去除”main”: index.js。 Package.json如下 Json 1234567891011121314 { &quot;name&quot;: &quot;webpack_demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;private&quot;: true, &quot;scripts&quot;: {}, &quot;keywords&quot;: [], &quot;author&quot;: &quot;Felix Ma&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: { &quot;webpack&quot;: &quot;^4.42.1&quot;, &quot;webpack-cli&quot;: &quot;^3.3.11&quot; }} 使用命令 Sh 1npx webpack 可调用项目中安装的webpack","link":"/2020/04/16/%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8-webpack%EF%BC%882%EF%BC%89-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"工具推荐篇：PlantUML,程序员的专属绘制流程图工具，就像写代码一样便利","text":"选择_PlatnUML_原因 _PlantUML_是开源的，有一个相对比较成熟的网站，通过简单的UML语言来实现想要的效果，有点极客范 _PlantUML_有比较详细的各类语言的guide文档 _PlantUML_做了很多的适配，比如常用的编译器_eclipse_，_IDEA intelliJ_都有对应的插件，同时还和_Maven_和_JQuery_都做了集成，还提供了_war_包形式，可以在本地的_JavaEE_容器（比如_Tomcat_）中运行起来 _PlantUML_语言简单直接易学，就好像Markdown语法一样，简单高效 _plantuml_官网 - 开源工具,使用简单的文字描述画UML图。 轻松从简单的文字说明创建_UML_图。也有许多种可用的图表。它也可以在PNG,乳胶,EPS,SVG图像导出。 程序员绘图工具-Plantuml - 简书 2018年11月29日 - 最近在网上找到了一款还算不错的绘图工具– Plantuml, 它本质上是也算一门可以快速画图的设计语言,学习起来也很方便。可以在http://plantuml.com/网站上体验一… PlantUML,让你知道什么才是高效绘制流程图 - 知乎 2019年8月6日 - 官方网址开源工具,使用简单的文字描述画UML图。_PlantUML_是一个开源项目,支持快速绘制的类型:顺序图的语法和功能用例图语法和功能类图的语法和功能新的活动图测试语法… 时序图-plantuml - 顺序图的语法和功能 _PlantUML_序列图的语法:你可以有几种类型的参与者(演员和其他人),箭头,音符,组…改变字体和颜色也有可能。 plantuml download | SourceForge.net 2020年3月6日 - Download plantuml for free. PlantUml allows to quickly create some UML diagram using a simple textual description language. _PlantUML_入门 - 简书 2019年3月24日 - 在线通过_PlantUML_语言绘制对应的UML图,_plantUML_官网提供了免费的在线编辑服务,通过在左侧输入对应的UML语言来生成对应的UML图,地址如下:online-site 1553415664042.png… IntelliJ IDEA反向生成_UML_类图 2019年6月18日 - 最近在开发的过程当中,对于已有的代码,想将相关类绘制成UML类图,虽然现在有很多UML类图的优秀软件,比如ProcessOn(可视化编辑)、draw.io(可视化编辑)、PlantUML(代码… _PlantUML__FamilyYuan的博客-CSDN博客 2017年11月30日 - _PlantUML_前言UML 对于技术文档来说,真的很重要,不管是形象展示,还是阅读理解,都发挥非常重要的作用。之前一直用 visio 画图,当然,我必须承认 visio 集… _PlantUML_安装与使用 - Wunsam_Chan - 博客园 2018年10月27日 - 如果你安装好了java环境,理论上在命令行中输入java -jar plantuml.jar ‘sample’.uml就可以了。 新版本的plantuml.jar可以有不需要graphviz的语法,不过如果你使用… 1 PlantUML 简介及语法、图标和示例_开发工具_向阳的味…_CSDN博客 2018年4月10日 - 一.安装PlantUML_插件IDEA 安装_PlantUML_二.windows下安装Graphvizwindows下Graphviz安装及入门教程三._PlantUML_使用方法_PlantUML 简介及语法… 博文 来自: 麦洛 在… _plantuml_使用教程【转】 - 小天儿 - 博客园 2016年4月16日 - 编写本文的目的旨在记录个人在学习_PlantUML_时对官网上一些内容的理解,以 及总结学习过程中遇到的问题,并将… PlantUML 速查表 - 前端速查表 前端速查表为你提供PlantUML_的基本使用教程,教你如何入门_PlantUML,同时也一步步熟悉PlantUML,学_PlantUML_用前端速查表。 PlantUML —— 应用于 Eclipse 的简单快速的 UML 编辑软件 2012年7月5日 - 支持的 UML 图包括:时序图、用例图、类图、组件图、活动图等。PlantUML 可以帮助开发人员建立和编辑 UML,有较好的应用前景。 UML 的简介… _PlantUml_入门(一) - OSCHINA 2012年3月18日 - PlantUML_的用法还是比较简单的,首先安装好 Graphviz,然后安装_plantuml_的eclipse插件 安装好之后从eclipse的菜单windows–&gt;show view–&gt;Other里找到_pla… PlantUML - UML建模 - 开发工具 - 深度开源 _PlantUML_是一个UML图绘制Java开源组件。利用它可以快速绘制:时序图、用例图、类图、组件图、活动图。这些图形使用一种简单和直观的语言来定义。 _PlantUML__图文_百度文库 评分:5/5 117页 2016年5月27日 - 使用PlantUML 绘制的 UML 语言参考指引 (2016 年 1 月 20 日星期三上午 8:22) PlantUML 是一个开源项目,并支持快速绘制: ? 时序图 ? 用例图 ? 类图 ? … PlantUML 简明教程 - 云+社区 - 腾讯云 2019年10月10日 - PlantUML 是一个开源项目,支持快速绘制时序图、用例图、类图、活动图、组件图、状态图、对象图、部署图等。同时还支持非 UML 图的甘特图、架构图等。… plantuml 生成uml图-dolinux-ChinaUnix博客 2013年4月11日 - 在win下,_plantuml_使用: 1. 首先安装好 Graphviz, 可以在http://www.graphviz.org/Download_windows.php 下载zip包解压到本地就可以了。 2. 然后安 _PlantUML_类图-云栖社区-阿里云 2016年4月8日 - 类之间的关系 _PlantUML_用下面的符号来表示类之间的关系: 泛化,Generalization:&lt;|– 关联,Association:&lt;– 组合,Composition:*– 聚合,Aggregation:o–… _PlantUML_知识库 - 开发者头条 - 1 在Android Studio 中使用 PlantUML 前言Unified Modeling Language (UML)又称统一建模语言或标准建模语言,用来描述 类(对象的)、对象、关联、职责、行为、接口、用… tools using the plantuml language - 使用_PlantUML_语言工具 您可以选择多种工具整合_PlantUML_。你可以用它在你的维基,在文本编辑器或IDE,你产生的文档中。你也可以从源代码中调用它。 plantuml.jar - Download plantuml from SourceForge.net PlantUml allows to quickly create some UML diagram using a simple textual description language. 1 PlantUML 简介及语法、图标和示例_开发工具_向阳的味…_CSDN博客 2018年4月10日 - 一.安装PlantUML_插件IDEA 安装_PlantUML_二.windows下安装Graphvizwindows下Graphviz安装及入门教程三._PlantUML_使用方法_PlantUML 简介及语法… 博文 来自: 麦洛 在… 利用_plantuml_绘制类图 - 类图的语法和功能 _PlantUML_类图的语法:您可以定义接口,成员关系,包,泛型,注释…改变字体和颜色也有可能。 (一)PlantUML 语法之时序图 - Yiaz - 博客园 2019年3月21日 - IDEA 下载插件 PlantUML,直接在 IDEA 里面编写 UML,很方便;然后电脑再安装渲染引擎 Gravizo ,没有它,复杂的类图就无法渲染了 ; 链接:https://pan.baid… 绘图工具(代码实现绘图)—_plantuml__wulong710的专栏-CSDN博客 2018年2月1日 - 最近看到asciidoc和plantuml;是编写文档的极好工具。相对word和visio,最大的好处是可以实现代码版本管理,作为changelist。 asciidoc,相对markdown来… 【工具使用系列】UML_建模工具_PlantUML - Allen-Moore的博客 2019年5月28日 - _PlantUML_快速入门… _PlantUML_是一个开源工具,允许用户使用纯文本语言创建UML图表。 _PlantUML_的语言是特定于域的语言的示例。它使用Graphviz软件来布置其图表。它已被… PlantUML 语法之时序图 | woodwhale’s blog 2019年1月13日 - 快速高效生成时序图… Visual Studio Code 安装 plantUML 插件,在插件应用商店中搜索:PlantUML,点击安装即可。快捷键:Alt + D 即可快速预览,Ctrl + S… plantuml PlantUml allows to quickly create some UML diagram using a simple textual description language.http://plantuml.sourceforge.net … _PlantUML_快速入门-社区博客-网易云 2018年7月11日 - 因为本人是开发人员,使用类图比较多,下面主要以类图为例介绍_PlantUML_的用法。先熟悉一下类图中的六种关系 类图中的六种关系 实现(Realize):元素A定义…","link":"/2020/04/09/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90%E7%AF%87%EF%BC%9APlantUML-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%93%E5%B1%9E%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%B0%B1%E5%83%8F%E5%86%99%E4%BB%A3%E7%A0%81%E4%B8%80%E6%A0%B7%E4%BE%BF%E5%88%A9/"},{"title":"微信 小程序需要授权 有部分人需要获取验证码","text":"12345678910111213141516171819202122232425262728293031323334353637//获取用户的授权信息，放到本地缓存中 wx.getSetting({ success: (res) =&gt; { if(res.authSetting['scope.userInfo']) { wx.setStorage({ key: 'can_getuserinfo', data: 1, }) } else { wx.setStorage({ key: 'can_getuserinfo', data: 0, }) } } }), //1:从本地缓存中获取数据，如果获取到根据结果显示Index页面的授权按钮是否显示， //2:如果从本地缓存获取不到数据则说明用户清空了本地数据，默认设置为0，让用户重新授权 wx.getStorage({ key: 'can_getuserinfo', success: function (res) { console.log(res.data); that.setData({ can_getuserinfo:res.data }) },fail:function() { that.setData({ can_getuserinfo: 0 }) } }) }, _微信小程序_判断用户是否_需要_再次_授权获取_个人信息 2018年7月7日 - 效果是如果用户授权_过了,则直接首页不显示_授权_按钮,直接进入业务页面,如果用户没_授权,则显示授权_按钮让用户选择_授权 微信小程序判断用户是否需要再次… _微信小程序_判断用户是否_需要_再次_授权获取_个人信息_javascript技巧… 2019年7月18日 - 这篇文章主要介绍了_微信小程序_判断用户是否需要再次_授权获取_个人信息,文中通过示例代码介绍的非常详细,对大家的学习或者工作具有一定的参考学习价值,… _微信小程序_判断用户是否_需要_再次_授权获取_个人信息_weix…_CSDN博客 2018年7月7日 - _微信小程序_判断用户是否需要再次_授权获取_个人信息 一、index.js设置如下 //获取用户的_授权_信息,放到本地缓存中 wx.getSetting({ success: (res) =&gt; {… 小程序_中_授权_手机号码为什么_验证码? | _微信_开放社区 2019年1月18日 - 框架类型 问题类型 操作系统版本 手机型号 微信_版本 _小程序 Bug 12.1 华为/…手机号码 授权_都是直接_授权_就可以了,只是有少_部分人_在_授权_时,还_需要验… _微信小程序_三种_授权_登录的方式 - weixin_33672400的博客 - CSDN博客 2019年5月14日 - 常规写法,_需要获取_用户公开信息(头像,昵称等)时,判断调取_授权_登录接口,但是此方法如果不经处理的话 用户如果拒绝_授权_或者删除该_微信小程序_后 需要重新… _微信小程序授权获取_到用户手机号之后还有必要发短信_验证码_绑定吗? 2019年12月31日 - 看不少_小程序_在_得到授权获取_到用户手机号之后,依然让…1人赞同了该回答 其实没必要。 短信验证的目的有两…说白了,这些产品不信任_微信获取_的号码,需… _微信小程序获取_用户_授权_手机号的问题-CSDN论坛 _微信_手机号_授权_登陆 点击这个按钮弹出框效果为: 但是有的_小程序_的效果是这样的: 请问这种效果是怎么做到的? 0 2019-04-29 16:31:02 回复数 11 查看全部楼层… 微信小程序获取_“_微信_手机号”_授权,然后用户“确认_授权_”后,弹不… 2018年5月17日 - 微信小程序获取_“_微信_手机号”_授权,然后用户“确认_授权_”后,弹不出来“填写手机短信_验证码_”的框,如何解决? 我_需要获取_填写的_验证码_才能进行下一步操… 如何取消对微信小程序_的_授权-百度经验 2017年11月27日 - 如何取消对微信小程序_的授权,细心的朋友有没有发现,大_部分小程序_在使用前都_要授权_你的_微信_昵称,头像等用户信息,_有些小程序_还要求获取你的地理位置,_有…","link":"/2020/06/04/%E5%BE%AE%E4%BF%A1%20%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%9C%80%E8%A6%81%E6%8E%88%E6%9D%83%20%E6%9C%89%E9%83%A8%E5%88%86%E4%BA%BA%E9%9C%80%E8%A6%81%E8%8E%B7%E5%8F%96%E9%AA%8C%E8%AF%81%E7%A0%81/"},{"title":"按值排序对象的 JavaScript 排序数组","text":"曾经拥有一组对象，需要根据特定值对其进行排序？这是一个每个人都会经常遇到的问题，想象一下任何表表的价目表。 按值排序对象的 JavaScript 排序数组让我们从以下对象数组开始： var products = [ { color: 'white', price: 10, name: 'Basic T-shirt' }, { color: 'red', price: 5, name: 'Cheap T-shirt' }, { color: 'black', price: 50, name: 'Exclusive T-shirt' }]; 所以，看到这个列表，我们已经有一个快速的两个选项，我们希望根据颜色和价格排序。 现在，我们如何根据值进行排序？ 我们可以使用 操纵器。sort``````Arrays products.sort((a, b) => (a.color > b.color ? 1 : -1)); 正如您可以看到一个简单明了的函数，它将根据颜色进行排序并替换值，直到它完成。您可以将此功能视为手动循环，但随后所有功能都为您完成。if...else 至于价格，我们可以做以下几点： products.sort((a, b) => (a.price > b.price ? 1 : -1)); 对第二个参数进行排序因此，假设我们想要对颜色进行排序，但如果颜色相同，则要对价格进行排序。 var productsPrice = [ { color: 'white', price: 10, name: 'Basic T-shirt' }, { color: 'white', price: 5, name: 'Cheap T-shirt' }, { color: 'black', price: 50, name: 'Exclusive T-shirt' }]; productsPrice.sort((a, b) =&gt; a.color &gt; b.color ? 1 : a.color === b.color ? (a.price &gt; b.price ? 1 : -1) : -1); 所以同样的设置，但我们使用回调功能来检查颜色是否相同，然后我们还需要检查价格！ 您可以玩以下 Codepen。 在CodePen上，由克里斯·邦格斯（@rebelchris） 查看按值排列对象的笔JavaScript 排序数组。 感谢您的阅读，让我们连接！感谢您阅读我的博客。请随时订阅我的电子邮件通讯，并在Facebook或Twitter上连接","link":"/2020/05/31/%E6%8C%89%E5%80%BC%E6%8E%92%E5%BA%8F%E5%AF%B9%E8%B1%A1%E7%9A%84%20JavaScript%20%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"title":"推荐算法简介","text":"在本教程中，您将收到一份简短的、无代码的建议系统介绍。我们将在下一教程中编写第一个推荐系统来跟进这一点。 目录您可以使用下面的目录跳到本建议系统教程的特定部分： 什么是推荐系统？ 推荐系统和线性代数 推荐系统如何工作？ 最后的想法 什么是推荐系统？建议系统用于在数据集中查找类似的条目。 也许最常见的建议真实示例存在于 Netflix 中。更具体地说，其视频流媒体服务将推荐基于你已经观看的内容的电影和电视节目。 另一个推荐系统是Facebook的”你可能认识的人”功能，它建议你可能的朋友，根据你现有的朋友名单。 充分开发和部署的建议系统极其复杂。它们也非常耗费资源。因此，我们仅在本课程中讨论推荐系统的基础知识。 推荐系统和线性代数成熟的推荐系统需要线性代数的深层背景，才能从头开始构建。 因此，如果您以前从未研究过线性代数，则本节中可能有些概念无法理解。 不过，不要担心 - 使构建推荐系统变得非常容易，而且实际上不需要任何线性代数背景来继续完成本课程。scikit-learn 推荐系统如何工作？推荐系统主要有两种类型： 基于内容的建议系统 协作筛选建议系统 基于内容的推荐系统会根据已使用的项目的相似性提供建议。他们完全按照你期望的推荐系统的方式。 协作筛选建议系统根据用户与项目交互的知识生成建议。换句话说，他们使用人群的智慧（因此，它的名字是”协作”一词）。 在现实世界中，协作筛选建议系统比基于内容的系统更常见。这主要是因为它们通常能产生更好的结果。一些从业者还发现协作筛选建议系统更易于理解。 协作筛选推荐系统还具有基于内容的系统所缺少的独特功能。也就是说，他们有能力自己学习功能。 这意味着他们可以开始根据您甚至未告诉他们考虑的属性来识别项之间的相似性！ 协作筛选中有两个子类别： 基于内存的协作筛选 基于模型的协作筛选 您无需了解这两种类型的协作筛选建议系统之间的差异，就可在本课程中取得成功。这足以识别存在多种类型。 最后的想法在本教程中，您收到了机器学习推荐系统的第一个无代码介绍。我们将在下一课中编写第一个 Python 推荐系统，以对此进行跟踪。 以下是我们在本教程中讨论的简要摘要： 现实世界中推荐制度的例子 不同类型的推荐系统，以及协作筛选系统如何比基于内容的建议系统更常用 推荐系统与线性代数的关系","link":"/2020/06/21/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/"},{"title":"日常笔记-开篇","text":"日常笔记-开篇学习markdown 语法标题： 123# 一级标题## 二级标题### 三级标题 序列：注意：中间会有个空格！中间会有个空格！中间会有个空格！常用 语法 的肯定是： 123- 列表文字1. 列表文字2. 列表文字 图片语法 的肯定是： 1![图片名](图片地址) 链接语法 的肯定是： 1[超链接名](超链接地址)","link":"/2019/11/14/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0-%E5%BC%80%E7%AF%87/"},{"title":"最新技术周刊 01","text":"这是本周值得您花时间的五个链接： 1.以下是9种最常用的机器学习算法，所有算法均以纯英文解释。本文将以初学者友好的方式向您介绍随机森林，K最近邻，线性回归和其他方法。 （阅读18分钟）： https://www.freecodecamp.org/news/a-no-code-intro-to-the-9-most-important-machine-learning-algorithms-today/ : https://www.freecodecamp.org/news/a-no-code-intro-to-the-9-most-important-machine-learning-algorithms-today/ 2.如果您想获得云认证，这是一个免费的Azure云认证课程。它将教您通过AZ-900考试所需了解的概念。 （观看3小时）： https://www.freecodecamp.org/news/azure-fundamentals-course-az900/ : https://www.freecodecamp.org/news/azure-fundamentals-course-az900/ 3. Flutter是Google提供的功能强大的新框架，可让您使用相同的代码库同时为iPhone，Android，Web和PC生成应用程序。本课程将教您Flutter基础知识。 （观看3小时）： https://www.freecodecamp.org/news/flutter-app-course-mobile-web-desktop/ : https://www.freecodecamp.org/news/flutter-app-course-mobile-web-desktop/ 4.从统计学上讲，DevOps是您可以进入的收入最高的非管理开发人员领域。此免费课程将教您一些Linux，网络以及其他一些入门学习DevOps所需的概念。这不是入门级的职业，但是如果您已经具备一些基本的编程技能，那么这将使您朝着正确的方向前进。 （观看3小时）： https://www.freecodecamp.org/news/devops-prerequisites-course/ : https://www.freecodecamp.org/news/devops-prerequisites-course/ 5.如何使用Node.js和Web套接字创建专业的聊天API。这个全面的教程将帮助您逐步构建自己的API，并为您提供许多编码实践。 （阅读35分钟）： https://www.freecodecamp.org/news/create-a-professional-node-express/ : https://www.freecodecamp.org/news/create-a-professional-node-express/","link":"/2020/06/21/%E6%9C%80%E6%96%B0%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A%2001/"},{"title":"架构师:架构师三大原则","text":"","link":"/2020/03/26/%E6%9E%B6%E6%9E%84%E5%B8%88-%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%89%E5%A4%A7%E5%8E%9F%E5%88%99/"},{"title":"构建一致的 RESTful API","text":"在构建 RESTful API 时，应用程序是无限的，而标准和/或最佳实践在不同的堆栈中保持不变。这是试图描绘一些这些标准和最佳做法（高度意见）。 授权表示状态传输 （REST） 有效地使会话无效，因此，我们的应用程序需要另一种方式授权尝试访问它的用户。最常用的授权工具之一是JSON Web令牌-JWT。用户登录或注册我们的应用程序后，将令牌分配给该用户一段时间（长度主要取决于应用程序的安全问题）。一种好的做法是向令牌添加唯一标识符，以便应用程序中的每个请求都可以为发出该请求的特定用户提供服务，而无需向用户请求额外的参数。 例如，如果我使用 JWT 登录，并且尝试检索我在应用程序上进行的所有事务，则应用程序应该能够仅基于我的 JWT 授权令牌提供我的事务。 无需进入实现详细信息，则可以通过让服务拦截传入请求、处理 JWT 令牌并设置在整个应用程序中可访问的current_user对象或变量来实现此目的。 资源、操作和 HTTP 方法在 REST 中，我们有资源，可以表示数据库表，例如公司、用户、帖子、消息等。每个资源都有一个可以对它执行的操作的列表。这些操作由对该资源的每个请求的 HTTP 方法确定。HTTP 方法也称为 HTTP VERBS，因为它们执行/确定操作。给定一个资源，下面的事务是一些最常见的对应的 HTTP 方法和操作。 123456GET - /事务（获取所有交易） GET - /事务/：id（获取单个事务） POST -/事务（创建新事务） PUT - /事务/：id（更新交易部分） update - /事务/：id（更新交易） delete - /事务/：id（删除交易） 根据应用程序的规模，您可能需要按自定义终结点扩展资源上可用的操作。自定义终结点可以影响整个资源（集合）或资源的成员。对于影响集合的操作，如下所示： 12GET - /事务/用户（获取已进行交易的所有用户） GET - /事务/失败（获取所有失败的事务） 对于成员，假设我们有一个单独的但相关的资源事务详细信息： 123GET - /事务/：id/详细信息（获取交易详细信息） POST -/事务/：id/详细信息（为事务创建详细信息） PUT -/事务/id/详细信息（更新交易记录的详细信息）。 HTTP 响应状态根据执行的操作和操作的状态，从每个请求返回的响应和状态。POST请求绝不应返回 204（无内容），删除请求不应返回 201（已创建）。以下是基于其请求和状态的最常见响应。 200 - 确定请求已完成。但是，如果请求的操作已成功完成，则不能出错，具体取决于操作，可能会有更合适的状态消息。 201 - 已创建理想情况下，每当在创建的对象旁边创建新对象（主要是使用POST请求）时，都应返回该对象。返回创建的对象是个人首选项，因为它将立即授予对新创建的对象的访问权限。 204 - 无内容在对象上完成DELETE后，可以而且应该返回。 401 - 未经授权当用户尝试需要授权但请求不具有该授权的操作时，这是适当的。 404 - 未找到极不可能，但如果用户请求不存在的资源，则 404 是需要响应的适当状态。尽管基于您的用例，但返回200 - 确定，空结果可能更合适。","link":"/2020/04/14/%E6%9E%84%E5%BB%BA%E4%B8%80%E8%87%B4%E7%9A%84-RESTful-API/"},{"title":"架构师:知人善用","text":"","link":"/2020/03/26/%E6%9E%B6%E6%9E%84%E5%B8%88-%E7%9F%A5%E4%BA%BA%E5%96%84%E7%94%A8/"},{"title":"架构师：一个演进式架构师应该承担的职责","text":"愿景确保在系统级有一个经过充分沟通的技术愿景，这个愿景应该可以帮助你满足客户和组织的需求。 同理心理解你所做的决定对客户和同事带来的影响。 合作和尽量多的同事进行沟通，从而更好地对愿景进行定义、修订及执行。 适应性确保在你的客户和组织需要的时候调整技术愿景。 自治性在标准化和团队自治之间寻找一个正确的平衡点。 治理确保系统按照技术愿景的要求实现。 演进式架构师应该理解，成功要靠不断地取舍来实现。总会存在一些原因需要你改变工作的方式，但是具体 做哪些改变就只能依赖于自己的经验了。而僵化地固守自己的想法无疑是最糟糕的做法。","link":"/2020/03/26/%E6%9E%B6%E6%9E%84%E5%B8%88%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%BC%94%E8%BF%9B%E5%BC%8F%E6%9E%B6%E6%9E%84%E5%B8%88%E5%BA%94%E8%AF%A5%E6%89%BF%E6%8B%85%E7%9A%84%E8%81%8C%E8%B4%A3/"},{"title":"正文提取算法","text":"浅识网页正文提取算法 - 游-游 - 博客园 2014年3月18日 - 浅识网页正文提取算法 因为要到一家互联网公司参加自然语言处理实习生面试,对于岗位要求中提到的工作内容–”网页正文内容提取”的相关知识进行了一下突… 网页_正文提取算法_介绍 - 不死鸟2013 - 博客园 2012年3月6日 - 国内:哈工大的《基于行块分布函数的通用网页_正文抽取_》该_算法_开源网址为http://code.google.com/p/cx-extractor/,效果为亲测,文章中呈准确率95%以上,… 网页正文_及内容图片_提取算法 - 简书 2015年10月5日 - 《基于行块分布函数的通用网页正文抽取算法_》的作者总结了一般从网页中提取文章正文的方法,提出基于行块分布的_正文抽取算法,并给出了 PHP 、Java 等… 网页_正文_及内容_提取算法__DT-CSDN博客 2016年5月23日 - 基于行块分布函数的通用网页正文抽取http://wenku.baidu.com/link?url=T… 正文抽取算法:1.Html2Article :http://www.cnblogs.com/jasondan/p/349775… _正文提取__爬虫_VergiL Wang的专栏-CSDN博客 2012年10月25日 - 目前互联网上公布出来的正文提取算法,大家可以综合比较下,一起来测试下哪个更好用。 词网–北京词网科爬虫 基于内容的网页_正文提取算法_的研究与实现 _正文提取算法_文档模板视觉特征网络爬虫网页文本一个网页,往往包含着导航,版本,广告,相关链接,主题信息等等各种复杂的信息。网页主题信息抽取主要负责完成自动抽取页面上… 正文提取_的库(_算法),大家有成熟的解决方案么 - V2EX 2016年9月2日 - Python - @phithon - 想求一个提取_文章_正文_的库或_算法, python 的。主要用在采集上,采集下来的东西准备去掉没用的头和尾,只保留_正文_。印象笔记有个浏… Web页面正文_信息_提取算法 (2)基于块和标签用途的WEB页面正文_信息_提取 本文提出一种基于块和标签用途的WEB页面正文_信息_提取_方法,在DOM树和VIPS_算法_的基础上,总结出了利用块和标签用途去_提取… .c-group-top{margin-bottom:0!important;padding:10px 10px 11px;border-top:1px solid #E3E3E3;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3}.c-group-middle{margin-bottom:0!important;padding:0 10px 8px;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3}.c-group-bottom{padding:0 10px 10px;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3;border-bottom:1px solid #E3E3E3}.c-group-title{margin-bottom:5px;font-size:16px}.c-group{width:516px!important} .c-group-top{margin-bottom:0!important;padding:10px 10px 11px;border-top:1px solid #E3E3E3;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3}.c-group-middle{margin-bottom:0!important;padding:0 10px 8px;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3}.c-group-bottom{padding:0 10px 10px;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3;border-bottom:1px solid #E3E3E3}.c-group-title{margin-bottom:5px;font-size:16px}.c-group{width:516px!important}","link":"/2020/05/24/%E6%AD%A3%E6%96%87%E6%8F%90%E5%8F%96%E7%AE%97%E6%B3%95/"},{"title":"6.深入Java系列异常org.springframework.security.authentication.BadCredentialsException","text":"记一次使用SpringSecurity_出现的异常_security.authenti…_CSDN博客 2019年11月27日 - org.springframework.security.authentication.BadCre… org.springframework.security.authentication.BadCredentialsException: Bad credentials a… SpringSecurity_出现org._springframework.security.authen…_博客园 2020年1月26日 - SpringSecurity出现org.springframework.security.authentication.BadCredentialsException: Bad credentials 出现Bad credentials,排除了配置问题,de… org.springframework.security.authentication.BadCreden…_博客园 2019年5月26日 - org.springframework.security.authentication.BadCredentialsException: Bad credentials 错误原因:方法上忘记加RequessMapping(“/方法映射”) … 获取org.springframework.security.authentication.Bad… 2018年6月1日 - Authentication auth = authManager.authenticate(authReq); 例外- org.springframework.security.authentication.BadCredentialsException: Bad cr… org.springframework.security.authentication.BadCred…_CSDN博客 2019年5月26日 - .springframework.security.authentication.BadCredentialsException: Bad credentials…问题:最近在做集成spring-securitry做app的认证,当我注入配… Caused by: org.springframework.security.authentication.Bad… 2018年11月1日 - 使用spring security登陆的时候一直报这个错Caused by: org.springframework.security.authentication.BadCredentialsException: Bad credentials 这… Java org.springframework.security.authentication.Bad… 2017年10月24日 - Java org.springframework.security.authentication.BadCredentialsException 代码实例以下是展示如何使用org.springframework.security.authenticati… org.springframework.security.authentication.BadCredentials… 2014年5月15日 - org.springframework.security.authentication.BadCredentialsException: The presented RememberMeAuthenticationToken does not contain the expect… spring - Authentication request failed: org.springframework… 2020年3月2日 - Authentication request failed: org.springframework.security.authentication.BadCredentialsException: Bad credentialsAsk Question Asked 5 year… …状态401当Authentication_Manager抛出_BadCredentialsException… 2018年12月28日 - Spring-Security: Return Status 401 When Authentication_Manager Throws _BadCredentialsException(Spring-Security:返回状态401当_Authentication_Mana… 关于Spring Security 手动设置_Authentication_的问题-CSDN论坛 import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.authentication.BadCredentialsException; import o… java – Spring Security _BadCredentialsException_如何… 2019年9月12日 - 当我抛出一个org._springframework.security.authentication.BadCredentialsException_异常时,在客户端它将显示如下401,{ ‘timestamp’: ‘2016-03-29T09:… BadCredentialsException Collection of Web Pages containing stack traces of org.springframework.security.authentication.BadCredentialsException SpringSecurity_出现org._springframework.security.authentication… 2020年1月27日 - .springframework.security.authentication.BadCredentialsException: Bad credentials…出现Bad credentials,排除了配置问题,debug跟到了数据库的内… org.springframework.security.BadCredentialsException: Bad… 2012年3月24日 - 严重: Servlet.service() for servlet default threw exception org.springframework.security.BadCredentialsException: Bad credentials at org.spr… 使用_SpringSecurity_3用户验证几点体会(异常信息,验证码… 2013年10月26日 - 所以就会导致明明抛UsernameNotFound_Exception_,但前台还是只能捕获Bad credentials_的问题。解决办法我们可以直接覆盖org._springframework.security.au… Spring _Security_常见问题解决方案 | 蜂蜂 - 个人博客 2019年5月23日 - 1、Spring Security 登录验证时候,表单name必须为username全小写。如果不一致会…._springframework.security.authentication.BadCred_entialsExceptio… …Authentication request failed: BadCredentialsException… Problem: Authentication request failed: org.springframework.security.authentication.BadCredentialsException: Could not obtain access token Question: What is m… Spring Security + LDAP始终返回BadCredentialsException – 91R… principal=samantha.catania, type=AUTHENTICATION_FAILURE, data={type=org.springframework.security.authentication.BadCredentialsException, message=Bad credentia… 配置spring secutiry出现的问题 - OSCHINA 2014年2月25日 - 11:10:06,449DEBUG UsernamePassword_Authentication_Filter:319 - Authentication request failed: org._springframework.security.authentication.Bad_C… org.springframework.security.authentication.BadCredentials… 2019年9月25日 - .springframework.security.authentication.BadCredentialsException: Bad credentials…使用spring security5.0后,配置文件中直接写普通的密码如:12… …的错误显示出来(用户名不存在显示Bad credentials…_博客园 2012年6月9日 - 默认情况下,不管你是用户名不存在,密码错误,SS都会报出Bad credentials_异常信息,而不现实具体的错误。翻源码发现在org._springframework.security.auth… org.springframework.security.authentication.BadCred…_CSDN博客 2014年5月10日 - BadCredentialsException: The presented RememberMeAuthenticationToken does not contain the expected key at org.springframework.security.authe… spring _security_报_Bad credentials_错误__spring_ securit…_CSDN博客 2019年7月13日 - org.springframework.security.authentication.BadCre… org.springframework.security.authentication.BadCredentialsException: Bad credentials。… org.springframework.security.authentication.BadCredentials… 2019年8月3日 - ###org.springframework.security.authentication.BadCredentialsException: Bad credentials debug日志显示 spring security 存储密码时会对密码进行… Spring_Cloud OAuth2 授权服务器认证失败:_BadCredentialsException… 2018年8月21日 - org.springframework.security.authentication.BadCredentialsException: Could not obtain access token at org.springframework.security.oauth2.cl… org.springframework.security.BadCredentialsExceptio…_CSDN博客 2012年9月9日 - 严重: Servlet.service() for servlet default threw exception org.springframework.security.BadCredentialsException: Bad credentials at org.spr… java - Spring Security BadCredentialsException - Stack Overflow .springframework.security.authentication.BadCredentialsException: Bad credentials org.springframework.security.authentication.BadCredentialsException: Bad cre… Spring boot: i keep getting org.springframework.security… 2020年1月10日 - .springframework.security.authentication.BadCredentialsException: Bad credentials …I am trying to configure my SpringBoot app with JWT, an… BadCredentialsException Collection of Web Pages containing stack traces of org.springframework.security.authentication.BadCredentialsException _Spring_和_Security_整合详解 - 码农教程 2019年2月11日 - springframework.security.authentication.AuthenticationDetailsSource; import org….BadCredentialsException; import org.springframework.secur… …Code Examples org.springframework.security.authentication… This page provides Java code examples for org.springframework.security.authentication.Authentication_Credentials_NotFound_Exception_. The examples are extracted f… Spring Security Pre-Auth 问题 - ITeye问答 2010年10月22日 - Abstract_Authentication_ProcessingFilter.unsuccessful_Authentication_(318) | Authentication request failed: org.springframework.security.authent… _Spring_自定义_Authentication_FailureHandler - 脚本之家 2019年4月28日 - pentos.spring.User de.pentos.spring.LoginController.login(de.pentos.spring.User)]: org._springframework.security.authentication.BadCred_ential… spring_boot项目(9)集成_security-百度经验 2019年7月12日 - import org.springframework.security.authentication._Authentication_Manager;import org._springframework.security.authentication.BadCred_entialsEx… spring _security_4 添加验证码的示例代码_java_脚本之家 2018年2月1日 - import org.springframework.security.core.AuthenticationException; import org.spring…public MyUsernamePassword_Authentication_Token(String pr… Spring Security - 心生于物而死于物 - ITeye博客 import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.authentication.BadCredentialsException; import o… 聊聊spring _security_的账户锁定 - code-craft - SegmentFault 思否 2017年12月21日 - spring-security-core-4.2.3.RELEASE-sources.jar!/org/springframework/security…(_Authentication_Failure_BadCredentials_Event event) { if (event… spring security_4认证流程及流程图_spring _security_简单入门-左搜 2017年3月24日 - import org.springframework.security.authentication._Authentication_Manager; import org._springframework.security.authentication.BadCred_entialsE… Spring_Boot入门建站全系列(十一)_Spring-_security_进行权限认证 - … 2019年8月13日 - import org.springframework.security.authentication._Authentication_Provider; import org._springframework.security.authentication.BadCred_entials…","link":"/2020/04/02/%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97%E5%BC%82%E5%B8%B8org-springframework-security-authentication-BadCredentialsException/"},{"title":"监督机器学习算法","text":"监督机器学习算法 机器学习教程第 1 部分 |初学者机器学习 https://youtu.be/E3l_aeGjkeI 机器学习教程第 2 部分 |初学者机器学习 - MI 环境 https://youtu.be/HqyrqxyDwPU 机器学习教程第 3 部分 |初学者机器学习 - Python 决策树 https://youtu.be/8isUCINSmys 机器学习教程第 4 部分 |初学者机器学习 - Python 决策树 https://youtu.be/24mxQzd3EsU 机器学习教程第 5 部分 |初学者机器学习 - Python 决策树 https://youtu.be/aVEfKRfWjHc 机器学习教程第 6 部分 |Knn（朋友推荐者）适合初学者 https://youtu.be/LK0zgA6Mr6k 机器学习教程第 7 部分 |适合初学者的机器学习 - 5 折交叉验证 https://youtu.be/Zx5cz8pXnOM 机器学习教程第 8 部分 |精度（MAE/RMSE） - 适合初学者的 Python 机器学习 https://youtu.be/lHAEPyWNgyY SC2 - 深明 机器学习 - 星际争霸 2 Python AI 部分 1 https://youtu.be/WFugpcvIil4 机器学习 - 星际争霸 2 Python AI 部分 2 - 兵营 https://youtu.be/O1fwJgjfh1w 机器学习 - 星际争霸 2 Python AI 部分 3 - 构建海军陆战队 https://youtu.be/XzjLwMwhd_Y 机器学习 - 星际争霸 2 Python AI 部分 4 - 攻击 https://youtu.be/90m-itTP_Zo 到 NN 简介 神经网络（深度学习） - 第 1 部分介绍 https://youtu.be/SG9FYMKIu68 神经网络（深度学习） - 第 2 部分 NN 类型 https://youtu.be/hp-wGZ4-CpU","link":"/2020/04/13/%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"},{"title":"程序员:程序猿与牛的斗争","text":"个体牛群体生看似没有问题了，往往问题还没有浮出水面。","link":"/2020/03/26/%E7%A8%8B%E5%BA%8F%E5%91%98-%E7%A8%8B%E5%BA%8F%E7%8C%BF%E4%B8%8E%E7%89%9B%E7%9A%84%E6%96%97%E4%BA%89/"},{"title":"程序员常去的网站","text":"_程序员经常去的网站_有哪些? - 知乎 2019年5月16日 - _程序员经常去的网站_有哪些? 除了公认比较有名的CSDN外 关注者146 被浏览13,296 关注问题​写回答 ​邀请回答 ​添加评论 ​分享… 介绍几个_程序员常去的网站__程序员_Curtis’Blog-CSDN博客 2018年12月20日 - 国外的:stackoverflow.com有干货的地方。代码遇到相关问题经常_被导到这个_网站去,回答质 14个_程序员常去的_外国_网站__网络_wangjie198704的博客-CSDN博客 2015年9月28日 - 下面这张图列出了14个_程序员经常_逛的顶级开发社区,作为程序员,你应该要了解其中一个或者最好是多个,并且学会使用它们,利用里面的资源提高自己的编程能… 一个优秀的程序员经常_浏览的十大_网站 - 简书 2018年4月30日 - 一个优秀的程序员经常_浏览的十大_网站 在鲁迅生活的那个年代,他的一些言论,代表着民国时代最振聋发聩的呐喊。 “明哲之士,必洞达世界之大势,权衡较量,… _程序员常去网站_汇总 - zhangzhenpeng - 博客园 2016年7月22日 - 程序员常去_网站汇总 搜集了一些关于程序员经常浏览_的网站,希望能够帮助到大家! 1 程序员论坛:http://www.gxcxy.com2 J2me社区 http://www.j2meforums… 程序员经常_逛哪些_网站 2019年5月23日 - 近日有小伙伴问“程序员经常逛的网站都有哪些”,那么我们就通过这篇文章来推荐几个常用通用款吧。 程序员经常去的网站,大概可以分三类,就像“stackoverflow”这个网… 程序员,你们_经常_逛_的网站_有哪些? - 知乎 2019年7月27日 - 对于_程序员_而言非常值得收藏_的网站_有很多,我将从技术学习类、业余放松类两个大的方向进行分享。(篇幅可… [转载]介绍几个程序员常去的网站 - OSCHINA 2014年5月13日 - csdn.net 国内的程序员_入门级_网站,内容很多很杂,包括论坛、资源下载、博客、各种资讯等等。_经常_只在这个_网站_找到稳定的资源下载。攒积分要从娃娃抓起… 干货分享:程序员经常去的_八个_网站!不止是为了学习 2018年9月8日 - 然而,由于互联网行业的高速发展,让得这个职业需要时刻学习着,否则就会被淘汰!今天就给大家推荐程序员经常去的_八个学习_网站,记得点个收藏哦! 0、开源… 程序员_必_去的_10个_网站-CSDN论坛 2013年7月31日 - 程序员_10大推荐_网站 1.gitHub (https://github.com/) gitHub是一个面向开源及私有软件项目的托管平台,因为只支持git 作为唯一的版本库格式进行托管,故…","link":"/2020/05/24/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B8%B8%E5%8E%BB%E7%9A%84%E7%BD%91%E7%AB%99/"},{"title":"程序员经常去的网站有哪些？","text":"0. GitHub — 开发者最最最重要的网站：https://github.com 这个不用多说了吧，代码托管网站，上面有很多资源，想要什么轮子，上去搜就好了。并且呢，上面有很多优秀的程序员，你可以在这里交到很多好朋友喔。 1. Stack Overflow — 解决 bug 的社区：https://stackoverflow.com/ 开发过程中遇到什么 bug，上去搜一下，只要搜索的方式对，百分之 99 的问题都能搜到答案。在这里能够与很多有经验的开发者交流，如果你是有经验的开发者，还可以来这儿帮助别人解决问题，提升个人影响力。 2. 程序员客栈：https://www.proginn.com/ 程序员客栈是领先的程序员自由工作平台，如果你是有经验有资质的开发者，都可以来上面注册成为开发者，业余的时候做点项目，赚点零花钱。当然，如果你想成为一名自由工作者，程序员客栈也是可以满足的。只要你有技术，不怕赚不到钱。很多程序员日常在这里逛一下，接一点项目做。很多公司也在这发布项目需求。 3. 掘金 — 帮助开发者成长的技术社区：https://juejin.im 现在国内优质的开发者交流学习社区，可以去看大佬们写的文章，也可以自己分享学习心的，与更多开发者交流。认识更多的小伙伴儿，提升个人影响力。 4. v2ex：https://www.v2ex.com/ V2EX 是一个关于分享和探索的地方，上面有很多各大公司的员工，程序员。你想要的应有尽有。 5. 博客园：https://www.cnblogs.com/ 博客园创立于2004年1月，是一个面向开发者的知识分享社区。自创建以来，博客园一直致力并专注于为开发者打造一个纯净的技术交流社区，推动并帮助开发者通过互联网分享知识，从而让更多开发者从中受益。博客园的使命是帮助开发者用代码改变世界。很多早期的高质量内容都在博客园。 6. Medium：https://medium.com/ 国外优质文章网站，Medium 的整体结构非常简单，容易让用户沉下心来专注于阅读。上面有很多高质量的技术文章，有很多厉害的人在上面发布内容。 7. Hacker News：https://news.ycombinator.com/news 国外优质文章网站，上面有很多高质量的技术文章，有很多厉害的人在上面分享内容。 8. GeeksforGeeks：https://www.geeksforgeeks.org/ GeeksforGeeks is a computer science portal for geeks。（感谢@三三白白的补充） 除了这些论坛，程序员还有一些必备网站：0. Google：https://google.com 这个不用多说了吧，查资料，有问题，Google 一下。当然，能访问的人自然会用，访问不了的人，可以用必应或者百度吧。 1. 算法学习 LintCode：https://www.lintcode.com/ 算法学习网站，上去每天刷两道算法题，走遍天下都不怕。 2. 算法学习 LeetCode：https://leetcode.com/ 也是算法题网站，同上。 3. 算法学习 LeetCode 中文站：https://leetcode-cn.com/ 这个是上面算法题网站的中文站点，英文不好的可以刷这个，英文好的推荐去刷英文网站的题目，还能提升英语能力。 4. 牛客网 — 面经和刷面试题：https://www.nowcoder.com 各个公司的面试题和面经分享，找工作前认真刷一刷，一定会有很大收获！拿到心仪的 offer！ 5. Web 开发练习题：https://www.freecodecamp.org/ 这是国外发起的一个 Web 开发学习的网站，从简单到深入，一步一步带你学习 Web 开发。就像一本练习册，并且当你完成相应的内容后，会得到相应的资格认证。 6. 百度前端技术学院 — 前端开发项目库：http://ife.baidu.com 学前端的看这里，百度官方推出的前端开发学习技术学院，题目从简单到困难，如果你把里面的题都做会了，找个 BAT 的前端工作不成问题的。 其他学习网站：0. 各种编程语言，编程工具，各种轮子的官方网站 要记得，学习一门语言或者一个工具，最优质的学习网站就是他的官方网站，官方文档。 1. 菜鸟教程：http://www.runoob.com/ 菜鸟教程的 Slogan 为：学的不仅是技术，更是梦想！ 记住：再牛逼的梦想也抵不住傻逼似的坚持！网站包括了HTML、CSS、Javascript、PHP、C、Python等各种基础编程教程。 2. 中国大学MOOC网：https://www.icourse163.org/ 中国大学MOOC是由网易与高教社携手推出的在线教育平台，承接教育部国家精品开放课程任务，向大众提供中国知名高校的MOOC课程。在这里，每一个有意愿提升自己的人都可以免费获得更优质的高等教育。 推荐给前端程序员的技术、论坛、资讯网站： https://medium.freecodecamp.com/ https://css-tricks.com/ http://css-weekly.com/ https://www.html5rocks.com/en/ https://mobilewebweekly.com/ http://www.echojs.com/ http://us5.campaign-archive1.com/?u=ea228d7061e8bbfa8639666ad&amp;id=68fee2a1f3&amp;e=91389ff35f https://www.smashingmagazine.com/ https://www.sitepoint.com/ http://javascriptweekly.com/ http://frontendfocus.co/ https://frontendfoc.us/ http://reactjsnewsletter.com/issues http://feeds.feedburner.com/html5rocks 推荐给前后端程序员的技术、论坛、资讯网站： https://hashnode.com/ http://us4.campaign-archive1.com/?u=9735795484d2e4c204da82a29&amp;id=0f792acd6e&amp;e=e6bacace33 http://rubyweekly.com/ https://golangweekly.com/ https://dbweekly.com/ https://risingstack.com/ http://nodeweekly.com/ https://webopsweekly.com/ https://postgresweekly.com/ http://nodeweekly.com 推荐给前安卓程序员的技术、论坛、资讯网站： http://androidweekly.net/ http://us2.campaign-archive2.com/?u=869610fc59cf83e08b6e0635a&amp;id=6880ca6f63&amp;e=1411ee8814 推荐给前 iOS 程序员的技术、论坛、资讯网站： https://iosdev.tools/ https://iosdevweekly.com/ https://littlebitesofcocoa.com/ http://ios-goodies.com/ http://digest.swiftweekly.com/ 知友推荐：1. 在线学习网站：https://www.tutorialspoint.com/ 2. 算法学习和竞赛网站：http://codeforces.com/ 3. 程序员问答网站：https://segmentfault.com/ 4. Linux Kernel：https://www.kernel.org/ 5. FCC 中文网：https://www.freecodecamp.one/ 6. B 站：https://www.bilibili.com/ 7. 阿里巴巴开源镜像：https://opsx.alibaba.com/mirror 8. USTC 开源镜像：http://mirrors.ustc.edu.cn/ 感谢 @七彩空气 ， @北洋水师 ，@二营长，@Keven， @Scapelan ， @地主家的穷儿子 ， @众神眷恋的H大葱 。 我的其他相关回答： 用一句话证明你是程序员？ 应该在哪些网站学习编程? 初级程序员如何快速成长？ 前端工程师学习路径和学习资源集合 前端工程师都有用哪些比较靠谱的小工具？ 你在 GitHub 上看到过的最有意思的项目是什么？ 作者：程序员客栈 &gt; 链接：https://www.zhihu.com/question/21704716/answer/685370433","link":"/2020/05/24/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BB%8F%E5%B8%B8%E5%8E%BB%E7%9A%84%E7%BD%91%E7%AB%99%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"},{"title":"获取微信公众号 jsapi_ticket","text":"…_公众号_开发】_获取_并保存access_token、_jsapi_ticket_票…_博客园 2017年6月21日 - #region _获取jsapi_ticket_/// /// _获取_Token/// public static string Get_jsapi_ticket_Token(string access_token){string strJson = RequestUrl(string.Format… _微信公众号开发(二)_获取_AccessToken、_jsapi_ticket - 小…_博客园 2018年7月16日 - _jsapi_ticket_是_公众号_用于调用_微信_JS接口的临时票据。正常情况下,_jsapi_ticket_的有效期为7200秒,通过access_token来_获取_。由于_获取jsapi_ticket_的api… _微信公众号开发_获取_access_token和_jsapiticket - Emine…_CSDN博客 2017年11月6日 - _微信公众号开发(二)_获取_AccessToken、_jsapi_ticket 阅读数 8936 AccessToken在_微信公众平台_接口开发中,AccessToken占据了一个很重要的地位,相当于进… _微信获得jsapi_ticket_,每次_获取_的都一样 | _微信_开放社区 2019年7月16日 - 我现在在做那个_微信_添加卡券的,把创建好的卡券在小程序里面添加,小程序与_公众号_都已经相互关联并且绑定到同一个开放平台下了,创建的卡券也是没有自定… _微信公众号获取jsapi_ticket_(多类型)_C#_蔡龙的技术交流站-CSDN博客 2019年1月14日 - 一、_jsapi_ticket_是什么?_jsapi_ticket_是_公众号_用于调用_微信_JS接口的临时票据。正常情况下,_jsapi_ticket_的有效期为7200秒,通过access_token来_获取_。由… asp源码_微信公众号获取jsapi_ticket_ 2018年10月12日 - asp源码_微信公众号获取jsapi_ticket_ 标签:scope ticket .com public response enc image api type 原文地址:https://www.cnblogs.com/lytocnc/p/9777… …SDK分享接口和界面操作接口-1-_获取jsapi_ticket_-朱祚华的在线… 微信公众号详解微信JS-SDK分享接口和界面操作接口 …第四章:_获取jsapi_ticket _获取jsapi_ticket (19…通过本课程的学习,详细了解微信Js-sdk的使用,将自己… 关于_微信_的_jsapi_ticket_的_获取_方法;_园荐_博客园 2018年7月18日 - 这个后期再说; 现在主要实验,_获取jsapi_ticket_,并生成前端页面需要注入的数据,从而使前端页面使用js-sdk的权限; 这里有一个容易忽视的小tips,_微信_前面… java_微信公众号_开发_获取jsapi_ticket_问题-CSDN问答 2017年5月11日 - 初接触_微信公众号_开发, 前端传个code过来,根据code_获取_的access_token,_获取jsapi_ticket_时提示invalid credential, access_token is invalid or not l… 获取JSAPI Ticket - _微信_之门开发文档|_微信_之门API 此接口用于获取 JSAPI Ticket. 开发者可以通过拥有的WGateKey_获取_WGateToken, …weixin_account_id string Y 微信之门添加_微信公众号_后 生成的ID token string… 微信–_获取jsapi_ticket_ 然后在计算出signature 2015年3月27日 - 生成签名之前必须先了解一下jsapi_ticket_,_jsapi_ticket_是_公众号_用于调用_微信_JS接口的临时票据。正常情况下,_jsapi_ticket_的有效期为7200秒,通过access… _微信公众平台jsapi_ticket_在线调试 - 程序园 2017年1月7日 - _微信公众平台开发调试 2014-03-03 微信 _微信公众平台_jsapi开发教程(1)_获取jsapi_ticket 2016-08-29 JavaScript 微信公众平台 2014-08-16 … 微信公众号获取 acess_token 和 jsapi-ticket - 简书 2019年12月29日 - 生成签名之前必须先了解一下jsapi_ticket_,_jsapi_ticket_是_公众号_用于调用_微信_JS接口的临时票据。正常情况下,_jsapi_ticket_的有效期为7200秒,通过access… 微信JSAPI _Ticket_接口签名详解_javascript技巧_脚本之家 2017年7月7日 - 这篇文章主要为大家详细介绍了微信JSAPI _Ticket_接口签名,具有一定的参考价值,感兴趣的小伙伴们可以参考一下本文实例为大家分享了_微信_JS接口签名的具体… _微信服务号开发(五)_微信公众号获取jsapi_ticket-微信公众号-复制… 2018年3月8日 - 看到网上有各种_获取微信公众号获取_jsapi_ticket,所以自己整理重新写了一个,贴出来供大家分享 _微信JS_分享等接口SDK(C#)_获取_access_token以及_jsapi_ticket_临时票据 2015年11月6日 - 而要_获取jsapi_ticket_的前提是你得_获取_到access_token,我们来看看_微信_JSSDK说明文档里对它们是如何定义的。 _jsapi_ticket_是_公众号_用于调用_微信_JS接口… asp源码_微信公众号获取jsapi_ticket_-布布扣-bubuko.com 2018年10月12日 - asp源码_微信公众号获取jsapi_ticket_ 标签:urlencode ams sco rec ket nco weixin connect ati 原文:https://www.cnblogs.com/lytocnc/p/9777307.html… 微信卡券 _获取api_ticket 拉取适用卡券列表__微信JS-SDK说明文档… 2017年10月17日 - _微信_卡券接口中使用的签名凭证api_ticket,与步骤三中config使用的签名凭证_jsapi_ticket_不同,开发者在调用_微信_卡券JS-SDK的过程中需依次完成两次不同的… …微信_公共号开发 - _获取_并缓存 access_token 和 _jsapi_ticket |… 2018年4月27日 - 背景使用 NodeJS 进行微信_公共号开发,后端调用各接口时都需使用 access_token,前端调用 js-api 则需要后端根据 _jsapi_ticket 生成 signature。由于 ac… _微信公众号相关 _获取_AccessToken、_jsapi_ticket - 豌豆ip代理 2019年3月29日 - _jsapi_ticket_是_公众号_用于调用_微信_JS接口的临时票据。正常情况下,_jsapi_ticket_的有效期为7200秒,通过access_token来_获取_。由于_获取jsapi_ticket_的api… 使用java_获取微信公众平台jsapi_ticket_ - 誠者为皇 - 博客园 2015年8月30日 - 生成签名之前必须先了解一下jsapi_ticket_,_jsapi_ticket_是_公众号_用于调用_微信_JS接口的临时票据。正常情况下,_jsapi_ticket_的有效期为7200秒,通过access… _微信公众号_开发(二)_获取_AccessToken、_jsapi_ticket__C#…_CSDN博客 2017年12月7日 - _jsapi_ticket_是_公众号_用于调用_微信_JS接口的临时票据。正常情况下,_jsapi_ticket_的有效期为7200秒,通过access_token来_获取_。由于_获取jsapi_ticket_的api… _微信开发之_获取jsapi_ticket - 一切随风飘 - 博客园 2017年7月6日 - 1、获取 access_token2、通过access_token换取 jsapi_ticket_3、签名算法签名生成规则如下:参与签名的字段包括noncestr(随机字符串), 有效的_jsapi_tick… java_获取微信jsapi_ticket_方法_乘龙再现的博客-CSDN博客 2016年11月4日 - _jsapi_ticket_是_公众号_用于调用_微信_JS接口的临时票据。正常情况下,_jsapi_ticket_的有效期为7200秒,通过access_token来_获取_。由于_获取jsapi_ticket_的api… _微信_sdk _获取jsapi_ticket__网络_xufangfang99的博客-CSDN博客 2017年7月11日 - 一、_jsapi_ticket_是什么?_jsapi_ticket_是_公众号_用于调用_微信_JS接口的临时票据。正常情况下,_jsapi_ticket_的有效期为7200秒,通过access_token来_获取_。由… 微信公众号_踩坑之请求_JS-SDK的_jsapi_ticket_接口,access…_CSDN博客 2019年6月20日 - 微信_测试号开发之四 _获取_access_token和_jsapi_ticket access_token:_公众号_的全局唯一接口调用凭据,_公众号_调用各接口时都需使用access_token。开发者… asp源码_微信公众号获取jsapi_ticket__tocnc的博客-CSDN博客 2018年11月13日 - _微信公众号开发(二)_获取_AccessToken、_jsapi_ticket 阅读数 9410 AccessToken在_微信公众平台_接口开发中,AccessToken占据了一个很重要的地位,相当于进… 微信公众平台获得jsApiTicket - erix1991的专栏 - CSDN博客 2016年7月6日 - @RequestMapping(value = “/get_JSApiTicket_”) public void get_JSApiTicket_(HttpServletRequest request, HttpServletResponse response) throws Unsup… _微信公众平台jsapi_开发教程(1)_获取jsapi_ticket_ - linf…-CSDN博客 2016年8月29日 - 生成签名之前必须先了解一下jsapi_ticket_,_jsapi_ticket_是_公众号_用于调用_微信_JS接口的临时票据。正常情况下,_jsapi_ticket_的有效期为7200秒,通过access… asp源码_微信公众号获取jsapi_ticket_ - 和硕宝亲王 - 博客园 2018年10月12日 - asp源码_微信公众号获取jsapi_ticket_ Public Function GetAuthorization_Code() Dim url, params url = “https://open.weixin.qq.com/connect/oauth2/a…","link":"/2020/05/27/%E8%8E%B7%E5%8F%96%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%20jsapi_ticket/"},{"title":"20.深入Java系列Java中的回调机制","text":"_Java回调机制_总结 - 带妳心菲 - 博客园 2018年9月18日 - 在Java中, 可以使用Future+Callable的方式做到这一点, 具体做法可以参见文章Java多线程21:多线程下其他组件之CyclicBarrier、Callable、Future和Futur… 理解java的回调机制 - KevinLyz的博客_CSDN博客 2019年5月10日 - Java_回调机制一、方法的调用模式理解接口和抽象类的设计理念二、回调场景三、小结最近学习了一下_Java 的回调机制,查看了网络上的一些内容,并借鉴了一些在这里整理一… _Java回调机制_和作用解析_wanderlustLee的博客-CSDN博客 2019年2月26日 - _Java中_一个类A_中的_方法调用另一个类B_中的_方法,可以直接调用,如果需要被调用的类B返回处理的结果, JAVA回调机制(CallBack)详解 - Bro__超 - 博客园 2016年4月10日 - 最近学习java,接触到了回调机制(CallBack)。初识时感觉比较混乱,而且在网上搜索到的相关的讲解,要么一言带过,要么说的比较单纯的像是给CallBack做了一… _Java回调机制_详解 - 简书 曾经自己偶尔听说过回调机制,隐隐约约能够懂一些意思,但是当让自己写一个简单的示例程序时,自己就傻眼了。随着工作经验的增加,自己经常听到这儿使用了回调,那儿使用… _Java 中回调机制_是什么原理? - 知乎 2016年11月8日 - 在学习Java接口时遇见的问题,Java核心技术上以timer类来讲的,但还是理解不好… _Java 中回调机制_是什么原理? 在学习Java接口时遇见的问题,Java核心技术上以timer类… 详解_Java的回调机制___java__脚本之家 2016年10月24日 - 最近学习java,接触到了回调机制(CallBack)。初识时感觉比较混乱,而且在网上搜索到的相关的讲解,本文介绍了Java的回调机制,有兴趣的同学可以了解一下。 java中的回调机制(自己的一点理解) 2014年3月4日 - 这几天一直在看关于回调机制方面的问题,经过几天的摸索,开始对android_中的回调机制_有了一点理解,下面做一个记录,有的是从别处借鉴过来的,有的是自己的… _java的回调机制___java_回调机制__java_回调机制异步 - 云+社区 - 腾讯云 Java 回调机制 参考链接_java回调机制_解读回调的思想类a的a()方法调用类b的b()方法类b的b()方法执行完毕主动调用类a的callback()方法代码分析? public interface… Java回调机制 - - ITeye博客 2015年8月15日 - 回调机制_是一种常见的设计模型,他把工作流内的某个功能,按照约定的接口暴露给外部使用者,为外部使用者提供数据,或要求外部使用者提供数据。 _java回调… _java回调机制_的通俗理解 - - ITeye博客 2010年11月18日 - 拿这个例子类比Ajax_中的回调机制_以及Spring中HibernateTemplate用到的回调+模板机制,可以更容易地理解回调机制。 Ajax代码: _Java_代码 function tes… 理解Java当中的回调机制(翻译)_java_脚本之家 2014年10月15日 - 今天我要和大家分享一些东西,举例来说这个在JavaScript中用的很多。我要讲讲回调(callbacks)。你知道什么时候用,怎么用这个吗?你真的理解了它在_java_环境_中的_用法了… _java回调机制_的通俗理解 - fengbin2005 - ITeye博客 2011年8月8日 - 拿这个例子类比Ajax_中的回调机制_以及Spring中HibernateTemplate用到的回调+模板机制,可以更容易地理解回调机制。 Ajax代码: _Java_代码 收藏代码 fun… 详解Java回调机制 (Callback) 讲解+实例_masterdo_新浪博客 2013年6月3日 - 正文 字体大小:大 中 小 详解Java回调机制 (Callback) 讲解+实例(2013-06-03 17:05:30) 转载▼分类: Java 我认为这是我看到的最简洁有效讲清楚Java回… java _回调机制_原理及示例 - 可乐的世界 - ITeye博客 2015年12月31日 - 今天讲的内容重点是回调机制,这是_java里面_动态绑定的又一面貌。 动态绑定:我们用父类的引用指向子类的对象,Father father = new Son();,内存上,是一个… 浅谈Java回调机制-站长之家 2016年4月14日 - 我决定用最直白的语言来给大家讲讲Android_的回调机制_是怎么个回事,阅读这篇文章你不需要太高深的技术功底,只要你会点_JAVA_基本的知识,知道什么叫类… 一个经典例子让你彻彻底底理解java回调机制 - 脚本之家 2019年1月10日 - 脚本之家收集整理的这篇文章主要介绍了一个经典例子让你彻彻底底理解java回调机制,脚本之家小编觉得挺不错的,现在分享给大家,也给大家做个参考。 转自… 求高手给讲解一下_JAVA中回调函数_是怎么实现的.-CSDN论坛 第一:我平时没有用过回调函数 或者说我可能没意识到自己在用回调函数 唯一印象就是AJAX_的回调_+异步 如果在_JAVA中_完成这个操作 是不是需要线程? 第二:跟第一个… Java回调机制–从模块调用说起 - 程序员大本营 本文简单介绍了_Java_模块调用的几种方式,主要通过demo阐释了_回调机制_的实现…在回调模式中,A()方法调用B()方法 B()方法执行完毕之后,调用A类的AA()方法… _java回调机制_实现_一点点-CSDN博客 2017年7月14日 - out.println(“调用了B_中的_A方法”); // A方法中对对象A的B方法进行了调用(…java回调机制_及其实现 阅读数 458 1. 什么是_回调函数回调函数,顾名思义,… _Java回调机制_解读 - 五月的仓颉 - 博客园 2017年2月23日 - _Java回调机制_解读 模块间调用 在一个应用系统中,无论使用何种语言开发,必然存在模块之间的调用,调用的方式分为几种: (1)同步调用 同步调用是最基本并且最简单的… _Java回调机制_是什么意思?_u011277123的博客-CSDN博客 2017年9月25日 - 华清远见成都中心2017-09-2010:39一、Java回调机制是什么意思_Java中的回调机制_是什… _Java中的回调机制_是什么意思呢?所谓回调:就是A类中调用B类中的… java回调机制 - 4396的博客 - CSDN博客 2019年1月21日 - Java_回调机制一、方法的调用模式理解接口和抽象类的设计理念二、回调场景三、小结最近学习了一下_Java 的回调机制,查看了网络上的一些内容,并借鉴了一… 浅谈_Java回调机制__比较喜欢、笑的博客专栏-CSDN博客 2016年6月13日 - _回调机制_让我们代码运行更加高效,也让我们代码变得非常的简洁明了!首先我们用个案例来一步一步带入,当我 _java回调机制_详解__Java__Aluo-CSDN博客 2016年3月10日 - 回调_介绍所谓_回调,就是客户程序Client调用服务程序Service_中的_某个方法A,然后Servic_Java_ _java回调机制_及其实现(转) - 沧海一滴 - 博客园 2015年10月8日 - 以上篇博文_java回调机制_及其实现为例,在例1中可以将FooBar作为一个主题(被观察者),ICallback的实现对象作为观察者,当FooBar调用setCallback时,通知ICa… 深入浅出: Java回调机制(异步) - judy! - 博客园 2017年7月13日 - 3、Servlet_中的_Filter(过滤器)是基于回调函数,需容器支持。 补充:其中 Filter(过滤器)和Interceptor(拦截器)的区别,拦截器基于是_Java_的反射机制,和容… java-_回调机制_详解 - Yangtuo - 博客园 2017年7月31日 - 三、Java_实现接口_回调 四、Android_中的_接口回调 五、参考资料 一、前言 最近在看android fragment与Activity进行数据传递的部分,看到了接口_回调_的内… _Java回调机制_解读 - 天涯海角路 - 博客园 2019年6月22日 - _Java回调机制_解读 模块间调用 在一个应用系统中,无论使用何种语言开发,必然存在模块之间的调用,调用的方式分为几种: (1)同步调用 同步调用是最基本并… _Java回调机制_的理解 - 剑冢、 - 博客园 2019年6月19日 - _Java回调机制_的理解 用一句话讲明_回调机制_就是,在A类_里面_拥有一个类B的对象,调用B类的某个方法并把自身引用传入,在B类的这个方法_里面_又通过传进来的A… 理解java回调机制 - 激流勇进、 - 博客园 2018年6月8日 - 这个例子就是Android典型的回调机制,看完这个你是不是更进一步的理解了回调机制呢? 线程run()也是一个回调方法,当执行Thread的start()方法就会回调这… Java_基础9:解读_Java回调机制 - 黄小斜 - 博客园 2019年4月7日 - 本文主要介绍了Java中的回调机制,以及Java多线程中类似回调的机制。 具体代码在我的GitHub中可以找到 https://github.com/h2pl/MyTech 文章首发于我的个人博客: … _java回调机制_及其实现 - JerryShao - 博客园 2014年5月21日 - java回调机制_及其实现 1. 什么是_回调函数 回调函数,顾名思义,用于_回调的_函数。_回调函数_只是一个功能片段,由用户按照_回调函数_调用约定来实现的一个函数… _java回调机制_及其实现_蚂蚁文库 2018年11月21日 - java回调机制_及其实现 1. 什么是_回调函数 回调函数,顾名思义,用于_回调的_函数。_回调函数_只是一个功能片段,由用户按照_回调函数_调用约定来实现的一个函数… .wa-se-st-single-video-zhanzhang-play { position: absolute; height: 40px; width: 40px; top: 50%; left: 50%; margin: -20px 0 0 -20px; background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpmOWQ4YzVjMi1kMjNiLTQ5ZjEtOWIyNi0wOGY3MmY4MTc1NTMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MDc0OTQ3OURGODgzMTFFNUFFQkZEMDZGREMzOTdFMTkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MDc0OTQ3OUNGODgzMTFFNUFFQkZEMDZGREMzOTdFMTkiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2Y2IwNzk4OC0yYjNiLTQ2MDItYTllMS0zNzI1Yzk5NTZmMmQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6ZjlkOGM1YzItZDIzYi00OWYxLTliMjYtMDhmNzJmODE3NTUzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Rtt+oAAABS5JREFUeNq8mWtIW2cYxxOXpNtUoihYbbxhzMAJ3jMvKxPnZR9Gvawdm2hhWOy+DLzPil91ImzKPq2jH1QQyqBRB4La6izzNi9RQYMzGg3qbCcuc5rNxBj3f9w53WhXzck5xwcekkPO+7y/vO95n9uRnpycSNyQV6Dp0AxoNPQK1AeqYH63Q3+HbkEXoEPQYegx14mkHAEjoGXQd61Wq3N1dXVrcnLy6cTExN74+PjB9vb2Ed0UGBgoT0lJ8UpOTlZqtdqAiIiIK56enh74aRDaCl0VGvAy9AvoOzMzM8uNjY0/63Q6C5d/VlBQ4FtXV/dGQkKCBpePoXegT4QAvAWtnp+fX8/Pz9evra3ZJDwkPDz8UldXV3xMTEwYLr+EfnvW/R5n/CaHtlsslsqampqHsbGx43zhSMgG2aqurn4I2+U0BzMXpxX0hn5nNpt9kpKShnZ2do4kIoifn58cj0xGaGgoHagPofuuANK/6TYajV7R0dHDdrv9RCKiKBQK6cLCQnpkZOQBLvOgR+cBdmDlItVq9YDD4RAVjhWZTCZdWVnJxkoacXnzrGewFM9FIk7a0EXBkdBcNCfNjcvbLwMkV1IJFzK0u7t7JLlgoTkbGhrIoVcyjv+FLW6HK7lMJ8xVozhAyqmpqT0hQWdnZ1PA8JTdanYFyXlezcvL03MxVl9fn4hIcj0kJORVoQDJ1+LjbYbpGeBn09PTy+vr65z9HFbxzbm5udvFxcUqIQCJgViIiQWkwJ9J4ctdo76+vj5tbW2fdHZ2XqUTyReSYckkNgJMR+B3IPxY+Bj1gBQWFmYsLi7ejIuL8+Zji1iIidgIMBM+6BehniGNRhM2MjLyKcKjho8dZErElEGAUQg3vwp5El+HNDU1fdzf3/+eUqmUuWMDzyGd5GgCVI2OjlqE9mtSqVSSnZ39lsFguJWVleXPdTyYKD6rCJB8mVUsBxwUFBTQ29tb2tLSEsdlHMOkJEDFxsaGqJFDDikrK7uGSV32mQyTwuMiw5m3t/drXN0QAdqDg4PlYsMNDAz8hBDWaTKZ/nLlfobJToB7iAaeImYqx62trd/n5OT0HR4eOjlEKGLaI8DNtLQ0HzHg9vf3rSUlJe3l5eWzXMcyTJvkowzIxeLxaRISbnNzczs3N/e+Xq//w53xiYmJAeQOCXAQdev7QsLhtC5gS3uQgDrctQGmICr4aYt/8PLykiHN8eULhtzyBAnDIAr2B3zgiAWFPi3esAfTjnhERTUfOJvNZq+trb1fVFQ04nQ6ef1RhuURsbF+sBV7rqGi2s10/Tcku/eam5uX+e4CCqdLxMK0SJ4lrNQreazT6eK5GlxaWjJptdp7fX19O0I8v93d3cTwI9u/+W8kuQNHGl5VVeVyYO/o6DAg93PZ+Z4nCId+xICvn7+sLqayswxFdNdFV3bUZTAajfnIzr/G5TdnFu6oC8AYeaGFO+Cyw8LCXijc/w+Qso0H1PqIiooaFhuS4JAzsq2PD6CH53W36IaPMOAQkFm09CJvaybm+pPmfB7urPYbdZmuYclXYKCgoqLCX2g4xGd/so05Vpmm0b67DcxSakdQAxOxVW82m218/VxPTw/bwPwKetfdBiYr1AFNh8EnODw3EGeTAco5+6ExNJZskC3JP034u+fWNm400akrSk30Y5SrW5j0tIk+NjZ2gAzm1DWpVCp5amrqaRMdeV2AWq2mJjo1CKiJ3iIRoYn+vLCvIaj6j5L8+xqCDZX0GLCvIQxMXB2WuPEa4m8BBgDXxE/mIU7+4wAAAABJRU5ErkJggg==) no-repeat; background-size:40px 40px; } .wa-se-st-single-video-zhanzhang-play:hover { background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpmOWQ4YzVjMi1kMjNiLTQ5ZjEtOWIyNi0wOGY3MmY4MTc1NTMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MDc0OTQ3OTlGODgzMTFFNUFFQkZEMDZGREMzOTdFMTkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MDc0OTQ3OThGODgzMTFFNUFFQkZEMDZGREMzOTdFMTkiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2Y2IwNzk4OC0yYjNiLTQ2MDItYTllMS0zNzI1Yzk5NTZmMmQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6ZjlkOGM1YzItZDIzYi00OWYxLTliMjYtMDhmNzJmODE3NTUzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+SH0i3gAABTFJREFUeNq8mVlIY1cYx3OTGE0Mneg8VEYRA3VBZYQykVKd4tQ1UnxrcV/wQaO+aNW2oL5YbEerPmlQxBUXfLSiIo4OVFtcKFoXqhYUYUaKVmPVuGXp/7M3YK0zk3tz44FPzsn1nPvLOd/5tjBWq1XEozGQMMgTSCDkEcQD4sY+P4ccQl5D1iELkCUI55cxHAEJ5AtI1OrqqmpmZsY0NzdnQt+yvb1tMRgM14upVCrGz89PHBISIg4PD5dGRERI0Tfg0UvIIAsuKCDtTgEkurGx0dzS0nK5vr5u4fLNAgMDxXl5ebLi4mIJhi8gzewuOwyohRTp9XrX8vLy85OTE146YWtKpZKpra110+l0Fxg2QUb4AkohX09OTsbU19cbR0ZGzCIBW2JioqSkpEQRHR09geH3EBMXQDnku4GBgccZGRlGk8lkFTmhSaVSpqenR5GcnPwbht9AzuwBpJ2r7erqCsvJyTHyvOX231KGEXV0dCiysrLolpff3sm7ACv6+/ufpaWlOR3uJmRvb68iJSVlCsNv3waYODExUa7Vak+cdaxvO27ouTI2NvYHDIdtn4tvmZJCmBHjfcNRo3c2NDQYWXP28C7AQjIlXG6rWq2WCwk5NjZmbmpqkqGru33E3pAe2Cjj6emp3btXVVUV5OXlpaioqFg+ODi4EgLS3d2dga1VoJsBeWXbwc9h68xc4GwNruwRzNFTuDMPIQCJgViIyXbE5PijWltbL/ku6unpqYDuflxaWvqBWCxmHIVkWaKIjQDDyPFvbGxYHFmUwGBwg7q7uz/y9fV1c2QtYiEmYiNADUUlQil6UFDQQ3iHT5KSkt53ZB0wkU4/IcAACpmEvI1QdFllZaWmpqYmRC6Xi/msASbSw0Ca7L2ysmIR2q6Rd4iLi1PDK0UGBwcruc5nmbwJULWzsyM4oK35+Pi819bW9hR+3ZfLPJZJRYBy2DCneg6ZTCYpLCx83Nzc/CFuvIs9c1gmfvrhQLAqw23nZh0oBsO3YpwNNz4+vpWbmzu7v79vl8dhmc4o9jPAbql2d3fNzgBDEGBBDrOCmG+Hyzww0eYZ6M+r0NBQpxz18fHxBbzLL1zhqLFM1754Q6PRSISGwy08QpT80/T09CGf+fDxxLROgPNw9C5Cws3Ozr5OT0//GZDnfNdgmRYIcAnbaQgICHD4mBG6WWGYfy8qKvrVaDTy1mliYRP9JTFbjniZn58vcwTu4uLCVF1dvYBQ6Q9HcxmWhaoQVtuuDVLGT0k1nwX39vZOsejM0NDQnwLYSoatPgzeDPmpVvKCMn6uC66tre0hd55eXl4+FkJ/WYZJW/3mZlZHEXEvMn7R6OioXfqD2/9gcXHx76urK0FcZXx8vAR5CXXTbHWbmxeDPmimcgSlgPYsOD8/fyQUnEQiYejd6OpvFpVu39zhmJiYic7OTjmFS/fV6F1dXV1yhGdU9frxXZUFsj/P77P00d7ersjOzqbSx1eQK3uLR8/7+vpCMjMzz8xms1Mo6ViRw8hTU1OX31Q8epNxpn/8EhOnoLRKrVYruCtMSEiQ4DIq6R0Ylt0FZ28B8zPK9BFsupaVlZ3DQzi0mwqFgqmrq3MrKCi4YC/EMN8C5n/CM7Zm8imVgPV6/eXm5ianNMHf31+s0+lsJWCyc1QCPninjvIsoj9D3voAkcoVTI2ZiuhbW1uWw8PD68U8PDwYtVp9XUSnSCkyMtIF/SM8mhI5qYj+v3mif3+G0JBvZ8GpIuVqc82Qv1iQDTKZIp4/Q/wjwAB2z0yP+KAgHAAAAABJRU5ErkJggg==); } .wa-se-st-image_single_video {overflow:hidden;position:relative;} .wa-se-st-image_single_video img {height:91px;} 一个故事让你明白Java回调机制(CallBack)_哔哩哔哩 (゜-゜)つ…用简易例子讲Java中的回调机制-风平浪静如码-51CTO博客 2019年11月21日 - 给出思想过于抽象,所以我会举出一个简单的实例(虽然简单,但是能说明问题),并总结_Java_实现回调的步骤。 实例基于知乎上一个解释什么是_回调机制_的回答。… JAVA回调机制(CallBack)详解 - _Java_开发 - 开发语言与工具 - 深度… 2016年4月2日 - 最近学习java,接触到了回调机制(CallBack)。初识时感觉比较混乱,而且在网上搜索到的相关的讲解,要么一言带过,要么说的比较单纯的像是给CallBack做了… Java 回调机制(CallBack) 趣解 - 码农头条 Java 回调机制(CallBack) 趣解 序言 最近学习java,接触到了回调机制(CallBack)。初识时感觉比较混乱,而且在网上搜索到的相关的讲解,要么一言带过,要么说的比较… _java回调函数_的例子 - hongye - ITeye博客 2013年9月30日 - * _回调_接口,定义_回调_中会被执行的方法 */ public interface MyCallback { void func(); } _Java_代码 /** * * @author hongye.hwy * @version… JAVA_同步_回调函数-sinkingboat-ChinaUnix博客 2013年7月18日 - 在C/C++中,要用回调函数,被掉函数需要告诉调用者自己的指针地址,但在_JAVA中_没有指针,怎么办?我们可以通过接口(interface)来实现定义_回调函数_。 首先定… JAVA回调函数(方法) - 不破不立 - ITeye博客 2012年2月8日 - 在C或者C++中回调函数_的定义: 程序在调用一个函数时,将自己的函数的地址作为参数传递给程序调用的函数时(那么这个自己的函数称_回调函数) 在java中: 类… 浅析_java回调机制_与观察者模式 - 木子李,日月明 - ITeye博客 2010年6月2日 - 1 java回调机制: 首先解释java回调机制,对象能够携带一些信息,这些信息允许它在稍后的某个时刻调用初始的对象,如果回调是通过指针实现的,那么就只能寄… _java中回调函数_到底怎么解释? 解释都太过于概念化,有没有通俗点的?… 所谓回调,就是客户程序C(用户)调用服务程序S_中的_某个_函数_A,然后S又在某个时候反过来调用C(用户)_中的_某个_函数_B,对于C… _java回调机制_详解-_java回调机制_详解文档介绍内容-阿里云 阿里云为您提供_java回调机制_详解相关的16条产品文档内容及常见问题解答内容,还有标点,windows磁盘格式化,邮件啊推送’,保留原始路径,cdn参数过滤,网卡抓包,主机优化,… _Java回调函数_使用简谈-百度经验 2015年12月24日 - _Java回调函数_使用简谈,所谓回调,就是客户程序C调用服务程序S_中的_某个函数A,然后S又在某个时候反过来调用C_中的_某个函数B,对于C来说,这个B便叫做_回调函数_。例如… _java_事件监听_回调机制_的理解 - gaomq - OSCHINA 2017年4月25日 - 在实现这个接口之后,这里的doSomething方法就是我们_的回调_方法。可以理解为我们写具体的实现,但是给别人调用。 public interface DoorEventListener e… 设计模式-怎样理解_java中的回调函数_——CSDN问答频道 2010年11月27日 - 怎样理解java中的回调函数 最近遇到回调函数问题,有点不太理解,到底什么是回调函数,有何用途,与命令模式是不是有点关系!编辑于:2019.01.17 03:08 … _Java中_关于_回调函数_的使用 - - ITeye博客 2014年7月15日 - _Java中_关于_回调函数_的使用 定义连接工厂使用 package huidiao; import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLExcep… java回调机制(老板与员工例子)-布布扣-bubuko.com 2017年3月9日 - 网上看到一位老哥写的一个_回调_小列子,感觉写得真好,言简意赅。 学习并分享下我的理解。 废话不说,直接上代码。 异步调用时解决耗时操作问题(请求网络 …","link":"/2020/04/05/20-%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97Java%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/"},{"title":"2020 年成为前端大师的 9 个项目","text":"介绍无论您是编程的新产品还是经验丰富的开发人员。在这个行业中，学习新概念和语言/框架是跟上快速变化所必须的。以React为例，Facebook在4年前刚刚开放，它已经成为全球JavaScript开发的首选。当然，Vue和Angular也有他们合法的追随者基础。然后是Svelte，以及通用框架，如Next.js或Nuxt.js，加茨比，Gridsome，和Quasar，和和。如果你想作为一个专家JavaScript开发人员闪耀，你至少应该有一些经验在不同的框架和库 - 除了做你的家庭作业与良好的，旧的JS。 为了帮助您在 2020 年成为前端大师，我收集了 9 个不同的项目，每个项目都有一个不同的主题和不同的 JavaScript 框架或库，作为可以构建并添加到您的产品组合的技术堆栈。记住，没有什么比实际构建的东西更有助于你，所以继续前进，磨练你的头脑，使这一切发生！ 1.使用 React（带挂钩）构建电影搜索应用首先，您可以开始使用 React 构建电影搜索应用。下面是最终应用程序的外观图像： 您将学习到什么构建此应用程序将使用相对较新的挂钩 API 提高反应技能。示例项目使用 React 组件、许多挂钩、外部 API，当然还有通过 CSS 进行一些样式设置。 技术堆栈和功能 用钩子反应 创建-反应应用 JSX Css 不使用任何类这个项目给你一个完美的切入点，以功能反应，一定会帮助你在2020年。你可以在这里找到示例项目：https://www.freecodecamp.org/news/how-to-build-a-movie-search-app-using-react-hooks-24eb72ddfaf7/跟随教程或给它自己的风味！ 2.使用 Vue 构建聊天应用程序另一个伟大的项目，你是建立一个聊天应用程序使用我最喜欢的JavaScript库VueJS。该应用程序将如下所示： 您将学习到什么在本教程之后，您将学习如何从头开始设置 Vue 应用、创建组件、处理状态、创建路由、连接到第三方服务，甚至处理身份验证。 技术堆栈和功能 Vue 武克斯 Vue 路由器 Vue CLI 推 Css 这确实是一个伟大的项目，开始与Vue或提高你现有的技能，以解决发展在2020年。你可以在这里找到教程：https://www.sitepoint.com/pusher-vue-real-time-chat-app/ 3.建立一个美丽的天气应用程序与角8此示例将帮助您使用 Google 的角 8 构建一个美丽的天气应用程序： 您将学习到什么此项目将教您宝贵的技能，例如从头开始创建应用程序，从设计到开发一直进行生产就绪部署。 技术堆栈和功能 角 8 火场 服务器端渲染 带有网格布局和 Flexbox 的 CSS 移动友好和响应式 黑暗模式 美丽的 UI 我真正真正喜欢这个全面的项目是，你学习的东西不是孤立，而是整个开发过程，从设计到最终部署。你真的应该这么做！https：//media.com/@hamedbaatour/构建一个真实世界美丽的网络应用程序，带角-6-a-z-终极指南-2018-i-e121dd1d55e 4.使用斯维尔特构建一个即将执行的应用程序与React、Vue和Angular相比，斯维尔特是这个街区的新孩子，但尽管如此，2020年还是其中一热点。好吧，做应用程序不一定是最热门的话题，但这真的可以帮助你提高你的Svelte技能，看起来像这样： 您将学习到什么本教程将向您展示如何从头到尾使用 Svelte 3 制作应用。它利用组件、样式和事件处理程序 技术堆栈和功能 斯维尔特 3 组件 通过 CSS 进行造型 ES 6 语法 没有那么多好的Svelte启动项目在那里，所以我觉得这个有点好开始。谁知道呢，也许你是另一个创造另一个，更全面的斯维尔特教程，将在下一年版本的这篇文章提出？https://medium.com/codingthesmartway-com-blog/building-a-svelte-3-todo-app-from-start-to-deployment-1737f72c23a6 5.使用 Next.js 构建电子商务购物车NextJ 是创建支持服务器端呈现开箱即用的 React 应用程序的最常见框架。这个项目将向您展示如何构建一个电子商务购物车如下所示： 您将学习到什么在此项目中，您将学习如何设置 Next.js 开发环境、创建新页面和组件、获取数据、样式和部署下一个应用程序。 技术堆栈和功能 下一个.js 组件和页面 数据提取 造型 部署 SSR 和 SPA 拥有真实的例子（如电子商务展示）来学习新的东西总是很棒。您可以在这里找到教程：https://snipcart.com/blog/next-js-ecommerce-tutorial 6.建立一个成熟的多语言博客网站Nuxt.jsNuxt.js 是 Vue Next.js 是要做出反应的。一个伟大的框架，结合服务器端呈现和单页应用程序的强大功能。您可以创建的最终应用如下所示： 您将学习到什么此示例项目将教您如何使用 Nuxt.js 从初始设置到最终部署构建一个成熟的网站。它利用了Nuxt提供的许多很酷的功能，如页面和组件，以及SCSS的样式。 技术堆栈和功能 努克斯特.js 组件和页面 Storyblok 模块 混合 用于国家管理的 Vuex 用于样式的 SCSS 纽克特中间件 这是一个非常酷的项目，并涵盖了Nuxt.js的许多伟大的功能。我个人喜欢与Nuxt合作，所以你真的应该试试这个，因为它也会使你一个更好的Vue开发人员！https://www.storyblok.com/tp/nuxt-js-multilanguage-website-tutorial 7.与盖茨比建立博客Gatsby 是一个伟大的静态站点生成器，在引擎盖下使用反应和 GraphQL。这是此项目的结果： 您将学习到什么在本教程中，您将学习如何利用 Gatsby 构建出色的博客，在利用 React 和 GraphQL 时，您可以很好地用于撰写自己的文章。 技术堆栈和功能 盖茨比 反应 图形QL 插件和主题 MDX / 标记 引导 CSS 模板 如果你想开始一个博客，这是一个很好的例子，如何做到这一点利用反应和图形QL。我不是说Wordpress总是一个糟糕的选择，但与加茨比，你可以创建高性能的网站，同时使用反应，这是一个真棒组合！https://blog.bitsrc.io/how-to-build-a-blog-with-gatsby-and-boostrap-d1270212b3dc 8.用网格构建博客网格是Vue…好吧，我们已经有下一个/Nuxt，但同样是Gridsome和Gatsby。两者都使用 GraphQL 作为数据层，但 Gridsome 使用 VueJS。这也是一个真棒静态网站生成器，将帮助您创建伟大的博客： 您将学习到什么这个项目将教你如何建立一个简单的博客，以开始与网格，GraphQL和Markdown。它还介绍了如何通过 Netlify 部署应用程序。 技术堆栈和功能 网格 Vue 图形QL 标记 内利菲 这肯定不是最全面的教程，但涵盖了 Gridsome 和 Markdown 的基本概念，可能是一个很好的起点。https://www.telerik.com/blogs/building-a-blog-with-vue-and-markdown-using-gridsome 9.使用夸萨尔构建类似 SoundCloud 的音频播放器应用程序Quasar 是另一个 Vue 框架，也可用于构建移动应用程序。在此项目中，您将创建一个类似于这样的音频播放器应用： 您将学习到什么虽然其他项目主要侧重于Web应用程序，但这个项目将向您展示如何通过Quasar框架使用Vue创建移动应用程序。你应该已经有一个工作科尔多瓦设置与Android工作室/x码配置。如果没有在教程中有一个链接到类星体网站，他们告诉你如何设置这个。 技术堆栈和功能 类星体 Vue 科尔多瓦 波浪冲浪者 UI 组件 一个小型项目，展示了 Quasar 构建移动应用程序的强大功能。https://www.learningsomethingnew.com/how-to-build-a-sound-cloud-like-audio-player-app-with-vue-js-quasar-and-wave-surfer 结论在本文中，我向您展示了可以构建的 9 个项目，每个项目都侧重于另一个 JavaScript 框架或库。现在，你的选择就是：你会尝试使用一个你以前没有使用过的框架吗？还是想通过为已有一定知识的技术做项目来增强你的技能？或者，你会依靠你最喜欢的框架/库，并在2020年完成所有项目？请随时发表评论，不要忘记跟随我更多的即将推出的帖子！","link":"/2020/06/25/2020%20%E5%B9%B4%E6%88%90%E4%B8%BA%E5%89%8D%E7%AB%AF%E5%A4%A7%E5%B8%88%E7%9A%84%209%20%E4%B8%AA%E9%A1%B9%E7%9B%AE/"},{"title":"25.深入Java系列Java中int的取值范围关键点","text":"取值范围及拆箱易错点 123456789Integer i7 = 197;Integer i8 = 197;System.out.println(i7 == i8);//falseSystem.out.println(i7.equals(i8));//truei7 = 127;i8 = 127;System.out.println(i7 == i8);//trueSystem.out.println(i7.equals(i8));//true _Java中Int_eger与int对比的一些坑 - 爱我所艾 - 博客园 2019年10月17日 - Java中Int_eger与int对比的一些坑 Integer与int类型的关系 “ Integer是_int的…Integer与Integer相互比较,数据_在-128-127_范围_内,就会从缓存中拿去_数… Java中int的_取值_范围 - qq_32534441的博客 - CSDN博客 2019年6月12日 - D区中的汉字占四个字节(一般字符的Unicode_范围_是U+…要了解Java中int_型_数据_取值_范围,还得从计算机的二进制…9223372036854775807即2的64次方项目中… _java 中int 的范围__百度知道_int_取值_范围_的计算方法(_Java_和C) - 李达西的博客 - CSDN博客 2019年5月30日 - 解释JAVA和C中int类型数值_取值_范围_的由来… 以Java为例,_Java的_int占用空间为4字节,即32Bit,32个二…要了解_Java中int_型_数据_取值_范围,还得从计算机的二进制存储说… Java_之_int_及它的取值_范围 - fly_Xiaoma的博客 - CSDN博客 2018年12月24日 - int是Java中的8种基本类型之一,一个int值占4个byte…要了解Java中int_型_数据_取值_范围,还得从计算机的二进制…遥想当年,机缘巧合入了 ACM 的坑,周边巨擘林立,… java中int_类型_数据的范围-CSDN论坛 2009年7月4日 - _java中int的_取值_范围_是多少 最近在看算法书的时候发现一个非常有意思的现象,在java中输入:System.out.println(Math.abs(-2147483648));输出为:-21474… _Java_千问:你真的会用_Java的int_型变量吗?有些坑你真的不知道 2019年12月27日 - 我们在进行_Java_编程的时候,使用最频繁_的数据_类型基本上就是_int_型了。平时在使用这种数据类型的过程中,我们似乎也并没有感觉到有什么太多需要注意的地… Java int 类型_数值_越界引发的思考 - 简书 2018年8月26日 - 相乘的结果,远超过了Java _int_类型可以表示的_范围_。…0表示正数,1表示负数,并且计算机_中的数据_使用补码来…温故基础知识,否则很可能在一些不起眼的地… Java中_显示类型_int的_文字xxxx超出了_范围-百度经验 2019年2月12日 - 昨天在编程的过程中,用到了long型的数据,我声明一个long型数据,但是显示:类型_int的_文字xxxx超出了_范围_。我很纳闷,我不是已经声明这个数据是long型的… _java中int_和Integer对比的一些坑 - 云+社区 - 腾讯云 2018年10月25日 - Integer是_int的_包装类,_int的_默认值是0,而Integer的默认值是null(jdk1.5的新特性…1、Integer与Integer相互比较,_数据_在-128-127_范围_内,就会从缓存中拿… _Java 中int_eger为什么_范围_取值要在-128到+127? - 知乎 2019年1月16日 - _java中的_integer并不是-128到127。_java中的int_占用4个字节,4*8=32位,去除一个符号位,实际表示_数据_大小… _java_对_int数值的_处理。-CSDN问答 2017年8月11日 - _java_集合截取按照_int_数组_里面的数值_截取 List&lt;String…} // 检查输入数值是否在_范围_之内 if (posX &lt; …遥想当年,机缘巧合入了 ACM 的坑,周边巨擘林… _Java中_看似简单实际很坑的题 - 知乎 Java中_看似简单实际很坑的题 Muggle 第一题(貌似是考察方法的参数传递) public class Test{ public static void main(String[] args){ _int a = 10; int b … 出现_java的int_类型_范围_异常-问答-阿里云开发者社区-阿里云 2019年7月17日 - 百度的时候说是JAVA 读数据_库时候用的是rs.getInt(i) 取出的结果超出了_INT的范围,但是我用的hibernate,这个要怎么改,而且_java的_int类型_范围_不是2的32… _java中_基本_数据_类型的取值_范围__百度文库 2016年8月17日 - 3 &gt;整型 在 Java 语言中,提供了多种整型_数据_类型:byte、short、_int_、long。…能够表示_数据的范围_越大,占用的内存空间也就越大,因此,在程序设计中 应… 尚学堂知识整理:Java _int数据_类型 2018年3月6日 - int数据_类型是32位有符号_Java_原语_数据_类型。 _int数据_类型的变量需要32位内存。 …此_范围中_的所有整数称为整数文字。 例如,10,-200,0,30,19等是_int的… tiny_int_(1)用java_转化为_int的坑-布布扣-bubuko.com 2018年6月14日 - 今天工作中有个需求:将_数据_库tiny_int_转换为_int_类型,在转换过程中发现该数字被转换为Boolean类型了 原因:在MYSQL官方的JDBC文档定义转换规则为:如果tin… _java中_整数_数值_默认是_int_类型,这句话正确吗? 如果使用一个巨大的整数值(超出了int_类型的表数_范围)时,_Java_不会自动把这个整数值当成long类型来处理,如果希望系统把这个整数值当成long类型来处理,应在这个整数… tiny_int_(1)用java_转化为_int的坑 2018年6月14日 - 今天工作中有个需求:将_数据_库tiny_int_转换为_int_类型,在转换过程中发现该数字被转换为Boolean类型了 原因:在MYSQL官方的JDBC文档定义转换规则为:如果tin… _Java_之戳中痛点 - (6)避免类型自动转换,例如两个整数相除得浮点数… 2017年6月13日 - 在上面已经做了 “可能要超出int范围,这里用long处理” 的处理,地球距离太阳的距离怎么是负的?这里要讲一个_java_处理运算的一个逻辑:先运算在进行类型转… 为什么_Java中int_型_数据_取值_范围_是[-2^31,2^31-1] - 别先生 - 博客园 1、为什么_Java中int_型_数据_取值_范围_是[-2^31,2^31-1],多么神奇的问题,网上找了很多,找不到点子上,自己瞎总结一下子。1.1、int是Java中的8种基本类型之一,… _java中int_和Integer对比的一些坑 - whendream - 博客园 2018年10月18日 - _java中int_和Integer对比的一些坑 — 作者:狂飙的yellowcong 来源:CSDN 原文:https…1、Integer与Integer相互比较,_数据_在-128-127_范围_内,就会从缓存… _java中_的_int的_取值_范围_如何计算jQuery32107930247946973674_1586170564915?_百度知道关于_int_取值_范围_的问题 - 力尽山拔的博客 - CSDN博客 2018年3月6日 - 2.如果电脑为32或者64位系统,则 int 为32位,四个字节。 所以这年头一般 int 都是32位,_数值范围_为-2147483648～2147483647(-2^32～2^32-1),也就是21亿… java Integer int 使用的坑 - chuonianban0066的博客 - CSDN博客 2019年2月26日 - _java中int_eger和int 阅读数 456 _java中int_eger和int先来说说int和integer的区别:java中的int是基本_的数据_类型,integer是_int的_封装类。 int初始化… 超出_int_型_的范围_了,不知怎么办,求助-CSDN论坛 输入_的数据_和你变量能表达的_范围_要适配啊。。。 …BigDecimal 的那些坑事儿 最近查看rebate数据时,…需要先了解一下_Java中int_型与byte型数组之间的相互… [为什么_Java中int_型_数据_取值_范围_是-2^{31}, 2^{31}-1…-CSDN博客 2019年2月28日 - 要了解Java中int_型_数据_取值_范围,还得从计算机的二进制存储说起。… int型数据_在计算机中以二进制存储,一个int型…Java中short型整数占16位,取值_范围… _JAVA中int_和Integer比较_的坑__java_weixin_42382121的博客-CSDN博客 2019年12月25日 - int 是基本类型,直接存数值 integer是对象,用一个引用指向这个对象 1.Java 中的数据_类型分为基本数据类型和复杂数据类型 _int 是前者&gt;&gt;integer 是后者(… _java中int_取值_范围_是怎么计算的?_lay的博客-CSDN博客 2018年4月9日 - 最后int能标识的最大/最小数字是:2的31次方:+/-…要了解Java中int_型_数据_取值_范围,还得从计算机的二进制…遥想当年,机缘巧合入了 ACM 的坑,周边巨擘… _int_型_数据_超过_范围_后值变化_苍白的咏叹调的博客-CSDN博客 2018年6月11日 - 在C语言中,int_型_数据_的取值_范围? 阅读数 6758 …java 怎样处理 int 类型溢出? 09-20 int 类型…遥想当年,机缘巧合入了 ACM 的坑,周边巨擘林立,… 为什么_Java中int_型_数据_取值_范围_是[-2^31,2^31-1]_Java…_CSDN博客 2020年2月29日 - 1、为什么_Java中int_型_数据_取值_范围_是[-2^31,2^31-1],多么神奇的问题,网上找了很多,找不到点子上,自己瞎总结一下子。1.1、int是Java中的8种基本类型之… 论【java_☞1】_数据_类型_的坑,bug定位系列 - 简书 首先,我们了解一下java中_有哪些_数据_类型且各自_范围_。 基本_数据_类型 _Java里面_包含…其中列举_int(整型)出来说明坑在哪。 需求说明: 抽样基数:(1-10个字符,记录上次… _int_类型_的数据_的引用问题-CSDN论坛 2014年5月18日 - 若超过_范围_值,比较时可使用(a._int_Value==b)来…上一次我们提到了_java中的_八种_数据_类型,没有涉及到…拒绝被坑!如何用Python和_数据_分析鉴别刷单!? 且… _Java_之戳中痛点 - (6)避免类型自动转换,例如两个整数相除…_博客园 2017年6月13日 - _Java_之戳中痛点 - (6)避免类型自动转换,例如两个整数相除得浮点数遇坑 …自动向_数据范围_大的方向转换:byte→short(char)→_int_→long→float→double)… Java中int的_取值_范围 - heixiu8的博客_CSDN博客 2017年11月2日 - D区中的汉字占四个字节(一般字符的Unicode_范围_是U+…解释_JAVA_和C_中int_类型_数值_取值_范围_的由来 博文 来自…9223372036854775807即2的64次方项目中遇到这个坑,记一… int_型整数_的范围 - chenwenjie666的博客 - CSDN博客 2018年8月10日 - 计算机中32位int_类型变量_的范围,其中int_类型是带符号…JNI_java_nativeinterface_Java_基本_数据_类型byteshort_int_long…遥想当年,机缘巧合入了 ACM _的坑,… _java中数值范围_详解 - Himire的专栏 - CSDN博客 2018年11月9日 - java中的_byte是1字节,8位,最高位是符号位,只有7…9223372036854775807即2的64次方项目中遇到这个坑,记一…_Java中的_基本_数据_类型及其取值_范围 阅读数… java 中 _数值_不超过3万. 用short好 还是_int_好-CSDN论坛 2014年7月6日 - short和int_问题 以前对于_java_基本_数据_类型总是在用,…5+6_的范围_并没有超过short型_的范围?为什么不能相加…被中传汉语言文学录取,却掉入了计算机的坑… java中_超过_int的_最大_范围 - lay的博客 - CSDN博客 2019年3月10日 - java中_超过_int的_最大_范围_直接po图片和代码如下图:大家有没有想过,在_java中,如果我们要保存一个超大的整数,该如何做呢?这是我心血来潮想到的一个问题?欢迎大家… _java中int_和Integer对比的一些坑 - 云+社区 - 腾讯云 2018年10月25日 - Integer是_int的_包装类,_int的_默认值是0,而Integer的默认值是null(jdk1.5的新特性…1、Integer与Integer相互比较,_数据_在-128-127_范围_内,就会从缓存中拿… _java中int范围_补码详解 - qq_35129986的博客_CSDN博客 2018年4月25日 - 一直知道_java中int范围_是-2147483648到2147483647,但是不知道为什么今天研究了一下:首先回忆了一下计算机中原码反码补码 正数的原码反码补码相等; 负… _java中_short、_int_、long、float、double取值_范围__Java…_CSDN博客 2016年10月16日 - java中_byte、short、_int_、long、float、double、char基本_数据_类型_范围 阅读数 836 基本类型,在Java中_所有数字都是带符号的。 类型 长度 _范围 byte 8bit/1byte -… Java_问题总结之1-2–超出_数据_类型取值_范围 - Keep Lear…_CSDN博客 2015年8月24日 - 分析:当前int型数据_达到最大值2147483647时,是第一位…_java 中int 类型的取值范围 阅读数 4285 int是整型…9223372036854775807即2的64次方项目中… int的_取值_范围 - 回忆 - CSDN博客 2019年8月5日 - 引言在学C++或者Java_的时候应该都会先了解各种基本_数据_类型的初值和它们的取值_范围,有些人可能会不太重视这块内容,其实很重要,很多大公司面试的过程中… _int_型_数据_超过_范围_后值变化 - AdamMaoKkk的博客 - CSDN博客 2018年11月22日 - 当int_型整数超出自己_范围_时,会从它的最小值重新开始,例如: _int i=2147483647;//int范围:-2147483648～2147483647 i+1;//i=-2147483648 unsigned int j… _java中int的_取值_范围_是多少 - lhj_sjtu的博客 - CSDN博客 2018年3月19日 - int是整型,对应我们数学上认识_的数值_为整数,就是没…_Java 中 int 的_取值_范围_是:-2^31 ~ 2^31-1大致…遥想当年,机缘巧合入了 ACM 的坑,周边巨擘林立,从此… Java中int,float,long,double取值范围,内存泄露_u01390…_CSDN博客 2016年3月28日 - _java中_所有数字都是带符号的,没有unsigned,_int_在_java中_是固定的32bits,表示的… _java中_所有数字都是带符号的,没有unsigned, _int_在_java中_是固定的32bi… 在JAVA中,如何设置一个_int_型_的数据_等于空_百度知道 2011年9月1日 - 回答：不能用int,要用Integer,一个_int_要调用就必须有值。而你可以判断Integer是否为null Integer i=new Integer(2);,if(i==null)… Java _int_转Long以后_数值_变了-CSDN论坛 Java中_如何将_int 类型转换为 Long类型 Long l = …拒绝被坑!如何用Python和数据分析鉴别刷单!? 且看…数来说,在长度一定的情况下,具有表示_数据范围_大的… java 中 int 类型的取值_范围__Java_mottohlm-CSDN博客 2017年11月5日 - int 是整型,对应我们数学上认识的数值_为整数,就是…_Java中int的_取值_范围 阅读数 4892 先看一个基本…zjshuster:今天被这个坑了 ArrayList的排序方… java中_short、_int_、long、float、double取值_范围 - liq…_CSDN博客 2017年11月9日 - Java中每种内建类型都有相应的外覆类。 _Java中int_和Integer关系是比较微妙的。关系如下: int是基本_的数据_类型; Integer是_int的_封装类; int和Integer都… _Java_之戳中痛点 - (6)避免类型自动转换,例如两个整数相除…_博客园 2018年8月22日 - _Java_之戳中痛点 - (6)避免类型自动转换,例如两个整数相除得浮点数遇坑 先来…自动向_数据范围_大的方向转换:byte→short(char)→_int_→long→float→dou… java_笔试面试_中的坑 - eaglepan - 博客园 2015年7月1日 - java中_8种基本_数据_类型,在传入方法时,是将其副本传入…4.java:[类型(字节)] byte(1) short(2) _int(…不可视阶段就是我们在_区域_代码中不可以再引用它… Java|_Java中int的_取值_范围_是多少_笔记本-CSDN博客 2019年7月31日 - _Java 中 int 的_取值_范围_是:-2^31 ~ 2^31-1大致想一下,int 占 4字节,也就… _Java 中 int 的_取值_范围_是:-2^31 ~ 2^31-1 大致想一下,int 占 4字… java里_short,_int,long,float,double_范围_及可写位数 - S…_CSDN博客 2018年3月8日 - Java中_Long最大值 阅读数 6万+ 9223372036854775807即2的64次方项目中遇到这个坑,记一下 博文 来自: goodbook 搬:_int,float,double,char四种_数据_类… _java中_如何把整型_int数据_转化成字符数组?初学java,考虑到了这个问… 2018年3月17日 - 回答：public class P { public static void main(String[] args) { int n=1234567; char[] arr=String.valueOf(n).toCharArray(); for(char c : arr)… java 中int _范围_越界校验算法 - 赵小白javaweb的博客 - CSDN博客 2019年8月7日 - 在计算之前需要分析计算是否会超过int 的范围,自己…_Java中_关于Short,byte越界需要强转,int,long越界自动…遥想当年,机缘巧合入了 ACM 的坑,周边巨… int的_取值_范围? - Ocean_tu的博客 - CSDN博客 2018年9月12日 - 计算机中32位int_类型变量_的范围,其中int_类型是带符号…JNI_java_nativeinterface_Java_基本_数据_类型byteshort_int_long…遥想当年,机缘巧合入了 ACM _的坑,… _java中int_和Integer对比的一些坑-云栖社区-阿里云 2018年10月18日 - Integer是_int的_包装类,_int的_默认值是0,而Integer的默认值是null(jdk1.5的新特性…1、Integer与Integer相互比较,_数据_在-128-127_范围_内,就会从缓存中拿… _Java_问题总结之1-2–超出_数据_类型取值_范围___Java__Keep L…_CSDN博客 2015年8月24日 - 数据_类型:int 取值_范围:-2^31–2^31-1 测试1: package p1…开局一张图:1、_java中int的_取值_范围_为-2147483648到+-2147483648。2、首先jdk中… java Integer_数值_==比较面试坑 - weixin_30847939的博客 - CSDN博客 2018年11月2日 - Integer是_java_基本_数据_类型_int的_装箱类型,面试时有时候会进行_数值_比较==挖坑,代码如下: Integer a = 1000,b=1000; Integer c = 100,d=100; System.out… _java_基本_数据_类型的取值_范围___java_基本_数据_类型,基本数…_CSDN博客 2019年4月15日 - (int) Character.MIN_VALUE); // 以数值_形式而不…_Java中_基本类型有8中。Java基本类型和取值_范围 类型…遥想当年,机缘巧合入了 ACM 的坑,周边巨擘林…","link":"/2020/04/06/25-%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97Java%E4%B8%ADint%E7%9A%84%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E5%85%B3%E9%94%AE%E7%82%B9/"},{"title":"26.深入Java系列Java中Integer为什么有个-128—+127","text":"计算机有3种编码方式表示一个数，对于正数而言，原反补都一样。 对于负数，就厉害了： -1 = 10000001（原）= 11111110（反）= 11111111（补） 人脑可以把符号位特殊处理，但是对于计算机如何处理符号位，在电路设计上就是十分复杂了 1 - 1 = 1 +（-1）这样就计算机就只处理加法就可以了 1-1=1 +（-1）= 0000 0001+1000 0001 = 1000 0010 = -2 所以计算机无法用原码表示 所以出现了反码 1-1=1 + (-1) = 0000 0001（原） + 1000 0001（原）= 0000 0001（反）+ 1111 1110（反）= 1111 1111（反） = 1000 0000（原）= -0 这样就对了，但是-0这个问题没法解决 所以又有了补码 1-1 = 1 + (-1) = 0000 0001（原） + 1000 0001（原） = 0000 0001（补） +1111 1111（补）= 0000 0000（补）=0000 0000（原） 这样-0就不存在，还可以用1000 0000表示-128 应该都知道钟表那个比喻 回拨2小时 = 前拨10小时 回拨4小时 = 前拨8小时 回拨5小时= 前拨7小时 -2与10同余，-4与8同余，-5与7同余 a ≡ a (mod m) 如果a ≡ b (mod m)，c ≡ d (mod m) 那么: (1)a ± c ≡ b ± d (mod m) (2)a * c ≡ b * d (mod m) 同余定理证明过程 (-1) mod 128 = 127 127 mod 128 = 127 2-1 ≡ 2+127 (mod 128) 原码, 反码, 补码 详解 _Integer_源码,_为什么_缓存范围在【-_128—+127_】?__Java__伟…_CSDN博客 2017年11月27日 - java_内部为了节省内存,_Integer_Cache类中有一个数组缓存了值从-_128_到_127_的_Integer_对象。当我们调用_Integer.valueOf(int i)的时候,如果i的值时结余-_128_到_127_之间的,… Java 中integer为什么范围取值要在-_128_到+127? - 知乎 2019年1月16日 - _java中_的_integer_并不是-_128_到_127_。_java中_的int占用4个字节,4*8=32位,去除一个符号位,实际表示数据大小… Java Integer -128~127 - 最怕一生碌碌无为,还安慰自己…_CSDN博客 2019年6月3日 - System.out.println(Integer.valueOf(“100”)==Integer.valueOf(“100”)); /…有0 个人打赏 私信求帮助 java中-128~127_数字常量池 阅读数 1802 _java… Integer_对象范围(-_128-127)之间_alan_gaohaodong的博客-CSDN博客 2018年6月17日 - 如果超出了范围,会从堆区new一个Integer_对象来存放值。 其实有上图第二行代码…_Java中_的AutoBoxing (_Integer_对-_128~_127_之间数值的特殊处理) 阅读数 2… Java Integer(-128~127)值的==和equals比较产生的思考 2016年9月18日 - 1、以上代码第一段和第二段旨在说明:在-128~127_的_Integer_值并且以_Integer x = value;的方式赋值的Integer_值在进行==和equals比较时,都会返回true,因为_… Integer_自动转换(-_128-127)问题 - 小程序员成长中… - CSDN博客 2014年3月19日 - 是通过Integer_Cache来实现的,_Integer_Cache值的范围是-_128_到_127(byte)。在这个范围内是直接返回数值,这个数值是放置与_java_内存的栈区的,不需要生成对象… _java_的_Integer_缓存整数介于-_128_到_127_之间_myzksky的专栏-CSDN博客 2018年7月10日 - 如果声明Integer_对象的数据,则在-_128_到_127_之间不会生成新的对象,会使用缓存中的…_Java Integer -128~127 阅读数 1万+ 今天刷到了一道题,_为什么_第一… _Java中Integer_的valueOf方法,-_128_到_127_的整数将被缓存_CSDN博客 2016年3月23日 - _java_的_Integer_缓存整数介于-_128_到_127_之间 阅读数 358 1、如果声明_Integer_对象的数据,则在-_128_到_127_之间不会生成新的对象,会使用缓存中的对象。2、dou… 一道面试题关于Integer_的缓存范围(-_128~127)所引起的一…_CSDN博客 2016年11月2日 - 于是自己各种百度、谷歌,其中有一个解释是这样的: JVM会自动维护八种基本类型的常量池,int常量池中初始化-128~127_的范围,所以当为_Integer i=_127_时,在… Java中_的AutoBoxing (_Integer_对-_128~_127_之间数值的特殊…_CSDN博客 2016年8月17日 - 在Java中_的,_Integer_和int是可以Autoboxing和boxing的,这里要注意的是:在 int自动装箱成_Integer_的过程中,如果数值是在-_128~_127_之间的值的话,那么会在在… _integer_的大于_127_与小于_128_使用==比较__Java__水桶妖的博客-CSDN博客 2018年7月14日 - Java_在处理_Integer_时使用了一个缓存,其中缓存了-_128_到_127_之间的数字对应的_Integer…为什么_在_Integer中128_不等于_128? 08-15 阅读数 2530 在Integer… 为什么_在_Integer中128_不等于_128?_w12111w的博客-CSDN博客 2017年8月15日 - 两个相同大小的int对象为什么_在值超过-_128~_127_后就不想等了 12-02 今天遇到…_java中_的_Integer_类型比较_——128_陷阱 阅读数 1077 大多数情况下,容易… 为什么_在_Java中_比较_Integer_Wrappers时_128=128_为false,而_127=127 为什么_在_Java中_比较_Integer_Wrappers时_128=128_为false,而_127=127_为真? class D { public static void main(String args[]) { _Integer b2=128; Integer b3=128;… 为什么127+_1是等于-_128-CSDN论坛 2013年3月12日 - java中_字节型数据范围是-_128~127;为什么-128-1就会…Integer a= 127 与 Integer b = 127 引入面试的…因此就能理解_为什么_是-_128_了: int型的_127_在计… java – _为什么_整数类缓存值在-_128_到_127_之间? 相关文章 - 程序园 _Java中Integer_的valueOf方法,-128到127的整数将被缓存 2016-03-23 Java _为什么_8位有符号数的范围为“-_128 — +127_”? 2015-03-03 _为什么_1个字节的取值范围… 在Java中_比较_Integer_包装器时,_为什么128 == 128_为false但_127 ==… 2020年2月25日 - 请注意,Integer_出于性能原因不存在缓存,而是为了符合JLS,第5.1.7节;必须为-_128_至_127(含)之间的值指定对象标识。Integer#valueOf(int)也记录此行为:… Java中_的AutoBoxing (_Integer_对-_128~_127_之间数值的特殊处理) 2017年11月27日 - //i1 and i2 is in the range of -128~127, while i3 and i4 not. Integer i1 = 102; Integer i2 = 102; Integer i3 = 232; Integer i4 … Integer_类型中奇怪的”_127“和”128“_对象 2019年3月22日 - 不相等原因:装箱时,java_为了提高效率,_Integer_Cache类中有一个数组将-_128&lt;=i&lt;=_127_范围之内的数据打包成缓存里的_Integer_对象了,因此不用new,这个区间里… 针对_java中Integer_的一些缓存 - - ITeye博客 2011年12月28日 - public class Java_Test { public static void main(String[] args){ …return _Integer_Cache.cache[i _+ 128]; else return new Integer(i); } … _java_关于_Integer_设置-_128_到_127_的静态缓存 - 山水花草 - 博客园 2017年9月26日 - valueOf会将常用的值(-128 to 127)cache起来。当i值在这个范围时,会比用构造方法Integer(int)效率和空间上更好。分类: java_se 标签: _java integer -12… 在Java中为什么_byte是-_127~_128_的取值范围?_Carlos_Java…_CSDN博客 2019年3月18日 - byte为何范围是-128~127 从我们接触_Java_的时候,就被告知基础类型byte是一…如果声明_Integer_对象的数据,则在-_128_到_127_之间不会生成新的对象,会使用… Integer 生成对象时,介于-128~_+127_之间的数据会被存放…-CSDN博客 2014年4月3日 - _java_的_Integer_缓存整数介于-_128_到_127_之间 阅读数 346 1、如果声明_Integer_对象的数据,则在-_128_到_127_之间不会生成新的对象,会使用缓存中的对象。2、dou… Integer 的-_128_至_127_缓存常量池记录 - 超人的博客_CSDN博客 2018年2月8日 - Integer 内部有一_个-128_到_127_的缓存池,但是如果是new出来的,那每一个对象都会…同Stringpool类似的,_Java中_存在整数(_Integer_对象,而非基本类型)pool。… _Java中_的Byte类型的取值范围_为啥_是-_128_到_127__ClawHub的…_CSDN博客 2018年12月24日 - byte为何范围是-128127 阅读数 6791 byte为何范围是-128127 从我们接触Java_的时候,就被告知基础类型byte是一个字节,占8位,表示的范围是-_128~127… java_的面试题:缓冲池(-_128~127)_wuxizhi777的专栏-CSDN博客 2016年6月5日 - _java_的_Integer_缓存整数介于-_128_到_127_之间 阅读数 360 1、如果声明_Integer_对象的数据,则在-_128_到_127_之间不会生成新的对象,会使用缓存中的对象。2、dou… _Integer_源码,_为什么_缓存范围在【-_128—+127_】_tylcheck…_CSDN博客 2018年10月18日 - java_内部为了节省内存,_Integer_Cache类中有一个数组缓存了值从-_128_到_127_的_Integer_对象。当我们调用_Integer.valueOf(int i)的时候,如果i的值时结余-128… Java Integer(-128~127)值的==和equals比较产生的思考_CSDN博客 2013年7月30日 - 1、以上代码第一段和第二段旨在说明:在-128~127_的_Integer_值并且以_Integer x = value;的方式赋值的Integer_值在进行==和equals比较时,都会返回true,因为_… Java中_的AutoBoxing (_Integer_对-_128~_127_之间数值的特殊…_CSDN博客 2017年11月27日 - 在Java中_的,_Integer_和int是可以Autoboxing和boxing的,这里要注意的是: 在 int自动装箱成_Integer_的过程中,如果数值是在-_128~_127_之间的值的话,那么会在… Java中_的AutoBoxing (_Integer_对-_128~_127_之间数值的特殊…_CSDN博客 2010年5月3日 - 在Java中_的,_Integer_和int是可以Autoboxing和boxing的,这里要注意的是: 在 int自动装箱成_Integer_的过程中,如果数值是在-_128~_127_之间的值的话,那么会在… _为什么_在_Integer中128_不等于_128___Java__小诸葛的博客-CSDN博客 2019年2月1日 - 在Integer中128 != 128_。 博文 来自: w12111w的博客 _Java Integer -128~127 阅读数 1万+ 今天刷到了一道题,_为什么_第一个为true,第二个为false。 Syst… Java中_的AutoBoxing (_Integer_对-_128~_127_之间数值的特殊…_CSDN博客 2010年5月3日 - 在Java中_的,_Integer_和int是可以Autoboxing和boxing的,这里要注意的是: 在 int自动装箱成_Integer_的过程中,如果数值是在-_128~_127_之间的值的话,那么会在… 为什么127+_1是等于-_128 - weixin_42630877的博客 - CSDN博客 2018年9月12日 - byte为何范围是-128~127 从我们接触_Java_的时候,就被告知基础类型byte是一…/* * 看程序写结果 * * 注意:_Integer_的数据直接赋值,如果在-_128_到_127_之… 【_Java_】奇怪的考试题:_128_与_127_对于==(等于号)的不同区…_CSDN博客 2016年12月26日 - java Integer 超过127_时,比较判断 博客 u014655105 3621 浏览器打开 奇怪的_Java_题:_为什么128 == 128_返回为False,而_127 == _127_会返回为True? 博客 wei… 【_Java_】奇怪的考试题:_128_与_127_对于==(等于号)的不同区…-CSDN博客 2018年8月12日 - 这是非常有趣的地方。如果你查看Integer. Java 类,你会找到_Integer_Cache._java_这个内部私有类,它为-_128_到_127_之间的所有整数对象提供缓存。 这个东西为… java中_byte的范围_为何_是-_128–127_而不是-_127–127…_CSDN博客 2017年8月9日 - +2^6=127;最小的负数,同理,为1 1111111,即-_127_。 到这里应该是许多人不明白的地方,_为什么_负数会到-_128_。这不得不崇拜伟大的印度阿三们。上述的描述会… _Integer_的自动拆箱和自动装箱的陷阱(整型数-_128_到_127_的…_CSDN博客 2016年10月11日 - Integer_的自动拆装箱的陷阱(整型数-_128_到_127_的值比较问题): 1、先看下面的例子: [_java] view plain copy package integer_demo; public class _Intege… Java_整型缓存(-_128 ~ 127)__java_,缓存_蒋固金(jiangguji…_CSDN博客 2016年12月19日 - _java_的_Integer_缓存整数介于-_128_到_127_之间 阅读数 361 1、如果声明_Integer_对象的数据,则在-_128_到_127_之间不会生成新的对象,会使用缓存中的对象。2、dou… 关于_Java中Integer_所涉及的缓冲区的理解_zha0zha0zha的…_CSDN博客 2016年12月14日 - 这个运行结果是符合我们所知道的java_基本知识的,即new操作的每一个对象的指向堆…但是当声明对象的值在区间[-_128, 127]中时,_Integer_的valueOf方法就会return cache…","link":"/2020/04/06/26-%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97Java%E4%B8%ADInteger%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%B8%AA-128%E2%80%94-127/"},{"title":"9 种常用关键机器学习算法","text":"机器学习正在改变世界。谷歌使用机器学习向用户推荐搜索结果。Netflix 使用它推荐电影供您观看。Facebook 使用机器学习来推荐您可能认识的人。 机器学习从未像现在这样重要。同时，理解机器学习也很难。田野里充满了行话。不同的 ML 算法数量每年都在增长。 本文将向您介绍机器学习领域的基本概念。更具体地说，我们将讨论当今 9 个最重要的机器学习算法背后的基本概念。 推荐系统什么是推荐系统？建议系统用于在数据集中查找类似的条目。 也许最常见的建议真实示例存在于 Netflix 中。更具体地说，其视频流媒体服务将推荐基于你已经观看的内容的电影和电视节目。 另一个推荐系统是Facebook的”你可能认识的人”功能，它建议你可能的朋友，根据你现有的朋友名单。 充分开发和部署的建议系统极其复杂。它们也非常耗费资源。 推荐系统和线性代数成熟的推荐系统需要线性代数的深层背景，才能从头开始构建。 因此，如果您以前从未研究过线性代数，则本节中可能有些概念无法理解。 不过，别担心——学习的 Python 库使得构建推荐系统变得非常简单。S0 你不需要太多的线性代数背景来构建真实世界的建议系统。 推荐系统如何工作？推荐系统主要有两种类型： 基于内容的建议系统 协作筛选建议系统 基于内容的推荐系统根据已使用的项目的相似性为您提供建议。他们完全按照你期望的推荐系统来做。 协作筛选建议系统根据用户与项目交互的知识生成建议。换句话说，他们利用了人群的智慧。（因此，其名称中的术语”协作”。 在现实世界中，协作筛选建议系统比基于内容的系统更常见。这主要是因为它们通常能产生更好的结果。一些从业者还发现协作筛选建议系统更易于理解。 协作筛选建议系统还具有缺少基于内容的系统的独特功能。也就是说，他们有能力自己学习功能。 这意味着他们甚至可以开始根据您甚至未告诉他们要考虑的属性来识别项之间的相似性。 协作筛选中有两个子类别： 基于内存的协作筛选 基于模型的协作筛选 在机器学习中取得成功，您无需了解这两种类型的协作筛选建议系统之间的区别。这足以识别存在多种类型。 章节总结以下是我们在本教程中讨论的关于建议系统的简要摘要： 现实世界中推荐制度的例子 不同类型的推荐系统，以及协作筛选系统如何比基于内容的建议系统更常用 推荐系统与线性代数的关系 线性回归线性回归用于根据另一组值的值预测某些值。y``````x 线性回归的历史线性回归是由弗朗西斯·加尔顿在19世纪创建的。 高尔顿是研究父母和孩子之间关系的科学家。更具体地说，高尔顿正在调查父亲身高和儿子身高之间的关系。 高尔顿的第一个发现是，儿子往往和父亲一样高。这并不奇怪。 后来，加尔顿发现了一些更有趣的东西。儿子的身高往往更接近于所有人的总平均身高__，而不是他自己的父亲__。 加尔顿给这种现象起一个名称：**回归**。具体来说，他说”父亲的儿子的身高倾向于倒退（或向）平均（平均）高度漂移”。 这导致了整个统计和机器学习领域称为回归。 线性回归数学创建回归模型时，我们尝试的只是绘制一条尽可能接近数据集中每个点的线。 典型的示例是线性回归的”最小平方法”，该方法仅计算向上和向下方向的直线的接近度。 下面是一个示例，可帮助说明这一点： 创建回归模型时，最终产品是一个方程，可用于预测 x 值的 y 值，而无需事先实际知道 y 值。 逻辑回归逻辑回归类似于线性回归，只不过它不是计算数值，而是估计数据点属于哪个_类别_。y 什么是逻辑回归？逻辑回归是一种机器学习模型，用于解决分类问题。 以下是机器学习分类问题的一些示例： 垃圾邮件（垃圾邮件还是垃圾邮件？ 汽车保险索赔（注销或修理？ 疾病诊断 每个分类问题都有两个类别，这使得它们成为二进制分类问题的示例。 逻辑回归非常适合解决二进制分类问题 - 我们只是为每个类别指定值和分别。0``````1 为什么我们需要逻辑回归？因为不能使用线性回归模型进行二进制分类预测。它不会导致良好的拟合，因为您尝试通过只有两个可能的值的数据集拟合直线。 此图像可以帮助您理解为什么线性回归模型不适合二进制分类问题： 在此图像中， 表示肿瘤是恶性的概率.相反，该值表示肿瘤不是恶性肿瘤的概率。如您所见，线性回归模型在预测数据集中大多数观测值的此概率方面做得很差。y-axis``````1-y 这就是为什么逻辑回归模型很有用。它们有一个弯曲到他们的最佳拟合线，这使得他们更适合预测分类数据。 下面是一个使用相同训练数据将线性回归模型与逻辑回归模型进行比较的示例： 西格莫伊德函数逻辑回归模型在其曲线中具有折弯的原因是因为它没有使用线性方程计算。相反，逻辑回归模型是使用 Sigmoid 函数构建的（由于逻辑回归中使用，因此也称为逻辑函数）。 您不必记住Sigmoid 函数即可在机器学习中取得成功。话虽如此，对它的外观有一些了解是有用的。 公式如下所示： Sigmoid 函数的主要特征值得理解：无论您向它传递什么价值，它始终都会在 0 和 1 之间生成输出。 使用逻辑回归模型进行预测要使用线性回归模型进行预测，通常需要指定截止点。此截止点通常是 。0.5 让我们用我们早期图像中的癌症诊断示例来在实践中看到这一原则。如果逻辑回归模型输出的值低于 0.5，则数据点被归类为非恶性肿瘤。同样，如果 Sigmoid 函数输出的值高于 0.5，则肿瘤将归类为恶性肿瘤。 使用混淆矩阵测量逻辑回归性能混淆矩阵可用作比较机器学习中真实正值、真负数、误报和假负数的工具。 当用于测量逻辑回归模型的性能时，混淆矩阵特别有用。下面是一个示例，演示如何使用混淆矩阵： 在此图中，TN 代表”真负”，FN 代表”假负”。FP 代表”误报”，TP 代表”真实正”。 混淆矩阵可用于评估模型在混淆矩阵的特定象限中是否特别弱。例如，它可能有异常数量的误报。 在某些应用程序中，确保模型在混淆矩阵的异常危险区域中表现良好也很有帮助。 例如，在这个癌症示例中，您希望非常确定模型的假阴性率不会很高，因为这将表明某人的恶性肿瘤被错误地归类为非恶性肿瘤。 章节总结在本节中，您首次接触了逻辑回归机器学习模型。 以下是您学到的有关逻辑回归的简要摘要： 使用逻辑回归模型解决的分类问题类型 物流函数（也称为 Sigmoid 函数）始终输出介于 0 和 1 之间的值 如何使用截止点使用逻辑回归机器学习模型进行预测 为什么混淆矩阵可用于测量逻辑回归模型的性能 K-最近邻域K 最近邻域算法可以帮助您解决分类问题，其中有两个以上类别。 什么是 K-最近邻域算法？K 最近邻域算法是基于简单原理的分类算法。事实上，这个原则是如此简单，最好通过实例来理解它。 想象一下，你有关于足球运动员和篮球运动员身高和体重的数据。K 近邻算法可用于预测新运动员是足球运动员还是篮球运动员。 为此，K 最近的邻域算法标识最接近新观测点的数据点。K 下图以 K 值的 K 值显示此情况，K 值为 ：3 在此图像中，足球运动员被标记为蓝色数据点，篮球运动员标记为橙色点。我们尝试分类的数据点标记为绿色。 由于新数据点的壁橱数据点中的大部分（3个中的2个）是蓝色足球运动员，因此K最近的邻域算法将预测新数据点也是足球运动员。 构建 K-最近邻域算法的步骤构建 K 最近邻域算法的一般步骤是： 存储所有数据 计算欧几里登距离的新数据点到数据集中的所有其他点x 按与x 使用与大多数最近数据点相同的类别进行预测K``````x K-最近邻域算法中 K 的重要性尽管从一开始可能并不明显，但更改 K-最近邻域算法中 的值将更改新点分配给哪个类别。K 更具体地说，值非常低将导致模型完全预测您的训练数据，并预测测试数据不足。同样，值过高会使模型不必要地复杂。K``````K 以下可视化效果很好地说明了这一点： K-最近邻域算法的优缺点最后，对 K-最近邻域算法的介绍，我想简要地讨论使用此模型的一些利弊。 以下是 K 最接近邻域算法的一些主要优点： 该算法简单易懂 根据新的训练数据对模型进行培训是微不足道的 它适用于分类问题中的任意数量的类别 可以轻松地向数据集添加更多数据 模型仅接受两个参数：以及您要使用的距离指标（通常为欧几里得距离）K 同样，以下是算法的一些主要缺点： 进行预测的计算成本很高，因为您需要对整个数据集进行排序 它不适用于分类功能 章节总结以下是您刚刚了解到的关于 k-最近邻域算法的简要摘要： K 近邻算法可以解决的分类问题（足球运动员与篮球运动员）的示例 K 最近邻域如何使用相邻数据点的欧几里得距离来预测新数据点属于哪个类别 为什么进行预测的价值K 使用 K 最近邻域算法的优缺点 决策树和随机林决策树和随机林都是树方法的示例。 更具体地说，决策树是机器学习模型，用于通过逐个循环浏览数据集中的每个要素来进行预测。随机林是决策树的集中，它们使用数据集中要素的随机顺序。 什么是树方法？在深入探讨机器学习中树方法的理论基础之前，先从示例开始是很有帮助的。 想象一下你每个星期一打篮球。此外，你总是邀请同一个朋友来和你一起玩。 有时朋友真的来了。有时他们没有。 决定是否来取决于许多因素，如天气，温度，风和疲劳。您开始注意到这些功能，并开始跟踪它们，同时您朋友决定是否播放。 您可以使用这些数据来预测你的朋友是否会出现打篮球。可以使用的一种技术是决策树。以下是此决策树的外观： 每个决策树都有两种类型的元素： Nodes：树根据某些属性的值拆分的位置 Edges：拆分到下一个节点的结果 您可以在上面的图像中看到 ， 和 的 节点。每个属性的每个潜在值都有一个边。outlook``````humidity``````windy 下面是在继续操作之前应了解的另外两个决策树术语： Root：执行第一次拆分的节点 Leaves：预测最终结果的终端节点 现在，您对决策树有了基本的了解。我们将在下一节中了解如何从头开始构建决策树。 如何从头开始构建决策树建立决策树比你想象的要难。这是因为决定要拆分数据的功能（这是属于熵和信息增益领域的主题）是一个数学上复杂的问题。 为了解决这个问题，机器学习从业者通常使用许多决策树，使用选择为拆分的要素的随机样本。 换句话说，每次拆分时，都会为每个树选择新的要素随机样本。这种技术称为随机林。 通常，从业者通常选择要素随机样本（表示）的大小作为数据集（表示）中总要素数的平方根。简洁，是 的平方根，然后从 随机选择特定要素。m``````p``````m``````p``````m 如果这现在不完全有意义，不要担心。当您最终构建第一个随机林模型时，它将更加清晰。 使用随机林的好处假设您正在使用具有非常强大功能的数据集。换句话说，数据集有一个功能比数据集中的其他功能更具有预测最终结果。 如果要手动构建决策树，则使用此功能作为决策树的顶部拆分是有意义的。这意味着您将有多个预测高度相关的树。 我们希望避免这种情况，因为取高度相关变量的平均值不会显著降低方差。通过随机选择随机林中每个树的特征，树变得不相关，并减小生成的模型的方差。这种相互性是使用随机林而不是手工决策树的主要优点 章节总结本文简要总结了您学到的关于决策树和随机林的知识： 可以使用决策树预测的问题示例 决策树的元素： 、 、 和nodes``````edges``````roots``````leaves 如何随机采样决策树特征，使我们能够构建一个随机林 为什么使用随机林来关联变量有助于降低最终模型的方差 支持矢量机支持向量机是分类算法（尽管从技术上讲，它们也可用于解决回归问题），它们通过切片划分类别之间的最广泛差距将数据集划分为多个类别。这一概念将在一瞬间通过可视化来更加清晰。 什么是支持向量机？支持向量机（简称 SVM）是受监督的机器学习模型，具有分析数据和识别模式的相关学习算法。 支持向量机可用于分类问题和回归问题。在本文中，我们将专门研究支持向量机用于解决分类问题。 支持矢量机的工作原理是什么？让我们深入了解支持向量机的真正工作方式。 给定一组训练示例（每个示例都标记为属于两个类别之一），支持向量机器训练算法可生成模型。此模型将新示例分配给两个类别之一。这使得支持向量机成为非概率二进制线性分类器。 SVM 使用几何进行分类预测。 更具体地说，SVM 模型将数据点映射为空间中的点，并将单独的类别进行划分，以便它们除以尽可能宽的开放间隙。根据它们所属的间隙的哪一侧，预测新数据点属于一个类别。 下面是一个示例可视化，可帮助您了解支持向量机背后的直觉： 正如您所看到的，如果新数据点落在绿线的左侧，它将使用红色类别标记。同样，如果新数据点落在绿线的右侧，它将被贴上属于蓝色类别的标签。 这条绿线被称为超平面，它是支持向量机算法的重要词汇。 让我们来看看支持向量机的不同可视表示形式： 在此图中，超平面标记为最佳超平面。支持向量机理论将最佳超平面定义为最大化每个类别最近数据点之间的边距。 如您所见，边距线实际上触及三个数据点 - 两个来自红色类别，一个来自蓝色类别。这些接触边距线的数据点称为支持向量，是支持向量机从中获取其名称的位置。 章节总结以下是您刚刚了解到的支持向量机的简要摘要： 支持向量机是受监督机器学习算法的一个示例 支持向量机可用于解决分类和回归问题 支持向量机如何使用超平面对数据点进行分类，该超平面可最大化数据集中类别之间的差值 在支持向量机中触摸边距线的数据点称为支持向量。这些数据点是支持向量机从中派生其名称的位置。 K-意味着聚类K-意味着聚类是一种机器学习算法，允许您识别数据集中类似数据段。 什么是 K-意味着聚类？K-意味着聚类是一种不受监督的机器学习算法。 这意味着它占用了未标记的数据，并尝试将数据中的相似观测组分组在一起。 K-意味着聚类算法对于解决实际问题非常有用。以下是此机器学习模型的一些用例： 营销团队的客户细分 文档分类 亚马逊、UPS 或联邦快递等公司的交付路线优化 识别和应对城市内的犯罪中心 专业体育分析 预测和预防网络犯罪 K 表示聚类算法的主要目标是将数据集划分为不同的组，以便每个组中的观测值彼此相似。 下面是实际外观的视觉表示形式： 我们将在本教程的下一节中探讨 K 表示聚类背后的数学。 K-意味着聚类算法的工作原理是什么？运行 K-表示聚类算法的第一步是选择要将数据划分为的群集数。此群集数是算法名称中引用的值。K 在 K-表示聚类算法中选择值是一个重要的选择。在本文中，我们将更多地讨论如何选择后面的正确值。K``````K 接下来，必须随机将数据集中的每个点分配给随机群集。这提供了我们的初始赋值，然后运行以下迭代，直到群集停止更改： 通过取取该群集内点的平均矢量来计算每个群集的质心 将每个数据点重新分配给具有最近质心的群集 下面是一个动画，说明对于值 为 的 K-表示聚类算法来说，这在实践中是如何工作的。您可以看到由黑色字符表示的每个群集的质心。K``````3``````+ 如您所见，此迭代将继续，直到群集停止更改 - 这意味着数据点不再分配给新的群集。 为 K 选择正确的 K 值意味着聚类算法为 K-意味着聚类算法选择适当的值实际上相当困难。选择”最佳”值没有”正确”答案。K``````K 机器学习从业者经常使用的一种方法称为肘部方法。 要使用弯头方法，您需要做的第一件事是计算一组值的 K 表示聚类算法的平方误差 （SSE） 的总和。K 中的 SSE 表示聚类算法定义为群集中每个数据点与群集的质心之间的平方距离之和。K 作为此步骤的示例，您可以计算 SSE 的值， 和 。K``````2``````4``````6``````8``````10 接下来，您需要针对这些不同的值生成 SSE 的绘图。您将看到错误会随着值的增加而减小。K``````K 这是有道理的 - 在数据集中创建的类别越多，每个数据点都越接近其特定群集的中心。 话虽如此，肘部法背后的理念是选择一个值，即上证所突然放慢下跌速度。此突然减少在图形中生成 。K``````elbow 例如，下面是 SSE 反对 的图表。在这种情况下，弯头方法建议使用近似 值。K``````K``````6 重要的是，只是对使用价值的估计。K-表示聚类算法中永远不会有”最佳”值。与机器学习领域的许多内容一样，这是一个高度依赖于情况的决策。6``````K``````K 章节总结以下是您在本文中学到的内容的简要摘要： K-意味着聚类算法能够解决的无监督机器学习问题示例 K-意味着聚类算法的基本原理 K-意味着聚类算法的工作原理 如何使用弯头方法在 K 表示聚类模型中选择 适当的值K 主要组件分析主要组件分析用于将多要素数据集转换为具有较少功能的转换数据集，其中每个新功能都是预先存在的要素的线性组合。此转换数据集旨在以更简单得多来解释原始数据集的大部分差异。 什么是主要组件分析？主要组件分析是一种机器学习技术，用于检查变量集之间的相互关系。 说的不同，主要成分分析研究变量集，以便确定这些变量的基础结构。 主要成分分析有时称为**因子分析**。 基于此描述，您可能会认为主要分量分析与线性回归非常相似。 事实并非如此。事实上，这两种技术有一些重要的区别。 线性回归与主分量分析的区别线性回归确定数据集的最佳拟合线。主组件分析确定几个最适合数据集的正交行。 如果您不熟悉正交一词，则只表示线彼此成直角（90 度），如地图上的北、东、南和西。 让我们考虑一个示例，以帮助您更好地理解这一点。 查看此图像中的轴标签。 在此图像中，x 轴主组件示例数据集中 73% 的方差。y 轴主组件解释了数据集中大约 23% 的方差。 这意味着数据集中 4% 的方差仍无法解释。您可以通过向分析添加更多主要组件来进一步减少此数字。 章节总结以下是您在本教程中学到的关于主要组件分析的简要摘要： 该主要组件分析试图找到确定数据集中可变性的正交因子 主分量分析与线性回归的区别 在数据集内部可视化时，正交主体组件的外观 添加更多主要组件可以帮助您解释数据集中的更多差异","link":"/2020/06/21/9%20%E7%A7%8D%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"},{"title":"9道价值20k薪资的VUE必备面试题","text":"9道价值20k薪资的“VUE必备面试题”，快来围观！关于Vue框架部分，总会涉及一些高频面试题，大多数看似非常初级。 有些纯记忆性质的面试题，我们在官方文档很容易就能查看到。 举个例子： vue组件之间如何通信? vue生命周期有哪些？ 这类面试题在文档中就能找到答案，网络上面找到的答案也是千篇一律。大家只要使用过vue并且稍加记忆即可流畅作答。 但是，如果我们也这样回答，那就算自己真的比其他竞争者更有实力，也很难脱颖而出，更别提获得高薪offer了。 怎么才能避免这种情况呢？ 很简单，其实面试官提出这类“常见问题”时，就意味着他想要听到“不常见的答案”。 我们只要将回答问题的方式、思路提升一个层级，给出标新立异的高水准解答，拿下高薪Offer就如探囊取物一般简单！ 下面，我们就一起来看看，“价格不菲”的面试题，都有哪些？ （1）v-if和v-for谁的优先级最高？当面试官提出这个问题时，显然想要考察应聘者对v-if和v-for的“基本功”，同时还想要考察应聘者如何将理论应用到操作里。 基于以上两点，我们可以拓展问题： 当v-if和v-for同时出现时，我们应该怎样优化从而获得更好的性能？ 得知了面试官的隐含问题，接下来我们对症下药就可以了。 首先，在源码中找答案： compiler/codegen/index.js（☜文件中的位置） 做个测试如下： 两者同级时，渲染函数如下： _l包含了isFolder的条件判断☝☝ 两者不同级时，渲染函数如下： 先判断条件再决定是否执行☝☝ 正确解答： 1、显然v-for优先于v-if被解析（把你是怎么知道的告诉面试官） 2、如果同时出现，每次渲染都会先执行循环再判断条件，无论如何循环都不可避免，浪费了性能 3、要避免出现这种情况，则在外层嵌套template，在这一层进行v-if判断，然后在内部进行v-for循环 4、如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项 顺便推荐一份Vue、js等相关面试题，点击下方就能1毛钱带走，即刻get前端必学3大技能！ 开课吧 的推荐 2020最新前端大厂面试题，1毛钱带走！ 点击领取 （2）VUE组件data为什么必须是函数我们都知道，VUE的data实例必须是函数，那么有没有与之相反的情况呢？答案是肯定的，因为VUE的根实例就没有“必须是函数”这个限制的。 所以，我们在对这道题进行解答之前，我们还要考虑与“VUE组件data对象实例”所对应的“VUE的根实例”。 通过两者的对比论证，会让我们的答案更加清晰缜密、更有说服力。 源码中找答案： src\\core\\instance\\state.js - initData() 文件中的位置☝ 通过源码得知： 函数每次执行都会返回全新data对象实例 测试代码如下： 然而程序甚至无法通过vue检测☟☟ 正确解答： Vue组件可能存在多个实例，如果使用对象形式定义data，则会导致它们共用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的； 采用函数形式定义，在initData时会将其作为工厂函数返回全新data对象，有效规避多实例之间状态污染问题。 而在Vue根实例创建过程中则不存在该限制，也是因为根实例只能有一个，不需要担心这种情况。 （3）vue中key的作用和工作原理为了表达的更加透彻，我们可以通过对比测试来寻找key的工作原理： 首先是在源码中找答案，它在文件中的位置是☟ src\\core\\vdom\\patch.js - updateChildren() 测试代码如下： 本次案例代码重现的是以下过程☟☟： 在不使用Key的情况下是这样的☟☟： 如果使用Key☟☟： // 首次循环patch A A B C D E A B F C D E // 第2次循环patch B B C D E B F C D E // 第3次循环patch E C D E F C D E // 第4次循环patch D C D F C D // 第5次循环patch C C F C // oldCh全部处理结束，newCh中剩下的F，创建F并插入到C前面 正确解答： 1、key的作用主要是为了高效的更新虚拟DOM，其原理是vue在patch过程中通过key可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个patch过程更加高效，减少DOM操作量，提高性能。 2、另外，若不设置key还可能在列表更新时引发一些隐蔽的bug 3、vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。 （4）你怎么理解vue中的diff算法？在分析diff算法之前，我们可以看一下VUE的diff算法模型图： 接下来还是先从源码入手解决问题： 源码分析1：必要性 lifecycle.js - mountComponent() 组件中可能存在很多个data中的key使用 源码分析2：执行方式 patch.js - patchVnode() patchVnode是diff发生的地方 整体策略：深度优先，同层比较 源码分析3：高效性 patch.js - updateChildren() 测试代码如下： 正确解答： 1、diff算法是虚拟DOM技术的必然产物：通过新旧虚拟DOM作对比（即diff），将变化的地方更新在真实DOM上； 另外，也需要diff高效的执行对比过程，从而降低时间复杂度为O(n)。 2、vue 2.x中为了降低Watcher粒度，每个组件只有一个Watcher与之对应，只有引入diff才能精确找到发生变化的地方。 3、vue中diff执行的时刻是组件实例执行其更新函数时，它会比对上一次渲染结果oldVnode和新的渲染结果newVnode，此过程称为patch。 4、diff过程整体遵循深度优先、同层比较的策略；两个节点之间比较会根据它们是否拥有子节点或者文本节点做不同操作； 比较两组子节点是算法的重点，首先假设头尾节点可能相同做4次比对尝试； 如果没有找到相同节点才按照通用方式遍历查找，查找结束再按情况处理剩下的节点； 借助key通常可以非常精确找到相同节点，因此整个patch过程非常高效。 （5）谈一谈对vue组件化的理解？听到“理解”两个字我们就要注意了，看似一道开放性的问题，实际是要考察我们对VUE组件化的认知基础。 我们可以从定义、优点、使用场景和注意事项等方面展开陈述，同时要强调vue中组件化的一些特点。 始终不变的是“从源码深入解决问题，最终达到深入浅出的效果。” 源码分析1：组件定义 src\\core\\global-api\\assets.js（☝文件中的位置）// 组件定义Vue.component('comp', {template: 'this is a component'}) vue-loader会编译template为render函数，最终导出的依然是组件配置对象。☟ this is a component 源码分析2：组件化优点 lifecycle.js - mountComponent() ☝组件、Watcher、渲染函数和更新函数之间的关系 源码分析3：组件化实现 构造函数， src\\core\\global-api\\extend.js 实例化及挂载， src\\core\\vdom\\patch.js - createElm() 正确解答： 1、组件是独立和可复用的代码组织单元。组件系统是 Vue 核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用； 2、组件化开发能大幅提高应用开发效率、测试性、复用性等； 3、组件使用按分类有：页面组件、业务组件、通用组件； 4、vue的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于VueComponent，扩展于Vue； 5、vue中常见组件化技术有：属性prop，自定义事件，插槽等，它们主要用于组件通信、扩展等； 6、合理的划分组件，有助于提升应用性能； 7、组件应该是高内聚、低耦合的； 8、遵循单向数据流的原则。 （6）谈一谈对vue设计原则的理解？和上一题的思路一样，我们首先要明确：关于VUE设计原则，我们要从哪几个方面入手进行详细解答？ 而在vue的官网上，就写着大大的定义和特点： 渐进式JavaScript框架 易用、灵活和高效 所以阐述此题的整体思路按照这个展开即可。 正确解答： 首先就是渐进式JavaScript框架： 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。 Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。 另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 易用性 vue提供数据响应式、声明式模板语法和基于配置的组件系统等核心特性。 这些使我们只需要关注应用的核心业务即可，只要会写js、html和css就能轻松编写vue应用。 灵活性 渐进式框架的最大优点就是灵活性，如果应用足够小，我们可能仅需要vue核心特性即可完成功能； 随着应用规模不断扩大，我们才可能逐渐引入路由、状态管理、vue-cli等库和工具； 不管是应用体积还是学习难度都是一个逐渐增加的平和曲线。 高效性 超快的虚拟 DOM 和 diff 算法使我们的应用拥有最佳的性能表现。 追求高效的过程还在继续，vue3中引入Proxy对数据响应式改进以及编译器中对于静态内容编译的改进都会让vue更加高效。 （7）对MVC、MVP和MVVM的理解当我们面对这道考题时，往往有些摸不着头脑，因为MVC、MVP和MVVM的知识点非常广泛，很难做到说清、说透。 那要怎么才能回答的简洁有条理？让面试官眼前一亮呢？ 来听我给你清晰解读一下这道题的正确思路吧！ 其实在日常工作中，类似MVP、MVC这类前端程序，我们程序员甚至自己都没用过，这恰恰就反映了： 前端这些年从无到有，从有到优的变迁过程。 想到这里，我们的解题思路便慢慢浮出水面了，那就是： 按时间顺序，浅谈MVC、MVP、MVVM等系列产品的更新迭代。 Web1.0时代 在web1.0时代，并没有前端的概念。 开发一个web应用多数采用： **http://ASP.NET/Java/PHP**编写， 项目通常由多个aspx/jsp/php文件构成。 每个文件中同时包含了HTML、CSS、JavaScript、C#/Java/PHP代码。 系统整体架构可能是这样子的☟： 这种架构的好处是简单快捷，但是，缺点也非常明显：JSP代码难以维护 为了让开发更加便捷，代码更易维护，前后端职责更清晰。便衍生出MVC开发模式和框架，前端展示以模板的形式出现。 典型的框架就是： Spring、Structs、Hibernate。 整体框架如图所示☟： 使用这种分层架构，职责清晰，代码易维护。 但这里的MVC仅限于后端，前后端形成了一定的分离，前端只完成了后端开发中的view层。 但是，同样的这种模式存在着一些问题： 1、前端页面开发效率不高 2、前后端职责不清 web 2.0时代 自从Gmail的出现，ajax技术开始风靡全球。有了ajax之后，前后端的职责就更加清晰了。 因为前端可以通过Ajax与后端进行数据交互，因此，整体的架构图也变化成了下面这幅图☟： 通过ajax与后台服务器进行数据交换，前端开发人员，只需要开发页面这部分内容，数据可由后台进行提供。 而且ajax可以使得页面实现部分刷新，减少了服务端负载和流量消耗，用户体验也更佳。 这时，才开始有专职的前端工程师。同时前端的类库也慢慢的开始发展，最著名的就是jQuery了。 当然，此架构也存在问题：缺乏可行的开发模式承载更复杂的业务需求，页面内容都杂糅在一起，一旦应用规模增大，就会导致难以维护了。 因此，前端的MVC也随之而来。 前后端分离后的架构演变——MVC、MVP和MVVM MVC 前端的MVC与后端类似，具备着View、Controller和Model。 Model：负责保存应用数据，与后端数据进行同步 Controller：负责业务逻辑，根据用户行为对Model数据进行修改 View：负责视图展示，将model中的数据可视化出来。 三者形成了一个如图所示的模型： 这样的模型，在理论上是可行的。但往往在实际开发中，并不会这样操作。因为开发过程并不灵活。 例如，一个小小的事件操作，都必须经过这样的一个流程，那么开发就不再便捷了。 在实际场景中，我们往往会看到另一种模式， 如图所示☟： 这种模式在开发中更加的灵活，backbone.js框架就是这种的模式。 但是，这种灵活可能导致严重的问题： 1、数据流混乱：如下图☟ 2、View比较庞大，而Controller比较单薄： 由于很多的开发者都会在view中写一些逻辑代码，逐渐的就导致view中的内容越来越庞大，而controller变得越来越单薄。 既然有缺陷，就会有变革。 前端的变化中，似乎少了MVP的这种模式，是因为AngularJS早早地将MVVM框架模式带入了前端。 MVP模式虽然前端开发并不常见，但是在安卓等原生开发中，开发者还是会考虑到它。 MVP MVP与MVC很接近，P指的是Presenter，presenter可以理解为一个中间人。 它负责着View和Model之间的数据流动，防止View和Model之间直接交流。 我们可以看一下图示☟ 我们可以通过看到，presenter负责和Model进行双向交互，还和View进行双向交互。 这种交互方式，相对于MVC来说少了一些灵活，VIew变成了被动视图，并且本身变得很小。虽然它分离了View和Model。 但是应用逐渐变大之后，导致presenter的体积增大，难以维护。 要解决这个问题，或许可以从MVVM的思想中找到答案。 MVVM 首先，何为MVVM呢？MVVM可以分解成(Model-View-VIewModel)。 ViewModel可以理解为在presenter基础上的进阶版。如图所示☟☟： ViewModel通过实现一套数据响应式机制自动响应Model中数据变化； 同时Viewmodel会实现一套更新策略自动将数据变化转换为视图更新； 通过事件监听响应View中用户交互修改Model中数据。 这样在ViewModel中就减少了大量DOM操作代码。 MVVM在保持View和Model松耦合的同时，还减少了维护它们关系的代码，使用户专注于业务逻辑，兼顾开发效率和可维护性。 总结： 这三者都是框架模式，它们设计的目标都是为了解决Model和View的耦合问题。 MVC模式出现较早主要应用在后端，如Spring MVC、http://ASP.NET MVC等，在前端领域的早期也有应用，如Backbone.js。 它的优点是分层清晰，缺点是数据流混乱，灵活性带来的维护性问题。 MVP模式在是MVC的进化形式，Presenter作为中间层负责MV通信，解决了两者耦合问题，但P层过于臃肿会导致维护问题。 MVVM模式在前端领域有广泛应用，它不仅解决MV耦合问题，还同时解决了维护两者映射关系的大量繁杂代码和DOM操作代码，在提高开发效率、可读性同时还保持了优越的性能表现。 （8）你了解哪些Vue性能优化方法？相对其他的“陷阱面试题”，这个问题就显得友善了很多，只要我们基础功底扎实，回答得井井有条并不是难事。 首先，我们要找到VUE性能的现存问题，大部分都是代码层面的，然后具体的提出代码层优化意见就可以了。 目前我们所知的VUE代码层优化大致为一下11点，村长已经都帮大家整理好了，请大家随意消化一下： ●路由懒加载 ●keep-alive缓存页面●使用v-show复用DOM●v-for 遍历避免同时使用 v-if●长列表性能优化●事件的销毁●图片懒加载●第三方插件按需引入●无状态的组件标记为函数式组件●子组件分割●变量本地化 ●SSR 下面是针对这11个优化点给出的具体优化方案： ●路由懒加载☟ const router = new VueRouter({ routes: [ { path: '/foo', component: () => import('./Foo.vue') } ]}) ●keep-alive缓存页面☟ ●使用v-show复用DOM☟ ●v-for 遍历避免同时使用 v-if☟ ●长列表性能优化： 如果列表是纯粹的数据展示，不会有任何改变，就不需要做响应化☟ 如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容☟ 参考： vue-virtual-scroller☟ https://github.com/Akryum/vue-virtual-scrollervue-virtual-scroll-list☟ https://github.com/tangbc/vue-virtual-scroll-list ●事件的销毁： Vue 组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 created() { this.timer = setInterval(this.refresh, 2000)},beforeDestroy() { clearInterval(this.timer)} ●图片懒加载： 对于图片过多的页面，为了加速页面加载速度。 所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。 参考项目： vue-lazyload☟ https://github.com/hilongjw/vue-lazyload ●第三方插件按需引入： 像element-ui这样的第三方组件库可以按需引入，避免体积太大。 import Vue from 'vue';import { Button, Select } from 'element-ui'; Vue.use(Button) Vue.use(Select) ●无状态的组件标记为函数式组件☟ ●子组件分割 ●变量本地化 ●服务端渲染 - SSR （9）你对Vue3.0的新特性有没有了解？young村长帮大家总结了Vue3.0改进方向，主要在以下几点： ●更快 ○虚拟DOM重写 ○优化slots的生成 ○静态树提升 ○静态属性提升 ○基于Proxy的响应式系统 ●更小： ○通过摇树优化核心库体积 ●更容易维护： ○TypeScript + 模块化 ●更加友好 ○跨平台：编译器核心和运行时核心与平台无关，使得Vue更容易与任何平台（Web、Android、iOS）一起使用 ●更容易使用 ○改进的TypeScript支持，编辑器能提供强有力的类型检查和错误及警告 ●更好的调试支持 ●独立的响应化模块 ●Composition API 虚拟 DOM 重写 期待更多的编译时提示来减少运行时开销，使用更有效的代码来创建虚拟节点。 组件快速路径+单个调用+子节点类型检测 ▷跳过不必要的条件分支 ▷JS引擎更容易优化 详情见下图☟ 优化slots生成 vue3中可以单独重新渲染父级和子级： ▷确保实例正确的跟踪依赖关系 ▷避免不必要的父子组件重新渲染 详情见下图☟ 静态树提升(Static Tree Hoisting) 使用静态树提升，这意味着 Vue 3 的编译器将能够检测到什么是静态的，然后将其提升，从而降低了渲染成本。 ▷跳过修补整棵树，从而降低渲染成本 ▷即使多次出现也能正常工作 详情见下图☟ 静态属性提升 使用静态属性提升，Vue 3打补丁时将跳过这些属性不会改变的节点。☟ 基于 Proxy 的数据响应式 Vue 2的响应式系统使用： Object.defineProperty 的getter 和 setter。 Vue 3 将使用 ES2015 Proxy 作为其观察机制，这将会带来如下变化： ●组件实例初始化的速度提高100％ ●使用Proxy节省以前一半的内存开销，加快速度，但是存在低浏览器版本的不兼容 ●为了继续支持 IE11，Vue 3 将发布一个支持旧观察者机制和新 Proxy 版本的构建 高可维护性 Vue 3 将带来更可维护的源代码。它不仅会使用 TypeScript，而且许多包被解耦，更加模块化。 created() { this.timer = setInterval(this.refresh, 2000)},beforeDestroy() { clearInterval(this.timer)} 更多 Vue、js 等相关面试题，点击下方即可获取，只要1毛钱，即刻get前端必学3大技能！ 作者：不露脸的web侠","link":"/2020/05/30/9%E9%81%93%E4%BB%B7%E5%80%BC20k%E8%96%AA%E8%B5%84%E7%9A%84VUE%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"C#编码规范","text":"1.概述 2.命名规范 2.1.大小写约定 2.1.1.大小写样式 2.1.2.标识符大小写规则 2.1.3.首字母缩写大小写规则 2.1.4.复合词与通用术语大小写规则 2.1.5.大小写敏感 2.2.常规命名约定 2.2.1.单词选择 2.2.2.缩写 2.2.3.特定语言命名 2.3.文件与目录命名 2.4.程序集命名 2.5.名字空间命名 2.5.1.一般规则 2.5.2.名字空间及类型的名字冲突 2.6.类、结构、接口命名 2.6.1.一般规则 2.6.2.范型参数命名 2.6.3.一般类型命名 2.6.4.枚举命名 2.7.类成员命名 2.7.1.方法命名 2.7.2.属性命名 2.7.3.事件命名 2.7.4.字段命名 2.8.参数命名 3.函数编码 3.1.空格、空行与缩进的使用 3.2.一般编码约定 4.异常处理 5.注释规范 5.1.C#标准///注释的使用 5.2.一般注释 5.3.其他注释 6.日志规范 1.概述本文档在《C#程序设计与编码规范》2005年版(Old_Backup/编码规范目录)内的基础上缩编修订而成。更多的.net设计知识，请参阅微软出版的相关指南。 2.命名规范2.1.大小写约定2.1.1.大小写样式 Pascal大小写 将标识符的首字母和后面连接的每个单词的首字母都大写。例如：BlackColor。 Camel大小写 标识符的首字母小写，而每个后面连接的单词的首字母都大写。例如：blackColor。 大写 标识符中的所有字母都大写。仅对于由两个或者更少字母组成的标识符使用该约定。例如：IO。 Private Camel大小写 标识符首字母为下划线”_”，后面单词采用Camel大小写。例如：_blackColor。 2.1.2.标识符大小写规则当标识符由多个单词组成的时候，不要在词间使用诸如”_”（Unix C程序样式 ）和”-“之类的分隔符。而要通过大小写来分隔单词。 下面给出一般标识符的大小写规则： 1.名字空间、类型、属性、方法、事件、只读字段及所有public成员的名称采用Pascal大小写。2.参数、局部变量名称采用Camel大小写。3.私有字段，Private Camel大小写。下表汇总了大写规则，并提供了不同类型的标识符的示例： 标识符 大小写 例子 名字空间 Pascal System.Drawing 类 Pascal AppDomain 接口 Pascal IDisposable 枚举类型 Pascal ErrorLevel 枚举值 Pascal FatalError 方法 Pascal ToString 属性 Pascal BackColor 事件 Pascal ValueChanged 只读静态字段 Pascal RedValue 参数 Camel typeName 局部变量 Camel targetCount 私有字段 Private Camel _brushColor 2.1.3.首字母缩写大小写规则首字母缩写(Acronyms)是由短语内各单词的字母构成。例如：HTML是Hypertext Markup Lanugage的首字母缩写。只有众所周知的首字母缩写才可以包含在标识符里。首字母缩写(Acronyms)与缩写词(Abbreviation)不同，缩写词（Abbreviation）仅简化一个单词。例如：ID是identifier的缩写词。一般情况下，不要使用缩写词。 特例：ID及OK两个缩写词可被用于标识符。但是应该依据使用环境，遵循Pascal或Camel大小写。 首字母缩写的大小写依赖于它的长度。所有的首字母缩写至少两个字母长。如果正好是两个字母长，被称作短首字母缩写（short acronyms）。三个或三个以上长度的首字母缩写，被称作长首字母缩写（long acronyms）。 下面给出长短首字母缩写的规则，标识符的大小写优先级更高。 4.短首字母缩写的两个字母均应大写，除非是Camel大小写标识符的第一个词。例如：属性名称DBRate中首字母缩写DB，是Pascal大小写标识符首单词。 例如：参数名称ioChannel中首字母缩写io，是Camel大小写标识符首单词。 5.长首字母缩的第一个字母大写，除非是Camel大小写的标识符的第一个词。例如：类名称XmlWriter中的首字母缩写Xml，是Pascal小写标识符首单词。 例如：参数名称htmlWriter中的首字母缩写html，是Camel大小写标识符首单词。 2.1.4.复合词与通用术语大小写规则6.不要将所谓封闭形式的复合词内的单词大写。他们是被作为单独的词的复合词，比如”endpoint”。确定一个词是否为封闭形式的复合词，查最新字典即可。例如：hashtable是一个封闭形式的，从而应当作为单独的词来对待及处理大小写。采用Pascal大小写，它是Hashtable；采用Camel大小写，它是hashtable。 下面一些通用术语不是封闭形式的复合词，采用Pacal及Camel两种方式展现。 BitFlag (bitFlag) FileName (fileName) LogOff (logOff) LogOn (logOn) SignIn (signIn) SignOut (signOut) UserName (userName) WhiteSpace (whiteSpace) 2.1.5.大小写敏感7.有些语言大小写不敏感，因此不要仅通过大小写来区分不同的标识符。8.Url使用aspx文件名的地方，与aspx文件名大小写一致。2.2.常规命名约定此部分是用于所有标识符命名，后面的章节将讨论特殊的元素，如名字空间及属性。 2.2.1.单词选择9.标识符命名均采用英文，注意拼写正确。10.选择可读的标识符名称。比如：属性名称HorizontalAlignment比AlignmentHorizontal在英语中更可读。 11.可读性比缩写简单性更重要。比如：属性名称CanScrollHorizontally比ScrollableX更好。 12.请不要使用任何下划线”_”、连字符”-“等非字母字符。私有字段首字符除外(Private Camel样式)。13.避免使用与C#、VB、C++语言关键字冲突的标识符名称。2.2.2.缩写一般情况下不应该使用缩写，这样会使程序不容易读，另外也很难确定缩写是否广为人知。 14.不要将缩写作为标识符中间的部分。例如：使用OnButtonClick而不是OnBtnClick 15.在必要的时候，为提高程序的简洁及可读性，使用广为人知的缩写。2.2.3.特定语言命名16.用语意命名标识符，而不要用C#关键字。例如：使用GetLength而不是GetInt 17.当标识符没有特定语意的时候，采用CLR类型名，而不要用C#关键字。例如：将数据转换成Int16类型的函数，应该被命名为ToInt16，而不是ToShort，因为short仅仅是Int16在C#语言中的对应类型名。 18.当标识符即没有特定语意，其类型也并不重要的时候，应采用一般的名称，诸如value或item。2.3.文件与目录命名19.每个类型（包括类、结构、接口、枚举）存放在一个文件，文件名与类型名称一致。自动生成程序除外。20.特殊的名字空间，放在单独的目录里，目录名字与名字空间相一致。2.4.程序集命名21.为程序集命名，以提示其主要功能，程序集的名称最好和名字空间名称相一致。采用如下方式命名： WanFangData.&lt;Component&gt;.dll 其中Component包含一个或多个点分隔的字句。 例如：WanFangData.WebContorls.dll 2.5.名字空间命名2.5.1.一般规则名字空间的名称，应能提示在此名字空间内的所有类型的主要功能。比如System.Socket名字空间所包含的类型，能够让程序员通过Socket方式进行网路通讯编程。 一般的命名规则是： WanFangData.(&lt;ProductName&gt;|&lt;Technology&gt;)[.&lt;Feature&gt;][.&lt;Subnamespace&gt;] 例如：Micorsoft.WindowsMobile.DirectX 22.名字空间的名字应该有很长的生命期，因此不要在里面加版本号、机构名称等易变的名称。23.采用Pascal大小写。24.在适当的时候使用复数名称，缩写除外。例如：应写System.Collections而不是System.Collection。 例如：应写System.IO而不是System.IOs。（缩写） 25.不要让名字空间及类具有相同的名称。例如：不要在一个名为Debug的名字空间中同时提供一个名为Debug的类。 2.5.2.名字空间及类型的名字冲突应尽量避免与已经存在的类库有名字冲突，否则用户将不得不改变程序，并使用限定名称。下面的讨论将与四类名字空间有关： 应用模型名字空间 诸如System.Windows.Forms，System.Web等与应用密切相关的名字空间。不同的应用很少同时在一个程序内使用，因此不容易出现冲突。 基础名字空间 基础应用提供提供特殊支持，并很少在代码中引用。比如：*.Designer，*.Permissions名字空间。很难出现冲突。 核心名字空间 核心名字空间是System.*名字空间。开发人员应该尽力，不产生名字冲突。（可以查Document，以识别此名称是否已经存在） 技术名字空间 技术名字空间一般为Company.Technology.*，应避免与其冲突。 26.不要引入一般类型名称，应该使用限定的一般类型名称。例如：Element，Node，Log及Message等。这样很容易产生冲突。 限定后：FormElement，XmlNode，EventLog，SoapMessage。 27.不要引入与程序模型名字空间冲突的类型名。例如：为Windows Form应用的用户写的控件库，请不要将类型命名为CheckBox，因为此名称已经存在于Windows Form应用中。 28.不要与核心名字空间名字冲突。例如：不要使用Dictionary类型名称，因为它在核心名字空间里存在。 29.不要在统一的技术名字空间内，使用相同的类名。2.6.类、结构、接口命名2.6.1.一般规则30.类型使用名词、名词短语或形容词短语，名称应反映使用场景。31.类名称不要加前缀（比如C、T）。（注：Delphi等语言的约定）32.考虑子类采用基类名称作为后缀。例如：从Stream继承的类，采用Stream作为后缀。 例如：从Exception继承的类，采用Exception作为后缀。 33.接口前面都加字母“I”前缀34.当定义接口/类对时，接口的默认实现类名称与接口名称只有前缀I有差别。例如：IAsynResult的默认实现名称为AsynResult。 2.6.2.范型参数命名35.范型参数应使用有描述性名称，除非单个字母足够且描述性名称并不增加什么价值。例如：IDictionary&lt;TKey,TValue&gt;。 36.需要使用单字母命名类型参数的时候，使用字母“T”。37.类型参数前缀加字母“T”。例如：TKey。 38.考虑在范型参数名称中加入类型约束。例如：参数限制为ISession的，应被命名为TSession。 2.6.3.一般类型命名下面规则，通过前后缀，帮助开发人员识别类的特定使用情景。 39.自定义属性，需要加后缀Attribute。例如：ObsoleteAttribute。 40.在事件（event）中使用的类型，需要加后缀EventHandler。例如：AssemblyLoadEventHandler 41.不用于事件的委托(delegate)类型，需要加后缀Callback。42.继承System.EventArgs的类，需要加后缀EventArgs。43.继承System.Exception的类，需要加后缀Exception。44.实现System.Collecions.IDictionary接口的类，需要加后缀Dictionary。45.实现System.Collections.(ICollection|IList|IEnumerable)接口的类，需要加后缀Collection。46.继承System.IO.Stream的类，需要加后缀Stream。47.继承System.Security.CodeAccessPermission的类，需要加后缀Permission。2.6.4.枚举命名48.不要在枚举值前加前缀。例如：不要写成如下形式 123456public enum Teams{ TeamsAlpha, TeamsBeta, TeamsDelta} 应该写为： 123456public enum Teams{ Alpha, Beta, Delta} 49.不要在枚举类型加后缀Enum。50.不要在Flags枚举类型加后缀Flags。51.用单数词作为枚举名称，除非它是Flags枚举类型。52.用复数词作为Flags枚举类型。2.7.类成员命名2.7.1.方法命名53.方法名称应为动词或动词短语。应从使用者的角度命名，选择描述函数做什么的动词，而不是怎么做的动词。 2.7.2.属性命名54.属性采用名词、名词短语或形容词命名。55.不要让属性名称与Get方法的名称相匹配。例如：属性名为EmployeeRecord，同时有个方法名为GetEmployeeRecord。使用者将无从选择。 56.布尔类型属性，采用肯定语气命名。使用Is,Can或Has作前缀，如果他们能增加清晰性。例如：使用CanSeek而不是CantSeek。 57.考虑属性使用与其类型相同的名称。例如：属性类型为CacheLevel，其名称也为CacheLevel。 2.7.3.事件命名58.事件采用动词或动词短语命名。59.让事件名称拥有前后的事件概念，采用现在进行时或过去时。例如：在窗口关闭之前的事件，被称为Closing。 例如：在窗口关闭之后的事件，被称为Closed。 60.不要在事件名称中使用Before、After前缀或后缀，来标示前后事件。61.使用两个参数Sender，e作为事件处理参数。Sender类型为object，e类型为EventArs或其继承类型。62.EventHandler，EventArgs相关命名见一般类型命名。2.7.4.字段命名63.采用名词或名词短语命名。2.8.参数命名64.使用描述性的名称。在大多数情形下，参数类型及其名称，应能确定参数的用途。65.命名应该基于参数的含义而不是类型。3.函数编码为了增强程序清晰新、可读性，应遵循以下规定。 3.1.空格、空行与缩进的使用66.函数参数在”,”后需要空格。例如：Function(param1, param2, param3); 67.各种双目操作符，比如“=”、“&lt;“等，前后需要有空格。68.if, while等关键字后面需要有空格。69.每次使用嵌套，嵌套体的所有内容必须缩进，使用Tab作为缩进符号。70.每个函数之间空两行。71.适当的增加空行，以区分方法内的大块逻辑。有时候在同一个方法中有明显的程序功能归组情况，而又不需要划分到单独的方法，此时应当用空行加以区分，并加注释。 3.2.一般编码约定72.代码行数不应超过80行。（不超出两屏长度）行数过多的代码不易于阅读，这也说明了模块化分可能存在问题。应该考虑将一个大的方法体拆分为更小的方法，以增加代码的清晰性。 73.一个代码行长度不应超过80个字符。（不超出一屏宽度）过长的代码行不易于阅读，当一行的确需要写很长时，应当折行书写。 74. 一般情况下不可以使用goto语句，除非goto能够加强程序的清晰性。有时需要一次跳出多层循环，使用goto更为清晰。 75.诸如for、if、foreach、while等嵌套层数不要超过3层，try-catch除外。主体逻辑代码嵌套过深，不易于阅读及理解。这也说明了逻辑或模块化分可能存在问题。应考虑修改逻辑，或将嵌套内的程序划分到一个更小的方法中。以增加清晰性。 76.变量在离其最近使用的地方声明。不要采用C或Pascal等语言在函数开头声明参数的方式。应该在使用时声明。 77.同一个类型的不同方法中不要出现重复代码。同一个类型的不同方法中出现大块的重复性代码，说明模块划分出现了问题，应当将重复性的代码划分到一个更小的方法中。以增加清晰性。 4.异常处理78.在框架代码中，不要通过捕获非特定异常的方式（如：Exception、SystemException），淹没（swallow）错误。你可以捕获上述的异常，如果捕获的目的是重新抛出异常，或将异常交给其他线程处理。下面展示了一个错误处理的例子： 123456789101112131415161718public class BadExceptionHandlingExample1{ public void DoWork() { // 做一些可能抛出异常的工作 } public void MethodWithBadHandler() { try { DoWork(); } catch (Exception e) { // 淹没了异常并继续执行 } }} 79.在应用代码中，避免通过捕获非特定异常的方式（如：Exception、SystemException），淹没（swallow）错误。有些情况下在应用中淹没错误是可以接受的，但是这种情况很少见。应用程序不应淹没可能造成意外状态的异常，如果你不能确认所有异常造成的可能结果，你应当让程序终止而不是淹没异常。 80.捕获特定的异常，如果你理解为什么它会从给定的上下文中抛出。你应该只捕获那些你可以恢复的异常。例如：打开不存在文件造成的FileNotFoundException可以被应用程序处理，因为它可以将问题告知用户，并让用户设置其他文件名。而打开文件请求抛出的ExcutionEngineException不应当被处理，因为低层发生的问题无法被知晓，并且应用程序也不能确认继续运行是否安全。 81.不要过度使用catch。异常应当尽可能向调用堆栈上层传递。捕获无法正确处理的异常，会隐藏重要的调试信息。 82.将清理代码放在finally块中，而不是catch块中。对于书写优良的代码，try-finally比try-catch更为常见。catch的目的是为了让你处理异常（例如，记录非致命错误）。finally的目的是为了让你执行清理代码而不管异常是否抛出。如果你分配了有限的资源，比如数据库联接或stream，你应当将释放它们的代码放在finally块中。 83.当捕获并重新抛出异常时，使用空的throw。这是保存调用堆栈的最好的方法。例如： 1234567891011121314151617public void MethodWithBadCatch(Object anObject){ try { // 引起异常的方法 DoWork(anObject); } catch (ArgumentNullException e) { System.Diagnostics.Debug.Write(e.Message); // 这样是错误的 // 会造成跟踪堆栈指向此处为错误地址，而非指向DoWork。 throw e; // 应该直接写成 // throw; }} 5.注释规范5.1.C#标准///注释的使用84.每个类必须注释，采用C#标准///注释，并在Summary中写明此类的主要功能，根据需要在Remark中进行详细描述，如关键设计思路。85.每个属性必须注释，采用C#标准///注释，并在Summary中写明此属性的含义。86.每个方法必须注释，采用C#标准///注释，并在Summary中写明此函数主要功能。根据需要在Remark中进行详细描述。5.2.一般注释87.当代码无法通过直接阅读而清晰获理解它的功能的时候，需要加注释。例如： 1if (password == “12345”) // 这是超级密码，通过后拥有管理员权限 88.当一段代码有单一目的，而没有分隔为一个函数的时候，用注释标明分段功能。例如： 1234567// 添加用户Line1;Line2;// 添加用户组Line1;Line2; 89.当一个嵌套很长，或者有多个嵌套时，需要在结尾加上注释。例如： 1234if （a &gt; b）{ ......} // end if (a &gt; b) 5.3.其他注释90.在准备添加代码的地方加入//TODO 注释。91.类似功能的一组函数，需要用#region来包围起来，并做说明。例如：一组函数都是和用户帐务操作有关的。 1234#region 用户帐务操作相关函数Function1;......#endregion 6.日志规范92.对于包含方法成员的类，尽可能使用log4net，以方便程序调试。Log成员定义写在类代码的第一行，内容如下：1private static readonly log4net.ILog log = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType); 93.需要加条件判断是否需要记录log，以增加程序性能，除非log直接输出简单字符串。例如： 1log.Debug(“简单字符串”); // 不需要判断 例如： 12if (log.IsDebugEnabled) // 有字符串等操作，需要判断 log.Debug(&quot;成功添加用户:&quot; + user.UserID); 94.日志级别： Fatal级：程序重大错误，以致无法启动或继续运行。 Error级：程序本身出错，或加载资源错误。注意此错误不是用户造成的错误，比如输入密码错。 Warning级：用户的一些错误可以记录到此级别，比如用户名密码输入错误。 Info级：程序运行时，会将log开到这个级别。此级别记录让用户看到的日志信息。比如程序启动，重要配置文件加载，访问某个页面等较大的事件。 Debug级：琐碎的方法调用过程记录。诸如方法进入、返回，方法内的重要事件。 95.重要函数（比如Page_Load）记录用时，可使用StopWatch。96.公共（public）方法或属性内的日志，需要记录方法或属性名。例如：log.Debug(“MethodName 开始准备数据表格”); 97.公共(public)方法，在方法代码第一行记录日志，标明此方法被调用并记下传入参数。（即进入时记录。）例如： 123456public void AddUser( string userName, string password){ if (log.IsDebugEnabled) log.Debug(“AddUser调用 username:” + userName + “, password:” + password); ......} 98.公共(public)方法返回前，记录日志，标明此方法结束并记下返回结果。如果返回内容过于复杂，比如为DataSet，可以简单记录其特征（记录数）。如果没有返回结果，比如void方法，直接标明返回即可。（即返回时记录。）例如： 1log.Debug(“AddUser 成功返回”); 99.在捕获异常时，需要记录日志，以及异常内容。（即截获异常时记录。）例如： 12catch(Exception ex) log.Debug(“AddUser出错”, ex); 100.在方法内有重要逻辑过程需要记录时，记录日志。（即重要逻辑记录。）101.在对外提供接口，而接口实现组件可由第三方开发时。需要在接口调用前后记录日志。（即三方组件调用时记录。）此条规则可以帮助我们迅速定位第三方错误，而不会因为两方都未正确记录日志而纠缠不清。 102.最外层代码（如Page_Load）要在最外层写try,catch(Excpetion)的代码，并记录异常。如果不知道如何处理，直接throw。","link":"/2019/11/22/C-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"title":"CSS编码规范","text":"1 前言 2 代码风格 2.1 文件 2.2 缩进 2.3 空格 2.4 行长度 2.5 选择器 2.6 属性 3 通用 3.1 选择器 3.2 属性缩写 3.3 属性书写顺序 3.4 清除浮动 3.5 !important 3.6 z-index 4 值与单位 4.1 文本 4.2 数值 4.3 url() 4.4 长度 4.5 颜色 4.6 2D 位置 5 文本编排 5.1 字体族 5.2 字号 5.3 字体风格 5.4 字重 5.5 行高 6 变换与动画 7 响应式 8 兼容性 8.1 属性前缀 8.2 Hack 8.3 Expression 1 前言CSS作为网页样式的描述语言，在百度一直有着广泛的应用。本文档的目标是使CSS代码风格保持一致，容易被理解和被维护。 虽然本文档是针对CSS设计的，但是在使用各种CSS的预编译器(如less、sass、stylus等)时，适用的部分也应尽量遵循本文档的约定。 2 代码风格2.1 文件[建议] CSS 文件使用无 BOM 的 UTF-8 编码。解释： UTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。 2.2 缩进[强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符。示例： 1234.selector { margin: 0; padding: 0;} 2.3 空格[强制] 选择器 与 { 之间必须包含空格。示例： 12.selector {} [强制] 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。示例： 1margin: 0; [强制] 列表型属性值 书写在单行时，, 后必须跟一个空格。示例： 1font-family: Arial, sans-serif; 2.4 行长度[强制] 每行不得超过 120 个字符，除非单行不可分割。解释： 常见不可分割的场景为URL超长。 [建议] 对于超长的样式，在样式值的 空格 处或 , 后换行，建议按逻辑分组。示例： 123456789101112131415161718/* 不同属性值按逻辑分组 */background: transparent url(aVeryVeryVeryLongUrlIsPlacedHere) no-repeat 0 0;/* 可重复多次的属性，每次重复一行 */background-image: url(aVeryVeryVeryLongUrlIsPlacedHere) url(anotherVeryVeryVeryLongUrlIsPlacedHere);/* 类似函数的属性值可以根据函数调用的缩进进行 */background-image: -webkit-gradient( linear, left bottom, left top, color-stop(0.04, rgb(88,94,124)), color-stop(0.52, rgb(115,123,162))); 2.5 选择器[强制] 当一个 rule 包含多个 selector 时，每个选择器声明必须独占一行。示例： 1234567891011/* good */.post,.page,.comment { line-height: 1.5;}/* bad */.post, .page, .comment { line-height: 1.5;} [强制] &gt;、+、~ 选择器的两边各保留一个空格。示例： 12345678910111213141516171819202122232425/* good */main &gt; nav { padding: 10px;}label + input { margin-left: 5px;}input:checked ~ button { background-color: #69C;}/* bad */main&gt;nav { padding: 10px;}label+input { margin-left: 5px;}input:checked~button { background-color: #69C;} [强制] 属性选择器中的值必须用双引号包围。解释： 不允许使用单引号，不允许不使用引号。 示例： 123456789/* good */article[character=&quot;juliet&quot;] { voice-family: &quot;Vivien Leigh&quot;, victoria, female}/* bad */article[character='juliet'] { voice-family: &quot;Vivien Leigh&quot;, victoria, female} 2.6 属性[强制] 属性定义必须另起一行。示例： 12345678/* good */.selector { margin: 0; padding: 0;}/* bad */.selector { margin: 0; padding: 0; } [强制] 属性定义后必须以分号结尾。示例： 123456789/* good */.selector { margin: 0;}/* bad */.selector { margin: 0} 3 通用3.1 选择器[强制] 如无必要，不得为 id、class 选择器添加类型选择器进行限定。解释： 在性能和维护性上，都有一定的影响。 示例： 1234567891011/* good */#error,.danger-message { font-color: #c00;}/* bad */dialog#error,p.danger-message { font-color: #c00;} [建议] 选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。示例： 1234567/* good */#username input {}.comment .avatar {}/* bad */.page .header .login #username input {}.comment div * {} 3.2 属性缩写[建议] 在可以使用缩写的情况下，尽量使用属性缩写。示例： 1234567891011/* good */.post { font: 12px/1.5 arial, sans-serif;}/* bad */.post { font-family: arial, sans-serif; font-size: 12px; line-height: 1.5;} [建议] 使用 border / margin / padding 等缩写时，应注意隐含值对实际数值的影响，确实需要设置多个方向的值时才使用缩写。解释： border / margin / padding 等缩写会同时设置多个属性的值，容易覆盖不需要覆盖的设定。如某些方向需要继承其他声明的值，则应该分开设置。 示例： 123456789101112131415161718192021222324/* centering &lt;article class=&quot;page&quot;&gt; horizontally and highlight featured ones */article { margin: 5px; border: 1px solid #999;}/* good */.page { margin-right: auto; margin-left: auto;}.featured { border-color: #69c;}/* bad */.page { margin: 5px auto; /* introducing redundancy */}.featured { border: 1px solid #69c; /* introducing redundancy */} 3.3 属性书写顺序[建议] 同一 rule set 下的属性在书写时，应按功能进行分组，并以 Formatting Model（布局方式、位置） &gt; Box Model（尺寸） &gt; Typographic（文本相关） &gt; Visual（视觉效果） 的顺序书写，以提高代码的可读性。解释： Formatting Model 相关属性包括：position / top / right / bottom / left / float / display / overflow 等 Box Model 相关属性包括：border / margin / padding / width / height 等 Typographic 相关属性包括：font / line-height / text-align / word-wrap 等 Visual 相关属性包括：background / color / transition / list-style 等 另外，如果包含 content 属性，应放在最前面。 示例： 1234567891011121314151617181920212223.sidebar { /* formatting model: positioning schemes / offsets / z-indexes / display / ... */ position: absolute; top: 50px; left: 0; overflow-x: hidden; /* box model: sizes / margins / paddings / borders / ... */ width: 200px; padding: 5px; border: 1px solid #ddd; /* typographic: font / aligns / text styles / ... */ font-size: 14px; line-height: 20px; /* visual: colors / shadows / gradients / ... */ background: #f5f5f5; color: #333; -webkit-transition: color 1s; -moz-transition: color 1s; transition: color 1s;} 3.4 清除浮动[建议] 当元素需要撑起高度以包含内部的浮动元素时，通过对伪类设置 clear 或触发 BFC 的方式进行 clearfix。尽量不使用增加空标签的方式。解释： 触发 BFC 的方式很多，常见的有： float 非 none position 非 static overflow 非 visible 如希望使用更小副作用的清除浮动方法，参见 A new micro clearfix hack 一文。 另需注意，对已经触发 BFC 的元素不需要再进行 clearfix。 3.5 !important[建议] 尽量不使用 !important 声明。[建议] 当需要强制指定样式且不允许任何场景覆盖时，通过标签内联和 !important 定义样式。解释： 必须注意的是，仅在设计上 确实不允许任何其它场景覆盖样式 时，才使用内联的 !important 样式。通常在第三方环境的应用中使用这种方案。下面的 z-index 章节是其中一个特殊场景的典型样例。 3.6 z-index[建议] 将 z-index 进行分层，对文档流外绝对定位元素的视觉层级关系进行管理。解释： 同层的多个元素，如多个由用户输入触发的 Dialog，在该层级内使用相同的 z-index 或递增 z-index。 建议每层包含100个 z-index 来容纳足够的元素，如果每层元素较多，可以调整这个数值。 [建议] 在可控环境下，期望显示在最上层的元素，z-index 指定为 999999。解释： 可控环境分成两种，一种是自身产品线环境；还有一种是可能会被其他产品线引用，但是不会被外部第三方的产品引用。 不建议取值为 2147483647。以便于自身产品线被其他产品线引用时，当遇到层级覆盖冲突的情况，留出向上调整的空间。 [建议] 在第三方环境下，期望显示在最上层的元素，通过标签内联和 !important，将 z-index 指定为 2147483647。解释： 第三方环境对于开发者来说完全不可控。在第三方环境下的元素，为了保证元素不被其页面其他样式定义覆盖，需要采用此做法。 4 值与单位4.1 文本[强制] 文本内容必须用双引号包围。解释： 文本类型的内容可能在选择器、属性值等内容中。 示例： 123456789101112131415161718192021/* good */html[lang|=&quot;zh&quot;] q:before { font-family: &quot;Microsoft YaHei&quot;, sans-serif; content: &quot;“&quot;;}html[lang|=&quot;zh&quot;] q:after { font-family: &quot;Microsoft YaHei&quot;, sans-serif; content: &quot;”&quot;;}/* bad */html[lang|=zh] q:before { font-family: 'Microsoft YaHei', sans-serif; content: '“';}html[lang|=zh] q:after { font-family: &quot;Microsoft YaHei&quot;, sans-serif; content: &quot;”&quot;;} 4.2 数值[强制] 当数值为 0 - 1 之间的小数时，省略整数部分的 0。示例： 123456789/* good */panel { opacity: .8}/* bad */panel { opacity: 0.8} 4.3 url()[强制] url() 函数中的路径不加引号。示例： 123body { background: url(bg.png);} [建议] url() 函数中的绝对路径可省去协议名。示例： 123body { background: url(//baidu.com/img/bg.png) no-repeat 0 0;} 4.4 长度[强制] 长度为 0 时须省略单位。 (也只有长度单位可省)示例： 123456789/* good */body { padding: 0 5px;}/* bad */body { padding: 0px 5px;} 4.5 颜色[强制] RGB颜色值必须使用十六进制记号形式 #rrggbb。不允许使用 rgb()。解释： 带有alpha的颜色信息可以使用 rgba()。使用 rgba() 时每个逗号后必须保留一个空格。 示例： 1234567891011/* good */.success { box-shadow: 0 0 2px rgba(0, 128, 0, .3); border-color: #008000;}/* bad */.success { box-shadow: 0 0 2px rgba(0,128,0,.3); border-color: rgb(0, 128, 0);} [强制] 颜色值可以缩写时，必须使用缩写形式。示例： 123456789/* good */.success { background-color: #aca;}/* bad */.success { background-color: #aaccaa;} [强制] 颜色值不允许使用命名色值。示例： 123456789/* good */.success { color: #90ee90;}/* bad */.success { color: lightgreen;} [建议] 颜色值中的英文字符采用小写。如不用小写也需要保证同一项目内保持大小写一致。示例： 1234567891011121314151617/* good */.success { background-color: #aca; color: #90ee90;}/* good */.success { background-color: #ACA; color: #90EE90;}/* bad */.success { background-color: #ACA; color: #90ee90;} 4.6 2D 位置[强制] 必须同时给出水平和垂直方向的位置。解释： 2D 位置初始值为 0% 0%，但在只有一个方向的值时，另一个方向的值会被解析为 center。为避免理解上的困扰，应同时给出两个方向的值。background-position属性值的定义 示例： 123456789/* good */body { background-position: center top; /* 50% 0% */}/* bad */body { background-position: top; /* 50% 0% */} 5 文本编排5.1 字体族[强制] font-family 属性中的字体族名称应使用字体的英文 Family Name，其中如有空格，须放置在引号中。解释： 所谓英文 Family Name，为字体文件的一个元数据，常见名称如下： 字体 操作系统 Family Name 宋体 (中易宋体) Windows SimSun 黑体 (中易黑体) Windows SimHei 微软雅黑 Windows Microsoft YaHei 微软正黑 Windows Microsoft JhengHei 华文黑体 Mac/iOS STHeiti 冬青黑体 Mac/iOS Hiragino Sans GB 文泉驿正黑 Linux WenQuanYi Zen Hei 文泉驿微米黑 Linux WenQuanYi Micro Hei 示例： 123h1 { font-family: &quot;Microsoft YaHei&quot;;} [强制] font-family 按「西文字体在前、中文字体在后」、「效果佳 (质量高/更能满足需求) 的字体在前、效果一般的字体在后」的顺序编写，最后必须指定一个通用字体族( serif / sans-serif )。解释： 更详细说明可参考本文。 示例： 123456789/* Display according to platform */.article { font-family: Arial, sans-serif;}/* Specific for most platforms */h1 { font-family: &quot;Helvetica Neue&quot;, Arial, &quot;Hiragino Sans GB&quot;, &quot;WenQuanYi Micro Hei&quot;, &quot;Microsoft YaHei&quot;, sans-serif;} [强制] font-family 不区分大小写，但在同一个项目中，同样的 Family Name 大小写必须统一。示例： 1234567891011121314151617/* good */body { font-family: Arial, sans-serif;}h1 { font-family: Arial, &quot;Microsoft YaHei&quot;, sans-serif;}/* bad */body { font-family: arial, sans-serif;}h1 { font-family: Arial, &quot;Microsoft YaHei&quot;, sans-serif;} 5.2 字号[强制] 需要在 Windows 平台显示的中文内容，其字号应不小于 12px。解释： 由于 Windows 的字体渲染机制，小于 12px 的文字显示效果极差、难以辨认。 5.3 字体风格[建议] 需要在 Windows 平台显示的中文内容，不要使用除 normal 外的 font-style。其他平台也应慎用。解释： 由于中文字体没有 italic 风格的实现，所有浏览器下都会 fallback 到 obilique 实现 (自动拟合为斜体)，小字号下 (特别是 Windows 下会在小字号下使用点阵字体的情况下) 显示效果差，造成阅读困难。 5.4 字重[强制] font-weight 属性必须使用数值方式描述。解释： CSS 的字重分 100 – 900 共九档，但目前受字体本身质量和浏览器的限制，实际上支持 400 和 700 两档，分别等价于关键词 normal 和 bold。 浏览器本身使用一系列启发式规则来进行匹配，在 &lt;700 时一般匹配字体的 Regular 字重，&gt;=700 时匹配 Bold 字重。 但已有浏览器开始支持 =600 时匹配 Semibold 字重 (见此表)，故使用数值描述增加了灵活性，也更简短。 示例： 123456789/* good */h1 { font-weight: 700;}/* bad */h1 { font-weight: bold;} 5.5 行高[建议] line-height 在定义文本段落时，应使用数值。解释： 将 line-height 设置为数值，浏览器会基于当前元素设置的 font-size 进行再次计算。在不同字号的文本段落组合中，能达到较为舒适的行间间隔效果，避免在每个设置了 font-size 都需要设置 line-height。 当 line-height 用于控制垂直居中时，还是应该设置成与容器高度一致。 示例： 123.container { line-height: 1.5;} 6 变换与动画[强制] 使用 transition 时应指定 transition-property。示例： 123456789/* good */.box { transition: color 1s, border-color 1s;}/* bad */.box { transition: all 1s;} [建议] 尽可能在浏览器能高效实现的属性上添加过渡和动画。解释： 见本文，在可能的情况下应选择这样四种变换： transform: translate(npx, npx); transform: scale(n); transform: rotate(ndeg); opacity: 0..1; 典型的，可以使用 translate 来代替 left 作为动画属性。 示例： 12345678910111213141516/* good */.box { transition: transform 1s;}.box:hover { transform: translate(20px); /* move right for 20px */}/* bad */.box { left: 0; transition: left 1s;}.box:hover { left: 20px; /* move right for 20px */} 7 响应式[强制] Media Query 不得单独编排，必须与相关的规则一起定义。示例： 123456789101112131415161718192021222324252627/* Good *//* header styles */@media (...) { /* header styles */}/* main styles */@media (...) { /* main styles */}/* footer styles */@media (...) { /* footer styles */}/* Bad *//* header styles *//* main styles *//* footer styles */@media (...) { /* header styles */ /* main styles */ /* footer styles */} [强制] Media Query 如果有多个逗号分隔的条件时，应将每个条件放在单独一行中。示例： 1234567@media(-webkit-min-device-pixel-ratio: 2), /* Webkit-based browsers */(min--moz-device-pixel-ratio: 2), /* Older Firefox browsers (prior to Firefox 16) */(min-resolution: 2dppx), /* The standard way */(min-resolution: 192dpi) { /* dppx fallback */ /* Retina-specific stuff here */} [建议] 尽可能给出在高分辨率设备 (Retina) 下效果更佳的样式。8 兼容性8.1 属性前缀[强制] 带私有前缀的属性由长到短排列，按冒号位置对齐。解释： 标准属性放在最后，按冒号对齐方便阅读，也便于在编辑器内进行多行编辑。 示例： 12345.box { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;} 8.2 Hack[建议] 需要添加 hack 时应尽可能考虑是否可以采用其他方式解决。解释： 如果能通过合理的 HTML 结构或使用其他的 CSS 定义达到理想的样式，则不应该使用 hack 手段解决问题。通常 hack 会导致维护成本的增加。 [建议] 尽量使用 选择器 hack 处理兼容性，而非 属性 hack。解释： 尽量使用符合 CSS 语法的 selector hack，可以避免一些第三方库无法识别 hack 语法的问题。 示例： 1234567891011/* IE 7 */*:first-child + html #header { margin-top: 3px; padding: 5px;}/* IE 6 */* html #header { margin-top: 5px; padding: 4px;} [建议] 尽量使用简单的 属性 hack。示例： 12345678910.box { _display: inline; /* fix double margin */ float: left; margin-left: 20px;}.container { overflow: hidden; *zoom: 1; /* triggering hasLayout */} 8.3 Expression[强制] 禁止使用 Expression。","link":"/2019/11/22/CSS%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"title":"GitHub日报：GitHub Explore code on GitHub today, today,2020 Mar 24.","text":"PatilShreyas / Foodium🍲Foodium is a sample food blog Android application 📱 built to demonstrate use of Modern Android development tools - (Kotlin, Coroutines, Flow, Dagger 2, Architecture Components, MVVM, Room, Retrofit, Moshi, Material Components). Kotlin 701 76 Built by 266 stars today Star didi / nightingaleA Distributed and High-Performance Monitoring System Go 648 76 Built by 273 stars today Star grocy / grocyERP beyond your fridge - grocy is a web-based self-hosted groceries &amp; household management solution for your home JavaScript 1,563 108 Built by 196 stars today Star elcronos / COVID-19COVID-19 Detector from x-rays using Computer Vision and Deep Learning JavaScript 223 65 Built by 101 stars today Star datasets / covid-19Novel Coronavirus 2019 time series data on cases Python 187 79 Built by 55 stars today Star ahmadawais / corona-cli🦠 Track the Coronavirus disease (COVID-19) or the Novel Coronavirus Strain in the command line. Both worldwide for all countries, for one country, or for the US States. Fast response time (&lt; 100ms). JavaScript 594 47 Built by 163 stars today Unstar JuliaLang / juliaThe Julia Language: A fresh approach to technical computing. Julia 25,927 3,799 Built by 34 stars today Star home-assistant / core🏡 Open source home automation that puts local control and privacy first Python 32,247 9,824 Built by 45 stars today Star deepset-ai / COVID-QAAPI &amp; Webapp to answer questions about COVID-19. Using NLP (Question Answering) and trusted, curated data sources. Jupyter Notebook 102 33 Built by 32 stars today Star coronasafe / careCare is a single point to link Hospitals, Corona Care Centers and Volunteers to the unified Corona Safe Network so that the Kerala Chief Ministers Office has direct access to live reports of health data v/s our total. healthcare capacity Python 59 50 Built by 13 stars today Unstar kon9chunkit / GitHub-Chinese-Top-Charts🇨🇳 GitHub中文排行榜，帮助你发现高分优秀中文项目、更高效地吸收国人的优秀经验成果；榜单每周更新一次，敬请关注！（武汉加油！中国加油！世界加油！） Python 16,138 2,114 Built by 473 stars today Star alexeygrigorev / data-science-interviewsData science interview questions and answers 1,242 252 Built by 95 stars today Star Jittor / jittorJittor is a high-performance deep learning framework based on JIT compiling and meta-operators. C++ 1,053 73 Built by 163 stars today Star lyswhut / lx-music-desktop一个基于 electron 的音乐软件 JavaScript 4,236 718 Built by 153 stars today Star LingCoder / OnJava8《On Java 8》中文版，又名《Java编程思想》 第5版 6,379 1,798 Built by 71 stars today Star nzw9314 / QuantumultXQuantumultX 507 349 Built by 13 stars today Star peixebabel / COVID-19Dados e plots sobre as informações do Corona Virus levantadas pelo Peixe Babel. Jupyter Notebook 147 16 Built by 22 stars today Star ElderJames / ant-design-blazor🌈An enterprise-class UI components based on Ant Design and Blazor WebAssembly. CSS 435 39 Built by 59 stars today Star ProtofyTeam / OxyGENOxyGEN MATLAB 74 14 Built by 12 stars today Star pomber / covid19JSON time-series of coronavirus cases (confirmed, deaths and recovered) per country - updated daily JavaScript 294 97 Built by 52 stars today Star trojan-gfw / igniterA trojan client for Android (UNDER CONSTRUCTION). Java 1,313 316 Built by 39 stars today Star jobbole / awesome-java-cnJava资源大全中文版，包括开发库、开发工具、网站、博客、微信、微博等，由伯乐在线持续更新。 12,561 4,323 Built by 58 stars today Star huihut / interview📚 C/C++ 技术面试基础知识总结，包括语言、程序库、数据结构、算法、系统、网络、链接装载库等知识及面试经验、招聘、内推等信息。 C++ 9,994 3,154 Built by 103 stars today Star google / automlGoogle Brain AutoML Jupyter Notebook 1,247 228 Built by 246 stars today Star pcm-dpc / COVID-19COVID-19 Italia - Monitoraggio situazione 2,635 994 Built by 73 stars today","link":"/2020/03/24/GitHub%E6%97%A5%E6%8A%A5%EF%BC%9AGitHub-Explore-code-and-developers-on-GitHub-today-today-Mar-24/"},{"title":"Gokit go流行微服务入门","text":"快速开始让我们创建一个最小的 Go 工具包服务。现在，我们将为此使用单个文件。 12main.go 您的业务逻辑您的服务从业务逻辑开始。在 Go 工具包中，我们将服务建模为接口。 12345678910111213141516// StringService provides operations on strings.import &quot;context&quot;type StringService interface { Uppercase(string) (string, error) Count(string) int}``` 该接口将具有实现。 import ( “context” “errors” “strings”) type stringService struct{} func (stringService) Uppercase(s string) (string, error) { if s == “” { return “”, ErrEmpty } return strings.ToUpper(s), nil} func (stringService) Count(s string) int { return len(s)} // ErrEmpty is returned when input string is emptyvar ErrEmpty = errors.New(“Empty string”) 123456## 请求和响应在 Go 工具包中，主要消息传递模式是 RPC。因此，我们接口中的每个方法都将建模为远程过程调用。对于每种方法，我们定义**请求和响应**结构，分别捕获所有输入和输出参数。 type uppercaseRequest struct { S string json:&quot;s&quot;} type uppercaseResponse struct { V string json:&quot;v&quot; Err string json:&quot;err,omitempty&quot; // errors don’t JSON-marshal, so we use a string} type countRequest struct { S string json:&quot;s&quot;} type countResponse struct { V int json:&quot;v&quot;} 123456## 节点Go 工具包通过称为**终结点**的抽象提供其大部分功能。终结点的定义如下（您不必将其放在代码的任意位置，它由 提供。 go-kit type Endpoint func(ctx context.Context, request interface{}) (response interface{}, err error) 12345它表示单个 RPC。也就是说，我们的服务接口中的一种方法。我们将编写简单的适配器，将服务的每个方法转换为终结点。每个适配器采用 StringService，并返回对应于其中一种方法的终结点。 import ( “context” “github.com/go-kit/kit/endpoint”) func makeUppercaseEndpoint(svc StringService) endpoint.Endpoint { return func(_ context.Context, request interface{}) (interface{}, error) { req := request.(uppercaseRequest) v, err := svc.Uppercase(req.S) if err != nil { return uppercaseResponse{v, err.Error()}, nil } return uppercaseResponse{v, “”}, nil }} func makeCountEndpoint(svc StringService) endpoint.Endpoint { return func(_ context.Context, request interface{}) (interface{}, error) { req := request.(countRequest) v := svc.Count(req.S) return countResponse{v}, nil }} 12345678## 传输现在，我们需要将您的服务暴露给外部世界，以便可以调用它。您的组织可能已经对服务应该如何相互对话了。也许你使用节俭，或自定义JSON通过HTTP。Go 套件支持开箱即用的许多**传输**。对于此最小示例服务，让我们在 HTTP 上使用 JSON。Go 套件在包传输/http 中提供了帮助器结构。 import ( “context” “encoding/json” “log” “net/http” httptransport &quot;github.com/go-kit/kit/transport/http&quot; ) func main() { svc := stringService{} uppercaseHandler := httptransport.NewServer( makeUppercaseEndpoint(svc), decodeUppercaseRequest, encodeResponse, ) countHandler := httptransport.NewServer( makeCountEndpoint(svc), decodeCountRequest, encodeResponse, ) http.Handle(&quot;/uppercase&quot;, uppercaseHandler) http.Handle(&quot;/count&quot;, countHandler) log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil)) } func decodeUppercaseRequest(_ context.Context, r *http.Request) (interface{}, error) { var request uppercaseRequest if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil { return nil, err } return request, nil} func decodeCountRequest(_ context.Context, r *http.Request) (interface{}, error) { var request countRequest if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil { return nil, err } return request, nil} func encodeResponse(_ context.Context, w http.ResponseWriter, response interface{}) error { return json.NewEncoder(w).Encode(response)} 1234567## 字符串vc1到目前为止，完整的服务是[stringsvc1。](https://zshipu.com/t?url=https://github.com/go-kit/kit/blob/master/examples/stringsvc1) $ go get github.com/go-kit/kit/examples/stringsvc1$ stringsvc1 12 $ curl -XPOST -d’{“s”:”hello, world”}’ localhost:8080/uppercase{“v”:”HELLO, WORLD”}$ curl -XPOST -d’{“s”:”hello, world”}’ localhost:8080/count{“v”:12} 12345678910111213# 中间件如果没有彻底的日志记录和检测，任何服务都无法被视为生产就绪。## 关切事项的分离将标注图的每一层分离到单个文件中，使 go-kit 项目在增加服务终结点数量时更易于阅读。我们的第一个示例[stringsvc1](https://zshipu.com/t?url=https://github.com/go-kit/kit/blob/master/examples/stringsvc1)在单个主文件中包含所有这些层。在增加更复杂的内容之前，让我们将代码分离到以下文件中，并将所有剩余的代码保留在 main.go 中。将**服务**放入服务.go 文件中，包含以下功能和类型。 type StringServicetype stringServicefunc Uppercasefunc Countvar ErrEmpty 123将**传输**放入具有以下函数和类型的文件中。 transport.go 1234 func makeUppercaseEndpointfunc makeCountEndpointfunc decodeUppercaseRequestfunc decodeCountRequestfunc encodeResponsetype uppercaseRequesttype uppercaseResponsetype countRequesttype countResponse 1234## 传输日志记录任何需要记录的组件都应将记录器视为依赖项，与数据库连接相同。因此，我们在 中构造我们的记录器，并将其传递给需要它的组件。我们从不使用全局范围的记录器。 func main 12345我们可以将记录器直接传递到我们的 stringService 实现中，但有更好的方法。让我们使用**中间件**，也称为装饰器。中间件是获取终结点并返回终结点的函数。 type Middleware func(Endpoint) Endpoint 1234567&gt; 请注意，中间件类型由 go-kit 为您提供。在这两者之间，它可以做任何事情。下面您可以看到如何实现基本日志记录中间件（您无需在任何地方复制/粘贴此代码）： func loggingMiddleware(logger log.Logger) Middleware { return func(next endpoint.Endpoint) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { logger.Log(“msg”, “calling endpoint”) defer logger.Log(“msg”, “called endpoint”) return next(ctx, request) } }} 12345使用[go-kit 日志](https://zshipu.com/t?url=https://gokit.io/faq/#logging-mdash-why-is-package-log-so-different)包并删除标准库[日志](https://zshipu.com/t?url=https://golang.org/pkg/log/)。您需要从文件底部删除。log.Fatal main.go import ( “github.com/go-kit/kit/log”) 12345并将其连接到我们的每个处理程序中。请注意，下一个代码部分_不会_编译，直到您遵循**应用程序日志记录**部分，该部分定义日志记录中间件。 logger := log.NewLogfmtLogger(os.Stderr) svc := stringService{} var uppercase endpoint.Endpointuppercase = makeUppercaseEndpoint(svc)uppercase = loggingMiddleware(log.With(logger, “method”, “uppercase”))(uppercase) var count endpoint.Endpointcount = makeCountEndpoint(svc)count = loggingMiddleware(log.With(logger, “method”, “count”))(count) uppercaseHandler := httptransport.NewServer( uppercase, // …) countHandler := httptransport.NewServer( count, // …) 123456789事实证明，这种技术对于不仅仅是日志记录非常有用。许多 Go 工具包组件都作为端点中间件实现。## 应用程序日志记录但是，如果我们想要登录应用程序域，如传入的参数，该怎么办？事实证明，我们可以为我们的服务定义一个中间件，并获得同样好和可组合的效果。由于我们的 StringService 被定义为接口，因此我们只需要制作一种新类型，以包装现有的 StringService 并执行额外的日志记录职责。 type loggingMiddleware struct { logger log.Logger next StringService} func (mw loggingMiddleware) Uppercase(s string) (output string, err error) { defer func(begin time.Time) { mw.logger.Log( “method”, “uppercase”, “input”, s, “output”, output, “err”, err, “took”, time.Since(begin), ) }(time.Now()) output, err = mw.next.Uppercase(s) return } func (mw loggingMiddleware) Count(s string) (n int) { defer func(begin time.Time) { mw.logger.Log( “method”, “count”, “input”, s, “n”, n, “took”, time.Since(begin), ) }(time.Now()) n = mw.next.Count(s) return } 12345And wire it in. import ( “os” &quot;github.com/go-kit/kit/log&quot; httptransport &quot;github.com/go-kit/kit/transport/http&quot; ) func main() { logger := log.NewLogfmtLogger(os.Stderr) var svc StringService svc = stringService{} svc = loggingMiddleware{logger, svc} // ... uppercaseHandler := httptransport.NewServer( makeUppercaseEndpoint(svc), // ... ) countHandler := httptransport.NewServer( makeCountEndpoint(svc), // ... ) } 1234567891011使用端点中间件解决传输域问题，如电路中断和速率限制。将服务中间件用于业务领域问题，如日志记录和检测。说到仪器...## 应用仪器在 Go 工具包中，检测意味着使用**包指标**记录有关服务运行时行为的统计信息。计算处理的作业数、记录请求完成后的持续时间以及跟踪在飞行中操作的数量都将被视为检测。我们可以使用与用于日志记录相同的中间件模式。 type instrumentingMiddleware struct { requestCount metrics.Counter requestLatency metrics.Histogram countResult metrics.Histogram next StringService} func (mw instrumentingMiddleware) Uppercase(s string) (output string, err error) { defer func(begin time.Time) { lvs := []string{“method”, “uppercase”, “error”, fmt.Sprint(err != nil)} mw.requestCount.With(lvs…).Add(1) mw.requestLatency.With(lvs…).Observe(time.Since(begin).Seconds()) }(time.Now()) output, err = mw.next.Uppercase(s) return } func (mw instrumentingMiddleware) Count(s string) (n int) { defer func(begin time.Time) { lvs := []string{“method”, “count”, “error”, “false”} mw.requestCount.With(lvs…).Add(1) mw.requestLatency.With(lvs…).Observe(time.Since(begin).Seconds()) mw.countResult.Observe(float64(n)) }(time.Now()) n = mw.next.Count(s) return } 12345并连接到我们的服务。 import ( stdprometheus “github.com/prometheus/client_golang/prometheus” kitprometheus “github.com/go-kit/kit/metrics/prometheus” “github.com/go-kit/kit/metrics”) func main() { logger := log.NewLogfmtLogger(os.Stderr) fieldKeys := []string{&quot;method&quot;, &quot;error&quot;} requestCount := kitprometheus.NewCounterFrom(stdprometheus.CounterOpts{ Namespace: &quot;my_group&quot;, Subsystem: &quot;string_service&quot;, Name: &quot;request_count&quot;, Help: &quot;Number of requests received.&quot;, }, fieldKeys) requestLatency := kitprometheus.NewSummaryFrom(stdprometheus.SummaryOpts{ Namespace: &quot;my_group&quot;, Subsystem: &quot;string_service&quot;, Name: &quot;request_latency_microseconds&quot;, Help: &quot;Total duration of requests in microseconds.&quot;, }, fieldKeys) countResult := kitprometheus.NewSummaryFrom(stdprometheus.SummaryOpts{ Namespace: &quot;my_group&quot;, Subsystem: &quot;string_service&quot;, Name: &quot;count_result&quot;, Help: &quot;The result of each count method.&quot;, }, []string{}) // no fields here var svc StringService svc = stringService{} svc = loggingMiddleware{logger, svc} svc = instrumentingMiddleware{requestCount, requestLatency, countResult, svc} uppercaseHandler := httptransport.NewServer( makeUppercaseEndpoint(svc), decodeUppercaseRequest, encodeResponse, ) countHandler := httptransport.NewServer( makeCountEndpoint(svc), decodeCountRequest, encodeResponse, ) http.Handle(&quot;/uppercase&quot;, uppercaseHandler) http.Handle(&quot;/count&quot;, countHandler) http.Handle(&quot;/metrics&quot;, promhttp.Handler()) logger.Log(&quot;msg&quot;, &quot;HTTP&quot;, &quot;addr&quot;, &quot;:8080&quot;) logger.Log(&quot;err&quot;, http.ListenAndServe(&quot;:8080&quot;, nil)) } 1234567## 字符串vc2The complete service so far is [stringsvc2](https://zshipu.com/t?url=https://github.com/go-kit/kit/blob/master/examples/stringsvc2). $ go get github.com/go-kit/kit/examples/stringsvc2$ stringsvc2msg=HTTP addr=:8080 12 $ curl -XPOST -d’{“s”:”hello, world”}’ localhost:8080/uppercase{“v”:”HELLO, WORLD”}$ curl -XPOST -d’{“s”:”hello, world”}’ localhost:8080/count{“v”:12} 12 method=uppercase input=”hello, world” output=”HELLO, WORLD” err=null took=2.455µsmethod=count input=”hello, world” n=12 took=743ns 12345678# Calling other servicesIt’s rare that a service exists in a vacuum. Often, you need to call other services. **This is where Go kit shines**. We provide transport middlewares to solve many of the problems that come up.Let’s say that we want to have our string service call out to a _different_ string service to satisfy the Uppercase method. In effect, proxying the request to another service. Let’s implement the proxying middleware as a ServiceMiddleware, same as a logging or instrumenting middleware. // proxymw implements StringService, forwarding Uppercase requests to the// provided endpoint, and serving all other (i.e. Count) requests via the// next StringService.type proxymw struct { next StringService // Serve most requests via this service… uppercase endpoint.Endpoint // …except Uppercase, which gets served by this endpoint} 123456## 客户端终结点我们有完全相同的终结点，我们已经知道，但我们会使用它调用，而不是服务，一个请求。以这种方式使用时，我们称之为_客户端_终结点。为了调用客户端终结点，我们只需执行一些简单的转换。 func (mw proxymw) Uppercase(s string) (string, error) { response, err := mw.uppercase(uppercaseRequest{S: s}) if err != nil { return “”, err } resp := response.(uppercaseResponse) if resp.Err != “” { return resp.V, errors.New(resp.Err) } return resp.V, nil} 12345现在，为了构造这些代理中间件之一，我们将代理 URL 字符串转换为终结点。如果我们假设 JSON 通过 HTTP，我们可以在传输/http 包中使用帮助程序。 import ( httptransport “github.com/go-kit/kit/transport/http”) func proxyingMiddleware(proxyURL string) ServiceMiddleware { return func(next StringService) StringService { return proxymw{next, makeUppercaseProxy(proxyURL)} }} func makeUppercaseProxy(proxyURL string) endpoint.Endpoint { return httptransport.NewClient( “GET”, mustParseURL(proxyURL), encodeUppercaseRequest, decodeUppercaseResponse, ).Endpoint()} 12345678## 服务发现和负载平衡如果我们只有一个远程服务，这很好。但在现实中，我们可能有许多可用的服务实例。我们希望通过一些服务发现机制来发现它们，并将我们的负载分散到所有这些机制中。如果其中任何一个实例开始表现不佳，我们希望处理这一点，而不会影响我们服务的可靠性。Go 工具包为不同的服务发现系统提供适配器，以获取最新实例集，这些实例作为单个终结点公开。这些适配器称为订阅者。 type Subscriber interface { Endpoints() ([]endpoint.Endpoint, error)} 12345在内部，订阅者使用提供的工厂函数将每个发现的实例字符串（通常是主机：端口）转换为可用的终结点。 type Factory func(instance string) (endpoint.Endpoint, error) 12345到目前为止，我们的工厂功能，使上文代理，只是直接调用URL。但是，将一些安全中间件（如断路器和限速器）放入工厂也很重要。 var e endpoint.Endpointe = makeUppercaseProxy(instance)e = circuitbreaker.Gobreaker(gobreaker.NewCircuitBreaker(gobreaker.Settings{}))(e)e = kitratelimit.NewTokenBucketLimiter(jujuratelimit.NewBucketWithRate(float64(maxQPS), int64(maxQPS)))(e) 12345现在，我们有一组终结点，我们需要选择一个。负载均衡器包装订阅者，并从多个中选择一个终结点。Go 套件提供了几个基本的负载均衡器，如果您想要更高级的启发式方法，则很容易编写您自己的设备。 type Balancer interface { Endpoint() (endpoint.Endpoint, error)} 12345现在，我们有能力根据一些启发式选择端点。我们可以用它来向使用者提供单个、逻辑的、可靠的终结点。重试策略将包装负载均衡器，并返回可用的终结点。重试策略将重试失败的请求，直到达到最大尝试或超时。 func Retry(max int, timeout time.Duration, lb Balancer) endpoint.Endpoint 12345让我们电汇我们最后的代理中间件。为简单起见，我们假设用户将指定多个带有标志的逗号分隔实例终结点。 func proxyingMiddleware(instances string, logger log.Logger) ServiceMiddleware { // If instances is empty, don’t proxy. if instances == “” { logger.Log(“proxy_to”, “none”) return func(next StringService) StringService { return next } } // Set some parameters for our client. var ( qps = 100 // beyond which we will return an error maxAttempts = 3 // per request, before giving up maxTime = 250 * time.Millisecond // wallclock time, before giving up ) // Otherwise, construct an endpoint for each instance in the list, and add // it to a fixed set of endpoints. In a real service, rather than doing this // by hand, you'd probably use package sd's support for your service // discovery system. var ( instanceList = split(instances) subscriber sd.FixedSubscriber ) logger.Log(&quot;proxy_to&quot;, fmt.Sprint(instanceList)) for _, instance := range instanceList { var e endpoint.Endpoint e = makeUppercaseProxy(instance) e = circuitbreaker.Gobreaker(gobreaker.NewCircuitBreaker(gobreaker.Settings{}))(e) e = kitratelimit.NewTokenBucketLimiter(jujuratelimit.NewBucketWithRate(float64(qps), int64(qps)))(e) subscriber = append(subscriber, e) } // Now, build a single, retrying, load-balancing endpoint out of all of // those individual endpoints. balancer := lb.NewRoundRobin(subscriber) retry := lb.Retry(maxAttempts, maxTime, balancer) // And finally, return the ServiceMiddleware, implemented by proxymw. return func(next StringService) StringService { return proxymw{next, retry} } } 1234567## 字符串vc3The complete service so far is [stringsvc3](https://zshipu.com/t?url=https://github.com/go-kit/kit/blob/master/examples/stringsvc3). $ go get github.com/go-kit/kit/examples/stringsvc3$ stringsvc3 -listen=:8001 &amp;listen=:8001 caller=proxying.go:25 proxy_to=nonelisten=:8001 caller=main.go:72 msg=HTTP addr=:8001$ stringsvc3 -listen=:8002 &amp;listen=:8002 caller=proxying.go:25 proxy_to=nonelisten=:8002 caller=main.go:72 msg=HTTP addr=:8002$ stringsvc3 -listen=:8003 &amp;listen=:8003 caller=proxying.go:25 proxy_to=nonelisten=:8003 caller=main.go:72 msg=HTTP addr=:8003$ stringsvc3 -listen=:8080 -proxy=localhost:8001,localhost:8002,localhost:8003listen=:8080 caller=proxying.go:29 proxy_to=”[localhost:8001 localhost:8002 localhost:8003]”listen=:8080 caller=main.go:72 msg=HTTP addr=:8080 12 $ for s in foo bar baz ; do curl -d”{&quot;s&quot;:&quot;$s&quot;}” localhost:8080/uppercase ; done{“v”:”FOO”}{“v”:”BAR”}{“v”:”BAZ”} 12 listen=:8001 caller=logging.go:28 method=uppercase input=foo output=FOO err=null took=5.168µslisten=:8080 caller=logging.go:28 method=uppercase input=foo output=FOO err=null took=4.39012mslisten=:8002 caller=logging.go:28 method=uppercase input=bar output=BAR err=null took=5.445µslisten=:8080 caller=logging.go:28 method=uppercase input=bar output=BAR err=null took=2.04831mslisten=:8003 caller=logging.go:28 method=uppercase input=baz output=BAZ err=null took=3.285µslisten=:8080 caller=logging.go:28 method=uppercase input=baz output=BAZ err=null took=1.388155ms 12345678910# 高级主题## 线程上下文上下文对象用于在单个请求的范围内跨概念边界传递信息。在我们的示例中，我们还没有通过业务逻辑来线程化上下文。但这几乎总是一个好主意。它允许您在业务逻辑和中间件之间传递请求范围的信息，对于更复杂的任务（如粒度分布式跟踪注释）是必需的。具体来说，这意味着您的业务逻辑接口将看起来像 type MyService interface { Foo(context.Context, string, int) (string, error) Bar(context.Context, string) error Baz(context.Context) (int, error)} ## 分布式跟踪 一旦基础结构增长到超过特定规模，通过多个服务跟踪请求就变得非常重要，因此您可以识别和排除热点。有关详细信息，请参阅[包跟踪](https://zshipu.com/t?url=https://github.com/go-kit/kit/blob/master/tracing)。 ## 创建客户端包 可以使用 Go 工具包为服务创建客户端包，以便从其他 Go 程序更轻松地使用服务。实际上，客户端包将提供服务接口的实现，该服务接口使用特定传输调用远程服务实例。有关示例，请参阅[添加vc/cmd/addcli](https://zshipu.com/t?url=https://github.com/go-kit/kit/blob/master/examples/addsvc/cmd/addcli)或[包配置文件/客户端](https://zshipu.com/t?url=https://github.com/go-kit/kit/blob/master/examples/profilesvc/client)。","link":"/2020/04/11/Gokit-go%E6%B5%81%E8%A1%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/"},{"title":"GraphQL 作为微服务的 API 网关","text":"GraphQL早在2015年就向公众发布，就像一只在圈养中饲养的动物一样，它在野外的第一步是胆怯的，基本上被忽视了。然而，到目前为止，它已经获得了一些重大的轰动，而且有充分的理由：它解决了标准 REST API 体系结构中固有的一些最棘手的问题。 具体来说，GraphQL 允许您在不进行版本控制的情况下自然地发展 API，它提供了可行的文档，避免了过度和不足提取的问题，并且它提供了一种通过单个请求聚合来自多个源的数据的便捷方法。一旦您通过非常规的方法和欺骗性的”类似 JSON”语法（这来自那些带给我们 React 及其”类似 HTML”语法的人），您可以开始欣赏其功能和灵活性。 如何在 API 网关中利用 GraphQL？它似乎是一个完美的解决方案，用于与多个微服务交互，每个微服务都专用于单个资源类型。好消息是，_您可以在_API 网关中使用 GraphQL，并且它可以与标准 REST 路由并驾齐驱。所以在某些情况下，你可以有你的蛋糕，也吃它。 [推文””GraphQL 可能是与多个微服务交互的完美解决方案”] GraphQL in a Nutshell在进入网关代码之前，让我们先回顾一下 GraphQL 的横向。与 REST 应用程序不同，GraphQL 实现依赖于单个终结点。所有 GraphQL 都使用查询向该终结点请求将数据（_始终_发布，永远不会获取）到该终结点，该查询描述正在请求哪些资源和字段。 GraphQL 将读取操作区分为”查询”，将操作区分为”突变”。为了支持查询，GraphQL 实现将定义一个根查询对象，该对象枚举所有可供查询的资源类型（以及它们的字段和数据类型）。您可以将其视为定义表和列的数据库架构。 为了支持突变，GraphQL 实现将定义一个根突变对象，该对象枚举所有可用的突变及其属性。突变可以被认为是行动，_例如_，或。即使在单个语言或框架中，对于这些 GraphQL 组件应存在的位置也没有标准结构，但这些关键元素必须存在于任何 GraphQL 实现中的某处。createUser``````updateOrder 同时使用GraphQL 和 REST 端点仅仅因为我们的 API 网关定义了 GraphQL 终结点，并不意味着我们也不能有其他终结点！完全可以在相同的应用程序中定义传统的 REST 路由。 由于我们希望避免在网关中复制代码，尤其是向微服务发出请求的代码，因此我们必须选择由哪种方法负责。我们可以剖析 GraphQL 查询并将其转换为相应的 REST 请求，也可以将 REST 请求转换为其 GraphQL 等效项。 事实证明，后者更简单，所以我们建议的诀窍是：将对REST路由的请求转换为GraphQL。不需要复制与微服务交互的代码，因为 REST 路由只是充当 GraphQL 的转换层。 在代码中现在我们已经描述了我们的攻击计划，让我们来看看一些代码！演示这些示例的存储库在Github上可用 这是一个Node.js应用程序使用流行的快速框架。您应该能够按照 README 中的说明克隆和安装应用程序。 从命令行运行应启动应用程序并开始侦听端口 4000。将浏览器指向查看 GraphQL 终结点。右侧将显示任何已注册的资源类型及其字段，因此您可以马上查看 GraphQL 如何提供一些可行的文档。yarn run start``````http://localhost:4000/graphql 我们可以运行示例查询来按其 ID 查找单个用户： 12{ users(_id: 3){ name }} The result should be: 123456789{ &quot;data&quot;: { &quot;users&quot;: [ { &quot;name&quot;: &quot;Tammy&quot; } ] }} 处理此代码位于 内部，它围绕对象旋转。这就是响应的结构并提供可行的文档的原因。src/users.js``````GraphQLObjectType REST 等效项接下来，让我们来看看如何支持获取相同数据的 REST 终结点。查找单个用户记录的传统路由将遵循 的模式。查看 内部，看看它是如何注册路由的：/users/:userId``````index.js 12const users = require('./src/rest/user');// ... app.use('/users', users); 这是相当标准的快速路由的东西。让我们看一下该文件，看看它是如何将请求转换为 GraphQL 的。src/rest/user.js 123456789101112131415161718192021222324const app = require('express');const router = app.Router();import rootSchema from '../app';import {graphql} from 'graphql'const query = (q, vars) =&gt; { return graphql(rootSchema, q, null, null, vars)}// Transform response to JSON API format// (if desired)const transform = (result) =&gt; { const user = result.data.users[0]; return { data: { type: 'user', id: user._id, attributes: { name: user.name } } }}// REST request to get a user router.get('/:userId', (req, res) =&gt; { // Convert the request into a GraphQL query string query(&quot;query{users(_id:&quot; + req.params.userId + &quot;){_id, name}}&quot;) .then(result =&gt; { const transformed = transform(result) res.send(transformed) }) .catch(err =&gt; { res.sendStatus(500) })})module.exports = router; 这真的是魔法发生的地方。路由的已注册回调将收集查询字符串并将其传递给 GraphQL： 1query(&quot;query{users(_id:&quot; + req.params.userId + &quot;){_id, name}}&quot;) 查询字符串映射出该”类似 JSON”语法中的查询对象 - 是的，它似乎是多余的，但有一个根查询节点，它包裹我们在交互式 GraphQL 页上使用的查询部分。 此方法可能会提醒您以前，在 ORM 之前，您必须手动组装查询字符串。在将请求参数放入查询字符串之前对其进行筛选可能更合适，但由于它由 GraphQL 解释，因此可能是安全的 — 如果字符串无效，GraphQL 会简单地阻塞。 此输出中包括一个变压器功能，该函数将默认 GraphQL 响应转换为JSON API格式，但这可能是您希望保留的内容，也可能不是您希望保留的内容。 您应该能够通过请求http://localhost:4000/users/2等 URL 并获取响应（如： 123456789{ &quot;data&quot;: { &quot;type&quot;: &quot;user&quot;, &quot;id&quot;: &quot;2&quot;, &quot;attributes&quot;: { &quot;name&quot;: &quot;João&quot; } }} 微服务的请求更复杂的示例涉及使用web请求实际触及微服务。这可以通过请求某天的励志名言来实现 http://quotes.rest/qod.json?category=inspire. 为了为这个数据添加GraphQL支持，我们需要做三件事: 修改根查询对象 src/app.js 中定义引用资源类型 .src/quote.js 定义一个将从远程API中获取数据的服务src/services/quote.js 修改根查询首先，我们需要将资源类型添加到内部的GraphQL根查询对象 inside :src/app.js 123456789101112// src/app.jsimport { GraphQLObjectType, GraphQLSchema,} from 'graphql/type';import userQuery from './users';import agendaQuery from './agenda-interface';import quoteQuery from './quote';const query = new GraphQLObjectType({ name: 'RootQueryType', fields: { users: userQuery, agenda: agendaQuery, quote: quoteQuery },});export default new GraphQLSchema({ query,}); 定义查询类型引号查询对象在 中定义 - 这几乎与用于用户查询的结构完全相同，但它引用一个服务类，其作业将是与远程微服务交互。src/quote.js 123456789101112131415// src/quote.jsimport { GraphQLObjectType, GraphQLNonNull, GraphQLString} from 'graphql/type';import { getQuote } from './services/quote'export const QuoteType = new GraphQLObjectType({ name: 'Quote', description: 'Quote of the day from API service', fields: () =&gt; ({ id: { type: GraphQLString, description: 'Quote id', }, quote: { type: new GraphQLNonNull(GraphQLString), description: 'The text of the quote', }, author: { type: GraphQLString, description: 'The person to whom the quote is attributed', }, date: { type: GraphQLString, description: 'Date in YYYY-MM-DD format', } })});export default { type: QuoteType, resolve: getQuote } 这完全取决于函数，我们接下来将讨论该函数。getQuote() 定义用于检索远程数据的服务函数在 中定义：getQuote()``````src/services/quote.js 12345678910111213141516171819202122232425// src/services/quote.js/** * This is where the app calls the microservice responsible for the &quot;Quote&quot; resource type. */import fetch from 'universal-fetch'export const getQuote = () =&gt; { const url = 'http://quotes.rest/qod.json?category=inspire' return fetch(url) .then(response =&gt; { return response.json() }) .then(json =&gt; { return transform(json) }) .catch(err =&gt; { console.trace(err) }) }// Transform the raw microservice output into// fields/types defined by the GraphQL typeconst transform = (json) =&gt; { const { contents } = json, { quotes } = contents, quote = quotes[0] return { id: quote.id, quote: quote.quote, author: quote.author, date: quote.date }} 此处的方法将微服务使用的任何格式转换为 GraphQL 为此资源类型定义的格式。如果需要将字段添加到响应中，必须将它们添加到 中的对象。transform``````QuoteType``````src/quote.js 完成这些部件后，您应该能够使用 GraphQL 进行查询： 1234{ quote{ quote, author }} 添加 REST 支持与以前一样，路由在文件中注册：index.js 12const quotes = require('./src/rest/quote');// ... app.use('/quote', quotes); REST 请求充当 GraphQL 语法的转换器。 123456789101112131415161718192021222324// src/rest/quote.jsconst app = require('express');const router = app.Router();import rootSchema from '../app';import {graphql} from 'graphql'const query = (q, vars) =&gt; { return graphql(rootSchema, q, null, null, vars)}// Transform response to JSON API formatconst transform = (result) =&gt; { const quote = result.data.quote; return { data: { type: 'quote', id: quote.id, attributes: { quote: quote.quote, author: quote.author, date: quote.date } } }}// REST request to get a quote router.get('/', (req, res) =&gt; { // Convert the request into a GraphQL query string query(&quot;query{quote{id, quote, author, date}}&quot;) .then(result =&gt; { const transformed = transform(result) res.send(transformed) }) .catch(err =&gt; { res.sendStatus(500) })})module.exports = router; 完成后，REST 终结点在http://localhost:4000/quote可用。 请注意，报价服务每小时有 10 个请求的限制，因此只能适度使用演示。 优点现在，您已经了解如何将 API 网关既具有 GraphQL 实现，又支持标准 REST 路由，因此优势应该显而易见： 你可以有你的API蛋糕，也吃它。图形QL还是REST？两者！ 您可以利用 GraphQL 的内置优势，从多个服务聚合数据。 缺点这种方法的大多数缺点通常与 GraphQL 有关。在填充 API 网关的角色时，GraphQL 最大的问题是它在_单个_终结点上运行。 API 网关通常_为每个路由_定义授权规则、限制速率和缓存时间。但是，由于 GraphQL 仅使用一个终结点，因此几乎不可能为任何内容定义特定于路由的规则。因此，您可能需要在单独的层中，甚至微服务本身中写入授权、限制和缓存逻辑。 这会产生自己的臭代码混乱，因为解决方案最终将削弱我们期望从网关获得的一些最基本的功能。 如果您的 API 未公开使用，则您不会进行无限数量的查询变体，因此，使用允许客户端请求任何可能的资源和字段组合的 GraphQL 解释器可以说是超量计算。长期以来，支持少数具有已知响应属性的用例在很多设置中效果很好，因此可能不需要重新发明该特定车轮。 尝试同时使用 GraphQL 和 REST 的另一个缺点是文档：无法保证 REST 终结点具有任何文档，更不用说与 GraphQL 查询对象保持同步的文档，因此，如果您选择在 API 网关中同时支持 GraphQL 和 REST，则可能会邀请一些不一致和忙碌工作。 总结我在这里介绍的解决方案对一些人来说可能是一个有趣的分心，或者它可能是一个可行的解决方案，这取决于您的需求。尽管可以在单个应用程序中将 GraphQL 和 REST API 共存，但更困难的问题是这种组合是否可行。 与围绕微服务和 API 网关的大多数问题一样，没有简单的正确和错误答案，只有权衡，只有您才能决定哪些解决方案最适合您的需求。 [通过@fireproofsocks”将”GraphQL 作为微服务的 API 网关”推文” 与朋友分享这个帖子！相关内容 [](https://zshipu.com/t?url=https://rollout.io/blog/an-introduction-to-graphql-via-the-github-api/ “An Introduction to GraphQL via the GitHub API RESTful, JSON-delivering APIs are today’s default choice when building an API. However, there’s a new API kid on the block that’s generating considerable attention: GraphQL. GraphQL is an entirely new way to consume and build APIs. Done right, you can build wonderfully tight integrations that aren’t possible with REST APIs.…”) [通过 GitHub API 对 GraphQL 的简介](https://zshipu.com/t?url=https://rollout.io/blog/an-introduction-to-graphql-via-the-github-api/ “An Introduction to GraphQL via the GitHub APIRESTful, JSON-delivering APIs are today’s default choice when building an API. However, there’s a new API kid on the block that’s generating considerable attention: GraphQL. GraphQL is an entirely new way to consume and build APIs. Done right, you can build wonderfully tight integrations that aren’t possible with REST APIs.…”) RESTful, JSON-delivering APIs are today’s default choice when building an API. However, there’s a new API kid on the block that’s generating considerable attention: GraphQL. GraphQL is an entirely new way to consume and build APIs. Done right, you can build wonderfully tight integrations that aren’t possible with REST APIs.… 三月 8， 2017 在”发展” [API 网关和微服务的设计模式](https://zshipu.com/t?url=https://rollout.io/blog/design-patterns-in-api-gateways-and-microservices/ “Design Patterns in API Gateways and MicroservicesFor all the buzz about microservices and API gateways, finding specifics can prove surprisingly difficult. I am reminded of the cartoon by Sidney Harris where the first step of a complex mathematical formula is presented, then a miracle occurs, and the sudden appearance of the glorious solution prompts an observer…”) 对于关于微服务和 API 网关的所有热议，查找细节可能证明极其困难。我想起了西德尼·哈里斯的漫画，其中提出了复杂数学公式的第一步，然后奇迹发生，而光荣解决方案的突然出现促使观察者… 十月 26， 2017 在”发展” [如何在 Rails 中实现图形QL API](https://zshipu.com/t?url=https://rollout.io/blog/how-to-implement-a-graphql-api-in-rails/ “How to Implement a GraphQL API in RailsGraphQL came out of Facebook a number of years ago as a way to solve a few different issues that typical RESTful APIs are prone to. One of those was the issue of under- or over-fetching data. Under-fetching is when the client has to make multiple roundtrips to the server…”) GraphQL在几年前从Facebook上出来，作为解决一些典型的RESTful API容易出现的不同问题的方法。其中之一是数据提取不足或过度提取的问题。正在获取不足是客户端必须多次往返服务器…","link":"/2020/06/14/GraphQL%20%E4%BD%9C%E4%B8%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%20API%20%E7%BD%91%E5%85%B3/"},{"title":"GraphQL 入门指南","text":"今天最常讨论的术语之一是 API。很多人不知道 API 的确切内容。基本上，API 代表应用程序编程接口。顾名下，这是一个界面，人们——开发人员、用户、消费者——可以与之交互。 您可以将 API 视为调酒师。你请酒保喝一杯，他们给你你想要的。简单。那么，为什么这是个问题呢？ 自现代网络开始以来，构建 API 并不像听起来那么难。但是，学习和理解 API 是。开发人员组成使用 API 构建某些内容或仅使用数据的用户。因此，您的 API 应该尽可能干净和直观。设计良好的 API 非常容易使用和学习。这也是直观的，在开始设计 API 时要记住这一点。 长期以来，我们一直在使用 REST 来构建 API。随之而来的是一些问题。使用 REST 设计构建 API 时，您将面临一些问题，例如： 1） 您将有很多端点 2） 开发人员将更难学习和了解您的 API 3） 信息获取过度和不足 为了解决这些问题，Facebook 创建了 GraphQL。今天，我认为 GraphQL 是构建 API 的最佳方式。本文将告诉您为什么今天应该开始学习它。 在本文中，您将了解 GraphQL 的工作原理。我将向您展示如何使用 GraphQL 创建设计良好、高效、功能强大的 API。 您可能已经听说过 GraphQL，因为很多人和公司都在使用它。由于 GraphQL 是开源的，其社区已经变得庞大。 现在，是时候开始在实践中学习GraphQL是如何工作的，以及所有关于它的魔力。 什么是GraphQL？GraphQL是 Facebook 开发的开源查询语言。它为我们提供了一种更有效的方法来设计、创建和使用我们的 API。基本上，它是REST的替代品。 GraphQL 有很多功能，例如： 编写所需的数据，并准确获取所需的数据。不再像我们习惯的 REST 那样过度提取信息。 它为我们提供了一个终结点，没有更多的版本2或版本3为相同的API。 GraphQL 是强类型，因此可以在执行之前验证 GraphQL 类型系统中的查询。它帮助我们构建更强大的 API。 这是 GraphQL 的基本介绍 - 为什么它如此强大，为什么它现在越来越受欢迎。如果你想了解更多关于它，我建议你去GraphQL网站，并检查出来。 开始本文的主要目标是学习如何设置 GraphQL 服务器，因此我们目前不会深入探讨这一点。目标是了解 GraphQL 在实践中是如何工作的，因此我们将使用称为 ☄️ Graphpack的零配置 GraphQL 服务器。 为了开始我们的项目，我们将创建一个新文件夹，您可以随心所欲地命名它。我要命名它： 1graphql-server 打开终端并键入： 123mkdir graphql-server 现在，您应该在机器中安装或安装。如果您不知道这些是什么，并且是 JavaScript 编程语言的包管理器。对于 Node.js，默认包管理器为 。 1npm 1yarn 在创建的文件夹中键入以下命令： 123npm init -y 或者，如果您使用 ： 1yarn 123yarn init 将为你创建一个文件，并且您安装的所有依赖项和命令都将在那里。 1package.json 因此，现在，我们将安装我们将使用的唯一依赖项。 ☄️图形包允许您创建具有零配置的GraphQL 服务器。由于我们刚刚开始使用 GraphQL，这将帮助我们继续前进并学习更多，而不必担心服务器配置。 在终端中，在根文件夹中，安装它像这样： 123npm install --save-dev graphpack 或者，如果您使用 ，则应如下所示： 1yarn 123yarn add --dev graphpack 安装_Graphpack_后，转到文件中的脚本，并将以下代码放在其中： 1package.json 123456&quot;scripts&quot;: { &quot;dev&quot;: &quot;graphpack&quot;, &quot;build&quot;: &quot;graphpack build&quot;} 我们将创建一个名为 的文件夹，它将是我们整个服务器中唯一的文件夹。 1src 在文件夹内创建一个名为 “之后”的文件夹，我们将仅创建三个文件。 1src 在我们的文件夹中创建一个名为 的文件。在此第一个文件中，放置以下代码： src schema.graphql 12345 type Query { hello: String } 在此文件中将是我们的整个 GraphQL 架构。如果你不知道它是什么，我稍后会解释——别担心。 1schema.graphql 现在，在我们的文件夹中，创建第二个文件。调用它，并在此第二个文件中放置以下代码： src resolvers.js 1234567891011 import { users } from &quot;./db&quot;;const resolvers = { Query: { hello: () =&gt; &quot;Hello World!&quot; } };export default resolvers; 此文件将是我们提供将 GraphQL 操作转换为数据的说明的方式。 1resolvers.js 最后，在_src_文件夹中创建第三个文件。调用此，并在此第三个文件中放置以下代码： db.js 123456 export let users = [ { id: 1, name: &quot;John Doe&quot;, email: &quot;john@gmail.com&quot;, age: 22 }, { id: 2, name: &quot;Jane Doe&quot;, email: &quot;jane@gmail.com&quot;, age: 23 } ]; 在本教程中，我们不使用真实数据库。因此，此文件将模拟数据库，只是为了学习目的。db.js 现在，我们的文件夹应该如下所示： src 123456src |--db.js |--resolvers.js |--schema.graphql 现在，如果您运行该命令，或者，如果您使用的 是 ，则应在终端中看到此输出： 1npm run dev 1yarn 1yarn dev 您现在可以转到 。这意味着我们已经准备好开始编写 GraphQL 中的第一个查询、突变和订阅。 1localhost:4000 您将看到 GraphQL 游乐场，这是一款功能强大的 GraphQL IDE，用于更好的开发工作流。如果您想了解有关 GraphQL 游乐场的更多信息，请单击此处。 模式GraphQL 有它自己的语言类型，用于编写架构。这是一种称为架构定义语言 （SDL）的人类可读架构语法。无论您使用何种技术，SDL 都将相同 ， 您可以将其用于所需的任何语言或框架。 这种架构语言非常有用，因为它很容易理解 API 将具有哪些类型。你可以理解它，只是看对了它。 类型类型是 GraphQL 最重要的特征之一。类型是表示 API 外观的自定义对象。例如，如果要构建社交媒体应用程序，您的 API 应具有帖子、用户、赞、组等类型。 类型具有字段，这些字段返回特定类型的数据。例如，我们将创建一个用户类型，我们应该有一些名称、电子邮件和年龄字段。类型字段可以是任何内容，并且始终返回数据类型为 Int、Float、字符串、布尔、ID、对象类型列表或自定义对象类型。 因此，现在编写我们的第一个类型，转到您的文件，并将已经存在的类型查询替换为以下内容： 1schema.graphql 12345678 type User { id: ID! name: String! email: String! age: Int } 每个用户都有一个 ID，所以我们给它一个 ID 类型。用户也将有一个名称和电子邮件，所以我们给它一个字符串类型，和一个年龄，我们给了一个Int类型。很简单，对吧？ 但是，那些呢！在每行的末尾？感叹号表示字段是不可空的，这意味着每个字段都必须返回每个查询中的一些数据。我们将在 User 类型中具有的唯一空字段是年龄。 在 GraphQL 中，您将处理三个主要概念： 查询- 从服务器获取数据的方式。 突变- 修改服务器上的数据并恢复更新数据（创建、更新、删除）的方式。 订阅- 保持与服务器的实时连接的方式。 我要向你解释所有。让我们从查询开始。 查询为了简单解释这一点，GraphQL 中的查询是获取数据的方式。在 GraphQL 中查询最美丽的事情之一是，您只是要获得所需的确切数据。没有更多，没有更少。这在我们的 API 中产生了巨大的积极影响 - 不再像使用 REST API 那样过度获取或获取不足的信息。 我们将在 GraphQL 中创建第一个类型查询。我们所有的查询都将在此类类型内结束。因此，首先，我们将转到我们并编写一个名为 Query 的新类型： 1schema.graphql 12345 type Query { users: [User!]! } 很简单：用户查询将返回给我们一个或多个用户的数组。它不返回 null，因为我们放入！， 这意味着它是一个不可空的查询。它应该总是返回的东西。 但是，我们也可以返回特定的用户。为此，我们将创建一个名为”用户”的新查询。在我们的查询类型中，放置以下代码： 123user(id: ID!): User! 现在，我们的查询类型应如下所示： 123456 type Query { users: [User!]! user(id: ID!): User! } 如您所见，在 GraphQL 中查询时，我们还可以传递参数。在这种情况下，要查询特定用户，我们将传递其 ID。 但是，您可能想知道：GraphQL 如何知道数据从何处获取？这就是为什么我们应该有一个文件。该文件告诉 GraphQL 如何以及从何处获取数据。 resolvers.js 首先，转到我们的文件并导入我们刚刚创建的文件。您的文件应如下所示： resolvers.js db.js 1234567891011 import { users } from &quot;./db&quot;;const resolvers = { Query: { hello: () =&gt; &quot;Hello World!&quot; } };export default resolvers; 现在，我们将创建第一个查询。转到您的文件并替换 hello 函数。现在，查询类型应如下所示： resolvers.js 12345678910111213141516 import { users } from &quot;./db&quot;;const resolvers = { Query: { user: (parent, { id }, context, info) =&gt; { return users.find(user =&gt; user.id == id); }, users: (parent, args, context, info) =&gt; { return users; } } };export default resolvers; 现在，要解释它是如何工作的： 每个查询解析器有四个参数。在用户函数中，我们将将 ID 作为参数传递，然后返回与传递的 ID 匹配的特定用户。很简单 在用户函数中，我们只需返回已存在的用户数组。它总是会回到我们所有的用户。 现在，我们将测试我们的查询是否正常工作。转到并放入以下代码： localhost:4000 12345678910 query { users { id name email age } } 它应该返回到我们所有的用户。 或者，如果要返回特定用户： 12345678910 query { user(id: 1) { id name email age } } 现在，我们将开始学习突变，这是GraphQL中最重要的特征之一。 突变在 GraphQL 中，突变是修改服务器上的数据并恢复更新数据的方式。您可以像 REST 的 CUD（创建、更新、删除）一样思考。 我们将在 GraphQL 中创建我们的第一个类型突变，并且我们所有的突变都将在这种类型的类型中结束。所以，首先，去我们的，并写一个新的类型称为突变： schema.graphql 1234567 type Mutation { createUser(id: ID!, name: String!, email: String!, age: Int): User! updateUser(id: ID!, name: String, email: String, age: Int): User! deleteUser(id: ID!): User! } 正如您所看到的，我们将有三个突变： 创建用户：我们应该传递 ID、姓名、电子邮件和年龄。它应该将新用户返回给我们。 更新用户：我们应该传递一个ID，以及一个新的名称，电子邮件，或年龄。它应该将新用户返回给我们。 删除用户：我们应该传递一个ID。它应该将删除的用户退还给我们。 现在，转到我们的文件和查询对象下方，创建一个新的突变对象，如下所示： resolvers.js 1234567891011121314151617181920212223242526 Mutation: { createUser: (parent, { id, name, email, age }, context, info) =&gt; { const newUser = { id, name, email, age }; users.push(newUser); return newUser; }, updateUser: (parent, { id, name, email, age }, context, info) =&gt; { let newUser = users.find(user =&gt; user.id == id); newUser.name = name; newUser.email = email; newUser.age = age; return newUser; }, deleteUser: (parent, { id }, context, info) =&gt; { const userIndex = users.findIndex(user =&gt; user.id == id); if (userIndex === -1) throw new Error(&quot;User not found.&quot;); const deletedUsers = users.splice(userIndex, 1); return deletedUsers[0]; } } 现在，我们的文件应该如下所示： resolvers.js 12345678910111213141516171819202122232425262728293031323334353637383940 import { users } from &quot;./db&quot;;const resolvers = { Query: { user: (parent, { id }, context, info) =&gt; { return users.find(user =&gt; user.id == id); }, users: (parent, args, context, info) =&gt; { return users; } }, Mutation: { createUser: (parent, { id, name, email, age }, context, info) =&gt; { const newUser = { id, name, email, age }; users.push(newUser); return newUser; }, updateUser: (parent, { id, name, email, age }, context, info) =&gt; { let newUser = users.find(user =&gt; user.id == id); newUser.name = name; newUser.email = email; newUser.age = age; return newUser; }, deleteUser: (parent, { id }, context, info) =&gt; { const userIndex = users.findIndex(user =&gt; user.id === id); if (userIndex === -1) throw new Error(&quot;User not found.&quot;); const deletedUsers = users.splice(userIndex, 1); return deletedUsers[0]; } } };export default resolvers; 现在，我们将测试我们的突变是否正常。转到并放入以下代码： 1localhost:4000 12345678910 mutation { createUser(id: 3, name: &quot;Robert&quot;, email: &quot;robert@gmail.com&quot;, age: 21) { id name email age } } 它应将新用户返回给您。如果你想尝试制造新的突变，我建议你自己尝试一下！尝试删除您创建的同一用户，以查看其是否正常工作。 最后，我们将开始了解订阅，以及为什么它们如此强大。 订阅正如我以前说过的，订阅是您与服务器保持实时连接的方式。这意味着，每当服务器中发生事件，并且每当调用该事件时，服务器都会向客户端发送相应的数据。 通过使用订阅，可以使应用更新到不同用户之间的最新更改。 基本订阅如下所示： 12345678910 subscription { users { id name email age } } 你会说它非常类似于查询，是的。但它的工作方式不同。 在服务器中更新某些内容时，服务器将运行订阅中指定的 GraphQL 查询，并将新更新的结果发送到客户端。 我们不会在本文中使用订阅，但如果您想阅读有关订阅的更多信息，请单击此处。 结论正如您所看到的，GraphQL 是一项非常强大的新技术。它为我们提供了构建更好且设计良好的 API 的真正能力。这就是为什么我建议你现在开始学习它。对我来说，它最终将取代REST。","link":"/2020/06/19/GraphQL%20%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"},{"title":"GraphQL架构拼接解释：架构委派","text":"架构拼接是 GraphQL 社区中的一个全新的主题。通常，它是指合并和连接多个 GraphQL 架构（或架构定义）以创建单个 GraphQL API 的行为。 架构拼接是一种新的、简便的方法来组合和重用 GraphQL API 架构拼接有两个主要概念： 架构委派：架构委派的核心思想是将特定解析器的调用转发（_委托_）到另一个解析器。从本质上讲，架构定义的相应字段正在”重新布线”。 架构合并：架构合并是创建两个（或更多）现有 GraphQL API_的联合_的想法。如果所涉及的架构完全分离，这没有问题-如果没有，则需要有一种方法来解决它们的命名冲突。 请注意，在大多数情况下，委派和合并实际上将一起使用，我们最终将采用一种混合方法，该方法同时使用这两种方法。在本系列文章中，我们将单独介绍它们，以确保每个概念都能很好地理解。 示例：构建自定义 GitHub API让我们从基于公共GitHub GraphQL API的示例开始。假设我们想要构建一个小型应用程序，提供有关Graphcool GitHub 组织的信息。 应用所需的 API 应公开以下功能： 检索有关 Graphcool 组织的信息（如其ID、__电子邮件地址_、_头像 URL_或_固定存储库 ) 按名称从 Graphcool 组织检索存储库列表 检索有关应用本身的简短说明 让我们从GitHub 的 GraphQL 架构定义中探索类型，了解如何将需求映射到架构的根字段。[Query](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ2MtY29kZXNuaXBwZXRzL2E1NGFiMjc5ZjZlYTE4MWYxM2EwMWEyMzJmMWFhOTU4I2ZpbGUtZ2l0aHViLWdyYXBocWwtTDQ1OTg=) 要求 1：检索有关 Graphcool 组织的信息第一个功能，检索有关 Graphcool 组织的信息，可以通过使用类型上的根字段来实现：repositoryOwner``````Query 我们可以发送以下查询来询问有关 Graphcool 组织的信息： 当我们提供作为字段时，它的工作原理。&quot;graphcool&quot;``````login``````repositoryOwner 这里的一个问题是，我们不能以简单的方式要求，因为只是一个没有字段的接口。但是，由于我们知道 Graphcool 组织的具体类型确实如此，因此我们可以在查询中使用内联片段来解决此问题：email``````[RepositoryOwner](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ2MtY29kZXNuaXBwZXRzL2E1NGFiMjc5ZjZlYTE4MWYxM2EwMWEyMzJmMWFhOTU4I2ZpbGUtZ2l0aHViLWdyYXBocWwtTDYxNjE=)``````email``````[Organization](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ2MtY29kZXNuaXBwZXRzL2E1NGFiMjc5ZjZlYTE4MWYxM2EwMWEyMzJmMWFhOTU4I2ZpbGUtZ2l0aHViLWdyYXBocWwtTDMwMDU=) 好的，这样这将起作用，但我们已经触及了一些摩擦点，不允许为了我们的应用而直接使用 GitHub GraphQL API。 理想情况下，我们的 API 只会公开一个根字段，该字段允许直接请求我们想要的信息，而无需在每个查询上提供参数，并让我们直接请求字段：Organization 要求 2：按名称检索 Graphcool 存储库列表第二个要求如何，按它们的名称检索 Graphcool 存储库的列表。再次查看类型，这变得有点复杂。API 不允许直接检索存储库列表，而是可以通过使用以下根字段提供 和 存储库来请求单个存储库：Query``````owner``````name 下面是相应的查询： 但是，我们_实际上_需要的应用程序（为了避免发出多个请求）是一个根字段，如下所示： 要求 3：检索有关应用本身的简短说明我们的 API 应该能够返回描述应用的句子，例如 。This app provides information about the Graphcool GitHub organization 这当然是一个完全自定义的要求，我们不能满足基于 GitHub API - 但很明显，我们需要实现它自己，可能与一个简单的根字段像这样：Query 定义应用程序架构现在，我们了解 API 所需的功能以及为架构定义的理想类型：Query 显然，此架构定义本身是不完整的：它错过了 和 类型的定义。解决此问题的一个简单方法是手动复制和粘贴 GitHub 架构定义中的定义。[Organization](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ2MtY29kZXNuaXBwZXRzL2E1NGFiMjc5ZjZlYTE4MWYxM2EwMWEyMzJmMWFhOTU4I2ZpbGUtZ2l0aHViLWdyYXBocWwtTDMwMDU=)``````[Repository](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ2MtY29kZXNuaXBwZXRzL2E1NGFiMjc5ZjZlYTE4MWYxM2EwMWEyMzJmMWFhOTU4I2ZpbGUtZ2l0aHViLWdyYXBocWwtTDUzNDA=) 此方法很快就会变得麻烦，因为这些类型定义本身依赖于架构中的其他类型（例如，类型具有类型字段），然后还需要手动复制这些字段。此依赖关系链进入架构的深度没有限制，您甚至可能最终手动复制完整的架构定义。Repository``````[codeOfconduct](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ2MtY29kZXNuaXBwZXRzL2E1NGFiMjc5ZjZlYTE4MWYxM2EwMWEyMzJmMWFhOTU4I2ZpbGUtZ2l0aHViLWdyYXBocWwtTDUzNTc=)``````[CodeOfConduct](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ2MtY29kZXNuaXBwZXRzL2E1NGFiMjc5ZjZlYTE4MWYxM2EwMWEyMzJmMWFhOTU4I2ZpbGUtZ2l0aHViLWdyYXBocWwtTDQyMA==) 请注意，手动复制类型时，可通过三种方式完成此操作： 整个类型复制过来，不添加其他字段 复制整个类型并添加其他字段（或重命名现有字段） 仅复制类型字段的子集 简单地复制完整类型的第一种方法是最直接的方法。这可以使用 自动使用，如下一节所述。[graphql-import](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9naXRodWIuY29tL2dyYXBoY29vbC9ncmFwaHFsLWltcG9ydA==) 如果将其他字段添加到类型定义或重命名现有字段，则需要确保实现相应的解析器，因为基础 API 当然不能处理解析这些新字段的问题。 最后，您可能决定仅复制类型字段的子集。如果不想公开类型的所有字段（基础架构可能具有不希望在应用程序架构中公开的类型上的字段），则可能是可取的。password``````User 导入GraphQL类型定义该程序包允许您跨不同的文件共享类型定义，从而为您节省该手动工作。可以从另一个 GraphQL 架构定义导入类型，如下所示：[graphql-import](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9naXRodWIuY29tL2dyYXBoY29vbC9ncmFwaHFsLWltcG9ydA==)``````.graphql 在 JavaScript 代码中，您现在可以使用函数，它将为您解析依赖项，确保架构定义完成。importSchema 实现 API有了上面的架构定义，我们才只过了一半。仍然缺少的是架构以_解析器_函数的形式_实现的_实现。 如果您此时感到迷失，请务必阅读本文，其中介绍了 GraphQL 架构的基本机制和内部工作原理。 让我们来思考如何实现这些解析器！第一个版本可以如下所示： 解析器是微不足道的，我们可以返回一个描述我们的应用程序的简单字符串。但是，如何处理我们实际需要从 GitHub GraphQL API 返回信息的那些和那里的信息？info``````graphcool``````graphcoolRepositories 在此处实现此项的天真方法是查看参数以检索传入查询_的选择集_，然后从头开始构造另一个具有相同选择集的 GraphQL 查询并将其发送到 GitHub API。为 GitHub GraphQL API 创建远程架构甚至可以促进这一点，但总体而言，过程仍是一个相当冗长且繁琐的过程。info 这正是_架构委派_发挥作用的地方！我们之前看到 GitHub 的架构公开了两个根字段，这两个根字段（在某种程度上）满足我们的需求：和 。我们现在可以利用它来保存创建一个全新的查询的工作，而不是_转发_传入的查询。repositoryOwner``````repository 委派到其他架构因此，我们不是试图构造一个全新的查询，而是简单地将传入_查询委托给另_一个架构。我们将用于的 API 称为 。提供。[delegateToSchema](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9naXRodWIuY29tL2Fwb2xsb2dyYXBocWwvZ3JhcGhxbC10b29scy9ibG9iL21hc3Rlci9zcmMvc3RpdGNoaW5nL2RlbGVnYXRlVG9TY2hlbWEudHMjTDMx)``````[graphql-tools](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly93d3cuYXBvbGxvZ3JhcGhxbC5jb20vZG9jcy9ncmFwaHFsLXRvb2xzLw==) delegateToSchema接收七个参数（按以下顺序排列）： schema：可执行实例（这是我们想要将执行委托给_的目标架构_）[GraphQLSchema](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cDovL2dyYXBocWwub3JnL2dyYXBocWwtanMvdHlwZS8jZ3JhcGhxbHNjaGVtYQ==) fragmentReplacements：包含内联片段的对象（这是针对本文中不会讨论的更高级的案例） operation： 具有三个值 （、 或 ） 之一的字符串，指示要委派给哪个根类型&quot;query&quot;``````&quot;mutation&quot;``````&quot;subscription&quot; fieldName：我们要委派给的根字段的名称 args：我们委派给的根字段的输入参数 context：通过目标的解析器链传递的上下文对象schema info：包含有关要委派的查询的信息的对象 为了让我们使用此方法，我们首先需要一个表示 GitHub GraphQL API 的可执行实例。我们可以从 获取它使用 。GraphQLSchema``````[makeRemoteExecutableSchema](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9ibG9nLmdyYXBoLmNvb2wvaG93LWRvLWdyYXBocWwtcmVtb3RlLXNjaGVtYXMtd29yay03MTE4MjM3Yzg5ZDc=)``````graphql-tools 请注意，GitHub 的 GraphQL API 需要身份验证，因此您需要身份验证令牌才能实现此工作。您可以按照本指南获取本指南。 为了为 GitHub API 创建远程架构，我们需要两件事： 其_架构定义_（以实例的形式）GraphQLSchema 知道如何从中获取数据[HttpLink](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9naXRodWIuY29tL2Fwb2xsb2dyYXBocWwvYXBvbGxvLWxpbmsvdHJlZS9tYXN0ZXIvcGFja2FnZXMvYXBvbGxvLWxpbmstaHR0cA==) 我们可以使用以下代码来实现此目的： [GitHubLink](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9naXRodWIuY29tL25pa29sYXNidXJrL2dpdGh1Yi1zY2hlbWEtZGVsZWdhdGlvbi9ibG9iL21hc3Rlci9zcmMvR2l0SHViTGluay5qcw==)只是一个简单的包装顶部，提供了一些方便围绕创建所需的Link组件。HttpLink 真棒，我们现在有一个可执行版本的GitHubGraphQL API，我们可以委托在我们的解析器！：塔达：让我们首先实现解析器：graphcool 我们传递函数预期的七个参数。总体而言，没有意外：是 GitHub GraphQL API 的远程可执行架构。在那里，我们希望将我们自己的查询的执行委托给 GitHub API 的查询。由于该字段需要一个参数，因此我们将其作为值提供。最后，我们只是通过解析器链传递 和 对象。delegateToSchema``````schema``````graphcool``````repositoryOwner``````login``````&quot;graphcool&quot;``````info``````context 解析器可以以类似的方式接近，但它有点棘手。与以前的实现不同的是，GitHub 架构定义中我们和原始字段的类型与以前不相上下。我们现在需要返回一个存储库数组，而不是单个存储库数组。graphcoolRepositories``````graphcoolRepositories: [Repository!]!``````repository: Repository 因此，我们继续使用，以确保我们可以同时委派多个查询，并将其执行结果捆绑到一系列承诺中：Promise.all 就是这样！现在，我们已经为自定义 GraphQL API 实现了所有三个解析器。虽然第一个 （for ） 微不足道，只是返回一个自定义字符串，并且使用_架构委派_将查询的执行转发到基础 GitHub API。info``````graphcool``````graphcoolRepositories 如果要查看此代码的工作示例，请查看此存储库。 使用Graphql工具的架构委派在上面在 GitHub 上构建自定义 GraphQL API 的示例中，我们看到了如何从编写样板代码以进行查询执行中节省我们。我们可以使用 提供的 API 将查询的执行委托给 的另一个（可执行的）实例，而不是从头开始构造新查询，并使用 或使用 一些其他 HTTP 工具将其发送过来。方便地，此实例可以创建为远程架构。[delegateToSchema](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9naXRodWIuY29tL2Fwb2xsb2dyYXBocWwvZ3JhcGhxbC10b29scy9ibG9iL21hc3Rlci9zcmMvc3RpdGNoaW5nL2RlbGVnYXRlVG9TY2hlbWEudHM=)``````fetch``````[graphql-request](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9naXRodWIuY29tL2dyYXBoY29vbC9ncmFwaHFsLXJlcXVlc3Q=)``````graphql-tools``````GraphQLSchema 在高级别上，只需充当GraphQL.js函数的”代理”。这意味着，在引擎盖下，它将根据作为参数传递的信息重新组合 GraphQL 查询（或突变）。构造查询后，它所做的只是使用架构和查询调用。delegateToSchema``````[execute](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cDovL2dyYXBocWwub3JnL2dyYXBocWwtanMvZXhlY3V0aW9uLyNleGVjdXRl)``````[execute](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9naXRodWIuY29tL2Fwb2xsb2dyYXBocWwvZ3JhcGhxbC10b29scy9ibG9iL21hc3Rlci9zcmMvc3RpdGNoaW5nL2RlbGVnYXRlVG9TY2hlbWEudHMjTDg0) 因此，架构委派不一定要求目标架构是远程架构，也可以使用本地架构来完成。在这方面，架构委派是一个非常灵活的工具 — 您甚至可能希望_在同_一架构中委派。这基本上是从 中采用的方法，其中多个架构首先合并到单个架构中，然后解析器重新布线。[mergeSchemas](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly93d3cuYXBvbGxvZ3JhcGhxbC5jb20vZG9jcy9ncmFwaHFsLXRvb2xzL3NjaGVtYS1zdGl0Y2hpbmcuaHRtbCNtZXJnZVNjaGVtYXM=)``````graphql-tools 从本质上讲，架构委派是能够轻松地将查询转发到现有的 GraphQL API。 架构绑定：重用 GraphQL API 的简便方法具备我们新获得的架构委派知识，我们可以引入一个新概念，它只不过是架构委托之上的一个薄的便利层，称为_架构绑定_。 公共GraphQL API 的绑定架构绑定的核心思想是提供一种使现有 GraphQL API 可重用的简单方法，以便其他开发人员现在可以通过 NPM 将其项目拉入其中。这允许一种全新的方法来构建 GraphQL”网关”，其中非常容易组合多个 GraphQL API 的功能。 使用 GitHub API 的专用绑定，我们现在可以从上面简化示例。现在，此部分不是手动创建远程可执行架构，而是由包完成。以下是完整实现在删除以前委托给 GitHub API 所需的所有初始设置代码的位置：[graphql-binding-github](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9naXRodWIuY29tL2dyYXBoY29vbC9ncmFwaHFsLWJpbmRpbmctZ2l0aHVi) 我们不是自己创建远程架构，而是实例化从导入的类并使用其函数。然后，它将在引擎盖下实际执行请求。[GitHub](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9naXRodWIuY29tL2dyYXBoY29vbC9ncmFwaHFsLWJpbmRpbmctZ2l0aHViL2Jsb2IvbWFzdGVyL3NyYy9pbmRleC50cyNMMjA=)``````graphql-binding-github``````delegate``````delegateToSchema 公共 GraphQL API 的架构绑定可以在开发人员之间共享。旁边还有一个绑定可用于 Yelp GraphQL API：由Devan Beitel[graphql-binding-github](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly93d3cuZ29vZ2xlLmRlL3NlYXJjaD9xPWdyYXBocWwtZ2l0aHViLWJpbmRpbmcmYW1wO29xPWdyYXBocWwtZ2l0aHViLWJpbmRpbmcmYW1wO2Fxcz1jaHJvbWUuLjY5aTU3LjQ4NTlqMGoxJmFtcDtzb3VyY2VpZD1jaHJvbWUmYW1wO2llPVVURi04)``````[graphql-binding-yelp](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9naXRodWIuY29tL0RldmFuQi9ncmFwaHFsLWJpbmRpbmcteWVscA==) 自动生成的委托函数这些类型的架构绑定的 API 甚至可以改进到_自动生成_委托函数的级别。绑定可以公开以相应的根字段命名的函数：，而不是编写以下内容。github.delegate('query', 'repository', ... )``````github.query.repository( ... ) 当这些委托函数在生成步骤中生成，并且基于强类型语言（如 TypeScript 或 Flow），此方法甚至会为与其他 GraphQL API 交互提供编译时类型安全性！ 要了解此方法的外观，请查看允许轻松为 Graphcool 服务生成架构绑定的存储库，并使用上述自动生成委托函数的方法。[graphcool-binding](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9naXRodWIuY29tL2dyYXBoY29vbC9ncmFwaGNvb2wtYmluZGluZw==) 总结这是我们系列”理解GraphQL架构拼接”的第二篇文章。在第一篇文章中，我们做了一些基础工作，并了解了远程（可执行）架构，这些架构是大多数架构拼接方案的基础。 在本文中，我们主要通过基于GitHub GraphQL API（该示例的代码可在此处提供）来讨论_架构委派_的概念。架构委派是一种机制，用于将解析器函数的执行转发（_委托_）到不同（或甚至相同）的 GraphQL 架构中的另一个解析器。它的关键好处是，我们不必从头开始构造一个全新的查询，而是可以重用和转发传入查询的（部分）。 使用架构委派作为基础时，可以创建专用 NPM 包，以便轻松共享现有 GraphQL API 的可重用_架构绑定_。要了解这些外观，可以签出GitHub API 的绑定，以及允许轻松为任何 Graphcool 服务生成绑定的绑定。[graphcool-binding](https://zshipu.com/t?url=https://www.colabug.com/goto/aHR0cHM6Ly9naXRodWIuY29tL2dyYXBoY29vbC9ncmFwaGNvb2wtYmluZGluZw==)","link":"/2020/06/15/GraphQL%E6%9E%B6%E6%9E%84%E6%8B%BC%E6%8E%A5%E8%A7%A3%E9%87%8A%EF%BC%9A%E6%9E%B6%E6%9E%84%E5%A7%94%E6%B4%BE/"},{"title":"HTML5实现播放RTMP协议视频","text":"_HTML5实现播放RTMP协议视频__网络_weixin_44005989的博客-CSDN博客 2019年5月30日 - HTML5实现播放RTMP协议视频 Video.js 7 &lt;link href=”css/video-js.min.css” … HTML5 _播放 rtmp_流直播_网络_qq_27156945的博客-CSDN博客 2019年6月20日 - HTML5实现播放RTMP协议视频 HTML5实现播放RTMP协议视频&lt;title&amp;… 出埃及记 6813 RTMP 在浏览器端播放… 使用video.js 7在_html_中_播放rtmp视频流 - 橘生淮南 - 博客园 2019年11月25日 - 不想使用硬件方的专用插件,所以计划视频_推送到SRS服务器,浏览器再通过_rtmp协议…1 2 &lt;_html_ lang=”en”&gt; 3 4 5 &lt;meta charset=… videojs 流媒体播放rtmp协议 - 简书 2017年12月16日 - _rtmp协议_需要flash的支持,_html5_不支持也无法支持这一协议。 搭建rtmp流媒体服务器可参考crtmpserver(如果不会,私信我给你文档) 接下来就是使用vid… HTML5 _播放RTMP视频_流简单示例_android html rtmp,android4.2… 2019年12月7日 - h5_实现rtmp协议视频播放_,里面包含实现样例源码,少积分下载! 2018-01-08 立即下载…代码,需要部署到服务器上(包括但不限于tomcat,iis),路径为test/te… 可以_播放_RTSP_协议_流媒体的_HTML5播放_器-CSDN论坛 2020年3月19日 - 有没有一个HTML5播放_器可以_播放_RTSP_协议_的_视频_流。_视频_H.264编码,音频AAC。 …em&gt;_协议对应的视频_流转码成_RTMP协议的_视频_流,因此延… .c-group-top{margin-bottom:0!important;padding:10px 10px 11px;border-top:1px solid #E3E3E3;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3}.c-group-middle{margin-bottom:0!important;padding:0 10px 8px;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3}.c-group-bottom{padding:0 10px 10px;border-left:1px solid #E3E3E3;border-right:1px solid #E3E3E3;border-bottom:1px solid #E3E3E3}.c-group-title{margin-bottom:5px;font-size:16px}.c-group{width:516px!important} 求使用_html5实现_hls流媒体_播放_的解决方案!!-CSDN论坛 2020年3月27日 - HTML5实现播放RTMP协议视频 weixin_44005989 16304 2019-05-30 H5视频之video.js播放rtmp直播源和hls直播源 qq285679784 5986 2019-01-04 H5播放… _HTML5_如何_实现视频_直播功能-H5教程-PHP中文网 2018年6月12日 - 移动 WEB 端目前以 HLS 为主,PC端则以 RTMP 为主实时性较好,接下来将围绕这两种_视频_流_协议_来展开H5直播主题分享,下面通过本文给大家分享_HTML5视频_直播思路详解,… html5 - _rtmp_在线直接_播放_不了 - SegmentFault 思否 html5 rtmp 我现在有个h5页面的在线播放功能,用rtmp格式播放但是查了下h5页面不支持rtmp,rtmp支持flash播放但是插入flash代码又播不了rtmp要怎么才能_播放rtmp_格式jQuery32105255350821476441_1590465410810… _html5_支持rtsp_协议视频_流吗?_html5_据说不支持直播视频,而rtsp是… 2015年12月2日 - 常见的视频_直播相关_协议: 1、RTMP(RealTime Messaging Protocol,实时消息传送协议…HTML5_对直播支持,可以采用HLS。具体到rtsp,_HTML5_是不能原生支持_播… 如何使用_视频流媒体服务器支持_HTML5_直播?__rtmp 2020年3月26日 - 当然可以了,H5火了这么久,涵盖了各个方面的技术,我们的流媒体服务器就可以支持H5的直播。 对于_视频_录制,可以使用强大的 WebRTC(Web Real-Time Commun… _rtmp协议_支持_html5播放_器吗_百度知道 2016年8月7日 - 回答：html5_不支持_rtmp协议 如何快速让前端开发一个_rtmp协议_的_视频_流文件 – Python量化投资 2019年12月13日 - 前端_播放rtmp协议_的_视频_流文件 最近公司的项目中需要在大屏可视化的页面中的一个位置是_视频_监控的,需求大概是这样的: 大屏右下角布局中有六个div,每个可以… HTML5 播放 RTSP/RTMP 方案 | 大专栏 2020年3月23日 - 使用 RTSP 协议传输流媒体数据需要有专门的媒体_播放_器和媒体服务器,也就是需要支持 RTSP 协议的客户端和服务器。 RTMP _RTMP 协议_是 Real Time Message… _HTML5实现视频_直播功能思路详解_html5_网页制作 - 编程客栈 2018年7月22日 - 移动 WEB 端目前以 HLS 为主,PC端则以 RTMP 为主实时性较好,接下来将围绕这两种_视频_流_协议_来展开H5直播主题分享,下面通过本文给大家分享_HTML5视频_直播思路详解,… 从_Html5_直播到互动直播,看直播_协议_的选择 - 知乎 2017年9月22日 - RTMP_的劣势 不支持_Html5_传播、浏览器推送 基于TCP_协议,虽然开发难度大,推广…直播实现低延迟,是对大部… 又拍云 视频_技术详解:_RTMP H5 直播流技术… _HTML5实现视频_直播功能思路详解-一佰互联网站建设 2019年4月20日 - 浏览器端,HTML5 video 标签无法播放 RTMP 协议_的_视频,可以通过 video.js 来实现。 &lt;link href=“http://vjs.zencdn.net/5.8.8/video-js.css”… _RTMP协议实现视频_直播流实战 2020年4月24日 - 一个开通了RTMP协议_的流地址,萤石云之类的监控提供商都有的,格式为rtmp://rtmp…”_html5“, lang: “zh_CN”, poster: poster,//[可选]_视频播放_前显示的… _RTMP协议实现视频_直播流实战 2020年4月24日 - 一个开通了RTMP协议_的流地址,萤石云之类的监控提供商都有的,格式为rtmp://rtmp…”_html5“, lang: “zh_CN”, poster: poster,//[可选]_视频播放_前显示的… _HTML_页面 加载_播放RTMP协议_流和HLS协议流直播_视频__PHP…_CSDN博客 2019年11月8日 - 主要内容让_rtmp_或hls的_协议_流直播_视频_能在_html_页面正常显示(这里也是综合参考了网上其余的资料,最终放出下面这些实测可用的方案)。 首先是HLS_协议_流, 这种是_播放_m3u8… _html5实现视频播放__andrewleeeeee的专栏-CSDN博客 2013年11月5日 - 1.关于视频格式,不同浏览器支持的不一样,safari–…3.如果希望增加flash插件,以处理浏览器不支持html5播放…HTML5实现播放RTMP协议视频 HTML5实现… H5_实现RTMP_流的直播小记_JavaScript_weixin_38457248的…_CSDN博客 2018年8月18日 - 专用的,rtmp_流为flv格式的,必须使用flash_播放_器,在video.js内部可以检测浏览器是否支持_html5播放_器直接_播放,如果不支持内部会自动调用浏览器的flash_播_… _html5_页面中使用videojs_播放rtmp视频_流(VUE)_javascrip…_CSDN博客 2019年12月16日 - HTML5实现播放RTMP协议视频 HTML5实现播放RTMP协议视频&lt;title&amp;… ddyy2695734664的博客 2362 … 网页中_播放rtmp视频_流(_实现_远程监控)_网络_weixin_4549…_CSDN博客 2020年1月9日 - 这两个地址要和使用的版本对应,反正我写的版本不对应,播放不了 效果图~ 这些…HTML5实现播放RTMP协议视频 HTML5实现播放RTMP协议视频… _HTML5_如何_实现视频_直播功能_xuehu837769474的博客-CSDN博客 2019年4月8日 - 移动 WEB 端目前以 HLS 为主,PC端则以 RTMP 为主实时性较好,接下来将围绕这两种_视频_流_协议_来展开H5直播主题分享,下面通过本文给大家分享_HTML5视频_直播… HTML5_的可以支持_RTMP 但是无法_播放_RTSP 兼容浏览器 - y…_CSDN博客 2016年6月22日 - 找半天,HTML5_的可以支持_RTMP 但是无法播放RTSP,flash也止步于RTMP,最后同事推荐了…(IE activex方式,谷歌、FF)_实现播放_RTSP_视频_流,那真是极好的~~ 废… 基于Html5+HLS_协议播放_符合部标1078_协议_的实时流媒体视频 2018年8月9日 - 由于现在主流的部标GPS和1077视频监控平台,都是BS架构,在网页上播放视频,早期的…HTML5实现播放RTMP协议视频 阅读数 6010 HTML5实现播放RTMP协议视… _HTML5视频_直播及H5直播扫盲_网络_纸上得来终觉浅,绝知…_CSDN博客 2016年8月15日 - HTML5 播放_直播_视频_时引入的一个 .m3u8 的文件,这个文件就是基于 HLS _协议,…RTMP 推流,可以使用第三方库 lib_rtmp_-iOS 进行推流,lib_rtmp_ 封装了一些核心的… HTML播放rtmp(ckplayer)_java_qq_27933251的博客-CSDN博客 2019年11月1日 - HTML5实现播放RTMP协议视频 HTML5实现播放RTMP协议视频&lt;title&amp;… 足迹人生的博客 1886 ckplayer实现mp4… 可以_播放_RTSP_协议_流媒体的_HTML5播放_器-CSDN论坛 2015年11月6日 - 有没有一个HTML5播放_器可以_播放_RTSP_协议_的_视频_流。_视频_H.264编码,音频AAC。 …em&gt;_协议对应的视频_流转码成_RTMP协议的_视频_流,因此延… _HTML5实现视频_直播功能思路详解-一团网 2018年3月14日 - 前言前不久抽空对目前比较火的视频_直播做了下研究与探索了解其整体实现流程以及探讨移动端_HTML5_直播可行性方案发现目前WEB上主流的_视频_直播方案有HLS和_RTMP h5 _rtmp播放demo_h5 rmtp demo,h5 _rtmp mp4-_HTML5_代码类资源 6天前 - h5_实现rtmp协议视频播放_,里面包含实现样例源码,少积分下载!… h5_实现rtmp协议视频播放_,里面包含实现样例源码,少…rtsp 最佳方案 比较,html5 rtsp-We… 求osceR解答下 HTML5_是否支持_RTMP协议? - OSCHINA 2012年8月5日 - flash _html5_不是直接cut了吗 评论(0) 引用此答案 举报 0 冯继虎 2012/09/11 10:09 不支持_rtmp协议_。 评论(0) 引用此答案 举报 我要回答 ks… html5-video.js _播放rtmp_直播流问题请教——CSDN问答频道 2019年5月31日 - video.js 播放rtmp_直播流问题请教 5C 问题如下:…_html5 javascript 开发语言 分享 | 评论1 | 收藏 …Auto.JS实现抖音,刷宝等刷_视频_app,自动点赞,… _rtmp_在线直接_播放_不了__Html5__论坛_素材牛 2018年5月17日 - 但是插入flash代码又播不了rtmp要怎么才能播放rtmp_格式??? 标签:rtmp_html5 …rtmp是一种协议_吧,并不是文件格式,一般传输的是flv格式_视频,龙珠直播就… html5-dash-hls-rtmp: _HTML5播放_器、M3U8直播和点播、_RTMP_直播… 2018年11月17日 - HTML5播放_器、M3U8直播和点播、_RTMP_直播、低延迟、推流/播流地址鉴权、优化浏览器兼容性,HLS+扩展。 https://github.com/Tinywan/_html5-dash-hls-rtm… 前端页面播放 rtmp 流与 flv 格式_视频_文件__Html5__萬仟网 2018年10月12日 - 插件播放_flv格式类型,遇到的问题 40m 以下可以_播放_出来,超过一定_视频_文件大小就会…3 &lt;source [src]=”safeurl” type=’_rtmp_/flv’&gt; 4 _5 6 –… GitHub - Tinywan/html5-dash-hls-rtmp: _HTML5播放_器、M3U8直播/… 🌻 HTML5播放_器、M3U8直播/点播、_RTMP_直播、低…🐦 支持的直播流输入_协议 RTMP 用于拉取和发布的…自定义音频_播放_器的实现 HLS-iOS_视频播放_服务架构深入… html5_流媒体_协议 - 云+社区 - 腾讯云 最后,实现了一个基于 rtmp 协议… HTML5 html5_是超文本标记语言的第五次…对于_视频播放,可以使用 hls(http live streaming)_协议播放_直播流,ios 和 android… 基于_html5_的websocket和_rtmp协议_的java socket服务器 - 程序员… 现代企事业单位中,会涉及到数据推送和获取服务或者会需要用到socket连接的场景,例如订单推送,实时数据推送,实时视频,聊天等 1.提供基于_html5_的websocket/_rtmp协议_的… 如何在HTML_网页中嵌入流媒体_视频(rtmp协议)? - VoidCC 2017年12月26日 - 我找到了运行我自己的_rtmp_服务器的方法,我也有一个mp4_视频_。 使用VLC我可以使用_rtmp_文件,但我需要将_视频_嵌入_HTML_网页。 我看到以下链接:https://www.c… html5 – 适用于_RTMP_和支持广告的免费_视频播放_器 - 脚本之家 2019年5月6日 - 脚本之家收集整理的这篇文章主要介绍了html5 – 适用于_RTMP_和支持广告的免费_视频播放_器,脚本之家小编觉得挺不错的,现在分享给大家,也给大家做个参考。… video.js_实现_浏览器_播放rtmp协议_直播流的问题汗血宝马 2019年11月19日 - 使用video.js_实现rtmp_流的直播播放…&lt;!–controls 规定浏览器应该为_视频_提供…器不支持_HTML5播放_器的时候自动唤起flash_播放_器… _HTML5视频_元素对实时流媒体有什么支持? - IT屋-程序员软件开发… 2018年7月6日 - Flash_视频播放_器比HTML5视频_支持更多。例如, JW Player 支持: 3种_视频_文件类型:MP4,WebM和FLV。 3种音频文件类型:AAC,MP3和Vorbis 。 2流_协议:HLS和RT… 视频_技术详解:_RTMP H5 直播流技术解析__HTML5_ - UCloud云社区 HTML5_本文聚焦 _RTMP 协议_的最精华的内容,接进行实际操作 Buffer 的练习和协议的…主要是用来传递音_视频_流的。它通过一种自定义的协议,来完成对指定直播流的_播放… HTML5_下的_视频_会议系统中基于_RTMP_的直播解决方案的设计与_实现 本课题基于C公司_HTML5视频_会议直播需求对主流Web直播解决方案研究,利用_RTMP协议_和_HTML5_等技术设计并实现了一种新的解决方案,该方案不需任何插件且能保证较低的直播… 用html5+PHP+Websocket做_视频_直播后台推流的思路? 问题描述:想用_html5_+MSE+Websocket+PHP做_视频_直播的,搜索一番资料之后MSE这块搞明白了,关于服务端音_视频_流处理这块搞不懂。有的说用nginx+_rtmp_做推... …网页播放_器, 跨平台(_html5, mobile),flv, f4v, mp4, rtmp协议… 超酷flv网页播放_器 CKplayer V_5.7 2012-09-29 13:56 − 协议下的flv,f4v,mp4视频;2、支持_rtmp协议视频_流;3、支持rtmp协议下的视频回放 ;4、可以自己… _视频_推流模式HLS,HTTP,RTSP,_RTMP协议_的区别-布布扣-bubuko.com 2019年5月10日 - 在带宽充裕的前提下,live HTTP能够实现跟RTSP和RTMP_同样的流媒体_播放_效果,…超文本标识语言_HTML5_中,_视频_文件的点播,同样也采用了HTTP作为其承载_协议… 基于_html5_的websocket和_rtmp协议_的java socket服务器 - 记录曾经… 获取服务或者会需要用到socket连接的场景,例如订单推送,实时数据推送,实时视频,…1.提供基于_html5_的websocket/_rtmp协议_的socket实现多线程服务器 2.可使用标准等… …的视频_格式:http_协议_的flv,mp4,m3u8及_rtmp协议,默认使用html5… chplayer支持的视频_格式:http协议的flv,mp4,m3u8及_rtmp协议,默认使用html5-video,在不支持h5的情况下兼容使用flashplayer http://www.chplayer.com … javascript,_html5__对_rtmp_不是很了解～求一款可以支持_rtmp_的_播放_器… 对rtmp_不是很了解～求一款可以支持_rtmp_的_播放_器插件,或者源码,要求可以在pc端展示相关阅读:使用Laravel_5.3中的Scout,默认搜索是algolia,对中文的支持好吗?… 前端多媒体(7)—— 在浏览器中_实现rtmp_推流 - cowboykx - 博客园 2017年7月6日 - 而且HTML5_规范里面并没有针对_RTMP_的实现。毕竟这个_协议_标准是Adobe公司制定的。 …建立流推送以后把摄像流用_视频播放_器_播放 private function getPla… 【_html5_如何_实现_直播】-博文推荐-CSDN博客 2019年12月28日 - 以前很多靠html代码无法实现的效果现在都可以通过html5实现,如视频,音频,网页绘图…由于这种方案首先将RTSP协议对应的_视频_流转码成_RTMP协议_的_视频_流,因此延迟通常会… html5 - rtmp_推流,怎么_实现_不通过flash来_播放 - SegmentFault 思否 2019年10月11日 - 现在直播项目中使用的是ckplayer插件,_视频播放_有flash和_html5_两种方式,但_html5_不支持_rtmp_推流,所以必须用到flash,每次在浏览器中都要允许flash,现在想… videojs_播放rtmp_流,测试代码__html_ js 播放 rtmp 流文件,html… 博客 Videojs实现rtmp流播放 博客 HTML5实现播放RTMP协议视频 博客 开发rtmp直播流测试地址 博客 videojs集成–播放rtmp流 博客 Video.js 播放rtmp视频流 … PC端_播放rtmp_和hls_视频_流 - 简书 本文将会介绍如何在网页端上实现直播的播放_。 hls_播放…{}”&gt; &lt;source src=”rtmp://10.10.5.119/live…最后你就可以在上面的HTML_页面里src的地方添加你的_rt… 求使用_html5实现_hls流媒体_播放_的解决方案!!-CSDN论坛 2015年3月23日 - HLS流无法在web端播放解决方案(video.js) 今天遇到了这么个问题,在电脑上无法看…HTML5实现播放RTMP协议视频 HTML5实现播放RTMP… 求使用_html5实现_hls流媒体_播放_的解决方案!!-CSDN论坛 2015年3月23日 - HLS流无法在web端播放解决方案(video.js) 今天遇到了这么个问题,在电脑上无法看…HTML5实现播放RTMP协议视频 HTML5实现播放RTMP… html5 支持_rtmp_直播流吗_百度知道 2016年8月31日 - 回答：从html5_实现播放_的角度来说,实时流和vod没有多大区别,都是一个播放的url,更多的工作在底层对于html5的video标签的具体实现。 _rtmp__player rtmp播放_器,适用于_html5 联合开发网 - pudn.com 2017年11月30日 - 说明: rtmp播放_器,适用于_html5,可以_播放rtmp_的流,包含demo(RTMP player, apply to it, can play the RTMP flow, contains the demo) … 使用videojs + ckplayer 播放rtmp 流与 flv 格式_视频_文件 - 码农… 2018年10月12日 - 本文章向大家介绍使用videojs + ckplayer 播放rtmp 流与 flv 格式视频_文件,需要的朋友可以参考一下技术:angular/cli , _html5 , typescript , scss ,es… RTMP HLS HTTP 直播_协议_一次看个够 - DoubleLi - 博客园 2017年8月3日 - HTML5_也是无法直接_播放RTMP,因此你看到的很多手机网页上的直播,是由下面HLS来推…如果分发的量特别大,譬如点播视频_网站,没有直播的实时性要求,HTTP_协… 需要一款_html5_的 _播放_器,可_播放rtmp_流,hls流,MP4 文件,flv文件等… 2017年6月20日 - 直播与点播:ffmpeg+nginx-rtmp-module 0 回答 4199 阅读 网易_视频_云开发教程 3 回答 2131 阅读 从_Html5_直播到互动直播,看直播_协议_的选择 1 回答 … _html5_直播流_html 直播流_播放___html播放_rtp流 - 云+社区 - 腾讯云 video 标签播放 hls 协议视频: your browser does not support html5 video. …但是针对目前的网络直播主要是将h264转换成rtmp_流,用_rtmp_的服务器进行_播放,这块… html5-video.js _播放rtmp_直播流问题请教——CSDN问答频道 2019年5月31日 - 几个视频_源的路径也没有出来(香港卫视: _rtmp://…FFMpeng推rtsp流,想rtmp_和HLS_协议播放,rtmp_能_播放_的…了使用_html5_可以获取摄像头但是无法_实现rtmp… html5_和一些_播放_器都支持http_协议,提供基于_rtmp协议_等的流媒体… 2015年7月15日 - _html5_和一些_播放_器都支持http协议,提供基于_rtmp协议_等…暂时不可以,rtmp是adobe的私有协议,基本上是专门给flash… windows+nginx+ffmpeg_实现_移动端_html5_直播m3u8|jquery教程|jquery… 2016年1月23日 - web移动端不支持flash,所以_rtmp协议_的直播流就无法_播放_了,只支持基于HTTP协议的流…_html5_直播的video_视频_源如下: http://nginx服务IP:端口号/hls/te…","link":"/2020/05/26/HTML5%E5%AE%9E%E7%8E%B0%E6%92%AD%E6%94%BERTMP%E5%8D%8F%E8%AE%AE%E8%A7%86%E9%A2%91/"},{"title":"HTML编码规范","text":"1 前言 2 代码风格 2.1 缩进与换行 2.2 命名 2.3 标签 2.4 属性 3 通用 3.1 DOCTYPE 3.2 编码 3.3 CSS和JavaScript引入 4 head 4.1 title 4.2 favicon 4.3 viewport 5 图片 6 表单 6.1 控件标题 6.2 按钮 6.3 可访问性 (A11Y) 7 多媒体 8 模板中的 HTML 1 前言HTML作为描述网页结构的超文本标记语言，在百度一直有着广泛的应用。本文档的目标是使HTML代码风格保持一致，容易被理解和被维护。 2 代码风格2.1 缩进与换行[强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符。示例： 1234&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt; [建议] 每行不得超过 120 个字符。解释： 过长的代码不容易阅读与维护。但是考虑到 HTML 的特殊性，不做硬性要求。 2.2 命名[强制] class 必须单词全字母小写，单词间以 - 分隔。[强制] class 必须代表相应模块或部件的内容或功能，不得以样式信息进行命名。示例： 12345&lt;!-- good --&gt;&lt;div class=&quot;sidebar&quot;&gt;&lt;/div&gt;&lt;!-- bad --&gt;&lt;div class=&quot;left&quot;&gt;&lt;/div&gt; [强制] 元素 id 必须保证页面唯一。解释： 同一个页面中，不同的元素包含相同的 id，不符合 id 的属性含义。并且使用 document.getElementById 时可能导致难以追查的问题。 [建议] id 建议单词全字母小写，单词间以 - 分隔。同项目必须保持风格一致。[建议] id、class 命名，在避免冲突并描述清楚的前提下尽可能短。示例： 1234567891011121314&lt;!-- good --&gt;&lt;div id=&quot;nav&quot;&gt;&lt;/div&gt;&lt;!-- bad --&gt;&lt;div id=&quot;navigation&quot;&gt;&lt;/div&gt;&lt;!-- good --&gt;&lt;p class=&quot;comment&quot;&gt;&lt;/p&gt;&lt;!-- bad --&gt;&lt;p class=&quot;com&quot;&gt;&lt;/p&gt;&lt;!-- good --&gt;&lt;span class=&quot;author&quot;&gt;&lt;/span&gt;&lt;!-- bad --&gt;&lt;span class=&quot;red&quot;&gt;&lt;/span&gt; [强制] 禁止为了 hook 脚本，创建无样式信息的 class。解释： 不允许 class 只用于让 JavaScript 选择某些元素，class 应该具有明确的语义和样式。否则容易导致 css class 泛滥。 使用 id、属性选择作为 hook 是更好的方式。 [强制] 同一页面，应避免使用相同的 name 与 id。解释： IE 浏览器会混淆元素的 id 和 name 属性， document.getElementById 可能获得不期望的元素。所以在对元素的 id 与 name 属性的命名需要非常小心。 一个比较好的实践是，为 id 和 name 使用不同的命名法。 示例： 12345678910111213141516171819202122&lt;input name=&quot;foo&quot;&gt;&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;&lt;script&gt;// IE6 将显示 INPUTalert(document.getElementById('foo').tagName);&lt;/script&gt;````### 2.3 标签#### [强制] 标签名必须使用小写字母。示例：```html&lt;!-- good --&gt;&lt;p&gt;Hello StyleGuide!&lt;/p&gt;&lt;!-- bad --&gt;&lt;P&gt;Hello StyleGuide!&lt;/P&gt; [强制] 对于无需自闭合的标签，不允许自闭合。解释： 常见无需自闭合标签有input、br、img、hr等。 示例： 12345&lt;!-- good --&gt;&lt;input type=&quot;text&quot; name=&quot;title&quot;&gt;&lt;!-- bad --&gt;&lt;input type=&quot;text&quot; name=&quot;title&quot; /&gt; [强制] 对 HTML5 中规定允许省略的闭合标签，不允许省略闭合标签。解释： 对代码体积要求非常严苛的场景，可以例外。比如：第三方页面使用的投放系统。 示例： 1234567891011&lt;!-- good --&gt;&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;&lt;!-- bad --&gt;&lt;ul&gt; &lt;li&gt;first &lt;li&gt;second&lt;/ul&gt; [强制] 标签使用必须符合标签嵌套规则。解释： 比如 div 不得置于 p 中，tbody 必须置于 table 中。 详细的标签嵌套规则参见HTML DTD中的 Elements 定义部分。 [建议] HTML 标签的使用应该遵循标签的语义。解释： 下面是常见标签语义 p - 段落 h1,h2,h3,h4,h5,h6 - 层级标题 strong,em - 强调 ins - 插入 del - 删除 abbr - 缩写 code - 代码标识 cite - 引述来源作品的标题 q - 引用 blockquote - 一段或长篇引用 ul - 无序列表 ol - 有序列表 dl,dt,dd - 定义列表 示例： 12345&lt;!-- good --&gt;&lt;p&gt;Esprima serves as an important &lt;strong&gt;building block&lt;/strong&gt; for some JavaScript language tools.&lt;/p&gt;&lt;!-- bad --&gt;&lt;div&gt;Esprima serves as an important &lt;span class=&quot;strong&quot;&gt;building block&lt;/span&gt; for some JavaScript language tools.&lt;/div&gt; [建议] 在 CSS 可以实现相同需求的情况下不得使用表格进行布局。解释： 在兼容性允许的情况下应尽量保持语义正确性。对网格对齐和拉伸性有严格要求的场景允许例外，如多列复杂表单。 [建议] 标签的使用应尽量简洁，减少不必要的标签。示例： 1234567&lt;!-- good --&gt;&lt;img class=&quot;avatar&quot; src=&quot;image.png&quot;&gt;&lt;!-- bad --&gt;&lt;span class=&quot;avatar&quot;&gt; &lt;img src=&quot;image.png&quot;&gt;&lt;/span&gt; 2.4 属性[强制] 属性名必须使用小写字母。示例： 12345&lt;!-- good --&gt;&lt;table cellspacing=&quot;0&quot;&gt;...&lt;/table&gt;&lt;!-- bad --&gt;&lt;table cellSpacing=&quot;0&quot;&gt;...&lt;/table&gt; [强制] 属性值必须用双引号包围。解释： 不允许使用单引号，不允许不使用引号。 示例： 123456&lt;!-- good --&gt;&lt;script src=&quot;esl.js&quot;&gt;&lt;/script&gt;&lt;!-- bad --&gt;&lt;script src='esl.js'&gt;&lt;/script&gt;&lt;script src=esl.js&gt;&lt;/script&gt; [建议] 布尔类型的属性，建议不添加属性值。示例： 12&lt;input type=&quot;text&quot; disabled&gt;&lt;input type=&quot;checkbox&quot; value=&quot;1&quot; checked&gt; [建议] 自定义属性建议以 xxx- 为前缀，推荐使用 data-。解释： 使用前缀有助于区分自定义属性和标准定义的属性。 示例： 1&lt;ol data-ui-type=&quot;Select&quot;&gt;&lt;/ol&gt; 3 通用3.1 DOCTYPE[强制] 使用 HTML5 的 doctype 来启用标准模式，建议使用大写的 DOCTYPE。示例： 1&lt;!DOCTYPE html&gt; [建议] 启用 IE Edge 模式。示例： 1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; [建议] 在 html 标签上设置正确的 lang 属性。解释： 有助于提高页面的可访问性，如：让语音合成工具确定其所应该采用的发音，令翻译工具确定其翻译语言等。 示例： 1&lt;html lang=&quot;zh-CN&quot;&gt; 3.2 编码[强制] 页面必须使用精简形式，明确指定字符编码。指定字符编码的 meta 必须是 head 的第一个直接子元素。解释： 见 HTML5 Charset能用吗 一文。 示例： 123456789&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; ...... &lt;/head&gt; &lt;body&gt; ...... &lt;/body&gt;&lt;/html&gt; [建议] HTML 文件使用无 BOM 的 UTF-8 编码。解释： UTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。 3.3 CSS和JavaScript引入[强制] 引入 CSS 时必须指明 rel=&quot;stylesheet&quot;。示例： 1&lt;link rel=&quot;stylesheet&quot; src=&quot;page.css&quot;&gt; [建议] 引入 CSS 和 JavaScript 时无须指明 type 属性。解释： text/css 和 text/javascript 是 type 的默认值。 [建议] 展现定义放置于外部 CSS 中，行为定义放置于外部 JavaScript 中。解释： 结构-样式-行为的代码分离，对于提高代码的可阅读性和维护性都有好处。 [建议] 在 head 中引入页面需要的所有 CSS 资源。解释： 在页面渲染的过程中，新的CSS可能导致元素的样式重新计算和绘制，页面闪烁。 [建议] JavaScript 应当放在页面末尾，或采用异步加载。解释： 将 script 放在页面中间将阻断页面的渲染。出于性能方面的考虑，如非必要，请遵守此条建议。 示例： 1234&lt;body&gt; &lt;!-- a lot of elements --&gt; &lt;script src=&quot;init-behavior.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; [建议] 移动环境或只针对现代浏览器设计的 Web 应用，如果引用外部资源的 URL 协议部分与页面相同，建议省略协议前缀。解释： 使用 protocol-relative URL 引入 CSS，在 IE7/8 下，会发两次请求。是否使用 protocol-relative URL 应充分考虑页面针对的环境。 示例： 1&lt;script src=&quot;//s1.bdstatic.com/cache/static/jquery-1.10.2.min_f2fb5194.js&quot;&gt;&lt;/script&gt; 4 head4.1 title[强制] 页面必须包含 title 标签声明标题。[强制] title 必须作为 head 的直接子元素，并紧随 charset 声明之后。解释： title 中如果包含 ascii 之外的字符，浏览器需要知道字符编码类型才能进行解码，否则可能导致乱码。 示例： 1234&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面标题&lt;/title&gt;&lt;/head&gt; 4.2 favicon[强制] 保证 favicon 可访问。解释： 在未指定 favicon 时，大多数浏览器会请求 Web Server 根目录下的 favicon.ico 。为了保证favicon可访问，避免404，必须遵循以下两种方法之一： 在 Web Server 根目录放置 favicon.ico 文件。 使用 link 指定 favicon。 示例： 1&lt;link rel=&quot;shortcut icon&quot; href=&quot;path/to/favicon.ico&quot;&gt; 4.3 viewport[建议] 若页面欲对移动设备友好，需指定页面的 viewport。解释： viewport meta tag可以设置可视区域的宽度和初始缩放大小，避免在移动设备上出现页面展示不正常。 比如，在页面宽度小于 980px 时，若需 iOS 设备友好，应当设置 viewport 的 width 值来适应你的页面宽度。同时因为不同移动设备分辨率不同，在设置时，应当使用 device-width 和 device-height 变量。 另外，为了使 viewport 正常工作，在页面内容样式布局设计上也要做相应调整，如避免绝对定位等。关于 viewport 的更多介绍，可以参见 Safari Web Content Guide的介绍 5 图片[强制] 禁止 img 的 src 取值为空。延迟加载的图片也要增加默认的 src。解释： src 取值为空，会导致部分浏览器重新加载一次当前页面，参考：https://developer.yahoo.com/performance/rules.html#emptysrc [建议] 避免为 img 添加不必要的 title 属性。解释： 多余的 title 影响看图体验，并且增加了页面尺寸。 [建议] 为重要图片添加 alt 属性。解释： 可以提高图片加载失败时的用户体验。 [建议] 添加 width 和 height 属性，以避免页面抖动。[建议] 有下载需求的图片采用 img 标签实现，无下载需求的图片采用 CSS 背景图实现。解释： 产品 logo、用户头像、用户产生的图片等有潜在下载需求的图片，以 img 形式实现，能方便用户下载。 无下载需求的图片，比如：icon、背景、代码使用的图片等，尽可能采用 css 背景图实现。 6 表单6.1 控件标题[强制] 有文本标题的控件必须使用 label 标签将其与其标题相关联。解释： 有两种方式： 将控件置于 label 内。 label 的 for 属性指向控件的 id。 推荐使用第一种，减少不必要的 id。如果 DOM 结构不允许直接嵌套，则应使用第二种。 示例： 123&lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;confirm&quot; value=&quot;on&quot;&gt; 我已确认上述条款&lt;/label&gt;&lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;textbox&quot; name=&quot;username&quot; id=&quot;username&quot;&gt; 6.2 按钮[强制] 使用 button 元素时必须指明 type 属性值。解释： button 元素的默认 type 为 submit，如果被置于 form 元素中，点击后将导致表单提交。为显示区分其作用方便理解，必须给出 type 属性。 示例： 12&lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;button type=&quot;button&quot;&gt;取消&lt;/button&gt; [建议] 尽量不要使用按钮类元素的 name 属性。解释： 由于浏览器兼容性问题，使用按钮的 name 属性会带来许多难以发现的问题。具体情况可参考此文。 6.3 可访问性 (A11Y)[建议] 负责主要功能的按钮在 DOM 中的顺序应靠前。解释： 负责主要功能的按钮应相对靠前，以提高可访问性。如果在 CSS 中指定了 float: right 则可能导致视觉上主按钮在前，而 DOM 中主按钮靠后的情况。 示例： 12345678910111213141516171819202122232425&lt;!-- good --&gt;&lt;style&gt;.buttons .button-group { float: right;}&lt;/style&gt;&lt;div class=&quot;buttons&quot;&gt; &lt;div class=&quot;button-group&quot;&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;button&quot;&gt;取消&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- bad --&gt;&lt;style&gt;.buttons button { float: right;}&lt;/style&gt;&lt;div class=&quot;buttons&quot;&gt; &lt;button type=&quot;button&quot;&gt;取消&lt;/button&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/div&gt; [建议] 当使用 JavaScript 进行表单提交时，如果条件允许，应使原生提交功能正常工作。解释： 当浏览器 JS 运行错误或关闭 JS 时，提交功能将无法工作。如果正确指定了 form 元素的 action 属性和表单控件的 name 属性时，提交仍可继续进行。 示例： 1234&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;p&gt;&lt;input name=&quot;username&quot; type=&quot;text&quot; placeholder=&quot;用户名&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;密码&quot;&gt;&lt;/p&gt;&lt;/form&gt; [建议] 在针对移动设备开发的页面时，根据内容类型指定输入框的 type 属性。解释： 根据内容类型指定输入框类型，能获得能友好的输入体验。 示例： 1&lt;input type=&quot;date&quot;&gt; 7 多媒体[建议] 当在现代浏览器中使用 audio 以及 video 标签来播放音频、视频时，应当注意格式。解释： 音频应尽可能覆盖到如下格式： MP3 WAV Ogg 视频应尽可能覆盖到如下格式： MP4 WebM Ogg [建议] 在支持 HTML5 的浏览器中优先使用 audio 和 video 标签来定义音视频元素。[建议] 使用退化到插件的方式来对多浏览器进行支持。示例： 123456789101112131415&lt;audio controls&gt; &lt;source src=&quot;audio.mp3&quot; type=&quot;audio/mpeg&quot;&gt; &lt;source src=&quot;audio.ogg&quot; type=&quot;audio/ogg&quot;&gt; &lt;object width=&quot;100&quot; height=&quot;50&quot; data=&quot;audio.mp3&quot;&gt; &lt;embed width=&quot;100&quot; height=&quot;50&quot; src=&quot;audio.swf&quot;&gt; &lt;/object&gt;&lt;/audio&gt;&lt;video width=&quot;100&quot; height=&quot;50&quot; controls&gt; &lt;source src=&quot;video.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;video.ogg&quot; type=&quot;video/ogg&quot;&gt; &lt;object width=&quot;100&quot; height=&quot;50&quot; data=&quot;video.mp4&quot;&gt; &lt;embed width=&quot;100&quot; height=&quot;50&quot; src=&quot;video.swf&quot;&gt; &lt;/object&gt;&lt;/video&gt; [建议] 只在必要的时候开启音视频的自动播放。[建议] 在 object 标签内部提供指示浏览器不支持该标签的说明。示例： 1&lt;object width=&quot;100&quot; height=&quot;50&quot; data=&quot;something.swf&quot;&gt;DO NOT SUPPORT THIS TAG&lt;/object&gt; 8 模板中的 HTML[建议] 模板代码的缩进优先保证 HTML 代码的缩进规则。示例： 123456789101112131415161718192021&lt;!-- good --&gt;{if $display == true}&lt;div&gt; &lt;ul&gt; {foreach $item_list as $item} &lt;li&gt;{$item.name}&lt;li&gt; {/foreach} &lt;/ul&gt;&lt;/div&gt;{/if}&lt;!-- bad --&gt;{if $display == true} &lt;div&gt; &lt;ul&gt; {foreach $item_list as $item} &lt;li&gt;{$item.name}&lt;li&gt; {/foreach} &lt;/ul&gt; &lt;/div&gt;{/if} [建议] 模板代码应以保证 HTML 单个标签语法的正确性为基本原则。示例： 12345&lt;!-- good --&gt;&lt;li class=&quot;{if $item.type_id == $current_type}focus{/if}&quot;&gt;{ $item.type_name }&lt;/li&gt;&lt;!-- bad --&gt;&lt;li {if $item.type_id == $current_type} class=&quot;focus&quot;{/if}&gt;{ $item.type_name }&lt;/li&gt; [建议] 在循环处理模板数据构造表格时，若要求每行输出固定的个数，建议先将数据分组，之后再循环输出。示例： 1234567891011121314151617181920212223&lt;!-- good --&gt;&lt;table&gt; {foreach $item_list as $item_group} &lt;tr&gt; {foreach $item_group as $item} &lt;td&gt;{ $item.name }&lt;/td&gt; {/foreach} &lt;tr&gt; {/foreach}&lt;/table&gt;&lt;!-- bad --&gt;&lt;table&gt;&lt;tr&gt; {foreach $item_list as $item} &lt;td&gt;{ $item.name }&lt;/td&gt; {if $item@iteration is div by 5} &lt;/tr&gt; &lt;tr&gt; {/if} {/foreach}&lt;/tr&gt;&lt;/table&gt;","link":"/2019/11/22/HTML%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"title":"1.JS系列js 获取子数组","text":"[JavaScript] 使用 slice() _获取子数组__JavaScript_Rom 2019年2月17日 - _js_之slice()方法 阅读数 7717 slice()通过索引位置_获取_新的数组,该方法不会修改原数组,只是返回一个新的_子数组_。用法:arrayObj.slice(start,end)arra… JS Array.slice 截取_数组_的实现方法_javascript技巧_脚本之家 2016年1月2日 - 这篇文章主要介绍了JS Array.slice 截取_数组_的实现方法,因为我们需要控制一下长度,需要的朋友可以参考下slice定义和用法slice() 方法可从已有的_数组_中… JS:二维_数组_排序和_获取子_级元素 - destinyruru - 博客园 2016年9月2日 - JS:二维_数组_排序和_获取子_级元素 1. 二维_数组_排序 1.按数值排序 1 var arr …其实是_数组_依次将_数组_元素复制给x,y,比如首先将arr[0]赋给x,arr[1]赋给y,… js 数组 子数组___js_ 删除_子数组___js 获取子数组 - 云+社区 - 腾讯云 ()功能:_获取_原数组的片段或_子数组_输入:片段的开始和结束输出:返回的数组包含第…_js_学习总结 设置该对象的属性不能被删除四:创建数组:创建数组有两种写法:1 var… _JS获取_json子项/_数组_的个数/长度 - IT-Why - CSDN博客 2018年12月28日 - @_JS获取_json子项/_数组_的个数/长度微信小程序_获取_json格式数据的个数/长度varjson={data:[a,b,c]}length=Object.keys(json.data).lengthvarjson={name:… _js_中实现截取_数组_的后几个元素作为一个新_数组_的方法 - 贝…_博客园 2018年10月25日 - (‘sliceArr ‘,sliceArr) // 得到[34,0,56,12,2] // slice(start,end)…原数组_变成了除了删除的元素剩下的元素集合。 标签: _js, _数组_截取, 后几个,… 如何_获得_在JavaScript两个_数组_的子集? - IT屋-程序员软件开发技术… 2016年6月1日 - 具体来说,code,它把的for..in ,就像它遍历_数组_元素的索引(不,它看起来通过的对象属性名)会搞的一团糟。 (这可能是为什么jQuery的没有做到这一点。) 活… _JS_里面如何_获取数组_里面的对象的值?-CSDN论坛 //从第二个tr子节点开始进行显示 for(var k=2;…楼主的代码主要是usernum++的顺序写到在了你获取_其…_js _获取数组_里的对象 数据格式 columns: [{title:… 如何_获取_JavaScript_数组_的所有子字符串(连续子序列)? - 问答 - 云… 2018年9月19日 - 如何获取_JavaScript_数组_的所有子字符串(连续子序列)?…对于内部_数组,可以从外部数组_的索引开始 ​ var _array… javascript - js _数组子_级id_获取_父级数据 - SegmentFault 思否 2019年9月26日 - 我拿到questionDetails_数组_下标0项中的id(210),怎么根据id(210) _获取_它父级的这个 smallTitalId(1002)这个是多选框 _JS_中如何_获取数组_中的一部分元素-百度经验 2019年12月23日 - JS_中如何_获取数组_中的一部分元素,在j中,可以使用for语句遍历_数组,通过if语句判断下标,把指定的一部分数组_元素取出来。下面小编举例讲解_JS_中如何_获取数… _JS数组_和子集_技术交流_牛客网 1.js数组 一、.数组_概念 _数组_是值的有序结合。每个值叫做一个元素,而每个元素在_数组_中都有一个位置,用数字表示,称为索引。二、关于_JS_中的_数组_特点 1._数组… js _获取_json_数组_里面_数组_的长度实例 - 脚本之家 2019年1月7日 - 下面小编就为大家带来一篇js _获取_json_数组_里面_数组_的长度实例。小编觉得挺不错的,现在就分享给大家,也给大家做个参考。一起跟随小编过来看看吧 _JS获取数组_长度(length属性) 在JS 中_获取数组_长度非常简单,每个_数组_都有一个 length 属性,该属性返回_数组_的最大长度,即其值等于最大下标值加 1。由于数字下标必须小于 2^32-1,所以 length… JavaScript Array 对象 new Array(); new Array(size); new Array(element0, element1, …, elementn); 参数 参数size 是期望的数组_元素个数。返回的_数组,length 字段将被设为… js 怎么去除_数组子_对象的双引号? - ITeye问答 js 怎么去除_数组子_对象的双引号?5 Java代码 Ext….不然取不到key1,key2及其对应的值。 问题补充:…”goods_factory”:”勃林格殷格翰美国子公司(密苏里州… 「_数组_长度」_JS获取_json子项/_数组_的个数/长度 - seo实验室 2019年9月10日 - _JS获取_json子项/_数组_的个数/长度 时间:2019-09-10 09:10:00来源:IT… 3 //_获取_4 … 找出最接近零值的子数组(_js_实现) - 简书 2018年5月17日 - MAX_VALUE; // 保证所有的零值_子数组_都_获取_到 // 如果只需_得到_一个的话,直接使用一个对象保存最小结果即可。 let minArr=[]; for(let i=0, len = … _js获取数组_的最后一个元素 - 田珊珊个人博客 2020年3月12日 - 下面是_js获取数组_最后一个元素的三种方式 一、JavaScript pop() 方法 pop() 方法用于删除并返回_数组_的最后一个元素。 注意:pop() 方法将删除 _array_Obj… js Array.slice的8种不同用法示例_javascript技巧_脚本之家 2019年7月10日 - 这篇文章主要给大家介绍了关于js Array.slice的8种不同用法,文中通过示例代码…用法2:获取_从 N 开始的_子数组 使用slice方法最简单的方法就是原始数组… _js_如何_获取_某id的子标签 - 小豫 - 博客园 2016年6月25日 - js_如何_获取_某id的子标签 思路:根据id_获取_父对象,然后使用childNodes_获取_所有子对象_数组,关键代码: document.getElementById(div_id).childNodes; // … _js获取数组_的最后一个元素_javascript技巧_脚本之家 2015年4月14日 - 这篇文章主要介绍了javascript_获取数组_的最后一个元素,需要的朋友可以参考下… (1)_js_内置pop方法pop() 方法用于删除并返回_数组_的最后一个元素,注意这… js_将一个_数组_分割成多个_子数组(数组拆分) - voice的博客 - CSDN博客 2019年11月13日 - js_将一个数组分割成多个_子数组 阅读数 5729 在做一个项目的时候需要将_得到_的json数据分组显示,于是自己写了个算法。将一个长数组分割成许多小数组保… _js数组_对象的父数据对象-_子数组_对象,(数组对象相减) - 一…_博客园 2017年11月3日 - _js_数组对象的父数据对象-_子数组_对象,(数组对象相减) Title var gridData_1=[{“name”:”123”,age:12},{“name”:”124”,age:13},{“name… js _取数组_中某个对象的集合 - abcByme - 博客园 2018年4月19日 - 5. js _取数组_中某个对象的集合(9194) 6. _js_正…12. jQuery 父iframe与子iframe 相互调用传值(5695… _js_将一个_数组_分割成多个_子数组__WLittleyang的博客-CSDN博客 2018年11月1日 - js_将一个数组分割成多个_子数组 原创 Luck Yang 发布于2018-11-01 16:25:57 阅读数 6733 收藏 展开 在做一个项目的时候需要将_得到_的json数据分组显示,… JS Array.slice 截取_数组_的实现方法 - 枫小秋 的博客_CSDN博客 2018年8月7日 - 这篇文章主要介绍了JS Array.slice 截取数组_的实现方法,因为我们需要控制一下长度,需要的朋友可以参考下 slice定义和用法 slice() 方法可从已有的_数组… javascript _数组获取_最大的指定个数的子集 - weixin_43…_CSDN博客 2019年7月18日 - 如果在JS_中想_得到_某个元素下的所有子元素,最好的方式还是使用childNodes属性。至于…给定一个_数组,求_数组_的全排列和全子集,暴力枚举法。1,求不含重复… _js_递归调用_获取_等于子集的该子集对应所有父集的一条链…_CSDN论坛 js_递归调用_获取_等于子集的该子集对应所有父集的一条链的信息 [问题点数:40…对于一个给定的_数组,从中选择一个元素,以该元素为界将其余元素划分为两个子集… js 模糊查询元素_JS获取子_、父、兄节点方法小结-JavaScript-第二… 2019年6月24日 - parentObj.childNodes 获取_已知父节点的子节点_数组(这里我在IE 7中获取_的是所有…你可能感兴趣的_JS,小结,节点,获取,方法 PHP_获取_文件扩展名的常用方… _js_删除_数组_里的某个元素-前端开发博客 2018年9月5日 - _js_删除_数组_的某个元素,_js_删除_数组_的某一项,JavaScript删除_数组_指定元素。其实都是通过_数组_的一个方法splice来对_数组_进行删除操作。 node._js获取_mongodb中_数组子_文档中的一个元素?_慕课猿问 2019年6月8日 - node._js获取_mongodb中_数组子_文档中的一个元素可以考虑使用聚合函数来实现。参考代码:{$match:{‘duid’:15}},{$project:{duid:1,”default”:1}},{$unwind… _JS_如何_获取_对象_数组_的某个属性集合?-CSDN论坛 2016年8月12日 - _js获取数组_对象中某个属性的最大值或最小值 最近的开发中经常会遇到前端自己生成唯一id,然后在_数组_中增加删除插入对象,这样一来就要的要当前使用的id… 父窗口取子_窗口的 _js 数组 - Javascript教程__JS_教程_技…_红黑联盟 2014年9月12日 - 父窗口取子_窗口的 _js _数组_2014-09-12 08:18:49 收藏 我要投稿 现在这个系统,用到了大量的选择器 和 自动完成,凭借我的三寸不烂之手, 将这些选择器 和 … _js数组_中如何随机取出一个值 - JavaScript 2019年8月3日 - 这篇文章主要介绍了_js数组_中如何随机取出一个值,需要的朋友可以参考下… _js数组_中如何随机取出一个值2019/8/3 13:24:03 0 人评论 834 次浏览 分类:JavaScript… _JS_如何取多维_数组_值? - 知乎 2018年3月22日 - JS取_VB_ARRAY_的一维_数组_可以 :var vArr = new VB_Array(obj_Array_);//obj_Array_为VB_ARRAY_一维数组 var retV… javascript-_JS_中如何从_数组_中_获取_自己想要的值?——CSDN问答频道 2016年8月2日 - _JS_中如何从_数组_中_获取_自己想要的值? 如题 还请大神指点指点 谢谢 找到合适的值 window.onload = function (){ var arr = [ ‘100p… _js获取_最后_数组___js数组获取_最后__js取数组_最后一个 - 云+社区… ()功能:获取_原数组的片段或_子数组_输入:片段的开始和结束输出:返回的数组包含第…数组是最简单的内存数据结构,_js_中以及几乎所有的语言都支持数组类型,所以学好_js… _JS_如何_获取_对象_数组_的某个属性集合?-CSDN论坛 2016年8月12日 - _js获取_对象属性值 对象属性值的_获取_方法,取决于对象属性名的类型。收藏帖子 匿名用户不能发表回复!查看全部 _js数组_中含有多个对象,怎么根据对象的一个… _js_怎么_获取数组_长度-问答-阿里云开发者社区-阿里云 2019年7月17日 - _js_怎么_获取数组_长度JavaScript 添加回答 分享到 全部回答(3) linggong3212345 2019-07-17 22:10:32 var a = []; vat len = a.length 0 0 wintsu … JavaScript _获取数组_的最后一个元素方法(多种) - 简书 2018年8月23日 - pop方法删除并返回_数组_的最后一个元素,注意该方法在_获取_了_数组_的最后一个元素的同时也将原_数组_的最后一…_JS_基本数据类型及变量声明在_js_中有三种声明… js _获取_json_数组_里面_数组_的长度实例_javascript技巧_脚本之家 2017年10月31日 - 下面小编就为大家带来一篇js _获取_json_数组_里面_数组_的长度实例。小编觉得挺不错的,现在就分享给大家,也给大家做个参考。一起跟随小编过来看看吧 _JS_里面如何_获取数组_里面的对象的值?-CSDN论坛 //从第二个tr子节点开始进行显示 for(var k=2;…楼主的代码主要是usernum++的顺序写到在了你获取_其…_JS _数组_取值 1.以对象方式取 let aa = [] aa[… _js获取数组_的名字 - 云+社区 - 腾讯云 不错的node._js_入门 我们可以用从关联_数组_中_获取_元素一样的方式从传递的对象中_获取_请求处理函数,因此就有了简洁流畅的形如handle(); 的表达式,这个感觉就像在前方中… javascript - 有什么方法可以在_数组_里面的_子数组_加一个对象呢… 2019年3月26日 - B_数组_是一个权限配置 如果B_数组_中的menuList的对象的menuId等于A_数组_的subList的对象的menuId时 在A_数组_的subList的对象中加入一个{getPermit:true};… JS_截取_数组:使用splice()和slice()方法 JS 截取数组(_得到数组_片段)的方法有两种,分别是使用 splice() 和 slice() …() 方法功能相近,但是它仅能够截取数组中指定区段的元素,并返回这个_子数组_。… _js_中split()方法_得到_的_数组_长度问题_javascript技巧_脚本之家 2018年7月19日 - split() 方法用于把一个字符串分割成字符串_数组_。这篇文章给大家介绍_js_中split()方法_得到_的_数组_长度问题,感兴趣的朋友一起看看吧定义和用法 split() … JavaScript slice() 方法 请注意,该方法并不会修改数组,而是返回一个_子数组_。如果想删除数组中的一段元素,应该使用方法 Array.splice()。提示和注释 注释:您可使用负值从数组的尾部选取元素… js 数组_相减 (一个_数组_去掉不符合条件的_子数组) - 小金子V - 博客园 2017年1月10日 - _数组_相减?我也希望将来在ES8或者更好_js_版本能带来_数组_之间相互运算的方法,但是现在不能,咱们只能靠已有的方法实现; var arr1 = [2,3,5,88,99,444,66],… js _获取_json_数组_里面_数组_的长度 - 柠夏 - 博客园 2017年10月30日 - 作为一个前端页面开发者第一次处理json数据,遇到了‘js _获取_json_数组_里面_数组_的长度’?竟然不知道 json没有.length属性(真是要嘲讽下自己),少壮不努力… _js获取数组_中的id值及name值从而显示城市列表 - 文章 2015年12月25日 - var newStr=new Array(); newStr.push(“ “); //newStr.push(“ “+province[val1].NAME+” “); newStr.push(“ “+city[val].NAME+” “); for(var … _js数组_中如何随机取出一个值_javascript技巧_脚本之家 2014年6月13日 - 这篇文章主要介绍了_js数组_中如何随机取出一个值,需要的朋友可以参考下… 这篇文章主要介绍了_js数组_中如何随机取出一个值,需要的朋友可以参考下复制代… _js取数组_数据__js取数组_数据类型__js取_后台_数组_数据 - 云+社区… d3_js_从多维_数组获取_数据。(1 个回答) 我正在编写d3_js_甜甜圈图,并试图从多维_数组_中输入数据:小提琴 topholders_array_的输出:{1:{address:0xd35a2d8c651f3eba4f0a044db96… js _获取数组_最后一个元素 - Sorr - 博客园 2018年12月21日 - js _获取数组_最后一个元素 当然有很多中做法 我这边就随便写几个最常用 最简单的方法把 1 # shift 2 删除_数组_第一个元素,并返回该元素,跟pop差不多 3 v…","link":"/2020/04/06/JS%E7%B3%BB%E5%88%97js-%E8%8E%B7%E5%8F%96%E5%AD%90%E6%95%B0%E7%BB%84/"},{"title":"Java 面试题系列 1","text":"Java 面试题系列一1. 简介本文包含一些有关核心 Java 的最重要工作面试问题的答案。其中一些问题的答案可能并不明显，因此本文将有助于澄清问题。 2. 初学者的核心Java语言问题问题 1.数据是通过引用传递的还是按 Java 中的值传递的？虽然这个问题的答案很简单，但这个问题对初学者来说可能令人困惑。首先，让我们澄清问题所在： 传递值 –这意味着我们将对象的副本作为参数传递到方法中。 通过引用传递 –这意味着我们将对对象的引用作为参数传递到方法中。 为了回答这个问题，我们必须分析两个案例。它们表示两种类型的数据，我们可以传递给方法：基元和对象。 当我们将基元传递给方法时，其值将复制到新变量中。当涉及到对象时，引用的值将复制到新变量中。因此，我们可以说Java是一种严格的_逐种语言_。 我们可以在我们的一篇文章中更多地了解这一点：在Java中传递值作为参数传递机制。 问题 2.导入和静态导入之间的区别是什么？我们可以使用常规导入导入特定类或不同包中定义的所有类： 123456789101112131415importjava.util.ArrayList;//specific classimportjava.util.*;//all classes in util package 我们还可以使用它们导入封闭类的公共嵌套类： 12345importcom.baeldung.A.* 但是，我们应该知道上面的导入不会导入类_A_本身。 还有一些静态导入，使我们能够导入静态成员或嵌套类： 123456importstaticjava.util.Collections.EMPTY_LIST; 其效果是，我们可以使用静态变量EMPTY_LIST而不预处理完全限定的类名称，即好像它是在当前类中声明的一样。 问题 3.哪些访问修改器在 Java 中可用，它们的目的是什么？_Java_中有四个访问修改器： 私人 _默认值_（包） 保护 公共 _专用_修饰符确保类成员在类外部无法访问。它可以应用于方法、属性、构造函数、嵌套类，但不能应用于顶级类本身。 与_私有_修改器不同，我们可以将_默认_修改器应用于所有类型的类成员和类本身。我们可以通过根本不添加任何访问修改器来应用_默认_可见性。如果我们使用_默认_可见性，我们的类或其成员将只能在类的包内访问。我们应该记住，默认访问修改器与_默认_关键字没有任何共同之处。 与_默认_修改器类似，一个包中的所有类都可以访问_受保护的_成员。此外，_受保护的_修改器允许子类访问超级类的受保护成员，即使它们不在同一个包中也是如此。我们不能将此访问修改器应用于类，而只能应用于类成员。 _公共_修改符可以与类关键字和所有类成员一起使用。它使类和类成员在所有包和所有类中都可以访问。 我们可以在Java 访问修改器一文中了解更多信息。 问题 4.哪些其他修改器在 Java 中可用，它们的目的是什么？Java 中还有五个其他修改器： 静态 最后 抽象 同步 挥发 性 这些不能控制可见性。 首先，我们可以将_静态_关键字应用于字段和方法。静态字段或方法是类成员，而非静态字段是对象成员。类成员不需要调用任何实例。它们使用类名称而不是对象引用名称调用。本文详细介绍了_静态_关键字。 然后，我们有_最后_关键字。我们可以将其用于字段、方法和类。当_在_字段上使用 final 时，这意味着无法更改字段引用。因此，无法将其重新分配给其他对象。当_最终_应用于类或方法时，它向我们保证该类或方法不能扩展或重写。本文将更详细地解释_最终_关键字。 下一个关键字是_抽象_的。这可以描述类和方法。当类是_抽象_的时，它们无法实例化。相反，它们被分类。当方法是_抽象_的时，它们没有实现，可以在子类中重写它们。 _同步_关键字可能是最先进的。我们可以将其与实例以及静态方法和代码块一起使用。当我们使用此关键字时，我们让 Java 使用监视器锁来提供给定代码片段的同步。有关_同步_的详细信息，请参阅本文。 我们要讨论的最后一个关键字是_不稳定的_。我们只能将其与实例字段一起使用。它声明字段值必须读取和写入主内存 - 绕过 CPU 缓存。可变变量的所有读取和写入都是原子的。本文详细介绍了易失性关键字。 问题 5.JDK、JRE 和 JVM 之间的区别是什么？_JDK_代表_Java开发工具包_，这是开发人员在Java中编写应用程序所需的一组工具。JDK 环境有三种类型： 标准版 + 开发套件，用于创建便携式桌面或服务器应用程序 企业版 – 支持分布式计算或 Web 服务的标准版扩展 嵌入式和移动应用的微型版和开发平台 JDK 中包含了大量的工具，可帮助程序员编写、调试或维护应用程序。最流行的是编译器 （_javac_）， 解释器 （_java_）， 一个归档器 （_jar_） 和文档生成器 （_javadoc_）. _JRE_是一个_Java运行时环境_。它是 JDK 的一部分，但它包含运行 Java 应用程序的最小功能。它由_Java虚拟机_、核心类和支持文件组成。例如，它没有任何编译器。 _JVM_是_Java虚拟机_的首字母缩写词，它是一种能够运行编译为字节码的程序的虚拟机。JVM 规范对此进行了描述，因为确保不同实现之间的互操作性非常重要。JVM最重要的功能是使用户能够将同一Java应用程序部署到不同的操作系统和环境，而不必担心下面是什么。 有关详细信息，我们来查看JVM、JRE 和 JDK文章之间的差异。 问题 6.堆栈和堆之间的区别是什么？内存有两个部分，其中 JVM 存储所有变量和对象。第一个是_堆栈_，第二个是_堆_。 _堆栈_是 JVM 为本地变量和其他数据保留块的地方。堆栈是一个_LIFO（_最后一个在先出）结构。这意味着，每当调用方法时，都会为局部变量和对象引用保留一个新块。每个新方法调用都保留下一个块。当方法完成执行时，块以相反的方式释放它们。 每个新线程都有自己的堆栈。 我们应该知道，堆栈的内存空间比堆少得多。当堆栈已满时，JVM 将抛出_堆栈溢出错误_。当有一个坏的递归调用，并且递归太深时，它可能发生。 每个新对象都是在 Java _h__eap_上创建的，该对象用于动态分配。有一个_g__arbage收集器_，负责删除未使用的对象，这些对象分为年轻（苗圃）和旧空间。对堆的内存访问比对堆栈的访问慢。堆已满时，JVM 会引发_内存错误_。 我们可以在 Java 文章中的堆栈内存和堆空间中找到更多详细信息。 问题 7._可比_接口和_比较接口_之间的区别是什么？有时，当我们编写一个新类时，我们希望能够比较该类的对象。当我们想要使用已排序的集合时，它特别有用。我们可以有两种方法可以做到这一点：使用_可比较_接口或_比较器_接口。 首先，让我们来看看_可比_接口： 1234567891011121314151617publicinterfaceComparable&lt;T&gt; {intcompareTo(T var1);} 我们应该通过要排序的对象的类实现该接口。 它有_比较To（）_方法，并返回一个整数。它可以返回三个值：-1、0 和 1，这意味着此对象小于、等于或大于比较的对象。 值得一提的是，重写_的比较T0（）_方法应该与_等（）_法一致。 另一方面，我们可以使用_比较器_接口。它可以传递到_集合_接口的_sort（）_方法或实例化排序集合时。这就是为什么它主要用于创建一次性排序策略。 此外，当我们使用不实现可比较接口的第三方类时，它也是有用的。 与_比较To（）_方法一样，重写_的比较（）_方法应与_等值（）_方法一致，但它们可以选择允许与 null 进行比较。 有关详细信息，请访问Java 中的比较器和可比性文章。 问题 8.什么是_空隙_类型，我们何时使用它？每次在 Java 中编写方法时，它必须具有返回类型。如果我们想要该方法返回不返回值，我们可以使用_void_关键字。 我们也应该知道，有一个_虚空_类。它是一个占位符类，可用于，例如，在使用泛型时。_虚空_类既不能实例化，也不能扩展。 问题 9.对象类的方法是什么，它们的作用是什么？了解_Object_类包含哪些方法以及它们的工作原理非常重要。当我们想要重写这些方法时，它也非常有用： 克隆（） = 返回此对象的副本 等于（） = 当此对象等于作为参数传递的对象时返回true finalize（） = 垃圾回收器在清理内存时调用此方法 getClass（） = 返回此对象的运行时类 哈希码（） = 返回此对象的哈希代码。我们应该知道，它应该与_等（）_法一致 通知（） - 向等待对象的监视器的单个线程发送通知 通知 All（） = 向所有等待对象监视器的线程发送通知 到String（） = 返回此对象的字符串表示形式 wait（） = 此方法有三个重载版本。它强制当前线程等待指定的时间量，直到另一个线程调用通知（）_或_通知此对象上的 All（）。 问题 10.什么是枚举和我们如何使用它？_Enum_是一种类类型，它允许开发人员指定一组预定义的常量值。要创建这样的类，我们必须使用_枚举_关键字。让我们想象一下一周中的天数： 12345678910111213141516publicenumDay {SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY} 为了迭代所有常量，我们可以使用静态_值（）_方法。此外，枚举使我们能够定义成员，如属性和方法，如常规类。 虽然它是一种特殊的类，但我们不能对它进行子类。但是，枚举可以实现接口。 _枚举_的另一个有趣的优点是，它们是线程安全的，因此它们被普遍用作单例。 我们可以在我们的指南中找到更多关于枚举。 问题 11.什么是JAR？_JAR_是_Java存档_的快捷方式。它是使用 ZIP 文件格式打包的存档文件。我们可以用它来包括应用程序所需的类文件和辅助资源。它具有许多功能： 安全性 –我们可以对 JAR 文件进行数字签名 压缩 –在使用 JAR 时，我们可以压缩文件以高效存储 可移植性 –我们可以跨多个平台使用相同的 JAR 文件 **版本控制 |**JAR 文件可以保存有关其包含的文件的元数据 密封 –我们可以在 JAR 文件中密封包裹。这意味着一个包中的所有类都必须包含在相同的 JAR 文件中 扩展名 –我们可以使用 JAR 文件格式来打包现有软件的模块或扩展名 十二 题。什么是_空指针异常_？_空指针异常_可能是 Java 世界中最常见的异常。这是一个未检查的异常，因此扩展_了运行时例外_。我们不应该试图处理它。 当我们尝试访问变量或调用 null 引用的方法时引发此异常，例如： 调用空引用的方法 设置或获取空引用的字段 检查空数组引用的长度 设置或获取空数组引用的项 投掷空 问题 13.Java 中的两种强制转换类型是什么？强制转换时可能会引发哪个异常？我们如何避免它？我们可以在 Java 中区分两种类型的强制转换。我们可以进行向上转换，该预测将对象强制转换为超级类型或下播对象，后者将对象强制转换到子类型。 _上播_非常简单，因为我们总能做到这一点。例如，我们可以将_字符串_实例向上转换为_对象_类型： 123456Object str =&quot;string&quot;; 或者，我们可以_降低_变量。它不像上播那样安全，因为它涉及类型检查。如果我们错误地强制转换对象，JVM 将在运行时引发_ClassCastExcption。_幸运的是，我们可以使用_关键字的实例_来防止无效的强制转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445Object o =&quot;string&quot;;String str = (String) o;// it's okObject o2 =newObject();String str2 = (String) o2;// ClassCastException will be thrownif(o2instanceofString) {// returns falseString str3 = (String) o2;} 我们可以在本文中了解有关类型转换的更多详细信息。 3. 面向高级程序员的核心Java语言问题问题 1.为什么字符串是一个不可改变的类？我们应该知道_，JVM_对待_String_对象的方式与其他对象不同。一个区别是_String_对象是不可变的。这意味着，一旦我们创建了它们，我们就无法更改它们。他们这样做的原因有几个： 它们存储在_字符串池_中，字符串池是堆内存的特殊部分。它负责节省大量空间。 _String_类的不变性可确保其哈希代码不会更改。因此，_字符串_可以有效地用作哈希集合中的键。我们可以确信，我们不会覆盖任何数据，因为哈希代码的变化。 它们可以安全地跨多个线程使用。没有线程可以更改_String_对象的值，因此我们免费获得线程安全性。 字符串是不可改变的，以避免严重的安全问题。敏感数据（如密码）可能会由不可靠的源或其他线程更改。 我们可以在本文中了解有关字符串的不可变性的更多。 问题 2.动态绑定和静态绑定之间的区别是什么？Java 中的绑定是一个将方法调用与正确的方法体关联的过程。我们可以区分Java中的两种类型的绑定：静态绑定和动态绑定。 静态绑定和动态绑定之间的主要区别是静态绑定发生在编译时，在运行时发生动态绑定。 _静态绑定_使用类信息进行绑定。它负责_解析私有或__静态_和_最终_方法和变量的类成员。此外，静态绑定绑定重载方法。 另一方面，_动态绑定_使用对象信息来解决绑定。这就是为什么它负责解决虚拟和重写的方法。 问题 3.什么是 JIT？_JIT_代表”及时”。它是 JRE 的一个组件，在运行时运行并提高应用程序的性能。具体来说，它是一个编译器，在程序启动后运行。 这与常规 Java 编译器不同，后者早在应用程序启动之前就编译了代码。JIT可以以不同的方式加快应用程序的速度。 例如，JIT 编译器负责动态将字节码编译为本机指令，以提高性能。此外，它可以优化代码到目标CPU和操作系统。 此外，它还可以访问许多运行时统计信息，这些统计信息可用于重新编译以实现最佳性能。这样，它还可以执行一些全局代码优化或重新排列代码，以更好的缓存利用率。 问题 4.什么是 Java 中的反射？反射是Java中一个非常强大的机制。反射是一种Java语言机制，它使程序员能够在运行时检查或修改程序的内部状态（属性、方法、类等）。java.lang.反射包提供使用反射所需的所有组件。 使用此功能时，我们可以访问类定义中包含的所有可能的字段、方法、构造函数。无论它们的访问修改器如何，我们都可以访问它们。这意味着，例如，我们能够访问私人成员。为此，我们不必知道他们的名字。我们要做的就是使用_类_的一些静态方法。 值得了解的是，可以通过反射限制访问。为此，我们可以使用 Java 安全管理器和 Java 安全策略文件。它们允许我们向类授予权限。 在使用 Java 9 以来的模块时，我们应该知道，默认情况下，我们无法使用从另一个模块导入的类的反射。为了允许其他类使用反射来访问包的私有成员，我们必须授予”反射”权限。 本文更深入地介绍了 Java 反射。 问题 5.什么是类加载器？_类加载器_是 Java 中最重要的组件之一。这是JRE的一部分。 简而言之，_类加载器_负责将类加载到 JVM 中。我们可以区分三种类型的类加载器： **引导类加载器 -**它加载核心Java类。它们位于_/jre/lib_目录中 **扩展类加载器 -**它加载位于_/jre/lib/ext_或_java.ext.dirs_属性定义的路径中的类 系统类加载器 –它在应用程序的类路径上加载类 类加载器”按需”加载类。这意味着类在程序调用后加载。此外，类加载器只能加载具有给定名称的类一次。但是，如果同一类由两个不同的类加载程序加载，则这些类在相等性检查中失败。 Java 文章中的类加载器中有关类加载器的详细信息。 问题 6.静态类加载和动态类加载之间的区别是什么？静态类加载发生在我们在编译时有源类可用时。我们可以通过_使用新_关键字创建对象实例来使用它。 动态类加载是指在编译时无法提供类定义的情况。然而，我们可以在运行时这样做。要创建类的实例，我们必须使用_class.forName（）_方法： 123Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;) 问题 7._可序列化_接口的目的是什么？我们可以使用_可序列化_接口，使用 Java 的序列化 API 实现类的序列化。序列化是一种将对象状态保存为字节序列的机制，而反序列化是从字节序列中还原对象状态的机制。序列化输出保存对象的状态和有关对象类型和字段类型的一些元数据。 我们应该知道，可序列化类的子类型也是可序列化的。但是，如果我们想要使类具有序列化，但其超类型是不可序列化的，我们必须执行两项操作： 实现_可序列化_接口 确保超类中没有参数构造函数 我们可以在我们的一篇文章中阅读更多关于序列化的文章。 问题 8.Java 中是否有析构函数？在 Java 中，垃圾回收器会自动删除未使用的对象以释放内存。开发人员无需标记对象以进行删除，这很容易出错。因此，明智的Java没有可用的析构函数。 如果对象持有打开的套接字、打开的文件或数据库连接，则垃圾回收器无法回收这些资源。我们可以以_接近_的方法释放资源，并使用_尝试-finally_语法在Java 7之前调用该方法，例如I/O类_FileInputStream_和_FileOutputStream。_从Java 7开始，我们可以实现接口_自动可连接，_并使用_尝试资源_语句编写更短、更简洁的代码。但是，API用户可能忘记调用_关闭_方法，因此_最终_方法和_清理器_类应运而生。”但请注意，它们不等同于析构函数。 它不能保证_最终确定_方法和_清洁_类将迅速运行。他们甚至没有机会在 JVM 退出之前运行。尽管我们可以调用_System.run Final 化_来建议 JVM 运行待定_任何对象的最终_方法，但它仍然是非确定性的。 此外，_最终_方法可能会导致性能问题、死锁等。我们可以通过查看我们的文章之一找到更多信息：Java 中最终方法指南。 从 Java 9开始，由于它的缺点，添加了_Cleaner_类以替换_最终_方法。因此，我们可以更好地控制执行清洁操作的螺纹。 但是java规范指出了在_System.exit_期间清理者的行为是特定于实现的，Java 不保证是否调用清理操作。","link":"/2020/04/06/Java-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B3%BB%E5%88%97-1/"},{"title":"Java编码规范","text":"Java编码规范1 说明 1.1 范围 1.2 术语和定义 2 排版规则 2.1 编码 2.2 页宽 2.3 换行 2.4 缩进 2.5 空行 2.6 大括号 2.7 小括号 2.8 空格 2.9 TODO 2.10 import 2.11 变量 3 命名规范 3.1 package 3.2 Class 3.3 Interface 3.4 方法命名 3.5 变量 4 注释规范 4.1 文档注释 4.2 块注释 4.3 单行注释 4.4 注意事项 5 编程技巧 5.1 类 5.2 方法 5.3 控制语句 5.3 数据校验 Creators 1 说明1.1 范围本规范规定了使用Java语言时排版、注释、命名、编码的规则和建议。本规范适用于使用Java语言成的产品和项目。 1.2 术语和定义 规则：必须遵守 建议：有充足的理由时可不遵守，但必须优先考虑 格式：对规范格式的说明或模板 说明：对规范或建议进行的必要解释 示例：对规范或建议从正反两方面给出的例子 补充：一些实践技巧或额外的说明 2 排版规则2.1 编码规 则：IDE的text file encoding设置为UTF-8。规 则：IDE中文件的换行符使用Unix格式，不要使用windows格式。 2.2 页宽规 则：编辑器列宽应设置为100列说 明： 当一行代码的长度过长时，为了阅读方便，应该换行展示。但因为每个人的字体设置，屏幕大小有所不同，因此需要统一列宽为100列。补 充：在Eclipse中我们可以设置自动排版的单行代码最大宽度。选择：【Window】→【Preferences】→【Java】→【Code Style】→【Formatter】，点击“new”新建一个“Profile”（若已经是自定义的profile则不需要新建）。选择选项卡【Line Wrapping】,修改下边的“Maximum line width”为100。在Eclipse中我们可以在编辑界面设置一条参考线提醒我们代码宽度。选择：【Window】→【Preferences】→【General】→【Editors】→【Text Editors】。将右侧的单选框“Show print margin”设置为选中状态，然后设置下边的“Print margin column”为100。 2.3 换行规 则：第二行相对第一行缩进4个空格，从第三行开始，不再缩进，而是与第二行保持同级。规 则：运算符、方法调用的点符号与下文一起换行。规 则：在多个参数超长时，逗号后换行。示 例： 12345678910//符合规范StringBuffer sb = new StringBuffer();//超过100个字符的时候，换行缩进4个空格，并且方法钱的点符号一起换行sb.append(&quot;wan&quot;).append(&quot;fang&quot;)... .append(&quot;shu&quot;)... .append(&quot;ju&quot;)... .append(&quot;gu&quot;);//在逗号后换行method(arg1, arg2, arg3, ...argx, argx1) 2.4 缩进规 则：程序块需要采用缩进风格编写，缩进为4个空格。说 明： 不同的编辑工具会导致Tab字符的宽度不统一，在编码时应注意其可能造成的问题。补 充：在Eclipse中我们可以设置Tab的宽度和输入空格数。选择：【Window】→【Preferences】→【General】→【Editors】→【Text Editors】。将右侧的“Display tab width”设置为4，将单选框“Insert spaces for tabs”设置为选中状态。选择：【Window】→【Preferences】→【Java】→【Code Style】→【Formatter】，点击“new”新建一个“Profile”（若已经是自定义的profile则不需要新建）。选择选项卡【Indentation】,将左侧的下拉框“Tab policy”改为Spaces only。然后修改“Tab size”为4。 2.5 空行规则：独立的程序块与变量声明之间加空行分割示 例： 123456//不符合规范if(log.getLevel() &lt; LogConfig.getRecordLevel()){ return;}LogWriter writer;int index; 1234567//符合规范if(log.getLevel() &lt; LogConfig.getRecordLevel()){ return;} LogWriter writer;int index; 2.6 大括号规 则：使用大括号（即使是可选的）说 明： 大括号与if, else, for, do, while即使只有一条语句或是空，也应该把大括号写上。示 例： 123//不符合规范的if(writeToFile) writeFileThread.interrupt(); 1234//符合规范的if(writeToFile){ writeFileThread.interrupt();} 规 则：对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格（紧凑风格）。说 明： 左大括号前不换行 左大括号后换行 右大括号前换行 如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行 示 例： 123456789//不符合规范if(isOk){ someThing();}else{ otherThing();} 123456//符合规范if(isOk){ someThing();}else{ otherThing();} 补 充：Kernighan和Ritchie风格指的是，Kernighan和Ritchie的《C Programming Language》一书中约定的“大括号放在同一行”规则。这种编码风格比较紧凑，也是Java官方和Google等诸多主流公司遵循的编码风格。 建 议：空块可以简洁的写成{}，除非它是多块语句的一部分。说 明： 一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。示 例： 1void doNothing() {} 2.7 小括号规 则：用小括号来限定计算优先级说 明： 没有理由假设代码的阅读者能够清晰的记住整个Java运算符优先级表。 2.8 空格规 则：函数参数在“，”后需要加空格。规 则：各种双目操作符，比如“=”，“&lt;”等，前后都要加空格。规 则：if, while等关键字后面需要有空格。补 充： 基本上Eclipse的自动格式化功能，就能保证这些空格的正确使用。 2.9 TODO规 则：TODO用于任务标记，要避免出现无用的TODO标记说 明： 自动生成代码中如果有TODO标记，请根据需要编写注释或删除TODO标记，避免产生无用的TODO，影响他人跟踪任务。 2.10 import规 则：import不要使用通配符说 明： 不要出现类似这样的import语句：import java.util.*。使用通配符会造成歧义，及不可预期的冲突或bug。程序应保持清晰、易懂、无歧义。 规 则：import不要引用不需要的包 2.11 变量规 则：每次只声明一个变量说 明： 不要使用组合声明（int a,b;），减少歧义性，增强可读性 规 则：需要时才声明，并尽快进行初始化 规 则：使用非C风格的数组声明说 明： 使用String[] args，而非String args[] 建 议：谨慎的使用公共变量说 明： 公共变量是增大模块间耦合的原因之一，应减少没必要的公共变量以降低模块间的耦合度。 3 命名规范规 则：命名应尽可能做到见名知意，力求语义表达清晰完整。规 则：代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。规 则：代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 3.1 package规 则：包名均采用小写建 议：包名一般为一个单词 规 则：内部包名规则一般为com.部门名称/站点域名.产品名/项目名.模块名，通用包放在com.wanfangdata下说 明： 由于历史遗留原因，部分内部包名格式为：部门名称.产品名/项目名.模块名。原则上，新建的包不要用此命名规则，但暂时也不修改此规则的包名 3.2 Class规 则：类的命名应该都是名词规 则：类名第一个字母要为大写，其他每个单词的第一个字母为大写（UpperCamelCase）规 则：类名要用完整的单词，除非是被公认的单词缩写规 则：抽象类命名应以Abstract为开头规 则：异常类命名使用Exception结尾规 则：测试类命名以它要测试的类名称开始，以Test结尾 建 议：如果使用了设计模式，建议在类(接口)命名中体现出具体的设计模式建 议：枚举类名以Enum后缀结束，美剧成员名称需要全部大写，单词间用下划线分隔。示 例： 123public class BalanceLimitAccountHandler;public interface SqlSessionFactory;public class LoginProxy; 3.3 Interface规 则：接口名的命名应该是名词或形容词规 则：接口名应以大写的I开头，其他单词第一个字母都要大写（UpperCamelCase）规 则：接口名要用完整的单词，除非是被公认的单词缩写建 议：接口类中的方法和属性不要加任何修饰符好（public也不要加）。 3.4 方法命名规 则：方法名应以动词或惯用短语描述规 则：方法名第一个字母都要小写，其他每个单词第一个字母都要大写（lowerCamelCase） 建 议：方法名中不要加入对象名字，可能会带来误解。说 明： 因为对象本身已经包含在调用语句中了 3.5 变量规 则：应避免用单个字符命名变量规 则：代码中严禁使用拼音与英文混合的方式，优先使用英文而非拼音 规 则：参数名第一个字母使用小写，其他每个单词第一个字母大写（lowerCamelCase） 规 则：常量名应该为名词或名词短语规 则：常量名每一个字母都应为大写，单词之间用“_”分开。规 则：不允许出现任何魔法值（未经定义的常量）直接出现在代码中。建 议：不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。 规 则：long或者Long初始赋值时，必须使用大写的L，不能是小写的l，小写容易跟数字1混淆，造成误解。 规 则：局部变量名第一个字母使用小写，其他每个单词第一个字母大写（lowerCamelCase）。规 则：局部变量名可以更宽松的使用缩写，但除了临时变量和循环变量应避免单字符命名。 规 则：POJO类中布尔类型的变量，都不要加is，否则部分框架解析会引起序列化错误。（参考阿里java规范）说 明：定义为基本数据类型Boolean isSuccess；的属性，它的方法也是isSuccess()，RPC框架在反向解析的时候，“以为”对应的属性名称是success，导致属性获取不到，进而抛出异常。 4 注释规范4.1 文档注释规 则：一般情况下，源程序有效注释量必须在30%以上。规 则：接口、Action方法、工具类的public方法等凡是提供给外界调用的方法都必须添加文档注释。规 则：文档注释用于描述Java的类、接口、构造函数、方法，一级成员变量（field）。 规 则：类和接口的注释在 package 关键字之后，class 或者 interface 关键字之前。规 则：类和接口的注释内容：类的注释主要是一句话功能简述、功能详细描述。说 明： 可根据需要列出：版本号、生成日期、作者、内容、功能、与其它类的关系等。 如果一个类存在Bug，请如实说明这些Bug 123456789/** * 〈一句话功能简述〉 * 〈功能详细描述〉 * @author [作者] * @version [版本号, YYYY-MM-DD] * @see [相关类/方法] * @since [产品/模块版本] * @deprecated */ 示例： 12345678910/** * LogManager 类集中控制对日志读写的操作。 * 全部为静态变量和静态方法，对外提供统一接口。分配对应日志类型的读写器， * 读取或写入符合条件的日志纪录。 * @author 张三，李四，王五 * @version 1.2, 2001-03-25 * @see LogIteraotor * @see BasicLog * @since CommonLog1.0 */ 规 则：类属性、公有和保护方法注释：写在类属性、公有和保护方法上面规 则：成员变量使用文档注释，而不是单行注释或尾部注释规 则：成员变量注释内容：成员变量的意义、目的、功能，可能被用到的地方 规 则：公有和保护方法注释内容：列出方法的一句话功能简述、功能详细描述、输入参数、输出参数、返回值、违例等说明： 12345678910/** * 〈一句话功能简述〉 * 〈功能详细描述〉 * @param [参数1] [参数1说明] * @param [参数2] [参数2说明] * @return [返回类型说明] * @exception/throws [违例类型] [违例说明] * @see [类、类#方法、类#成员] * @deprecated */ 示 例： 12345678910111213141516/** * 根据日志类型和时间读取日志。 * 分配对应日志类型的LogReader， 指定类型、查询时间段、条件和反复器缓冲数， * 读取日志记录。查询条件为null或0表示无限制，反复器缓冲数为0读不到日志。 * 查询时间为左包含原则，即 [startTime, endTime) 。 * @param logTypeName 日志类型名（在配置文件中定义的） * @param startTime 查询日志的开始时间 * @param endTime 查询日志的结束时间 * @param logLevel 查询日志的级别 * @param userName 查询该用户的日志 * @param bufferNum 日志反复器缓冲记录数 * @return 结果集，日志反复器 * @since CommonLog1.0 */public static LogIterator read(String logType, Date startTime, Date endTime, int logLevel, String userName, int bufferNum) 4.2 块注释规 则：块注释用来为文件、方法、数据结构和算法进行描述或是用来划分文件的模块规 则：块注释一般放在每个文件的开始或是每个模块、方法的前面，也可能放在方法之内规 则：在块注释前应该有一个空行，以便同其他代码进行分割 4.3 单行注释规 则：简短的注释可以只用一行来说明，并与后面的代码进行相同的缩进规 则：单行注释如果一行写不下，就应该考虑使用块注释规 则：在单行注释前应该有一个空行，以便痛其他代码进行分割规 则：非常短的注释可以跟被说明的代码放在同一行，以尾部注释的形式出现 4.4 注意事项规 则：注释必须与代码同步更新建 议：应避免注释中提供代码中已清晰表达出来的重复信息建 议：当要写非文档注释的时候，应考虑下是否可以将代码写的更清晰易懂说 明： 过多的非文档注释，往往反映出代码的低质量**建 议：TODO与FIXME注释格式建议包含（标记人，标记时间，预计处理时间） 5 编程技巧5.1 类规 则：明确类的功能，精确（而非近似）地实现类的设计，一个类仅实现一组相近的功能说 明： 划分类的时候，应该尽量把逻辑处理、数据和显示分离，实现类功能的单一性示 例： 数据类不能包含数据处理的逻辑，通信类不能包含显示处理的逻辑 规 则：所有的数据类必须重载toString() 方法，返回该类有意义的内容说 明： 如果父类中已经实现了较为合理的toString()方法，子类可以继承而不必重写 规 则：只要重写equals，就必须重写hashCode。规 则：因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法。规 则：如果自定义对象做为Map的键，那么必须重写hashCode和equals。 建 议：@Override能用则用说 明： 只要是合法的，就把@Override注解用上。补 充： 参考自谷歌编码规范 5.2 方法规 则：参数个数&gt;4个时抽取参数类建 议：参数列表中请尽量不取用true、false类参数，避免因为调用者不明确导致的问题 建 议：返回调用函数方应该知道的消息，慎用void建 议：返回空的集合时使用Collections.empty方法，不要直接返回null 规 则：每个方法不得超过100行建 议：超过50行的代码建议考虑重构 规 则：方法不得包含隐式功能说 明： 如：getIdsFromList(List modelList)仅应该执行从list获取id的操作，而不应该对list有修改 规 则：避免使用不易理解的数字，用有意义的标识来替代规 则：涉及物理状态或者含有物理意义的常量，不应直接使用数字，必须用有意义的静态变量来代替 5.3 控制语句规 则：在一个switch块内，都必须包含一个default语句并且放在最后，即使它什么代码也没有规 则：在if/else/for/while/do语句中必须使用大括号，即使只有一行代码，避免使用下面的形式：if (condition) statements; 规 则：尽量少用else示 例： 1234567//不符合规范if(condition){ ... return obj;}//接着写else的业务逻辑代码 5.4 数据校验建 议：方法中需要进行参数校验的场景 调用频次低的方法 执行时间开销很大的方法，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。 需要极高稳定性和可用性的方法 对外提供的开放接口，不管是RPC/API/HTTP接口 敏感权限入口 建 议：方法中不需要参数校验的场景 极有可能被循环调用的方法，不建议对参数进行校验。但在方法说明里必须注明外部参数检查。 底层的方法调用频度都比较高，一般不校验。（参数错误不太可能到底层才会暴露问题） 被声明成private只会被自己代码所调用的方法。","link":"/2019/11/22/Java%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"title":"Python 中的线性回归 - 分步指南","text":"在本课程的最后一课中，您了解了线性回归机器学习算法背后的历史和理论。 本教程将教您如何使用库在 Python 中创建、训练和测试第一个线性回归机器学习模型。scikit-learn 目录您可以使用下面的目录跳到此 Python 机器学习教程的特定部分： 我们将在本教程中使用数据集 我们将在本教程中使用库 导入数据集 了解数据集 构建机器学习线性回归模型 将我们的数据集拆分为训练数据和测试数据 构建和培训模型 从我们的模型进行预测 测试模型的性能 平均绝对误差 （MAE） 平均平方误差 （MSE） 根均值平方错误 （RMSE） 本教程的完整代码 最后的想法 我们将在本教程中使用数据集由于线性回归是我们在本课程中学习的第一个机器学习模型，我们将在本教程中使用人工创建的数据集。这将使您能够专注于学习机器学习概念，并避免花费不必要的时间来清理或操作数据。 更具体地说，我们将使用一组住房数据，并试图预测房价。在构建模型之前，我们首先需要导入所需的库。 我们将在本教程中使用库我们需要导入的第一个库是熊猫，它是”面板数据”的波特曼托，是最常用的Python库，用于处理表格数据。 在别名下导入是约定的。您可以使用以下语句导入：pandas``````pd``````pandas import pandas as pd 接下来，我们需要导入NumPy，这是一个流行的数值计算库。Numpy 以其NumPy 数组数据结构及其有用的方法重塑、进行和追加而闻名。 在别名下导入 NumPy 是约定的。您可以使用以下语句导入：np``````numpy import numpy as np 接下来，我们需要导入matplotlib，这是 Python 最受欢迎的数据可视化库。 matplotlib通常导入在别名 下。您可以使用以下语句导入：plt``````matplotlib import matplotlib.pyplot as plt %matplotlib inline 该语句将导致我们的可视化效果直接嵌入到 Jupyter 笔记本中，从而更易于访问和解释。%matplotlib inline``````matplotlib 最后，您需要导入 ，这是另一个 Python 数据可视化库，它使得使用 matplotlib 创建美丽的可视化效果变得更加容易。seaborn 您可以使用以下语句导入：seaborn import seaborn as sns 总之，以下是本教程中所需的所有导入： import pandas as pd import numpy as np import matplotlib.pyplot as plt %matplotlib inline import seaborn as sns 在未来的课程中，我将具体说明哪些进口是必要的，但我不会像我在这里那样详细解释每个进口。 导入数据集如前所述，我们将使用一组房屋信息。我们将使用 数据集已上载到我的网站，作为以下 URL 的文件：.csv https://nickmccullum.com/files/Housing_Data.csv 要将数据集导入Jupyter 笔记本，您首先应该通过复制此 URL 并将其粘贴到浏览器中来下载文件。然后，将文件移动到与 Jupyter 笔记本相同的目录中。 完成此操作后，以下Python语句将住宅数据集导入到 Jupyter 笔记本中： raw_data = pd.read_csv('Housing_Data.csv') 此数据集具有许多功能，包括： 房屋面积的平均收入 该地区平均客房数 房子卖的价格 房子的地址 此数据是随机生成的，因此您将看到一些通常没有意义的细微差别（例如，在数字后大量小数位数，该数字应该是整数）。 了解数据集现在，数据集已在变量下导入，您可以使用 方法获取有关数据集的一些高级信息。具体来说，跑步可以：raw_data``````info``````raw_data.info() RangeIndex: 5000 entries, 0 to 4999 Data columns (total 7 columns): Avg. Area Income 5000 non-null float64 Avg. Area House Age 5000 non-null float64 Avg. Area Number of Rooms 5000 non-null float64 Avg. Area Number of Bedrooms 5000 non-null float64 Area Population 5000 non-null float64 Price 5000 non-null float64 Address 5000 non-null object dtypes: float64(6), object(1) memory usage: 273.6+ KB 了解此数据集的另一个有用方法是生成对图。可以为此使用 方法，并将整个方法作为参数传递。下面是用于此项的整个语句：seaborn``````pairplot``````DataFrame sns.pairplot(raw_data) 此语句的输出如下： 接下来，让我们开始构建线性回归模型。 构建机器学习线性回归模型我们需要做的第一件事是将数据拆分为（其中包含我们将用于进行预测的数据）和 a（其中包含我们试图预测的数据）。x-array``````y-array 首先，我们应该决定要包括哪些列。您可以使用 生成 DataFrame 列的列表，该列表输出：raw_data.columns Index(['Avg. Area Income', 'Avg. Area House Age', 'Avg. Area Number of Rooms', 'Avg. Area Number of Bedrooms', 'Area Population', 'Price', 'Address'], dtype='object')&lt;/code&gt; 我们将在 除 外将使用所有这些变量（因为这是我们试图预测的变量）和（因为它仅包含文本）。x-array``````Price``````Address 让我们创建我们的，并将其分配给一个称为 的变量。x-array``````x x = raw_data[['Avg. Area Income', 'Avg. Area House Age', 'Avg. Area Number of Rooms', 'Avg. Area Number of Bedrooms', 'Area Population']]&lt;/code&gt; 接下来，让我们创建我们的，并将其分配给一个称为 的变量。y-array``````y y = raw_data['Price'] 我们成功地将数据集划分为（即模型的输入值）和 （即模型的输出值）。我们将在下一节中了解如何将数据集进一步拆分为训练数据和测试数据。x-array``````y-array 将我们的数据集拆分为训练数据和测试数据scikit-learn使将数据集划分为训练数据和测试数据非常容易。为此，我们需要从 模块导入函数。train_test_split``````model_selection``````scikit-learn 下面是执行此操作的完整代码： from sklearn.model_selection import train_test_split 数据接受三个参数：train_test_split 我们x-array 我们y-array 测试数据所需的大小 有了这些参数，函数将为我们拆分我们的数据！如果我们希望我们的测试数据占整个数据集的 30%，则下面是执行此操作的代码：train_test_split x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.3) 让我们解压缩这里发生的事情。 该函数返回长度为 4 的Python 列表，其中列表中的每个项目分别为 、和 。然后，我们使用列表解包将正确的值分配给正确的变量名称。train_test_split``````x_train``````x_test``````y_train``````y_test 现在，我们已经正确地划分了我们的数据集，是时候构建和训练我们的线性回归机器学习模型了。 构建和培训模型我们需要做的第一件事是从导入估计器。下面是用于此的 Python 语句：LinearRegression``````scikit-learn from sklearn.linear_model import LinearRegression 接下来，我们需要创建 Python 对象的实例。我们将将其分配给一个称为 的变量。下面是用于此代码的代码：Linear Regression``````model model = LinearRegression() 我们可以使用’的方法，根据我们的训练数据来训练这个模型。scikit-learn``````fit model.fit(x_train, y_train) 我们的模型现在已经接受培训。您可以使用以下语句检查模型的每个系数： print(model.coef_) 此打印件： [2.16176350e+01 1.65221120e+05 1.21405377e+05 1.31871878e+03 1.52251955e+01] 同样，下面是如何查看回归方程的截取： print(model.intercept_) 此打印件： -2641372.6673013503 查看系数的更好方法是将它们放置在 DataFrame 中。这可以通过以下语句完成： pd.DataFrame(model.coef_, x.columns, columns = ['Coeff']) 在这种情况下，输出更易于解释： 让我们花点时间了解一下这些系数的含义。让我们具体看一下变量，其系数约为 。Area Population``````15 这意味着，如果保持所有其他变量常数，则一个单位的增加将导致预测变量中的单位增加 - 在这种情况下，Area Population``````15``````Price 不同地说，特定变量上的大系数意味着该变量对您尝试预测的变量的值有很大的影响。同样，小值的影响很小。 现在，我们已经生成了第一个机器学习线性回归模型，是时候使用该模型从测试数据集进行预测了。 从我们的模型进行预测scikit-learn使从机器学习模型进行预测变得非常容易。您只需调用前面创建的变量上的方法。predict``````model 由于变量旨在进行预测，因此它仅接受参数。它将为您生成值！predict``````x-array``````y 下面是使用 方法从我们的模型生成预测所需的代码：predict predictions = model.predict(x_test) 变量保存存储在 中的要素_的预测_值。由于我们使用 方法将_实际_值存储在 中，接下来我们要执行的是将数组的值与 的值进行比较。predictions``````x_test``````train_test_split``````y_test``````predictions``````y_test 一个简单的方法是使用散点图绘制两个数组。使用 方法轻松构建垫图利布散点图。下面是以下代码：plt.scatter plt.scatter(y_test, predictions) 下面是此代码生成的散点图： 如您所见，我们的预测值非常接近数据集中观测值的实际值。此散点图中完全直线对角线表示我们的模型完美地预测了这些值。y-array 直观地评估模型性能的另一种方法是绘制其 ，即实际值和预测值之间的差异。residuals``````y-array``````y-array 一个简单的方法是使用以下语句： plt.hist(y_test - predictions) 下面是此代码生成的可视化效果： 这是我们机器学习模型中残差的直方图。 您可能会注意到，我们机器学习模型中的残差似乎正常分布。这是一个非常好的迹象！ 它表明我们选择了适当的模型类型（在本例中为线性回归），以便从数据集进行预测。我们将在本课程的后面部分学习有关如何确保您使用正确的模型。 测试模型的性能我们在本课程的开头了解到，回归机器学习模型有三个主要性能指标： 平均绝对误差 均方误差 根均方误差 现在，我们将了解如何计算本教程中构建的模型的每个指标。在继续操作之前，请在 Jupyter 笔记本中运行以下导入语句： from sklearn import metrics 平均绝对误差 （MAE）您可以使用以下语句计算 Python 中的平均绝对错误： metrics.mean_absolute_error(y_test, predictions) 平均平方误差 （MSE）同样，您可以使用以下语句计算 Python 中的平均平方错误： metrics.mean_squared_error(y_test, predictions) 根均值平方错误 （RMSE）与均值绝对误差和均方误差不同，实际上没有用于计算根均方误差的内置方法。scikit-learn 幸运的是，它真的不需要。由于根平均平方误差只是均方误差的平方根，因此您可以使用 NumPy 的方法轻松计算它：sqrt np.sqrt(metrics.mean_squared_error(y_test, predictions)) 本教程的完整代码下面是此 Python 机器学习教程的整个代码。您也可以在此 GitHub 存储库中查看它。 import pandas as pd import numpy as np import matplotlib.pyplot as plt import seaborn as sns %matplotlib inline raw_data = pd.read_csv(‘Housing_Data.csv’) x = raw_data[[‘Avg. Area Income’, ‘Avg. Area House Age’, ‘Avg. Area Number of Rooms’, 'Avg. Area Number of Bedrooms', 'Area Population']] y = raw_data[‘Price’] from sklearn.model_selection import train_test_split x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.3) from sklearn.linear_model import LinearRegression model = LinearRegression() model.fit(x_train, y_train) print(model.coef_) print(model.intercept_) pd.DataFrame(model.coef_, x.columns, columns = [‘Coeff’]) predictions = model.predict(x_test) plt.scatter(y_test, predictions)plt.hist(y_test - predictions) from sklearn import metrics metrics.mean_absolute_error(y_test, predictions) metrics.mean_squared_error(y_test, predictions) np.sqrt(metrics.mean_squared_error(y_test, predictions)) 最后的想法在本教程中，您学习了如何创建、训练和测试第一个线性回归机器学习算法。 以下是您在本教程中学到的内容的简要摘要： 如何导入构建线性回归机器学习算法所需的库 如何使用将数据集拆分为训练数据和测试数据scikit-learn 如何使用该模型训练线性回归模型并做出预测scikit-learn 如何使用线性回归性能指标scikit-learn","link":"/2020/06/21/Python%20%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%20-%20%E5%88%86%E6%AD%A5%E6%8C%87%E5%8D%97/"},{"title":"Python 中的逻辑回归 - 分步指南","text":"在上一篇文章中，我们了解了逻辑回归的理论基础，以及如何使用它来解决机器学习分类问题。 本教程将教您如何在 Python 中构建逻辑回归模型，从而教您有关逻辑回归机器学习技术的更多信息。 目录您可以使用下面的目录跳到此 Python 逻辑回归教程的特定部分： 我们将在本教程中使用数据集 我们将在本教程中使用导入 将数据集导入到我们的 Python 脚本中 通过探索性数据分析了解我们的数据集 每个分类类别的流行程度 性别之间的生存率 乘客舱位之间的生存率 泰坦尼克号乘客的年龄分布 泰坦尼克号乘客的票价分配 从我们的数据集中删除空数据 构建逻辑回归模型 删除缺少过多数据的列 使用虚拟变量处理分类数据 向熊猫数据帧添加虚拟变量 从数据集中删除不必要的列 创建训练数据和测试数据 训练逻辑回归模型 使用我们的逻辑回归模型进行预测 衡量逻辑回归机器学习模型的性能 本教程的完整代码 最后的想法 我们将在本教程中使用数据集泰坦尼克号数据集是一个非常著名的数据集，包含泰坦尼克号上乘客的特征。它通常用作逻辑回归问题的介绍性数据集。 在本教程中，我们将使用泰坦尼克号数据集与 Python 逻辑回归模型相结合，以预测乘客是否在泰坦尼克号失事中幸存下来。 原始的泰坦尼克号数据集在Kaggle.com上公开提供，这是一个托管数据集和数据科学竞赛的网站。 为了让您在本课程中轻松学习，我们将使用半清洁版本的泰坦尼克号数据集，这将节省您在数据清理和操作方面的时间。 清理过的泰坦尼克号数据集实际上已经可供你使用。您可以通过单击以下链接下载数据文件： 泰坦尼克号数据 下载此文件后，在同一工作目录中打开Jupyter 笔记本，我们可以开始构建逻辑回归模型。 我们将在本教程中使用导入与之前一样，我们将在本教程中使用多个开源软件库。以下是在通过 Python 逻辑回归模型编写代码时需要运行的导入： import pandas as pd import numpy as np import matplotlib.pyplot as plt %matplotlib inline import seaborn as sns 接下来，我们需要将泰坦尼克号数据集导入到 Python 脚本中。 将数据集导入到我们的 Python 脚本中我们将使用熊猫的方法将我们的文件导入到熊猫数据帧中。read_csv``````csv``````titanic_data 下面是执行此操作的代码： titanic_data = pd.read_csv('titanic_train.csv') 接下来，让我们调查泰坦尼克号数据集中实际包含的数据。有两种主要方法可以执行此操作（具体使用数据帧）：titanic_data 该方法将打印 DataFrame 的前 5 行。你可以用任何你想的号码来代替。titanic_data.head(5)``````5 您还可以打印 ，这将显示名为的列。titanic_data.columns 运行第二个命令 （） 生成以下输出：titanic_data.columns Index(['PassengerId', 'Survived', 'Pclass', 'Name', 'Sex', 'Age', 'SibSp', 'Parch', 'Ticket', 'Fare', 'Cabin', 'Embarked'], dtype='object'&lt;/code&gt; 这些是数据框架中列的名称。以下是每个数据点的简要说明： PassengerId：泰坦尼克号上每位乘客的数字标识符。 Survived：一个二进制标识符，指示乘客是否在泰坦尼克号失事中幸存下来。此变量将保存的值，如果他们存活下来，如果他们没有生存。1``````0 Pclass：乘客的舱位。这可以容纳 值 ， 或 ， 取决于乘客在船舶中的位置。1``````2``````3 Name：乘客的名字。 Sex：男性或女性。 Age：乘客的年龄（以年数表示）。 SibSp：船上兄弟姐妹和配偶人数。 Parch：船上的父母和孩子的数量。 Ticket：乘客的票号。 Fare：乘客在泰坦尼克号上买票花了多少钱。 接下来，我们将使用一些基本的探索性数据分析技术，详细了解我们的数据集。 通过探索性数据分析了解我们的数据集每个分类类别的流行程度当使用机器学习技术对分类问题进行建模时，最好了解类别之间的比率。对于这个具体问题，了解我们的培训数据中有多少幸存者与非幸存者是很有用的。 可视化的一种简单方法是使用绘图。在此示例中，您可以使用以下 Python 代码创建相应的绘图：seaborn``````countplot``````seasborn sns.countplot(x='Survived', data=titanic_data) 这将生成以下绘图： 正如你们所看到的，非幸存者的发生率比幸存者多得多。 性别之间的生存率比较与其他数据功能相关的存活率也很有用。例如，我们可以比较使用以下 Python 代码的值之间的生存率：Male``````Female``````Sex sns.countplot(x='Survived', hue='Sex', data=titanic_data) 这将生成以下绘图： 正如您所看到的，有一个乘客更有可能是非幸存者比乘客与.Sex``````Male``````Sex``````Female 乘客舱位之间的生存率我们可以使用变量执行类似的分析，看看哪些乘客级别是最有可能（也是最少）的乘客是幸存者。Pclass 下面是执行此操作的代码： sns.countplot(x='Survived', hue='Pclass', data=titanic_data) 这将生成以下绘图： 从这个阴谋中最引人注目的观察是，在泰坦尼克号坠毁时，价值为三等舱的乘客更有可能死亡。因为第三类飞机是最便宜的，最不豪华的。Pclass``````3 泰坦尼克号乘客的年龄分布我们可以进行的另一个有用的分析是调查泰坦尼克号乘客的年龄分布。直方图是一个很好的工具。 您可以使用以下代码生成变量的直方图：Age plt.hist(titanic_data['Age'].dropna()) 请注意，该方法是必要的，因为dropna() 下面是此代码生成的直方图： 正如您所看到的，泰坦尼克号乘客的集中值介于 和 之间。Age``````20``````40 泰坦尼克号乘客的票价分配我们将使用的最后一种探索性数据分析技术是调查泰坦尼克号数据集中票价的分布情况。 您可以使用以下代码执行此操作： plt.hist(titanic_data['Fare']) 这将生成以下绘图： 正如您所看到的，泰坦尼克号数据集中有三个不同的价格组。这是有道理的，因为变量还有三个唯一值。差异组对应于不同的类别。Fare``````Pclass``````Fare``````Pclass 由于泰坦尼克号数据集是一个真实世界的数据集，它包含一些丢失的数据。我们将在下一节中学习如何处理缺失的数据。 从我们的数据集中删除空数据首先，让我们检查数据集包含缺失数据的位置。为此，运行以下命令： titanic_data.isnull() 这将生成布尔值的 DataFrame，如果单元格为空值，则单元格包含该值。下面是一个图像，如下所示：True``````False 评估此数据集中缺少的数据的一个更有用的方法是创建快速可视化。为此，我们可以使用可视化库。下面是可用于使用库创建 的快速命令：seaborn``````heatmap``````seaborn sns.heatmap(titanic_data.isnull(), cbar=False) 下面是生成的可视化效果： 在此可视化中，白线表示数据集中缺少的值。您可以看到 和 列包含泰坦尼克号数据集中的大部分缺失数据。Age``````Cabin 该列特别包含足够少的缺失量，以便我们可以使用某种形式的数学来填充缺失的数据。另一方面，数据缺少足够的数据，我们可能完全将其从模型中删除。Age``````Cabin 使用数据集的其余部分的平均数据填充缺失数据的过程称为 。现在，我们将使用 来填充列中缺少的数据。imputation``````imputation``````Age 最基本的形式是用整个数据集的平均值填充缺失的数据。但是，有更好的方法。imputation``````Age``````Age 我们将用乘客所属的特定乘客舱的平均值填充缺失值。要了解此功能为什么有用，请考虑以下框图：Age``````Age``````Pclass sns.boxplot(titanic_data['Pclass'], titanic_data['Age']) 正如您所看到的，价值（最昂贵的乘客舱）的乘客往往是最年长的，而价值（最便宜的）的乘客往往是最年轻的。这是非常合乎逻辑的，所以我们将使用不同数据中的平均值到列中缺少的数据。Pclass``````1``````Pclass``````3``````Age``````Pclass``````imputate``````Age 对像泰坦尼克号数据集这样的数据集执行最简单的方法是构建自定义函数。首先，我们需要确定每个值的平均值。imputation``````Age``````Pclass #Pclass value 1titanic_data[titanic_data['Pclass'] == 1]['Age'].mean() #Pclass value 2titanic_data[titanic_data[‘Pclass’] == 2][‘Age’].mean() #Pclass 3titanic_data[titanic_data[‘Pclass’] == 2][‘Age’].mean() 下面是我们将用于缺少变量的最终函数：imputate``````Age def impute_missing_age(columns): age = columns[0] passenger_class = columns[1] if pd.isnull(age): if(passenger_class == 1): return titanic_data[titanic_data['Pclass'] == 1]['Age'].mean() elif(passenger_class == 2): return titanic_data[titanic_data['Pclass'] == 2]['Age'].mean() elif(passenger_class == 3): return titanic_data[titanic_data['Pclass'] == 3]['Age'].mean() else: return age&lt;/code&gt; 现在，此归给函数已完成，我们需要将其应用于 DataFrame 中的每一行。Python 的方法是一个很好的工具：titanic_data``````apply titanic_data['Age'] = titanic_data[['Age', 'Pclass']].apply(impute_missing_age, axis = 1) 现在，我们已经对每行执行了处理丢失数据，让我们来调查一下我们的原始框图：imputation``````Age sns.heatmap(titanic_data.isnull(), cbar=False) 正如您所看到的，我们的熊猫数据框架的列中不再有任何缺失的数据！Age 您可能想知道为什么我们花了这么多时间专门处理列中缺少的数据。这是因为鉴于对大多数灾害和疾病生存的影响，它是一个变量，在我们的数据集中可能具有较高的预测价值。Age``````Age 现在，我们已经了解了此数据集的结构并删除了缺少的数据，让我们开始构建逻辑回归机器学习模型。 构建逻辑回归模型现在是删除逻辑回归模型的时候了。 删除缺少过多数据的列首先，让我们删除该列。正如我们提到的，此列中缺失数据的高流行率意味着缺少的数据是不明智的，因此我们将使用以下代码完全删除它：Cabin``````impute titanic_data.drop('Cabin', axis=1, inplace = True) 接下来，让我们删除包含熊猫方法缺少数据的任何其他列：dropna() titanic_data.dropna(inplace = True) 使用虚拟变量处理分类数据我们需要处理的下一个任务是处理分类功能。也就是说，我们需要找到一种方法，在数值上处理非自然数值的观测值。 这方面的一个很好的例子是列，它有两个值： 和 。同样，该列包含一个字母，指示乘客离开哪个城市。Sex``````Male``````Female``````Embarked 为了解决这个问题，我们将创建 。这些为非数字要素的每个类别分配一个数值。dummy variables 幸运的是，有一个内置的方法，它可以很容易地创建虚拟变量。该方法确实存在一个问题 - 它将为 DataFrame 列中的每个值创建一个新列。pandas``````get_dummies()``````get_dummies 让我们考虑一个示例来帮助更好地理解这一点。如果我们在列上调用 方法，我们会得到以下输出：get_dummies()``````Age pd.get_dummies(titanic_data['Sex']) 正如您所看到的，这将创建两个新列： 和 。这些列都是彼此的完美预测变量，因为列中的值表示列中的值，反之亦然。female``````male``````0``````female``````1``````male 这称为，它显著降低了算法的预测能力。要删除此参数，我们可以将 参数添加到如下所示的方法：multicollinearity``````drop_first = True``````get_dummies pd.get_dummies(titanic_data['Sex'], drop_first = True) 现在，让我们为和列创建虚拟变量列，并将它们分配给调用 和 的变量。Sex``````Embarked``````sex``````embarked sex_data = pd.get_dummies(titanic_data['Sex'], drop_first = True) embarked_data = pd.get_dummies(titanic_data[‘Embarked’], drop_first = True) 关于下面定义的变量，有一件重要的事情需要注意。它有两个列：和，但由于我们已经删除了另一列（列），其余两列都不是彼此的完美预测变量，因此在新的修改后的数据集中不存在。embarked``````Q``````S``````C``````multicollinearity 将虚拟变量添加到数据帧pandas接下来，我们需要将我们的和列添加到 DataFrame 中。sex``````embarked 您可以使用以下代码将这些数据列串联到现有 DataFrame 中：pandas titanic_data = pd.concat([titanic_data, sex_data, embarked_data], axis = 1) 现在，如果您运行该命令，您的 Jupyter 笔记本将生成以下输出：print(titanic_data.columns) Index(['PassengerId', 'Survived', 'Pclass', 'Name', 'Sex', 'Age', 'SibSp', 'Parch', 'Ticket', 'Fare', 'Embarked', 'male', 'Q', 'S'], dtype='object')&lt;/code&gt; 和 列的存在表明我们的数据已成功串联。male``````Q``````S 从数据集中删除不必要的列这意味着我们现在可以从 DataFrame 中删除原始和列。还有其他列（如，，）不预测泰坦尼克号的坠机存活率，所以我们也将删除这些。以下代码为我们处理此问题：Sex``````Embarked``````Name``````PassengerId``````Ticket titanic_data.drop(['Name', 'Ticket', 'Sex', 'Embarked'], axis = 1, inplace = True) 如果现在打印，您的犹太笔记本将生成以下输出：titanic_data.columns Index(['Survived', 'Pclass', 'Age', 'SibSp', 'Parch', 'Fare', 'male', 'Q', 'S'], dtype='object'&lt;/code&gt; DataFrame 现在具有以下外观： 正如您所看到的，此数据集中的每个字段现在都是数字字段，这使得它成为逻辑回归机器学习算法的优秀候选项。 创建训练数据和测试数据接下来，是时候将我们拆分为训练数据和测试数据了。与以前一样，我们将使用内置功能来执行此操作。titatnic_data``````scikit-learn 首先，我们需要将数据划分为值（我们将用于预测的数据）和值（我们试图预测的数据）。以下代码处理此问题：x``````y y_data = titanic_data['Survived'] x_data = titanic_data.drop(‘Survived’, axis = 1) 接下来，我们需要从 导入 函数。以下代码执行此导入：train_test_split``````scikit-learn from sklearn.model_selection import train_test_split 最后，我们可以使用该函数与列表解包相结合来生成我们的训练数据和测试数据：train_test_split x_training_data, x_test_data, y_training_data, y_test_data = train_test_split(x_data, y_data, test_size = 0.3) 请注意，在这种情况下，测试数据是参数指定的原始数据集的 30%。test_size = 0.3 现在，我们已经为我们的逻辑回归模型创建了我们的培训数据和测试数据。我们将在本教程的下一节中训练我们的模型。 训练逻辑回归模型要训练模型，我们首先需要使用以下命令导入相应的模型：scikit-learn from sklearn.linear_model import LogisticRegression 接下来，我们需要通过实例化对象的实例来创建模型：LogisticRegression model = LogisticRegression() 要训练模型，我们需要调用我们刚刚创建并在和变量中传递的对象上的方法，如下所示：fit``````LogisticRegression``````x_training_data``````y_training_data model.fit(x_training_data, y_training_data) 我们的模型现在已经接受培训。我们将在本教程的下一节中使用此模型进行预测。 使用我们的逻辑回归模型进行预测让我们使用我们刚刚创建的逻辑回归模型对我们的测试数据进行一组预测。我们将将这些预测存储在一个变量中，称为 ：model``````predictions predictions = model.predict(x_test_data) 我们的预测已经作出。接下来，让我们来检查模型的准确性。 衡量逻辑回归机器学习模型的性能scikit-learn具有出色的内置模块，便于测量分类机器学习模型的性能。我们将使用此模块来测量我们刚刚创建的模型的性能。classification_report 首先，让我们导入模块： from sklearn.metrics import classification_report 接下来，让我们使用该模块计算逻辑回归机器学习模块的性能指标： classification_report(y_test_data, predictions) 下面是此命令的输出： precision recall f1-score support 0 0.83 0.87 0.85 169 1 0.75 0.68 0.72 98 accuracy 0.80 267 macro avg 0.79 0.78 0.78 267 weighted avg 0.80 0.80 0.80 267 如果您有兴趣查看原始混淆矩阵并手动计算性能指标，则可以使用以下代码执行此操作： from sklearn.metrics import confusion_matrix print(confusion_matrix(y_test_data, predictions)) 这将生成以下输出： [[145 22] [ 30 70]] 本教程的完整代码您可以在此 GitHub 存储库中查看本教程的完整代码。下面还粘贴如下，供参考： import pandas as pd import numpy as np import matplotlib.pyplot as plt %matplotlib inline import seaborn as sns #Import the data settitanic_data = pd.read_csv(‘titanic_train.csv’) #Exploratory data analysissns.heatmap(titanic_data.isnull(), cbar=False) sns.countplot(x=’Survived’, data=titanic_data) sns.countplot(x=’Survived’, hue=’Sex’, data=titanic_data) sns.countplot(x=’Survived’, hue=’Pclass’, data=titanic_data) plt.hist(titanic_data[‘Age’].dropna()) plt.hist(titanic_data[‘Fare’]) sns.boxplot(titanic_data[‘Pclass’], titanic_data[‘Age’]) #Imputation functiondef impute_missing_age(columns): age = columns[0] passenger_class = columns[1] if pd.isnull(age): if(passenger_class == 1): return titanic_data[titanic_data['Pclass'] == 1]['Age'].mean() elif(passenger_class == 2): return titanic_data[titanic_data['Pclass'] == 2]['Age'].mean() elif(passenger_class == 3): return titanic_data[titanic_data['Pclass'] == 3]['Age'].mean() else: return age #Impute the missing Age datatitanic_data[‘Age’] = titanic_data[[‘Age’, ‘Pclass’]].apply(impute_missing_age, axis = 1) #Reinvestigate missing datasns.heatmap(titanic_data.isnull(), cbar=False) #Drop null datatitanic_data.drop(‘Cabin’, axis=1, inplace = True) titanic_data.dropna(inplace = True) #Create dummy variables for Sex and Embarked columnssex_data = pd.get_dummies(titanic_data[‘Sex’], drop_first = True) embarked_data = pd.get_dummies(titanic_data[‘Embarked’], drop_first = True) #Add dummy variables to the DataFrame and drop non-numeric datatitanic_data = pd.concat([titanic_data, sex_data, embarked_data], axis = 1) titanic_data.drop([‘Name’, ‘PassengerId’, ‘Ticket’, ‘Sex’, ‘Embarked’], axis = 1, inplace = True) #Print the finalized data settitanic_data.head() #Split the data set into x and y datay_data = titanic_data[‘Survived’] x_data = titanic_data.drop(‘Survived’, axis = 1) #Split the data set into training data and test datafrom sklearn.model_selection import train_test_split x_training_data, x_test_data, y_training_data, y_test_data = train_test_split(x_data, y_data, test_size = 0.3) #Create the modelfrom sklearn.linear_model import LogisticRegression model = LogisticRegression() #Train the model and create predictionsmodel.fit(x_training_data, y_training_data) predictions = model.predict(x_test_data) #Calculate performance metricsfrom sklearn.metrics import classification_report print(classification_report(y_test_data, predictions)) #Generate a confusion matrixfrom sklearn.metrics import confusion_matrix print(confusion_matrix(y_test_data, predictions)) 最后的想法在本教程中，您学习了如何在 Python 中构建逻辑回归机器学习模型。 以下是您在本文中学到的内容的简要摘要： 为什么泰坦尼克号数据集经常用于学习机器学习分类技术 在使用分类机器学习问题的数据集时如何执行探索性数据分析 如何处理熊猫数据框架中缺少的数据 使用它来填充缺失的数据意味着什么以及如何imputation 如何为机器学习数据集中的分类数据创建虚拟变量 如何在Python中训练逻辑回归机器学习模型 如何使用 Python 中的逻辑回归模型进行预测 如何快速计算机器学习分类问题的性能指标scikit-learn``````classification_report","link":"/2020/06/21/Python%20%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%20-%20%E5%88%86%E6%AD%A5%E6%8C%87%E5%8D%97/"},{"title":"Vue.js新手入门指南","text":"Vue.js新手入门指南 最近在逛各大网站，论坛，以及像SegmentFault等编程问答社区，发现Vue.js异常火爆，重复性的提问和内容也很多，楼主自己也趁着这个大前端的热潮，着手学习了一段时间的Vue.js，目前用它正在做自己的结业项目。 在做的过程中也对Vue.js的官方文档以及其各种特性有了许多认识。作为一个之前以PHP+模版引擎为主的开发，从一个从未接触过除HTML+CSS+JavaScript+JQuery以外的前端技术的人到现在可以独立使用Vue.js以及各种附属的UI库来开发项目，我总结了一些知识和经验想与大家分享。 下面我就以问答的形式来分享吧。这里假设你仅仅只掌握了HTML+CSS+JavaScript，如果你对JQuery这个前端库，以及各种后端模版语言比如说PHP，JSP还有所了解并且使用过的话那就太好了。 1.Vue.js是什么？ Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。 Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 如果你是有经验的前端开发者，想知道 Vue.js 与其它库/框架的区别，查看对比其它框架。 这是官网的介绍，是不是觉得非常的抽象非常的官方？看完之后可能还是有很多人不是很懂这个框架到底是用来做什么的，什么是“渐进式框架”？什么是“自底向上增量开发”？什么是“视图层”？什么是“单文件组件”？什么是“复杂的单页应用？”第二段话里面“响应的数据绑定和组合的视图组件”这又是个啥？还有最后一段话，“Vue.js 与其它库/框架的区别”究竟是什么？ 不要担心，如果你慢慢看完这里面的所有问答，一定会对前面那些可能你从未听说过的专业术语有一种恍然大悟的感觉。 2.Vue.js到底是什么？想必现在能看到我这篇文章的人，都是用着APP或者网页版知乎在阅读把。Vue.js就是一个用于搭建类似于网页版知乎这种表单项繁多，且内容需要根据用户的操作进行修改的网页版应用。 3.单页应用程序（SPA）顾名思义，单页应用一般指的就是一个页面就是应用，当然也可以是一个子应用，比如说知乎的一个页面就可以视为一个子应用。单页应用程序中一般交互处理非常多，而且页面中的内容需要根据用户的操作动态变化。 4.你前面说的网页版知乎我也可以用JQuery写啊，为什么要用Vue.js呢？讲到JQuery，就不得不说到JavaScript的DOM操作了。如果你用JQuery来开发一个知乎，那么你就需要用JQuery中的各种DOM操作方法去操作HTML的DOM结构了。 现在我们把一个网页应用抽象一下，那么HTML中的DOM其实就是视图，一个网页就是通过DOM的组合与嵌套，形成了最基本的视图结构，再通过CSS的修饰，在基本的视图结构上“化妆”让他们看起来更加美观。最后涉及到交互部分，就需要用到JavaScript来接受用户的交互请求，并且通过事件机制来响应用户的交互操作，并且在事件的处理函数中进行各种数据的修改，比如说修改某个DOM中的innerHTML或者innerText部分。 我们把HTML中的DOM就可以与其他的部分独立开来划分出一个层次，这个层次就叫做视图层。 Vue 的核心库只关注视图层 我们为什么要把视图层抽取出来并且单独去关注它呢？ 因为在像知乎这种页面元素非常多，结构很庞大的网页中，数据和视图如果全部混杂在一起，像传统开发一样全部混合在HTML中，那么要对它们进行处理会十分的费劲，并且如果其中有几个结构之间存在藕断丝连的关系，那么会导致代码上出现更大的问题，这什么问题呢？ 你是否还记得你当初写JQuery的时候，有写过$(‘#xxx’).parent().parent().parent()这种代码呢？当你第一次写的时候，你觉得页面元素不多，不就是找这个元素的爸爸的爸爸的爸爸吗，我大不了在注释里面写清楚这个元素的爸爸的爸爸的爸爸不就好了。但是万一过几天之后你的项目组长或者你的产品经理突然对你做的网页提出修改要求，这个修改要求将会影响页面的结构，也就是DOM的关联与嵌套层次要发生改变，那么$(‘#xxx’).parent().parent().parent()可能就会变成$(‘#xxx’).parent().parent().parent().parent().parent()了。 这还不算什么，等以后产品迭代越来越快，修改越来越多，而且页面中类似的关联和嵌套DOM元素不止一个，那么修改起来将非常费劲。而且JQuery选择器查找页面元素以及DOM操作本身也是有性能损失的，可能到时候打开这个页面，会变得越来越卡，而你却无从下手。 当你在编写项目的时候遇到了这种问题，你一定会抱怨，为什么世上会有HTML这种像盗梦空间一样的需要无数div嵌套才能做出页面的语言，为什么当初学JQuery看中的是它简洁的DOM操作，现在却一点也不觉得它有多简洁，难道我学的是假的JQuery？为什么写个代码这么难，你想砸电脑，你想一键盘拍在产品狗的脑袋上，责怪他天天改需求才让你原本花清香茶清味的代码变得如此又臭又长。 这个时候如果你学过Vue.js，那么这些抱怨将不复存在。 5.Vue.js为什么能让基于网页的前端应用程序开发起来这么方便？因为Vue.js有声明式，响应式的数据绑定，与组件化的开发，并且还使用了Virtual DOM这个看名字就觉得高大上的技术。 可是这些名词都是啥？ 6.响应式的数据绑定这里的响应式不是@media 媒体查询中的响应式布局，而是指vue.js会自动对页面中某些数据的变化做出响应。至于是如何响应的，大家可以先把下面这段代码随便粘贴到一个扩展名为html的文件然后用浏览器打开，随便在文本框里面输入一些文字，观察一下页面变化。 vue.js测试 - 代码之美专栏 {{ message }} var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' } }) 是不是会发现一个很神奇的现象，文本框里面输入的文字和后面的p标签中的内容一起变化？ 换句话说，p标签里面通过这个写法与input标签中的value绑定在了一起，其中变化，另外一个和它绑定的数据就跟着变化。 结合标题来说，就是vue.js会自动响应数据的变化情况，并且根据用户在代码中预先写好的绑定关系，对所有绑定在一起的数据和视图内容都进行修改。而这种绑定关系，在图上是以input 标签的v-model属性来声明的，因此你在别的地方可能也会看到有人粗略的称vue.js为声明式渲染的模版引擎。 7.组件化开发还记得在传统前端开发的时候，我们都是每个人做一个页面，然后最后套入各种后端模版引擎，比如说PHP的Smarty或者Java的JSP等等。 但是现在我们做单页应用，页面交互和结构十分复杂，一个页面上就有许许多多的模块需要编写，而且往往一个模块的代码量和工作量就非常庞大，如果还按照原先的方法来开发，那么会累死人。而且遇到以后的产品需求变更，修改起来也非常麻烦，生怕动了其中一个div之后，其他div跟着雪崩，整个页面全部乱套，或者由于JavaScript的事件冒泡机制，导致修改一些内层的DOM事件处理函数之后，出现各种莫名其妙的诡异BUG。 在面向对象编程中，我们可以使用面向对象的思想将各种模块打包成类或者把一个大的业务模块拆分成更多更小的几个类。在面向过程编程中，我们也可以把一些大功能拆分成许多函数，然后分配给不同的人来开发。 在前端应用，我们是否也可以像编程一样把模块封装呢？这就引入了组件化开发的思想。 Vue.js通过组件，把一个单页应用中的各种模块拆分到一个一个单独的组件（component）中，我们只要先在父级应用中写好各种组件标签（占坑），并且在组件标签中写好要传入组件的参数（就像给函数传入参数一样，这个参数叫做组件的属性），然后再分别写好各种组件的实现（填坑），然后整个应用就算做完了。 8.Virtual DOM现在的网速越来越快了，很多人家里都是几十甚至上百M的光纤，手机也是4G起步了，按道理一个网页才几百K，而且浏览器本身还会缓存很多资源文件，那么几十M的光纤为什么打开一个之前已经打开过，已经有缓存的页面还是感觉很慢呢？这就是因为浏览器本身处理DOM也是有性能瓶颈的，尤其是在传统开发中，用JQuery或者原生的JavaScript DOM操作函数对DOM进行频繁操作的时候，浏览器要不停的渲染新的DOM树，导致页面看起来非常卡顿。 而Virtual DOM则是虚拟DOM的英文，简单来说，他就是一种可以预先通过JavaScript进行各种计算，把最终的DOM操作计算出来并优化，由于这个DOM操作属于预处理操作，并没有真实的操作DOM，所以叫做虚拟DOM。最后在计算完毕才真正将DOM操作提交，将DOM操作变化反映到DOM树上。 对于vue.js的Virtual DOM，目前业界有着褒贬不一的评价。有人认为Vue.js作为一个轻量级框架，引入Virtual DOM会加大Vue.js本身的代码尺寸，也会消耗更多CPU（手机上会更耗电）（注意：消耗更多的CPU并不意味着会更卡，因为JavaScript计算是后台计算，他的计算量还不至于让DOM操作变得卡顿），并且在操作单个DOM元素的时候，反而多了一道计算工序，会更慢。但也有人认为基本上会用Vue.js开发的都是页面中内容很多的元素，肯定操作的DOM量级普遍较大，平均一下还是比较划算的。 9.我到底该怎么用Vue.js做单页应用开发？说了这么多，我还是不知道怎么用它做出一个像知乎那样的页面啊，到底怎么学它呢？ 前面我们看了一个响应式的数据绑定案例，那只是一个DEMO，而且也看不出有什么实际意义，离真正的单页应用程序还差得远，到底怎么用它开发真实的项目呢？ 我的建议是，先把介绍 - vue.js官方文档的基础部分硬着头皮看一遍。除了组件这个小节涉及到了很多晦涩难懂的名词以外，前面几章完全就是把Vue.js当作一个模版引擎来用。 然后开始学习ECMAScript6，Webpack，NPM以及Vue-Cli的基本用法，最好对Node.js也要有所了解。 最后组件部分先大致看一遍，了解组件里面都有哪些概念之后，开始看网上各种实战视频以及文章还有别人开源的源代码。 10.在前面你提到过好几次ECMAScript，这是啥？ECMAScript听名字好像和JavaScript很像，难不成他们有什么千丝万缕的联系？ 没错你猜对了，他们之间还真有着很深的联系。 引用阮一峰老师的话：（ECMAScript 6入门） 要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是1.0版。 该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。 因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。日常场合，这两个词是可以互换的。 而ECMAScript6就是新一代的JavaScript语言。 这里也强烈推荐大家学习ECMAScript6的时候参考这本书ECMAScript 6入门 11.我在学习Vue.js的时候老是听到Webpack，这是啥？Webpack是一个前端打包和构建工具。如果你之前一直是手写HTML，CSS，JavaScript，并且通过link标签将CSS引入你的HTML文件，以及通过Script标签的src属性引入外部的JS脚本，那么你肯定会对这个工具感到陌生。不要紧，我们先来了解一下为什么要用Webpack，然后带着原因去学习就好了。 12.为什么要用Webpack前面说了，做一个单页应用程序本身就相当复杂，而且在做的时候肯定会使用到很多素材和别的第三方库，我们该如何去管理这些东西呢？ 还有前面讲到了Webpack是一个前端打包工具，前端代码为什么要打包呢？因为单页应用程序中用到很多素材，如果每一个素材都通过在HTML中以src属性或者link来引入，那么请求一个页面的时候，可能浏览器就要发起十多次请求，往往请求的这些资源都是一些脚本代码或者很小的图片，这些资源本身才几k，下载连1秒都不需要，但是由于HTTP是应用层协议，它的下层是TCP这个运输层协议，TCP的握手和挥手过程消耗的时间可能比下载资源本身还要长，所以需要把这些小文件全部打包成一个文件，这样只要一次TCP握手和挥手的过程，就把多个资源给下载下来了，并且多个资源由于都是共享一个HTTP请求，所以head等部分也是共享的，相当于形成了规模效应，让网页展现更快，用户体验更好。 前面说到Webpack还有构建的功能，这就不得不提到了ECMAScript6这个新版本的JavaScript，但是现在国内外还有很多人用着老版本的浏览器，这些浏览器并不支持ECMAScript6，那么我们的前端项目如何在这种浏览器上运行呢？这就需要Webpack的Loader自动载入一个转换器来将我们写的ECMAScript6转换成浏览器能支持的老版本JavaScript语言，这个转换器的名字叫做babel，如果你以后听到或者看到了这个单词，应该要知道它就是一个ECMAScript6 to 老版本JavaScript的转换器了。这也是Webpack的构建功能。当然对前端有更深入的同学还会知道Sass，Less，stylus之类的CSS预处理器，我们也可以通过在Loader中编写特定的规则来实现自动将这些CSS预处理语言转换成普通浏览器能识别的CSS代码。 开头的介绍提到了vue.js可以使用单文件组件开发项目，其实也是通过Webpack将单文件组件中的模版，样式以及JS转换到主页面中 当然Webpack不止这点功能，它还可以通过安装各种插件来扩展，比如说热加载技术，就是解放键盘的F5键。让我们修改代码，并且按Ctrl+S保存之后，浏览器页面自动刷新变化，不需要我们去手动刷新，还有一些插件可以自动添加注释，自动给CSS代码加上一些浏览器内核对CSS3兼容前缀，就像webkit-xxx之类的一样。 13.NPM和Node.js又是什么？它们是什么关系？首先讲讲Node.js。我们知道通常情况下，JavaScript的运行环境都是浏览器，因此JavaScript的能力也就局限于浏览器能赋予它的权限了。比如说读写本地系统文件这种操作，一般情况下运行在浏览器中的JavaScript代码是没有这个操作权限的。如果我们想用JavaScript写出一些能够运行在操作系统上的，能够具有像PHP，JAVA之类的编程语言具有的功能的程序该怎么办呢？Node.js就解决了这个问题。Node.js是一个服务端的JavaScript运行环境，通过Node.js可以实现用JavaScript写独立程序。像我们之前提到的Webpack就是Node.js写的，所以作为一个前端开发，即使你不用Node.js写独立程序，也得配一个Node.js运行环境，毕竟很多前端工具都是使用它写的。 NPM是一个node.js的包管理器。我们在传统开发的时候，JQuery.js大多都是百度搜索，然后去官网下载，或者直接引入CDN资源，这种方法太过于麻烦。如果以后遇到其他的包，这个包的代码本身可能还调用了其他的包（也称这个包和其他的那几个包存在依赖关系），那么我们要在自己的项目中引入一个包将变得十分困难。现在我们有了NPM这个包管理器，直接可以通过 npm install xxx包名称 的方式引入它，比如说 npm install vue 就自动在当前项目文件夹下导入了这个包，并且npm自动下载好了vue这个包依赖的其他包。 至于有的人在按照网上的npm教程配置的时候踩坑了，发现下载速度很慢或者完全下载不了，那是因为我国有着众所周知的原因，网上也有各种解决方法可以解决这个问题，大家多善用搜索引擎。 前面提到了Webpack可以安装各种插件来扩展功能，其实也是通过这种方式扩展。 如果你学过PHP的话，NPM就和PHP里面的Composer差不多。也和CentOS下的yum和Ubuntu下的apt-get差不多。 14.Vue-CLi又是啥？它是一个vue.js的脚手架工具。说白了就是一个自动帮你生成好项目目录，配置好Webpack，以及各种依赖包的工具，它可以通过 npm install vue-cli -g 的方式安装，后面的-g表示全局安装的意思，意味着你可以打开命令行之后直接通过vue命令调用它。 15.我该不该学Vue.js？现在Vue.js无论是发展势头还是作者支持还是很好的，而且它本身中文资料就比较多，教程也很多，现在随随便便打开几个和前端开发有关的知乎专栏，基本上都能见到相关文章，社区也很活跃。 至于你该不该学，取决于你自己，如果你当前只是做做以内容展示为主的项目，或者就是成天用各种CMS建站仿站，并且以后都不打算更换更好的工作，那么可以暂时不用学。如果你开发的项目交互非常多，而且前后端开发都对前后端分离有很清楚的认识，那么可以大胆的学习，并且在实际项目中运用。 16.Vue.js怎么火起来的？关于这个问题，网上说法很多，我自己认为主要还是前些年大前端变革太快，而最近一年开始Vue.js+Webpack这个组合开始逐渐稳定下来了，而且已经有了很多中文资料。 对比它的竞争对手AngularJS，新旧版本项目无法平滑升级，变革太大让用户感觉不安稳。 而React本身主流推荐用的是JSX，需要额外学习一门语法（什么？学Vue.js还要学ECMAScript6？现在ECMAScript6是趋势，并不是因为Vue.js才要学的），并且React本身用的是render写法编写模版代码，这让很多用习惯了Smarty等后端模版引擎得人来使用感觉很不适应，现在看来React本身在中国一些论坛社区的火爆程度还是没有Vue.js高。 当然也并不是说除了Vue.js以外其他框架都很差。像知乎新版也是用React开发的，他还是有各自优秀的地方大家可以深入学习之后做出自己的判断。 17.我在很多地方还看到Vuex和Vue-route，它们又是什么？Vuex是vue的一个状态管理器。用于集中管理一个单页应用程序中的各种状态。 Vue-route是vue的一个前端路由器，这个路由器不是我们上网用的路由器，而是一个管理请求入口和页面映射关系的东西。它可以实现对页面局部进行无刷新的替换，让用户感觉就像切换到了网页一样。 要讲清楚这两个东西，又得花费大量篇幅，所以这里只是简单提一下，先学好vue.js本身才是最重要的。 18.我还在一些地方看到过Vue-resource和Axios，它们又是什么？我们在传统的前后端不分离的开发中，后端直接把数据通过模版引擎拼接进了返回的HTML中。而现在做单页应用程序属于前后端分离开发，那么这个单页应用程序中的数据就得通过ajax的方式获取，也要通过ajax的方式提交到后端。 在传统开发中我们都是通过xmlhttprequest手动操作，或者通过JQuery的ajax方法来进行数据提交获取。 vue.js本身没有封装ajax操作库，所以我们要通过Vue-resource和Axios来进行ajax操作，而因为种种原因，现在vue.js2.0已经将axios作为官方推荐的ajax库了。 19.我该学Vue.js2.0还是1.0呢？现在很多框架和语言都是学新不学旧（Python慢慢也变得如此），因此如果不是为了维护老旧项目，肯定推荐学Vue.js2.0。而且学会了Vue.js2.0，再去学习Vue.js1.0也不是什么难事。 20.写Vue.js用什么开发工具和电脑呢？前端开发基本上不需要太高端的电脑都能胜任，现在这个时代是台电脑，装个编辑器都可以做前端开发的。 Vue.js的组件文件本质上还是普通的代码文件，所以各种编辑器配合一些语法检查插件就足够了。我自己用的是sublime text 3，安装一些插件之后可以实现.vue单文件组件高亮代码以及各种自动完成。Webstorm中也有类似插件，大家可以在网上各种教学文章的指导下配置好环境。 结语：可能包括我在内的很多人在看到Vue.js那神奇的双向绑定优雅写法都会有一种非常惊艳，而看到中文文档发布之后有种想立马学习的冲动。可惜大前端终究是大前端，如果一个对于前端各个方面没有深入认识就想着能一步登天，肯定对不起大前端的“大”字。原本看着只想学一个Vue.js，没想到顺带把ECMAScript6，Webpack配置，ESLint配置，bable配置，npm使用，node.js语法，以后vue全家桶中的vuex，vue-route等等等等都学了一遍。前段时间网上也流传出了一个职位叫做Webpack配置工程师，从这里也可以看出弄懂前端这个大杂烩确实不是那么容易。大家一起加油，有什么问题也可以在评论区回复，我会抽空补充在文章内容中。谢谢各位的支持！~ 本文章由 @昌维 原创，在知乎专栏-代码之美 https://zhuanlan.zhihu.com/codes 首发，转载请注明出处。大家喜欢和支持我的文章可以点开我的头像以及专栏名称进行关注，或是点击下方的打赏按钮进行支持，谢谢。^_^ 作者：昌维","link":"/2020/05/30/Vue.js%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"},{"title":"WebRTC系列：WebRTC基础学习之一","text":"1无插件的实时通讯 想象一下，如果你的手机、电视、电脑都可以通过一个平台进行通信，想象一下，你可以在Web应用中轻松地加入视频聊天和p2p数据分享，这就是WebRTC的愿景。 想试一试吗？WebRTC现在已经被集成到Chrome、Opera和Firefox，在apprtc.appspot.com有个简单的视频聊天应用可供测试。 1.在Chrome、Opera或Firefox中打开apprtc.appspot.com。 2.点击允许按钮允许应用启用你的摄像头。 3.在新的选项卡中打开页面底部显示的URL，当然能在另外一台电脑上打开该URL会更好。 关于这个应用的具体教程详见“一个简单的视频聊天客户端”章节。 2快速开始 如果你没有时间阅读这篇文章，想直接编码，你可以这样： 1.看一看Gooogle关于WebRTC的幻灯片（here)。 2.你果你没有用过getUserMedia，要先学习一下它，教程：HTML5 Rocks article，例子：simpl.info/gum。 3.掌握RTCPeerConnection API，教程：本文的代码段，例子：simpl.info/pc，这个例子在一个单独的网页中实现了WebRTC。 4.了解一下WebRTC信令服务、防火墙和NAT转发，教程：apprtc.appspot.com。 5.实在等不及了，可以通过这20+ demos练习WebRTC的Java API。 6.如果有什么问题，可以试试问题帮助页面test.webrtc.org。 或者你可以直接跳到这一步：在WebRTC codelab上一步一步的学习如何构建一个完整的视频聊天应用程序，包括一个简单的信令服务器。 3关于WebRTC的小故事无插件的实时通讯 其实一个Web开发的终极挑战就是通过音频和视频进行实时通信，视频通信应该像文本通信一样自然，如果没有它，我们在用户交互方面的创新能力会受到限制。 在过去，实时通信都比较复杂，需要非常丰富的音频和视频技术才能进行开发。 完整的实现实时通信需要整合大量的数据和服务，在Web上实现尤其困难。 2008年，Gmail视频聊天火了。2011年谷歌发布了Hangouts，收购了GIPS，GIPS为RTC开发了许多组件，比如编码和回声消除技术。谷歌开源了GIPS的相关技术，并且与IETF和W3C等标准化组织达成了行业共识。2011年5月爱立信构建了第一个WebRTC应用。 WebRTC目前实现了实时、无插件的音频、视频和数据通信，我们迫切需要它，因为： 1.许多web service在使用RTC，但是需要下载原生app或者插件，比如Skype、Facebook和谷歌Hangouts。 2.下载、安装和升级插件非常繁琐，而且容易出错。 3.插件不容易发现问题，测试很困难，大部分都需要授权，开发成本太高。 WebRTC项目的宗旨是：API是开源、免费的、标准的、可内建于浏览器且比其他现存的技术更加高效。 4WebRTC使用现状 目前WhatsAPP、Facebook Messenger等应用都使用了WebRTC，不仅如此WebRTC还出现在其他平台中，比如TokBox。WebRTC可以被整合到WebKitGTK+或者Qt原生应用中。 WebRTC实现了下列三个API： 1.MediaStream (别名getUserMedia) 2.RTCPeerConnection 3.RTCDataChannel getUserMedia可用于Chrome、Opera、Firefox和Edge。你可以看看这个跨浏览器的demo和Chris Wilson的amazing examples，这些例子使用getUserMedia作为音频的输入。 RTCPeerConnection可用于Chrome、Opera和Firefox。经过几次迭代之后 RTCPeerConnection被Chrome和Opera实现为webkitRTCPeerConnection，被Firefox实现为mozRTCPeerConnection。其他的实现已经被废弃。当标准化进程稳定之后，这两个实现名字的前缀会被移除。Chromium的一个超级简单的RTCPeerConnection实现在GitHub上，大量的视频聊天应用在apprtc.appspot.com。 RTCDataChannel可用于Chrome、Opera和Firefox。在GitHub上有关于数据通道的例子，可以去实践一下。 5我的第一个WebRTC应用 开发WebRTC应用需要做好下列准备： 1.获取音视频流或者其他数据 2.得到网络信息，如IP地址和端口，通过网络和其它WebRTC客户端交换数据，解决NATs/防火墙穿透问题。 3.协调信令通信来报告错误、启动或关闭会话。 4.交换媒体和客户端信息，比如分辨率和编解码参数。 5.传输音视频流或者其他数据。 为了实现数据流通信，WebRTC实现了下列API： 1.MediaStream：从设备获取数据流，比如说摄像头和麦克风。 2.RTCPeerConnection：音视频通话，包括设备加密和带宽管理。 3.RTCDataChannel：p2p通信。 6MediaStream (别名getUserMedia) MediaStream API代表媒体流的同步。比如，从摄像头和麦克风获取的媒体流具有同步视频和音频轨道。不要将这里的MediaStream轨道和元素混淆，它们是完全不同的概念。 理解MediaStream最简单的方法如下： 1.在Chrome或Opera中打开例子 https://webrtc.github.io/samples/src/content/getusermedia/gum 2.打开控制台 3.检查stream变量，该变量是全局的。 每个MediaStream都有输入，即navigator.getUserMedia()；也有输出，被传递到video元素或RTCPeerConnection getUserMedia()方法有三个参数： 1.一个约束对象。 2.一个成功的回调，如果成功会回传一个MediaStream。 3.一个失败的回调，如果失败会回传一个error对象。 每个MediaStream都有一个label，比如 ‘Xk7EuLhsuHKbnjLWkW4yYGNJJ8ONsgwHBvLQ’,getAudioTradks()和 getAudioTracks()方法会回传一个MediaStreamTracks对象的数组。 在例子 https://webrtc.github.io/samples/src/content/getusermedia/gum 中,stream.getAudioTracks()回传了一个空数组（因为没有音频），假设摄像头正常工作并连接，stream.getVideoTracks()回传一个MediaStreamTracks对象的数组。数组中的每个MediaStreamTracks对象包含一种媒体（‘video’或‘audio’）和一个label（比如’FaceTime HD Camera (Built-in)’），而且还代表了一个或多个音视频的数据通道。在这个例子中，只有一个视频轨道，没有音频。当然，很容易就能扩展到其他情况。 在Chrome或Opera中, URL.createObjectURL()方法将MediaStream转换成Blob URL，该Blob URL可以设置为video元素的输入（在Firefox和Opera中，视频源可以通过数据流本身设置）。版本M25开始，基于Chromium的浏览器（Chrome和Opera）允许来自getUserMedia的音频数据传递到aduio或video元素。 getUserMedia还可用作Web Audio API的输入节点。 在manifest中添加audioCapture和videoCapture权限可以在加载的时候得到（仅一次）授权，毕竟加载之后用户不会再有对摄像头或麦克风的访问请求。 最终的目的是使MediaStream适用于任何数据源，不仅限于摄像头和麦克风，还包括来自磁盘或者传感器等输入设备二进制数据。 需要注意的是getUserMedia()必须在服务器上使用，而不是本地文件中，否则的话将会抛出权限的错误PERMISSION_DENIED。 getUserMedia()通常和其他的Java API及库一起使用: Webcam Toy是一个photobooth应用，它使用WebGL来添加一些特效，让用户可以共享照片或是保存到本地。 FaceKat是一个人脸追踪的游戏，使用headtrackr.js。 ASCII Camera使用Canvas API来生成ASCII码的图片。 7约束 Constraints已经在Chrome、FireFox和Opera中实现了。通过约束可以设置getUserMedia()和RTCPeerConnection的addStream()获取视频的分辨率，约束的实现是为了通过applyConstraints()方法控制视频高度和宽度的比例、帧率、和正反摄像头模式等等…… 这里有一个例子： https://webrtc.github.io/samples/src/content/getusermedia/resolution/。 一个陷阱：getUserMedia约束设置在浏览器的一个标签中，会约束之后打开的所有标签。设置一个非法的值会提示以下错误： 8屏幕和标签捕获 Chrome应用可以通过chrome.tabCapture和chrome.desktopCapture这两个API实时分享浏览器标签或者整个桌面。桌面捕获的例子：WebRTC samples GitHub repository。更多关于屏幕录制、编码的信息和有参考：Screensharing with WebRTC。 在Chrome中，可以将屏幕捕获当做MediaStream的数据源，此时使用的是实验性的chromeMediaSource约束，一个例子：this demo。需要注意的是屏幕捕获功能需要HTTPS支持，并且只用于开发中，通过一个命令行标志来启用。 9信令：会话控制，网络和媒体信息 WebRTC使用RTCPeerConnection在浏览器（别名peer）之间互通数据流，但是需要一种机制去协调通信或者发送控制消息，这个过程被称为信令。WebRTC没有指定信令方法和协议，信令不是RTCPeerConnection API的一部分。 因此，WebRTC应用的开发者可用选择其擅长的消息协议，比如SIP或XMPP，或者其他合适的双工通信协议。 apprtc.appspot.com这个例子使用XHR和Channel API作为信令机制。codelab是我们通过Socket.io构建，运行在Node server上的应用。 信令通常用于交互三类信息： 1.会话控制消息；初始化或者关闭通信，报告错误。 2.网络信息：对于外部而言，我的IP地址和端口是什么？ 3.媒体信息：什么编码和分辨率浏览器可以处理，我的浏览器要和谁通信。 在p2p的流传输之前，必须通过信令成功的交换信息。 假如Alice想和Bob通信，这里有个简单的例子来自WebRTC W3C Working Draft，展示了实际的信令处理过程。例子中假设存在某种信令机制，该机制通过createSignalingChannel()方法创建。注意在Chrome和Opera中，RTCPeerConnection是带有前缀的。 首先，Alice和Bob交换网络信息，‘finding candidates’表示通过ICE framework查找网络接口和端口。 1.Alice创建一个RTCPeerConnection对象，该对象内置onicecandidate处理器。 2.这个处理器在网络candidate生效时开始运行。 3.Alice通过信令通道发送序列化的数据给Bob，信令通道可以是WebSocket或者其他机制。 4.当Bob收到Alice的candidate消息后，调用addIceCandidate将candidate添加到远端描述。 WebRTC客户端（别名peer，这里指Alice和Bob）需要明确并交换本地和远程音视频媒体信息，比如分辨率和编码格式。交换媒体信息的信令，是通过交换会话描述协议（SDP）来实现的。 1.Alice调用了RTCPeerConnection的createOffer()方法，它的回调参数传入的是RTCSessionDeion（Alice的本地会话描述）。 2.在回调中，Alice调用setLocalDeion()方法设置了本地会话描述，然后将该会话描述通过信令通道发送给Bob。注意，RTCPeerConnection并不会采集candidate直到setLocalDeion()被调用。 3.Bob使用setRemoteDeion()方法将Alice发送给他的会话描述设置为远程会话描述。 4.Bob调用了RTCPeerConnection的createAnswer()方法，并传入它从Alice接收到的远程会话描述，此时一个与Alice兼容的本地会话产生了。createAnswer()的回调参数传入的是RTCSessionDeion（Bob将它设置为本地会话描述并发送给Alice）。 5.当Alice收到Bob的会话描述，她使用setRemoteDeion()方法将其设置为远程会话描述。 6.Ping RTCSessionDeion对象遵从SDP（Session Deion Protocol），一个SDP对象看起来如下所示： 交换网络和媒体信息可以同时进行，但这两个过程必须在音视频流开始传输之前完成。 上述的offer/answer架构被称为JSEP（Java Session Establishment Protocol），JSEP架构如下所示： 一旦信令过程成功，就可以直接进行Caller和callee之间p2p的数据流传输了。 10RTCPeerConnection RTCPeerConnection是WebRTC的组件，用来稳定高效的处理端对端的数据流通信。 下图是WebRTC的架构图，标明了RTCPeerConnection扮演的角色。你可能注意到了，绿色部分是相当复杂的。 从Java的角度来看，理解这个图最重要的是理解RTCpeerConnection这一部分。WebRTC对编解码器和协议做了大量的工作，使实时通信成为可能，甚至在一些不可靠的网络中： 1.包补偿 2.回声消除 3.自适应带宽 4.视频抖动缓冲 5.自动增益控制 6.噪声抑制 7.图像清除 章节九中的例子从信令的角度进行了讲解，下面我们将学习两个WebRTC应用；一个简单的演示了RTCPeerConnection，另一个是功能齐全的视频聊天客户端。 11无服务器的RTCPeerConnection 下面的代码来自 https://webrtc.github.io/samples/src/content/peerconnection/pc1 包含基于网页的本地和远程RTCPeerConnection。这个例子中caller和callee在同一个网页中，能更加清晰的展示RTCPeerConnection API的工作流程，因为RTCPeerConnection对象之间可以直接交换数据和消息，不需要通过中继信道机制。 一个陷阱：RTCPeerConnection()第二个约束类型的参数是可选的，它与getUserMedia()中使用的约束类型不同。 本例中pc1表示本地端（caller），pc2表示远程端（callee） caller 1.创建一个RTCPeerConnection，并通过getUserMedia()添加数据流。 2.创建一个offer，并将它设置为pc1的本地会话描述，设置为pc2的远程会话描述。可以直接在代码中设置，不需要使用信令，因为caller和callee在同一个网页中。 callee 1.创建pc2，接收pc1的数据流，并显示到video元素中 12有服务器的RTCPeerConnection 实际应用中，WebRTC需要服务器，无论多简单，下面四步是必须的： 1.用户通过交换名字之类的信息发现对方。 2.WebRTC客户端应用交换网络信息。 3.客户端交换媒体信息包括视频格式和分辨率。 4.WebRTC客户端穿透NAT网关和服务器。 换句话说，WebRTC需要四种类型的服务端功能。 1.用户发现和通信 2.信令 3.NAT/防火墙穿透 4.中继服务器，防止端到端的通信失败 以上这些不在本文讨论范围之内。可以说基于STUN和TURN协议的ICE框架，使得RTCPeerConnection处理NAT穿透和其他网络难题成为可能。 ICE框架用于端到端的连接，比如说两个视频聊天客户端。起初，ICE尝试通过UDP直接连接两端，这样可以保证低延迟。在这个过程中，STUN服务器有一个简单的任务：使NAT后边的端能找到它的公网地址和端口（谷歌有多个STUN服务器，其中一个用在了 apprtc.appspot.com例子）。 如果UDP传输失败，ICE会尝试TCP：首先是HTTP，然后才会选择 HTTPS。如果直接连接失败，通常因为企业的NAT穿透和防火墙，此时ICE使用中继（Relay）服务器。换句话说，ICE首先使用STUN和UDP直接连接两端，失败之后返回中继服务器。‘finding cadidates’就是寻找网络接口和端口的过程。 WebRTC工程师Justin Uberti在幻灯片2013 Google I/O WebRTC presentation中提供了许多关于ICE、STUN和TURN的信息。 13一个简单的视频聊天客户端 如果你觉得这个例子比较难，你也行会喜欢上我们的WebRTC codelab。那里一步步的介绍了如何建立一个完整的视频聊天应用，包括一个运行于Node server上基于Socket.io的信令服务器。 apprtc.appspot.com是一个测试WebRTC的好地方，里面有视频聊天的例子，它实现了信令和基于STUN服务器的NAT/防火墙穿透。这个例子使用adapter.js处理不同的RTCPeerConnection和getUserMedia()实现。 下面我们详细的过一遍代码。 如何开始 这个例子从initialize()函数开始运行。 需要注意的是，变量room和openChannel()参数的值都是由Google App Engine应用自身提供的。查看一下index.html template 就知道该赋什么值了。 这段代码初始化HTML video元素的相关变量，video元素播放来自本地摄像头（localVieo）和远程摄像头（remoteVideo）的视频流。resetStatus()设置了一条状态消息。 openChannel()函数建立了WebRTC客户端间的消息通道。 关于信令，本例使用的是Google App Engine Channel API，这使得JavaScritp客户端无需轮询就能实现消息传输。 使用Channel API建立通道的流程大致如下： 1.客户端A生成一个唯一ID。 2.客户端A向Google App Engine应用请求一个通道标识（即openChannel()的参数），并将它的ID传给Google App Engine应用。 3.Google App Engine应用会调用Channel API为客户端ID分配一个通道和一个通道标识。 4.Google App Engine应用将通道标识发给客户端A。 5.客户端A打开socket并监听服务器上建立的通道。 发送消息的流程大致如下： 1.客户端B给Google App Engine应用发送了一个POST请求，要求升级程序。 2.Google App Engine应用给通道发送一个请求消息。 3.消息经通道传递给客户端A 4.客户端A的onmessage回调函数被调用。 重申一次，信令传输机制是由开发者选择的。WebRTC并没有指定信令机制。本例的Channel API能被其他的方式取代，比如WebSocket。 initialize()调用完openChannel()之后，紧接着调用getUserMedia()，这个函数可以检测出浏览器是否支持getUserMedia API。如果一切顺利，onUserMediaSuccess会被调用。 这样一来，本地摄像头就能显示在localVideo元素中了。 此时，initiator被设置成1（直到caller的会话终止），maybeStart()被调用。 该函数使用了一种巧妙的结构，可以工作于多个异步回调：maybeStart()可能被任何函数调用，但是只有当localStream被定义、channelReady为true且通信还未开始的情况下，maybeStart()才会运行。因此，当连接还未建立，本地流已经可用，且信令通道已经准备好时，连接才会创建并加载本地视频流。接着started被设置为true。所以连接不会被创建多次 。 RTCPeerConnection: 发起通话 在 maybeStart()中被调用的createPeerConnection()，才是关键所在。 这段代码的目的是使用STUN服务器建立一个连接，并将onIceCandidate()作为回调函数。然后给RTCPeerConnection每个事件指定处理器（函数）：当会话连接或打开，当远程流被加载或移除。在本例中，这些处理器只是记录了状态消息——除了onRemoteStreamAdded()，它给remoteVideo元素设置了数据源。 一旦createPeerConnection()在maybeStart()中被调用，就会发起通话，创建Offer并发送消息给对端。 这里的offer创建过程类似于上面无信令的例子。但是，除此之外，一条消息被发送到了对端，详见setLocalAndSendMessage()： 用Channel API传输信令 当RTCPeerConnection在createPeerConnection()中成功创建的时候，onIceCandidate()回调函数会触发，并发送关于candidate的信息。 从客户端到服务器的消息外传，是通过sendMessage()方法内的XHR请求实现的。 XHR多用于从客户端发送信令消息到服务端，但是某些机制需要用来实现服务端到客户端的消息传输：本例用的是Google App Engine Channel API。来自此API的消息会传递到 processSignalingMessage()： 如果消息是来自对端的answer（offer的回应），RTCPeerConnection设置远程会话描述，通信开始。如果消息是offer（来自callee），RTCPeerConnection设置远程会话描述，发送answer给callee，然后调用RTCPeerConnection的startIce()方法发起连接。 于是乎，caller和callee都发现了对方并交换相关信息，会话被初始化，实时数据通信可以开始了。 网络技术 WebRTC目前只实现了一对一的通信，但是可用于更复杂的网络环境：比如，多个peer各自直接通信，即p2p；或者通过MCU（Multipoint Control Unit）服务器来实现流的转发、合成或音视频的录制。 许多WebRTC应用只演示了浏览器间的通信，但是通过网关服务器可以实现WebRTC与telephones（别名PSTN）和VOIP系统直接的通信。2012年5月，Doubango Telecom开源了sipml5 SIP client，该客户端基于WebRTC和WebSocket，能实现浏览器和IOS或Android应用之间的视频通话。 14RTCDataChannel 除了音频和视频，WebRTC支持其他类型数据的实时通信。 TCDataChannel API支持p2p低延迟和高吞吐量的二进制数据流交换，这里有个例子：http://webrtc.github.io/samples/src/content/datachannel/datatransfer 很多领域都潜在地使用到了这个API，比如： 1.游戏 2.远程桌面应用 3.实时文字聊天 4.文件传输 5.分散网络 充分利用了RTCPeerConnection的多个特性，能实现强大而灵活的p2p通信。 1.利用RTCPeerConnection进行会话设置。 2.通过优先级设置多个同步的channel。 3.可靠和非可靠的语义传递。 4.内建立安全的DTLS和拥塞控制。 5.能用于音视频或其他方面 TCDataChannel API语法与WebSocket类似，包括send()方法和message事件。 因为是浏览器间的直接通信，所以RTCDataChannel要比WebSocket快得多，即使通信用到了中继服务器。 RTCDataChannel可用于Chrome、Opera和Firefox。出色的Cube Slam游戏使用TCDataChannel API来交换游戏状态：是敌还是友！Sharefest演示了通过RTCDataChannel分享文件，peerCDN提供了WebRTC如何实现p2p内容分发的一种思路。 更多关于RTCDataChannel的信息，可以参考IETF的draft protocol spec。 15安全 实时通信应用或插件会在许多方面忽视了安全性： 1.浏览器之间、浏览器与服务器之间的音视频或其他数据没有加密。 2.应用在用户没有察觉的情况下录制和分发音视频。 3.恶意软件或病毒可能入侵了正常的插件或应用。 WebRTC的许多特性可以避免这些问题： 1.WebRTC采用类似DTLS和SRTP的安全协议。 2.所有的WebRTC组件强制加密，包括信令机制。 3.WebRTC不是插件：它的组件运行于浏览器沙盒，不是独立的一个进程，这些组件不需要单独安装，且随着浏览器更新。 4.摄像头和麦克风的访问必须经过明确准许，当摄像头和麦克风运行时，界面上会清楚的显示出来。 关于流媒体安全的讨论超出了本文的范畴。更多信息可参考IETF的WebRTC Security Architecture。","link":"/2020/03/22/WebRTC%E7%B3%BB%E5%88%97%EF%BC%9AWebRTC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%80/"},{"title":"【前端知识梳理】HTML篇 笔记整理（一）","text":"1、html5有哪些新特性、移除了那些元素？ 2、前端注意哪些SEO? 3、从浏览器地址栏输入url到显示页面的步骤 4、如何进行网站性能优化 5、语义化的理解 6、对浏览器内核的理解 7、请描述一下 cookies，sessionStorage 和 localStorage 的区别？ 8、页面访问cookie的限制条件 9、cookie的作用与弊端 10、介绍cookie的属性 11、预测最近面试会考 Cookie 的 SameSite 属性 12、SameSite 13、doctype 的作用？严格模式与混杂模式如何区分？它们有何意义？ 14、HTML5 为什么只需写&lt; !DOCTYPE HTML&gt; ? 15、WEB标准以及W3C标准是什么? 16、行内元素有哪些？块级元素有哪些？空（void）元素有哪些？ 17、xhtml和html有什么区别? 18、iframe有那些缺点？ 19、网页验证码是干嘛的，是为了解决什么安全问题 20、title与h1的区别、b与strong的区别、i与em的区别？ 1、html5有哪些新特性、移除了那些元素？ HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加 绘画 canvas 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失 sessionStorage 的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如article、footer、header、nav、section 表单控件，calendar、date、time、email、url、search 新的技术webworker、 websocket、 Geolocation 移除 的元素： 纯表现的元素：basefont、big、center、font、 s、strike、tt、u 对可用性产生负面影响的元素：frame、frameset、noframes 支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签 可以利用这一特性让这些浏览器支持HTML5新标签 浏览器支持新标签后，还需要添加标签默认的样式 当然也可以直接使用成熟的框架、比如html5shim 12345&lt;!--[if lt IE 9]&gt; &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; &lt;![endif]--&gt; 2、前端注意哪些SEO? 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 3、从浏览器地址栏输入url到显示页面的步骤简略回答 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成。 详细回答 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系） 开启网络线程到发出一个完整的HTTP请求（这一部分涉及到dns查询，TCP/IP请求，五层因特网协议栈等知识） 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等） 后台和前台的HTTP交互（这一部分包括HTTP头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等） 单独拎出来的缓存问题，HTTP的缓存（这部分包括http缓存头部，ETag，catch-control等） 浏览器接收到HTTP数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和DOMContentLoaded等） CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念） JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等） 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容） 4、如何进行网站性能优化 content 方面 减少HTTP请求：合并文件、CSS精灵、inline Image 减少DNS查询：DNS缓存、将资源分布到恰当数量的主机名 减少DOM元素数量 Cookie 方面 减小cookie大小 Server 方面 使用CDN 配置ETag 对组件使用Gzip压缩 图片 方面 优化图片：根据实际颜色需要选择色深、压缩 优化css精灵 不要在HTML中拉伸图片 css 方面 将样式表放到页面顶部 不使用CSS表达式 使用&lt;link&gt;不使用@import js 方面 将脚本放到页面底部 将javascript和css从外部引入 压缩javascript和css 删除不需要的脚本 减少DOM访问 5、语义化的理解 简单来说：用正确的标签做正确的事情！ HTML语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析； 在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的。 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解 6、对浏览器内核的理解 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核 JS引擎则：解析和执行javascript来实现网页的动态效果 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎 7、请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密） cookie数据始终在同源的http请求中携带（即使不需要），即会在浏览器和服务器间来回传递 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存 存储大小： cookie数据大小不能超过4k sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage 数据在当前浏览器窗口关闭后自动删除 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 8、页面访问cookie的限制条件cookie （储存在用户本地终端上的数据） cookie 指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据。cookie 在网络系统中几乎无处不在，当我们浏览以前访问过的网站时，网页中可能会出现 ：你好 XXX。 1. 跨域问题： cookie允许Web开发者保留他们的用户的登录状态。但是当你的站点有一个以上的域名时就会出现问题了。在cookie规范上说，一个cookie只能用于一个域名，不能够发给其它的域名。因此，如果在浏览器中对一个域名设置了一个cookie，这个cookie对于其它的域名将无效。 解决： 通过nginx反向代理 jsonp方式请求 2. 设置了HTTP only： 如果在cookie中设置了HttpOnly属性，那么通过程序(JS脚本、Applet等)将无法读取到cookie信息，这样能有效的防止XSS攻击。 9、cookie的作用与弊端cookie的作用 可以在客户端上保存用户数据，起到简单的缓存和用户身份识别等作用。 保存用户的登陆状态，用户进行登陆，成功登陆后，服务器生成特定的cookie返回给客户端，客户端下次访问该域名下的任何页面，将该cookie的信息发送给服务器，服务器经过检验，来判断用户是否登陆。 记录用户的行为。 cookie弊端 增加流量消耗，每次请求都需要带上cookie信息。 安全性隐患，cookie使用明文传输。如果cookie被人拦截了，那人就可以取得所有的session信息。 Cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉 10、介绍cookie的属性在chrome控制台中的Application选项卡中可以看到cookie的信息。 一个域名下面可能存在着很多个cookie对象。但一个cookie只能用于一个域名，不能够发给其它的域名。 Name 为一个cookie的名称（用 JavaScript 操作 Cookie 的时候注意对 Value 进行编码处理。） value 为一个cookie的值（用 JavaScript 操作 Cookie 的时候注意对 Value 进行编码处理。） Domain 为可以访问此cookie的域名 注：二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie。所以要想cookie在多个二级域名中共享，需要设置domain为顶级域名，这样就可以在所有二级域名里面获得到这个cookie的值了。 顶级域名只能获取到domain设置为顶级域名的cookie，其他domain设置为二级域名的无法获取。 Path 为可以访问此cookie的页面路径。 比如domain是abc.com,path是/test，那么只有/test路径下的页面可以读取此cookie Expires 字段为此cookie超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; 当为会话性 Cookie 的时候，值保存在客户端内存中，并在用户关闭浏览器时失效。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样。 与会话性 Cookie 相对的是持久性 Cookie，持久性 Cookies 会保存在用户的硬盘中，直至过期或者清除 Cookie。这里值得注意的是，设定的日期和时间只与客户端相关，而不是服务端。 Max-Age Max-Age 用于设置在 Cookie 失效之前需要经过的秒数。比如： 1Set-Cookie: id=a3fWa; Max-Age=604800; Max-Age 可以为正数、负数、甚至是 0。 如果 max-Age 属性为正数时，浏览器会将其持久化，即写到对应的 Cookie 文件中。 当 max-Age 属性为负数，则表示该 Cookie 只是一个会话性 Cookie。 当 max-Age 为 0 时，则会立即删除这个 Cookie。 假如 Expires 和 Max-Age 都存在，Max-Age 优先级更高。 Size 此cookie大小 HttpOnly 若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。 Secure 设置是否只能通过https来传递此条cookie。使用 HTTPS 安全协议，可以保护 Cookie 在浏览器和 Web 服务器间的传输过程中不被窃取和篡改。 SameSite( 3月份比较火的一个问题，下面会参考别人文章进行整理） 11、预测最近面试会考 Cookie 的 SameSite 属性参考文章出处 前言 2 月份发布的 Chrome 80 版本中默认屏蔽了第三方的 Cookie，在灰度期间，就导致了阿里系的很多应用都产生了问题，为此还专门成立了小组，推动各 BU 进行改造，目前阿里系基本已经改造完成。所有的前端团队估计都收到过通知，也着实加深了一把大家对于 Cookie 的理解，所以很可能就此出个面试题，而即便不是面试题，当问到 HTTP 相关内容的时候，不妨也扯到这件事情来，一能表明你对前端时事的跟进，二还能借此引申到前端安全方面的内容，为你的面试加分。 HTTP 一般我们都会说 “HTTP 是一个无状态的协议”，不过要注意这里的 HTTP 其实是指 HTTP 1.x，而所谓无状态协议，简单的理解就是即使同一个客户端连续两次发送请求给服务器，服务器也识别不出这是同一个客户端发送的请求，这导致的问题就比如你加了一个商品到购物车中，但因为识别不出是同一个客户端，你刷新下页面就没有了…… Cookie 为了解决 HTTP 无状态导致的问题，后来出现了 Cookie。不过这样说可能会让你产生一些误解，首先无状态并不是不好，有优点，但也会导致一些问题。而 Cookie 的存在也不是为了解决通讯协议无状态的问题，只是为了解决客户端与服务端会话状态的问题，这个状态是指后端服务的状态而非通讯协议的状态。 Cookie 的设置 那 Cookie 是怎么设置的呢？简单来说就是 客户端发送 HTTP 请求到服务器 当服务器收到 HTTP 请求时，在响应头里面添加一个 Set-Cookie 字段 浏览器收到响应后保存下 Cookie 之后对该服务器每一次请求中都通过 Cookie 字段将 Cookie 信息发送给服务器。 12、SameSiteSameSite 是最近非常值得一提的内容，因为 2 月份发布的 Chrome80 版本中默认屏蔽了第三方的 Cookie，这会导致阿里系的很多应用都产生问题，为此还专门成立了问题小组，推动各 BU 进行改造。 作用 SameSite 属性可以让Cookie在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。 属性值 Strict仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。 Lax允许部分第三方请求携带 Cookie None无论是否跨站都会发送 Cookie 之前默认是 None 的，Chrome80 后默认是 Lax。 跨域和跨站 首先要理解的一点就是跨站和跨域是不同的。同站(same-site)/跨站(cross-site)」和第一方(first-party)/第三方(third-party)是等价的。但是与浏览器同源策略（SOP）中的「同源(same-origin)/跨域(cross-origin)」是完全不同的概念。 同源策略的同源是指两个 URL 的协议/主机名/端口一致。例如，https://www.taobao.com/pages/...，它的协议是 https，主机名是www.taobao.com，端口是 443。 同源策略作为浏览器的安全基石，其「同源」判断是比较严格的，相对而言，Cookie中的「同站」判断就比较宽松：只要两个 URL 的 eTLD+1 相同即可，不需要考虑协议和端口。其中，eTLD 表示有效顶级域名，注册于 Mozilla 维护的公共后缀列表（Public Suffix List）中，例如，.com、.co.uk、.github.io 等。eTLD+1 则表示，有效顶级域名+二级域名，例如taobao.com等 举几个例子，www.taobao.com和www.baidu.com是跨站，www.a.taobao.com和www.b.taobao.com是同站，a.github.io和b.github.io是跨站(注意是跨站)。 改变 接下来看下从 None 改成 Lax 到底影响了哪些地方的 Cookies 的发送？直接来一个图表： 从上图可以看出，对大部分 web 应用而言，Post 表单，iframe，AJAX，Image 这四种情况从以前的跨站会发送三方 Cookie，变成了不发送。 Post表单：应该的，学 CSRF 总会举表单的例子。 iframe：iframe 嵌入的 web 应用有很多是跨站的，都会受到影响。 AJAX：可能会影响部分前端取值的行为和结果。 Image：图片一般放 CDN，大部分情况不需要 Cookie，故影响有限。但如果引用了需要鉴权的图片，可能会受到影响。 除了这些还有 script 的方式，这种方式也不会发送 Cookie，像淘宝的大部分请求都是 jsonp，如果涉及到跨站也有可能会被影响。 问题 我们再看看会出现什么的问题？举几个例子： 天猫和飞猪的页面靠请求淘宝域名下的接口获取登录信息，由于 Cookie 丢失，用户无法登录，页面还会误判断成是由于用户开启了浏览器的“禁止第三方 Cookie”功能导致而给与错误的提示 淘宝部分页面内嵌支付宝确认付款和确认收货页面、天猫内嵌淘宝的登录页面等，由于 Cookie 失效，付款、登录等操作都会失败 阿里妈妈在各大网站比如今日头条，网易，微博等投放的广告，也是用 iframe 嵌入的，没有了 Cookie，就不能准确的进行推荐 一些埋点系统会把用户 id 信息埋到 Cookie 中，用于日志上报，这种系统一般走的都是单独的域名，与业务域名分开，所以也会受到影响。 一些用于防止恶意请求的系统，对判断为恶意请求的访问会弹出验证码让用户进行安全验证，通过安全验证后会在请求所在域种一个Cookie，请求中带上这个Cookie之后，短时间内不再弹安全验证码。在Chrome80以上如果因为Samesite的原因请求没办法带上这个Cookie，则会出现一直弹出验证码进行安全验证。 天猫商家后台请求了跨域的接口，因为没有 Cookie，接口不会返回数据 …… 如果不解决，影响的系统其实还是很多的…… 解决方案就是设置 SameSite 为 none。 13、doctype 的作用？严格模式与混杂模式如何区分？它们有何意义？DOCTYPE是document type (文档类型) 的缩写。 &lt; !DOCTYPE &gt; 声明位于文档的最前面，处于标签之前，它不是html标签。主要作用是告诉浏览器的解析器使用哪种HTML规范或者XHTML规范来解析页面。 严格模式和混杂模式都是浏览器的呈现模式，浏览器究竟使用混杂模式还是严格模式呈现页面与网页中的DTD（文件类型定义）有关，DTD里面包含了文档的规则。比如：loose.dtd 严格模式：又称标准模式，是指浏览器按照W3C标准来解析代码，呈现页面 混杂模式：又称为怪异模式或者兼容模式，是指浏览器按照自己的方式来解析代码，使用一种比较宽松的向后兼容的方式来显示页面。 14、HTML5 为什么只需写&lt; !DOCTYPE HTML&gt; ?HTML5不基于 SGML （标准通用标记语言），因此不需要对DTD（ DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。）进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 15、WEB标准以及W3C标准是什么?标签闭合、标签小写、不乱嵌套、使用外链css和js、结构行为表现的分离 16、行内元素有哪些？块级元素有哪些？空（void）元素有哪些？行内元素不可以设置宽高，不独占一行块级元素可以设置宽高，独占一行 行内： 1&lt;a&gt;、&lt;abbr&gt;、&lt;acronym&gt;、&lt;b&gt;、&lt;bdo&gt;、&lt;big&gt;、&lt;br&gt;、&lt;cite&gt;、&lt;code&gt;、&lt;dfn&gt;、&lt;em&gt;、&lt;i&gt;、&lt;img&gt;、&lt;input&gt;、&lt;kbd&gt;、&lt;label&gt;、&lt;q&gt;、&lt;samp&gt;、&lt;select&gt;、&lt;small&gt;、&lt;span&gt;、&lt;strong&gt;、&lt;sub&gt;、&lt;sup&gt;、&lt;textarea&gt;、&lt;tt&gt;、&lt;var&gt; 块级： 1&lt;address&gt;、&lt;caption&gt;、&lt;dd&gt;、&lt;div&gt;、&lt;dl&gt;、&lt;dt&gt;、&lt;fieldset&gt;、&lt;form&gt;、&lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;、&lt;h6&gt;、&lt;hr&gt;、&lt;legend&gt;、&lt;li&gt;、&lt;noframes&gt;、&lt;noscript&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;p&gt;、&lt;pre&gt;、&lt;table&gt;、&lt;tbody&gt;、&lt;td&gt;、&lt;tfoot&gt;、&lt;th&gt;、&lt;thead&gt;、&lt;tr&gt; 空： 常见的： 1&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; 鲜为人知的： 1&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;link&gt; &lt;meta&gt;&lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt; 17、xhtml和html有什么区别? 功能上的差别 主要是XHTML可兼容各大浏览器、手机以及PDA，并且浏览器也能快速正确地编译网页 书写习惯的差别 XHTML 元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素 18、iframe有那些缺点？ iframe会阻塞主页面的Onload事件 搜索引擎的检索程序无法解读这种页面，不利于SEO iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题 19、网页验证码是干嘛的，是为了解决什么安全问题 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试 20、title与h1的区别、b与strong的区别、i与em的区别？ title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响; strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时，&lt;strong&gt; 会重读，而&lt;B&gt;是展示强调内容。 i 内容展示为斜体，em表示强调的文本；","link":"/2020/04/11/%E3%80%90%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E3%80%91HTML%E7%AF%87-%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"一个简单的RTMP服务器实现","text":"一个简单的RTMP服务器实现 — RTMP实现要点_网络_Sky…_CSDN博客 2019年1月8日 - 《一个简单的RTMP服务器实现 — RTMP与FLV》:https://blog.csdn.net/u011728480/article/details/85780974 RTMP简介 RTMP是Real Time Messaging Proto… 一个简单的RTMP服务器实现 — RTMP复杂握手(Complex H…_CSDN博客 2019年1月9日 - #PS:要转载请注明出处,本人版权所有#PS:这个只是 《 我自己 》理解,如果和你的#原则相冲突,请谅解,勿喷背景参考前置文章:《一个简单的RTMP服务器实现 … 大概是最简单的 rtmp 推流_服务器_搭建方法 - 简书 2017年9月24日 - 一开始想到要弄_一个简单的 rtmp 服务器_是为了给同学上课投射屏幕用。因为我用的是 Linux ,没法用国产的那些课室软件给他们投放屏幕,于是只好出此下策… simple-rtmp-server 是一个_很_简单的_流媒体_服务器, - 安子 - 博客园 2014年12月31日 - · nginx + rtmp 搭建流媒体服务器_· Simple-_RTMP-Server 服务器_搭建· 推荐一款优秀的开源流媒体_服务器_系统:SRS(Simple _RTMP Server)· _实现_输出h264… 大概是最简单的 rtmp 推流_服务器_搭建方法 - 知乎 2018年12月18日 - 一开始想到要弄_一个简单的 rtmp 服务器_是为了给同学上课投射屏幕用。因为我用的是 Linux ,没法用国产的那些课室软件给他们投放屏幕,于是只好出此下策… iOS_简单_直播实现(一:创建本地rtmp服务器)_园荐_博客园 根据上面教程配置好nginx+rtmp服务器 原先准备自己_实现_一下直播推流,但是今天在技术群聊的时候, 有朋友推荐了优酷土豆旗下来疯直播前不久开源的iOS推流框架LFLive… 如何搭建_一个简单的rtmp_协议的流媒体_服务器__百度知道 2016年9月25日 - 回答：下个red5 装上。 .wa-se-st-single-video-zhanzhang-play { position: absolute; height: 40px; width: 40px; top: 50%; left: 50%; margin: -20px 0 0 -20px; background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpmOWQ4YzVjMi1kMjNiLTQ5ZjEtOWIyNi0wOGY3MmY4MTc1NTMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MDc0OTQ3OURGODgzMTFFNUFFQkZEMDZGREMzOTdFMTkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MDc0OTQ3OUNGODgzMTFFNUFFQkZEMDZGREMzOTdFMTkiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2Y2IwNzk4OC0yYjNiLTQ2MDItYTllMS0zNzI1Yzk5NTZmMmQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6ZjlkOGM1YzItZDIzYi00OWYxLTliMjYtMDhmNzJmODE3NTUzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Rtt+oAAABS5JREFUeNq8mWtIW2cYxxOXpNtUoihYbbxhzMAJ3jMvKxPnZR9Gvawdm2hhWOy+DLzPil91ImzKPq2jH1QQyqBRB4La6izzNi9RQYMzGg3qbCcuc5rNxBj3f9w53WhXzck5xwcekkPO+7y/vO95n9uRnpycSNyQV6Dp0AxoNPQK1AeqYH63Q3+HbkEXoEPQYegx14mkHAEjoGXQd61Wq3N1dXVrcnLy6cTExN74+PjB9vb2Ed0UGBgoT0lJ8UpOTlZqtdqAiIiIK56enh74aRDaCl0VGvAy9AvoOzMzM8uNjY0/63Q6C5d/VlBQ4FtXV/dGQkKCBpePoXegT4QAvAWtnp+fX8/Pz9evra3ZJDwkPDz8UldXV3xMTEwYLr+EfnvW/R5n/CaHtlsslsqampqHsbGx43zhSMgG2aqurn4I2+U0BzMXpxX0hn5nNpt9kpKShnZ2do4kIoifn58cj0xGaGgoHagPofuuANK/6TYajV7R0dHDdrv9RCKiKBQK6cLCQnpkZOQBLvOgR+cBdmDlItVq9YDD4RAVjhWZTCZdWVnJxkoacXnzrGewFM9FIk7a0EXBkdBcNCfNjcvbLwMkV1IJFzK0u7t7JLlgoTkbGhrIoVcyjv+FLW6HK7lMJ8xVozhAyqmpqT0hQWdnZ1PA8JTdanYFyXlezcvL03MxVl9fn4hIcj0kJORVoQDJ1+LjbYbpGeBn09PTy+vr65z9HFbxzbm5udvFxcUqIQCJgViIiQWkwJ9J4ctdo76+vj5tbW2fdHZ2XqUTyReSYckkNgJMR+B3IPxY+Bj1gBQWFmYsLi7ejIuL8+Zji1iIidgIMBM+6BehniGNRhM2MjLyKcKjho8dZErElEGAUQg3vwp5El+HNDU1fdzf3/+eUqmUuWMDzyGd5GgCVI2OjlqE9mtSqVSSnZ39lsFguJWVleXPdTyYKD6rCJB8mVUsBxwUFBTQ29tb2tLSEsdlHMOkJEDFxsaGqJFDDikrK7uGSV32mQyTwuMiw5m3t/drXN0QAdqDg4PlYsMNDAz8hBDWaTKZ/nLlfobJToB7iAaeImYqx62trd/n5OT0HR4eOjlEKGLaI8DNtLQ0HzHg9vf3rSUlJe3l5eWzXMcyTJvkowzIxeLxaRISbnNzczs3N/e+Xq//w53xiYmJAeQOCXAQdev7QsLhtC5gS3uQgDrctQGmICr4aYt/8PLykiHN8eULhtzyBAnDIAr2B3zgiAWFPi3esAfTjnhERTUfOJvNZq+trb1fVFQ04nQ6ef1RhuURsbF+sBV7rqGi2s10/Tcku/eam5uX+e4CCqdLxMK0SJ4lrNQreazT6eK5GlxaWjJptdp7fX19O0I8v93d3cTwI9u/+W8kuQNHGl5VVeVyYO/o6DAg93PZ+Z4nCId+xICvn7+sLqayswxFdNdFV3bUZTAajfnIzr/G5TdnFu6oC8AYeaGFO+Cyw8LCXijc/w+Qso0H1PqIiooaFhuS4JAzsq2PD6CH53W36IaPMOAQkFm09CJvaybm+pPmfB7urPYbdZmuYclXYKCgoqLCX2g4xGd/so05Vpmm0b67DcxSakdQAxOxVW82m218/VxPTw/bwPwKetfdBiYr1AFNh8EnODw3EGeTAco5+6ExNJZskC3JP034u+fWNm400akrSk30Y5SrW5j0tIk+NjZ2gAzm1DWpVCp5amrqaRMdeV2AWq2mJjo1CKiJ3iIRoYn+vLCvIaj6j5L8+xqCDZX0GLCvIQxMXB2WuPEa4m8BBgDXxE/mIU7+4wAAAABJRU5ErkJggg==) no-repeat; background-size:40px 40px; } .wa-se-st-single-video-zhanzhang-play:hover { background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpmOWQ4YzVjMi1kMjNiLTQ5ZjEtOWIyNi0wOGY3MmY4MTc1NTMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MDc0OTQ3OTlGODgzMTFFNUFFQkZEMDZGREMzOTdFMTkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MDc0OTQ3OThGODgzMTFFNUFFQkZEMDZGREMzOTdFMTkiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2Y2IwNzk4OC0yYjNiLTQ2MDItYTllMS0zNzI1Yzk5NTZmMmQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6ZjlkOGM1YzItZDIzYi00OWYxLTliMjYtMDhmNzJmODE3NTUzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+SH0i3gAABTFJREFUeNq8mVlIY1cYx3OTGE0Mneg8VEYRA3VBZYQykVKd4tQ1UnxrcV/wQaO+aNW2oL5YbEerPmlQxBUXfLSiIo4OVFtcKFoXqhYUYUaKVmPVuGXp/7M3YK0zk3tz44FPzsn1nPvLOd/5tjBWq1XEozGQMMgTSCDkEcQD4sY+P4ccQl5D1iELkCUI55cxHAEJ5AtI1OrqqmpmZsY0NzdnQt+yvb1tMRgM14upVCrGz89PHBISIg4PD5dGRERI0Tfg0UvIIAsuKCDtTgEkurGx0dzS0nK5vr5u4fLNAgMDxXl5ebLi4mIJhi8gzewuOwyohRTp9XrX8vLy85OTE146YWtKpZKpra110+l0Fxg2QUb4AkohX09OTsbU19cbR0ZGzCIBW2JioqSkpEQRHR09geH3EBMXQDnku4GBgccZGRlGk8lkFTmhSaVSpqenR5GcnPwbht9AzuwBpJ2r7erqCsvJyTHyvOX231KGEXV0dCiysrLolpff3sm7ACv6+/ufpaWlOR3uJmRvb68iJSVlCsNv3waYODExUa7Vak+cdaxvO27ouTI2NvYHDIdtn4tvmZJCmBHjfcNRo3c2NDQYWXP28C7AQjIlXG6rWq2WCwk5NjZmbmpqkqGru33E3pAe2Cjj6emp3btXVVUV5OXlpaioqFg+ODi4EgLS3d2dga1VoJsBeWXbwc9h68xc4GwNruwRzNFTuDMPIQCJgViIyXbE5PijWltbL/ku6unpqYDuflxaWvqBWCxmHIVkWaKIjQDDyPFvbGxYHFmUwGBwg7q7uz/y9fV1c2QtYiEmYiNADUUlQil6UFDQQ3iHT5KSkt53ZB0wkU4/IcAACpmEvI1QdFllZaWmpqYmRC6Xi/msASbSw0Ca7L2ysmIR2q6Rd4iLi1PDK0UGBwcruc5nmbwJULWzsyM4oK35+Pi819bW9hR+3ZfLPJZJRYBy2DCneg6ZTCYpLCx83Nzc/CFuvIs9c1gmfvrhQLAqw23nZh0oBsO3YpwNNz4+vpWbmzu7v79vl8dhmc4o9jPAbql2d3fNzgBDEGBBDrOCmG+Hyzww0eYZ6M+r0NBQpxz18fHxBbzLL1zhqLFM1754Q6PRSISGwy08QpT80/T09CGf+fDxxLROgPNw9C5Cws3Ozr5OT0//GZDnfNdgmRYIcAnbaQgICHD4mBG6WWGYfy8qKvrVaDTy1mliYRP9JTFbjniZn58vcwTu4uLCVF1dvYBQ6Q9HcxmWhaoQVtuuDVLGT0k1nwX39vZOsejM0NDQnwLYSoatPgzeDPmpVvKCMn6uC66tre0hd55eXl4+FkJ/WYZJW/3mZlZHEXEvMn7R6OioXfqD2/9gcXHx76urK0FcZXx8vAR5CXXTbHWbmxeDPmimcgSlgPYsOD8/fyQUnEQiYejd6OpvFpVu39zhmJiYic7OTjmFS/fV6F1dXV1yhGdU9frxXZUFsj/P77P00d7ersjOzqbSx1eQK3uLR8/7+vpCMjMzz8xms1Mo6ViRw8hTU1OX31Q8epNxpn/8EhOnoLRKrVYruCtMSEiQ4DIq6R0Ylt0FZ28B8zPK9BFsupaVlZ3DQzi0mwqFgqmrq3MrKCi4YC/EMN8C5n/CM7Zm8imVgPV6/eXm5ianNMHf31+s0+lsJWCyc1QCPninjvIsoj9D3voAkcoVTI2ZiuhbW1uWw8PD68U8PDwYtVp9XUSnSCkyMtIF/SM8mhI5qYj+v3mif3+G0JBvZ8GpIuVqc82Qv1iQDTKZIp4/Q/wjwAB2z0yP+KAgHAAAAABJRU5ErkJggg==); } .wa-se-st-image_single_video {overflow:hidden;position:relative;} .wa-se-st-image_single_video img {height:91px;} 【详细教程】超简单_搭建SRS_服务器,_实现_自己_的RTMP_推流直播_哔…【详细教程】超简单_搭建SRS_服务器,_实现_自己_的RTMP_推流直播… 2020年2月19日 - 分享视频到博客或论坛 复制视频地址 复制通用代码 手机看 手机扫码观看视频 扫一扫手机继续观看 【详细教程】超简单_搭建SRS_服务器,_实现_自己_的RTMP_推流… cpp-SRS是一个_国产的_简单的RTMP_HLS直播_服务器-其它代码类资源… 2019年8月16日 - SRS是一个采用MIT协议授权的国产的简单的RTMP/HLS 直播_服务器_。最新版还支持FLV模式,同更多下载资源、学习资料请访问CSDN下载频道. 【详细教程】超简单_搭建SRS_服务器,_实现_自己_的RTMP_推流直播… 2020年2月19日 - 分享视频到博客或论坛 复制视频地址 复制通用代码 手机看 手机扫码观看视频 扫一扫手机继续观看 【详细教程】超简单_搭建SRS_服务器,_实现_自己_的RTMP_推流… 云rtmp服务器_搭建_腾讯云搭建_rtmp服务器__用腾讯云搭建_rtmp服务器… 在这一节中我们主要是通过nginx+rtmp_模块搭建一个点播服务,就是你有很多视频文件…和对象存储服务(cos)构建,并使用云_服务器(cvm)提供_简单的_后台服务,可以_实现_登录… 「自己开发直播」通过Nginx-rtmp-module搭建直播_服务器_并_实现_直播 2017年3月4日 - 帮别人做一个简单(非常非常简单)的直播平台(摆摆样子),涉及到了搭建RTMP_流媒体_服务器(虽然我觉得用SDK好的很多hhh)。_简单的_了解了一下直播需要的关键… 南昌网站建设案例:rtmp服务器_虚拟机(_简单rtmp服务器)-萝卜建站… 2020年4月16日 - 安装虚拟机做一个WEB服务器,如何在本机子上直接访问?就是虚拟机相当。 版权声明:萝卜建站工作室提醒您:在浏览本本网站关于rtmp服务器_虚拟机(_简单rtmp… srs _rtmp_流媒体_服务器_搭建 SRS全称Simple RTMP Server,定位是运营级的互联网直播服务器_集群,是一个非常_简单_就可以推送_rtmp_视频流_的服务器.github主页:https://github.com/ossrs/srs&lt;… 如何用c++开发rtmp_流媒体_服务器-CSDN论坛 2016年11月30日 - 用C++实现的RTMP服务器、HTTP服务器 用C++实现的RTMP服务器、HTTP服务器 2010年…一个简单的RTMP服务器实现— RTMP实现要点 #PS:要转载请注明出处,… 基于RTMP_协议的轻量级视频_服务器_的 设计与_实现 - 道客巴巴 2016年2月13日 - 电子科技大学UNIVERSITY OF ELECTRONIC SCIENCEAND TECHNOLOGY OF CHINA硕士学位论文MASTER THESIS论文题目 基于 RTMP 协议的轻量级视频_服务器_的设计… Nginx-rtmp-module搭建直播_服务器_并_实现_直播 | fireflyi博客 2019年7月8日 - yum安装的nginx没有configure,也别折腾了最_简单的_快速就是在下载一个 可以编译…4._rtmp_的效果比较好,延迟低,我的阿里云_服务器_是1核1g1M,延迟仅4秒正文… 一个简单的RTMP服务器实现 — RTMP与H264_Java_Sky的专栏-CSDN博客 2019年1月4日 - 由于考虑到后期可能会涉及到移动端播放视频以及以及减轻前端的开发难度(前端可直接用H5播放),选择了H264+RTMP这样一种方式。 市面上成熟的RTMP服务器… 一个简单的RTMP服务器实现 — RTMP与FLV_PHP_Sky的专栏-CSDN博客 2019年1月7日 - #PS:要转载请注明出处,本人版权所有#PS:这个只是 《 我自己 》理解,如果和你的#原则相冲突,请谅解,勿喷背景参考前置文章:《一个简单的RTMP服务器实现 … 实现_输出h264直播流_的rtmp服务器 - Sun‘刺眼的博客 - 博客园 2016年7月19日 - rtmp服务器_的功能比较复杂,要完整_实现_比较困难,如果你需要的是一个完整功能_的rtmp server,那就可以从它们之中选择一个,如果你的需求和我一样,只是一个… iOS_简单_直播实现(一:创建本地rtmp服务器) - weixin_308…_CSDN博客 2016年8月4日 - 付费学员加入QQ群,可获得1~3年的专业解答,周六晚8:00 ~10:00 QQ群内部直播答疑, 以及就业指导,项目练习等服务.rn 一个简单的RTMP服务器实现 — RTMP… _简洁rtmp_源站_服务器__OSSRS-CSDN博客 2013年10月17日 - 公司在做编码器,需要和_rtmp服务器_对接,nginx-rtmp实在是太复杂,不方便调试,所以做了_一个简单rtmp服务器_。参与这个项目的几个朋友,说不仅仅想_实现_流媒… RTMP服务器(一)_后端_朱韦刚(zhuweigangzwg)的技术博客-CSDN博客 2014年10月22日 - _Rtmp_可以衍生出21种packetheader,即ChunkHeader一个字节,没有扩展时间戳,常用的4种分别为:类型0 0类型的块长度为11字节。在一个块流的开始和时间戳返… 极速搭建RTMP_直播流_服务器+webapp (vue) _简单实现_直播效…_博客园 2018年11月14日 - safari浏览器测试效果 _RTMP_直播流_服务器_简单搭建成功,这个只是_简单的实现_了 推流播流而已,测试发现直播有延… nginx_的rtmp_搭建流媒体_服务器实现_直播流 - 孤独的DNA - 博客园 2018年5月28日 - 只是做了一个简单的_本地播放,后来到线上测试,发现这玩意对带宽要求比较高,我的渣渣_服务器_玩不过来 更多的研究中… 分类: nginx 标签: _rtmp, nginx 好… _rtmp服务器_搭建-windows_运维_Dao的专栏-CSDN博客 2019年6月28日 - (此处注意千万不要命名为nginx-1.7.11.3-Gryphon,笔者初次搭建_rtmp_推流_服务器_时,将解压后的目录命名为nginx-1.7.11.3-Gryphon,出现局域网内的其他电脑… 简单_几步_实现RTMP_直播_Python@steveyg-CSDN博客 2019年4月15日 - RTMP协议是Real Time Message Protocol(实时信息传输协议)的缩写,它是由Adobe公司…一个简单的RTMP服务器实现 — RTMP实现要点 #PS:要转载请注明出… 简单_直播_实现(一:创建本地rtmp服务器)Mac上搭建直播服…_CSDN博客 2017年8月28日 - nginx是非常优秀的开源服务器,用它来做hls或者_rtmp_流媒体_服务器_是非常不错的选择,本人在网上整理了安装流程,分享给大家并且作备忘。 步骤安装 1、安装… 大概是最简单的 rtmp 推流_服务器_搭建方法 - 简书 2017年9月24日 - 一开始想到要弄_一个简单的 rtmp 服务器_是为了给同学上课投射屏幕用。因为我用的是 Linux ,没法用国产的那些课室软件给他们投放屏幕,于是只好出此下策… 极速搭建RTMP_直播流_服务器+webapp (vue) _简单实现_直播效…_博客园 2018年11月14日 - safari浏览器测试效果 _RTMP_直播流_服务器_简单搭建成功,这个只是_简单的实现_了 推流播流而已,测试发现直播有延… 一起玩树莓派3 + 源码方式搭建nginx+rtmp服务器,及_简单_测试 2016年11月19日 - nginx(Engine X)是一个很流行的web_服务器_,以小巧、稳定、并发能力强著称。很多大公司_服务器_都用的这货,比如… Nginx-_rtmp实现_直播媒体实时流效果_nginx_脚本之家 2018年8月6日 - 这篇文章主要介绍了Nginx-_rtmp实现_直播媒体实时流效果,文中给出了总体设计图,为了整合平台,会自建RTMP流媒体_服务器_和使用云厂商SaaS_的RTMP_流媒体服务,需要的朋友可以… 利用nginx搭建_RTMP_视频点播、直播、HLS_服务器__程序随记_新浪博客 2018年10月25日 - 找到nginx源码包中 configure 所在的目录,以下脚本就是基于configure来实现的,在本…使用_rtmp_协议简述了的搭建了一个流媒体_服务器_的过程,并且描述了… 开源代码Window下搭建rtmp_流媒体_服务器 - rtmp- - ITkeyowrd 2016年7月22日 - 那么下面我们就在Windows下搭建一个RTMP_视频流…当然流媒体发布_服务器_开源工具还有比较好的。…1用Python_实现简单的服务器 2Asp.net SignalR… _rtmp_直播_服务器__刘贤松_handler_新浪博客 2020年3月25日 - _rtmp_直播_服务器__刘贤松_handler_新浪博客_刘贤松_handler_新浪博客,刘贤松_handler,为什么go语言,原因太多了! 轻量级协程,随时goroutine 方便的channe… 云导播台的设计和实现–基于golang的livego rtmp服务器 2017年9月23日 - 这里_一个简单的_云导播台就在livego的框架上进行开发。 三、_实现_的云导播台功能列表 _rtmp_流_服务器_主动拉取多路直播流; 拉取多路直播流指: _rtmp_流,… simple-rtmp-server首页、文档和下载 - RTMP/HLS 直播服务器 - OS… 2013年11月28日 - 一个采用MIT协议授权的国产的简单的RTMP/HLS 直播服务器,其核心的价值理念在于简单高效。 使用方法: tep 1: build srs tar xf simple-rtmp-server-.…","link":"/2020/05/26/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84RTMP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0/"},{"title":"将您的Spring Booot应用迁移到最新的Spring Security 和 OAuth 2.0","text":"Spring Boot 1.5.x 使 Spring Security 与 OAuth 2.0 集成到应用程序中比以往更加容易。Spring Boot 2.1.x 通过使 OpenID Connect 成为堆栈中的一级公民，将其拨号至 11。 在此帖子中，您从Spring boot 1.5.19 和Spring Security 4.2.x 开始。您将其与奥克塔的 OAuth 服务集成。从那里，您将转到Spring boot 2.1.3 和Spring Security 5.1。您将看到与 Okta 的集成方式变得更加容易。最后，您将 Okta 的Spring boot器与Spring boot 2.1.3 一起使用，以进一步减少代码和配置。 OpenID 连接和 OAuth 2.0 的三分钟概述起初，有孤立的网站，没有彼此交谈，这是可悲的。 像 Yelp 这样的网站开始希望访问您在 Google 联系人中的联系信息。因此，Yelp 自然会收集您的 Google 用户名和密码，以便访问您的联系人。你给了叶尔普你的许可，所以这很好，是吗？不！使用您的用户名和密码，Yelp 可以访问您的电子邮件、文档 （Google 中的所有内容），而不仅仅是您的联系人。更糟糕的是，Yelp 不得不以一种可以明文使用的方式存储您的密码，并且没有标准的方式撤销您对 Yelp 访问 Google 帐户的同意。 我们需要一个授权框架，允许您在不放弃密码的情况下授予对某些信息的访问权限。提示奥阿特 三个修订后，我们在OAuth 2.0（有1.0和1.0a之前），一切是正确的与世界。现在，像Yelp （a ） 这样的应用程序可以从像谷歌 （a ） 这样的服务中请求。您 （） 使用您的凭据登录 Google，并将您的凭据交给 Yelp 以访问您的联系人（以及仅您的联系人）。 在手，Yelp 提出 Google 联系人 API （） 的请求，并获得您的联系人。Yelp 永远不会看到您的密码，也永远不会访问任何您同意的以外的任何内容。而且，您可以随时撤回您的同意。Client Application``Access Token``Authorization Server``Resource Owner``Consent``Access Token``Resource Server 在这个同意和授权的新世界里，只有一件事缺失：身份。提示打开 ID 连接。OIDC 是 OAuth 2.0 之上的一个薄层，它引入了一种新的令牌类型：标识令牌。在这些以JWT格式加密签名的令牌中编码，是有关经过身份验证的用户的信息。这开启了互操作性和单一登录水平的新水平的大门。 OAuth（以及扩展 OIDC）使用许多已定义的来管理 和 之间的交互。在这篇文章中，您将专注于 。此流旨在从您的浏览器中启动，如下所示：Flows``Client App``Authorization Server``Resource Server``Authorization Code Flow Yelp 希望访问您的联系人。它显示一个按钮来链接您的谷歌联系人。 单击该按钮时，您将被重定向到 Google，您使用用户名和密码登录（如果您尚未登录）。 Google 会显示一个屏幕，告诉您 Yelp 希望以只读访问您的联系人。 一旦您同意，Google 会通过您的浏览器重定向回 Yelp，并带有临时代码（称为授权代码） 使用此代码，Yelp 联系 Google 进行访问令牌交易 Google 验证代码，如果所有签出，则向 Yelp 发出功能有限的访问令牌（仅读访问您的联系人） 然后，Yelp 向 Google 联系人 API 提供访问令牌 Google 联系人 API 验证令牌，如果请求与令牌标识的功能匹配，则将您的联系人列表返回 Yelp OAuth 2.0 和SpringBootSpring已是第17个年头。Spring及其包含的许多项目（如Spring Security）是浩大的。 公平地说，位于Spring及其众多项目的发动机是配置。Spring Boot 将”约定超过配置”的概念带到了 Spring 的世界，以便您可以快速启动和运行生产就绪应用程序。它通过有意见的自动配置系统（如果需要，可以覆盖该系统）来达到这个要求。 Spring Security在Spring中正式化和身份验证和授权方法。 OAuth 和 OIDC 非常适合Spring Security构建，在最新版本的 Spring Boot（本文撰写时为2.1.3版）和Spring Security版（截至本文撰写时为5.1.4版）中，这些标准现在是一流的公民。 如果您一直在使用 Spring Boot 1.5.x 进行 OAuth 和 OIDC，则需要做一些迁移工作才能进入 Spring Boot 2.1.x 的新世界，但这是值得的。 在迁移路径中穿行的示例代码中，您将与 Okta 的 OAuth 和 OIDC 服务集成。但是，您可以按照本指南联系任何符合 OAuth 和 OIDC 的提供商。 配置打开 ID 连接Okta 可为您的应用程序配置 OIDC 和 OAuth 2.0。所有你需要做的是提供一些基本的信息，Okta做所有的重担。是OaaS！（Auth 作为服务）。 获取 Okta 设置与 OIDC 和 OAuth 2.0 在代码中找到的Spring boot示例。只需执行此配置一次，才能在 3 个代码示例中使用。 首先，先https://developer.okta.com/signup/，为自己创建一个免费的开发者Okta组织。按照说明激活您的组织。 在奥克塔创建 OIDC 应用程序从 Okta 管理员 UI 菜单中单击Applications 单击并单击该选项。Add Application``Web 点击。输入 应用的 。添加另一个登录重定向 Uri： 。保留所有其他默认值。Next``Name``Login Redirect URIs``http://localhost:8080/login/oauth2/code/okta``http://localhost:8080/login 注： 您添加两个不同的登录重定向 uris 来支持 Spring Boot 的不同版本。在 2.1.x 版本中，您将使用：http://localhost:8080/login/oauth2/code/okta 点击。向下滚动并捕获 和 值。Done``Client ID``Client Secret 就是这样！四个步骤。还不算太糟 玩Spring boot打开 ID 连接和 OAuth 2.0 游戏代码示例分为 3 个 maven 模块： 和 。这些是完全封闭的示例，它们之间没有父关系。他们做每个都有正确的版本，为该示例。这使得文件比必要的更详细，但它使它可以运行完全独立的 和每个版本的 每个版本。您甚至可以为每个版本使用不同的 JVM 版本。oauth2-demo-1.5``oauth2-demo-2.1``okta-oauth2-demo-2.1``spring-boot-starter-parent``pom.xml``Client Application``Resource Server 每个版本的示例代码都有四个主文件 pom.xml- 标识依赖项 application.yml- OIDC 和 OAuth 所需的配置 DemoApplication.java- 客户端应用程序 DemoResourceServer.java- 资源服务器 在每种情况下，我都设定了最小化依赖项、配置和注释以完成工作的目标。此外，应用程序代码、控制器代码和配置代码被人为地包含在单个文件中。这是为了保持这个例子清楚和简洁。在真实应用程序中，您将这些顾虑分离到他们自己的类中。 当您启动 时，它将在http://localhost:8080上收听。当您启动 时，它将在http://localhost:8081上收听。DemoApplication``ResourceServer 默认情况下，Spring Security 可保护所有路径（无论您是否使用 OIDC 和 OAuth）。当您第一次导航到**http://localhost:8080/**时，您将重定向到 Okta 进行身份验证。然后，您将被重定向回，您将在浏览器中看到您的全名。DemoApplication 接下来，如果导航到http://localhost:8080/api，则 将对上面进行身份验证时设置 的 api 调用 。这一切都是在幕后完成的。在浏览器中，您将看到一个响应，指示您能够访问受保护的资源。而且，为了达到良好程度，您可以尝试直接导航到http://localhost:8081/api。您应该看到该请求失败，因为没有访问令牌。Client Application``Resource Server``Access Token 查看代码的每个版本之间的差异。 钻研Spring boot资源服务器代码在每个示例中，资源服务器代码几乎相同： 12345678910111213141516171819202122232425262728293031 @RestController@SpringBootApplicationpublic class OAuth2DemoResourceServer_1_5 { public static void main(String[] args) { SpringApplication app = new SpringApplication(OAuth2DemoResourceServer_1_5.class); app.setDefaultProperties(Collections.singletonMap(&quot;server.port&quot;, &quot;8081&quot;)); app.run(args); } @GetMapping(&quot;/api&quot;) String api() { return &quot;Made it to protected api on resource server!&quot;; }}``` 单独查看此代码 （没有依赖项和配置的上下文） 您可能倾向于认为它只是一个普通的旧 REST 控制器。但是，由于这些依赖关系和配置，它连接到 OAuth 框架。代码中的一大区别是，对于 Spring Boot 1.5.x 版本，您需要在类中包含注释。在 Spring Boot 2.1.x 版本中，您不需要该注释。`@EnableResourceServer`其余差异在依赖项和配置上，将在下面介绍。## [使用Spring boot 1.5.x、Spring安全 4.2.x 和 OAuth 2.0](#using-spring-boot-15x-spring-security-42x-and-oauth-20)这个版本的Spring和Spring Security做了很长的路，使工作与OAuth 2.0文明。你在下面看到，没有太多。它在新版本中变得更好！### [资源服务器依赖项和配置](#resource-server-dependencies-and-configuration)查看资源服务器的文件：`pom.xml` org.springframework.boot spring-boot-starter-security org.springframework.boot spring-boot-starter-web org.springframework.security.oauth spring-security-oauth2 12345如您所见，Spring Security 4.2.x 具有 OAuth2 支持作为辅助依赖项。查看配置文件：`application.yml` security: oauth2: client: clientId: {okta client id} clientSecret: {okta client secret} resource: tokenInfoUri: https://{yourOktaDomain}.okta.com/oauth2/default/v1/introspect 123456789101112131415只需要 a 和 。`clientId``clientSecret``tokenInfoUri`Okta 使用 JWT 进行访问令牌。这意味着_您可以在本地_验证 JWT 是 （a） 获取与用于签名的私钥匹配的公钥，以及 （b） 从 JWT 的有效负载中解析值（例如，当它过期时）。但是，对于 Spring Boot 1.5，这需要额外的配置和其他代码。因此，为了保持一切尽可能简单，此版本的资源服务器使用 [inspect]（https：//auth.net/2/令牌内省/）请求。但是，此选择的影响是，资源服务器每次收到请求时都会对 Okta 进行 API 调用，以便 Okta 验证访问令牌。在其他示例中，您将看到 JWT 处理是内置的，更易于配置和管理。此外，值得注意的是，早期版本的OktaSpring boot器包括支持验证和分析JWT访问令牌，所以如果你必须使用Spring boot1.5.x，看看[OktaSpring boot器的](https://github.com/okta/okta-spring-boot/tree/okta-spring-boot-parent-0.6.1)匹配版本。### [客户端应用程序依赖项、配置和代码](#client-application-dependencies-configuration-and-code)客户端应用程序具有与资源服务器相同的三个依赖项： 和 。`spring-boot-starter-security``spring-boot-starter-web``spring-security-oauth2`下面是文件：`application.yml` security: oauth2: client: clientId: {okta client id} clientSecret: {okta client secret} accessTokenUri: https://{yourOktaDomain}.okta.com/oauth2/default/v1/token userAuthorizationUri: https://{yourOktaDomain}.okta.com/oauth2/default/v1/authorize clientAuthenticationScheme: form scope: openid profile email resource: userInfoUri: https://{yourOktaDomain}.okta.com/oauth2/default/v1/userinfo server: http://localhost:8081 1234567在这里，您显式配置 OAuth 授权代码流中所需的每个组件。客户端应用程序将重定向以启动授权服务器 （Okta） 的流。一旦 Okta 重定向临时授权代码，客户端应用程序将使用 该值与授权服务器交换授权代码以访问令牌。与授权服务器的这两种交互都需要 和 。用于获取有关经过身份验证的用户的信息，并且需要访问令牌。`userAuthorizationUri``accessTokenUri``clientId``clientSecret``userInfoUri`的值是客户端应用程序用于标识访问资源服务器的位置的自定义属性。它的完整配置坐标是： 。`server``security.oauth2.resource.server`查看客户端应用程序代码： @EnableOAuth2Sso @RestController @SpringBootApplication public class OAuth2DemoApplication_1_5 { @Value(&quot;#{ @environment['security.oauth2.resource.server'] }&quot;) private String resourceServerUrl; private OAuth2ProtectedResourceDetails resource; public OAuth2DemoApplication_1_5(OAuth2ProtectedResourceDetails resource) { this.resource = resource; } public static void main(String[] args) { SpringApplication.run(OAuth2DemoApplication_1_5.class, args); } @GetMapping(&quot;/&quot;) String home(OAuth2Authentication authentication) { return &quot;Hello &quot; + authentication.getName(); } @GetMapping(&quot;/api&quot;) String api(OAuth2Authentication authentication) { return tokenRelayTemplate(authentication) .getForObject(resourceServerUrl + &quot;/api&quot;, String.class); } private OAuth2RestTemplate tokenRelayTemplate(OAuth2Authentication authentication) { OAuth2AuthenticationDetails details = (OAuth2AuthenticationDetails) authentication.getDetails(); OAuth2ClientContext context = new DefaultOAuth2ClientContext( new DefaultOAuth2AccessToken(details.getTokenValue()) ); return new OAuth2RestTemplate(resource, context); } } 1234567891011121314151617181920212223注释是挂钩到此类中的库所必需的。`@EnableOAuth2Sso``spring-security-oauth2`根映射方法 - 以对象作为其参数。显示全名。当您访问此路径时，Spring Security 将自动启动授权代码流。`@GetMapping(&quot;/&quot;)``OAuth2Authentication``getName()`为了使客户端应用程序对资源服务器进行 API 调用，可以使用 。这是一种通常进行 RESTful API 调用的机制，在这种情况下，您可以使用实例传递作为授权代码流一部分自动（和内部）设置的访问令牌。更详细地看一下。`RestTemplate``OAuth2RestTemplate`该方法的内脏是好和紧凑：`api``return tokenRelayTemplate(authentication).getForObject(resourceServerUrl + &quot;/api&quot;, String.class);`将对象传递到私有方法的调用中，然后从那里，它只是一个标准方法调用，url 指向资源服务器的 api 终结点 （http://localhost:8081/api）。`OAuth2Authentication``tokenRelayTemplate``RestTemplate.getForObject`重担在方法中完成。将方法调用 （返回 ） 转换为 。这是此代码中的第一个&quot;ding&quot; - 需要强制转换方法调用结果。`tokenRelayTemplate``authentication.getDetails()``Object``OAuth2AuthenticationDetails`获得对象后，可以使用其方法获取原始访问令牌（在 Okta 的情况下，这将是 JWT）。这使我们能够完成 OAuth2RestTemplate 的创建，并且当发出资源服务器的请求时，访问令牌现在将自动在 HTTP 授权标头中发送。`OAuth2AuthenticationDetails``getTokenValue()`## [使用Spring boot 2.1.x、Spring安全 5.1.x 和 OAuth 2.0](#using-spring-boot-21x-spring-security-51x-and-oauth-20)有了这个版本的Spring boot和Spring Security，OAuth 2.0 和 OpenID Connect 作为一流的公民被带入折叠。这将更改依赖项、配置和代码 - 所有功能都更好。### [资源服务器依赖项和配置](#resource-server-dependencies-and-configuration-1)下面是文件：`pom.xml` org.springframework.boot spring-boot-starter-security org.springframework.boot spring-boot-starter-oauth2-resource-server org.springframework.boot spring-boot-starter-web 12345再次你有3个依赖项，但这次你摆脱了直接的Spring Securityauth2引用，而是使用正式的Spring boot器： 。这为我们提供了所有明智的默认值和其他启动器的自动配置。`spring-boot-starter-oauth2-resource-server`接下来是配置文件：`application.yml` spring: security: oauth2: resourceserver: jwt: jwk-set-uri: https://{yourOktaDomain}.okta.com/oauth2/default/v1/keys 123456789嗯，这是一股清新的空气！所有资源服务器需求都是 （JWT 密钥集） 终结点。此终结点返回资源服务器用于验证访问令牌的加密签名的一组公钥。`jwks`从较小的配置文件的角度来看，这不仅仅是一个好处。使用完全相同的代码（减去注释），您可以从本地验证访问令牌中获益，从而减轻了对授权服务器进行其他 Introspect 调用的需求。我们的资源服务器将抓取公钥一次，然后在本地验证传入访问令牌 - 非常高效。`@EnableResourceServer`### [客户端应用程序依赖项、配置和代码](#client-application-dependencies-configuration-and-code-1)下面是客户端应用程序的文件：`pom.xml` org.springframework.boot spring-boot-starter-oauth2-client org.springframework.boot spring-boot-starter-webflux org.springframework.boot spring-boot-starter-security org.springframework.boot spring-boot-starter-web 1234567这一次，除了和Spring boot器启动器，你有启动器。这为我们提供了客户端应用程序的所有合理的默认值和自动配置。这种新方法还减少了必须引入项目的代码量。您有一个单独的资源服务器启动器，以及客户端应用程序的单独启动器。`spring-boot-starter-security``spring-boot-starter-web``spring-boot-starter-oauth2-client`最后一个依赖项 是 您将用来对资源服务器进行 api 调用而不是使用 。下面将介绍更多内容。`spring-boot-starter-webflux``RestTemplate`接下来，`application.yml` spring: security: oauth2: client: provider: okta: issuer-uri: https://{yourOktaDomain}.okta.com/oauth2/default registration: okta: client-id: {okta client id} client-secret: {okta client secret} resource: server: http://localhost:8081 12345678910111213在这种情况下，您只需要 和 。OAuth 集成将使用已知的终结点自动检索授权服务器的授权和令牌终结点。您可以通过浏览到：`client-id``client-secret``issuer-uri``https://{yourOktaDomain}.okta.com/oauth2/default/.well-known/oauth-authorization-server`您将返回一个 json 文档，该文档包含 Okta 授权服务器的所有配置信息，包括指向 JWT 密钥集 uri 的链接。您还可以在坐标处对资源服务器进行自定义配置： 。`spring.security.oauth2.resource.server`请注意，该配置中嵌入了该配置。您现在可以在代码中用作命名提供程序。接下来看看。`okta``spring.security.oauth2.client.provider.okta.issuer-uri``okta`下面是客户端应用程序： @RestController @SpringBootApplication public class OAuth2DemoApplication_2_1 { @Value(&quot;#{ @environment['spring.security.oauth2.resource.server'] }&quot;) private String resourceServerUrl; private WebClient webClient; public OAuth2DemoApplication_2_1(WebClient webClient) { this.webClient = webClient; } public static void main(String[] args) { SpringApplication.run(OAuth2DemoApplication_2_1.class, args); } @GetMapping(&quot;/&quot;) String home(@AuthenticationPrincipal OidcUser user) { return &quot;Hello &quot; + user.getFullName(); } @GetMapping(&quot;/api&quot;) String api() { return this.webClient .get() .uri(this.resourceServerUrl + &quot;/api&quot;) .retrieve() .bodyToMono(String.class) .block(); } @Configuration public static class OktaWebClientConfig { @Bean WebClient webClient( ClientRegistrationRepository clientRegistrations, OAuth2AuthorizedClientRepository authorizedClients ) { ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2 = new ServletOAuth2AuthorizedClientExchangeFilterFunction( clientRegistrations, authorizedClients ); oauth2.setDefaultOAuth2AuthorizedClient(true); oauth2.setDefaultClientRegistrationId(&quot;okta&quot;); return WebClient.builder() .apply(oauth2.oauth2Configuration()) .build(); } } } 12345678910111213141516171819202122232425您不再需要注释。OAuth2 和 OIDC 现在是Spring和Spring Security生态系统中的一流公民。`@EnableOAuth2Sso`查看根映射。这将启动授权代码流。这一次，您可以注入一个对象，该对象填充了作为此流的一部分从 ID 令牌获得的所有信息。用于返回经过身份验证的用户的全名。`OidcUser``OidcUser.getFullName()`通过构造函数依赖项注入，您可以访问对象。Spring 的新指南一般是使用而不是和最新版本的Spring boot和Spring Security遵循此。 由于依赖项，在范围内。该方法使用应用程序.yml 的文件（http://localhost:8081/api）。这看起来像对终结点的普通 HTTP GET 方法请求。但是，在授权代码流期间获取的访问令牌作为此请求的一部分一起发送，这是资源服务器的要求。`WebClient``WebClient``RestTemplate``WebClient``spring-boot-starter-webflux``api``WebClient object to make an api call to the Resource Server as configured in the`要理解这背后的机制，可以检查将 公开为 的嵌入式类。`@Configuration``WebClient``Bean`由于通常用于[反应](https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html)性应用程序上下文，因此您需要一些胶水，使其在传统的 Servlet 方法的上下文中工作，这就是此示例的组织方式。`WebClient`为此创建对象。而且，由于可以配置任意数量的客户端应用程序，因此将默认值设置为命名配置：（以前在文件中显示）。`ServletOAuth2AuthorizedClientExchangeFilterFunction``okta``application.yml`使用 生成器[模式](https://dzone.com/articles/creational-design-patterns-builder-pattern)方法应用设置的对象并返回该对象。此对象被注入到客户端应用程序，并确保在进行 api 调用时，访问令牌包含在授权标头中。`WebClient``ServletOAuth2AuthorizedClientExchangeFilterFunction``WebClient`## [Spring boot 2.1.x 和奥克塔Spring boot器](#spring-boot-21x-and-the-okta-spring-boot-starter)我们的最后一次迭代是合并奥克塔Spring boot器。到目前为止，通用Spring boot 1.5.x 和Spring boot 2.1.x 示例都可以配置为任何 OAuth 2.0 / OIDC 提供程序。Okta 已经创建了自己的Spring boot器，该启动器列[在https://start.spring.io，](https://start.spring.io)并可轻松集成到您的应用程序中。与前面的每个示例一样，请查看此示例的依赖项、配置和代码。### [资源服务器依赖项和配置](#resource-server-dependencies-and-configuration-2)下面是资源服务器的文件：`pom.xml` org.springframework.boot spring-boot-starter-web com.okta.spring okta-spring-boot-starter 1.1.0 12345您属于 2 个依赖项，同时使资源服务器的代码完全相同。看看：`application.yml` okta: oauth2: clientId: {okta client id} clientSecret: {okta client secret} issuer: https://{yourOktaDomain}.okta.com/oauth2/default audience: http://localhost:8081 1234567现在，您拥有了一种易于阅读的相对平面配置。为了增加安全性，您只需要 与资源服务器的基本 URL 匹配的值。除了验证 JWT 访问令牌的加密签名外，它还将确保在有效负载中编码的受众值与文件中的配置值匹配。`clientId``clientSecret``issuer``audience``audience``application.yml`### [客户端应用程序依赖项、配置和代码](#client-application-dependencies-configuration-and-code-2)以下是文件中客户端应用程序的依赖项：`pom.xml` org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-webflux com.okta.spring okta-spring-boot-starter 1.1.0 12345您有与资源服务器相同的 2 个依赖项，以便客户端应用程序可以使用该对象发出 api 请求。`spring-boot-starter-webflux``WebClient`该文件与资源服务器完全相同。现在，您已经实现了资源服务器和客户端应用程序的配置的完整奇偶校验。您还可以在客户端应用程序中重用该值。借助 Spring Boot 的环境变量支持，您可以在此处将其纳入范围：`application.yml``okta.oauth2.audience` @Value(\"#{ @environment['okta.oauth2.audience'] }\") private String resourceServerUrl; 12345客户端应用程序代码的其余部分与 Spring Boot 2.1.x 示例相同（没有 Okta 启动器支持）。下面是使用对象使资源服务器 api 请求的代码：`WebClient` return this.webClient .get() .uri(this.resourceServerUrl + \"/api\") .retrieve() .bodyToMono(String.class) .block(); ``` （注意参考）this.resourceServerUrl 通过Spring boot、Spring Security、OpenID 连接和 OAuth 2.0 进入未来此帖子的代码可以在GitHub Okta 开发人员存储库中找到。 请按照这些链接了解有关OIDC、OAuth 2.0、JWT和各种流的更多信息。 Spring Boot 和 Spring Security 对 OpenID 连接和 OAuth 2.0 的一流支持增加了与提供商（如 Okta）的互操作性，具有最少的依赖关系、最少的配置和最少的代码。 https://start.spring.io是您使用最新版本创建 Spring Boot 应用的朋友，该应用具有您需要的依赖项，包括 Okta 的”Spring boot器启动器”。","link":"/2020/03/31/%E5%B0%86%E6%82%A8%E7%9A%84Spring-Booot%E5%BA%94%E7%94%A8%E8%BF%81%E7%A7%BB%E5%88%B0%E6%9C%80%E6%96%B0%E7%9A%84Spring-Security-%E5%92%8C-OAuth-2-0/"},{"title":"数据科学专家必修之路","text":"步骤 1.满足您的先决条件 开始之前，您需要多变量微积分、线性代数和 Python。如果你的数学背景是多变量微积分和线性代数，你将有足够的背景来理解几乎所有的概率/统计/机器学习的工作。 多变量微积分：掌握多变量微积分的最佳资源是什么？ 数值线性代数 / 计算线性代数 / 矩阵代数： 线性代数,线性模型和矩阵代数简介.避免线性代数类过于理论化，您需要一个与真实矩阵配合的线性代数类。 多变量微积分对机器学习的某些部分非常有用，而且概率很大。线性/矩阵代数对于机器学习中的许多概念是绝对必要的。 您还需要一些编程背景开始，最好是在 Python 中。本指南上的大部分其他内容都可以在工作中学习（如随机森林、熊猫、A/B 测试），但如果没有知道如何编程，您就无法逃脱！ Python 是数据科学家学习的最重要语言。要学习编写代码、有关 Python 的更多以及为什么 Python 如此重要，请查看 如何学习编码？ 如何学习 Python？ 为什么 Python 是数据科学家的首选语言？ 对于有抱负的数据科学家和数据挖掘者来说，Python 是最重要的编程语言吗？ R是数据科学家学习的第二种最重要的语言。我说，这是一个人与统计背景，谁通过本科主要使用R。虽然 R 对于专用统计任务功能强大，但 Python 功能更通用，因为它将使您能够更多地连接到生产级工作。 如果你目前在学校，参加统计学和计算机科学课程。看看如果我想成为数据科学家，我应该上什么课？ 步骤 2.将自己融入社区 退房见面会找到一些你感兴趣的！参加有趣的讲座，现场了解数据科学，并会见数据科学家和其他有抱负的数据科学家。开始阅读数据科学博客，关注有影响力的数据科学家： 关于数据的最佳、有见地的博客是什么，包括企业如何使用数据？ 您的机器学习和数据科学新闻的来源是什么？为什么？ 在Twitter、Facebook、G+和LinkedIn上，哪些最好的数据科学账户可以关注？ 关于数据的最佳 Twitter 帐户是什么？ 步骤 3.设置并学会使用工具 Python 安装 Python、iPython 和相关库（指导) 如何学习 Python？ R 安装R和RStudio（最好同时了解 Python 和 R） 学习 R旋流 崇高的文本 安装崇高的文本 学习使用崇高文本的最佳方式是什么？ Sql 如何学习 SQL？什么是一些良好的在线资源，如网站、博客或视频？（您可以使用 Python 中的 sqlite 包来练习） 步骤 4.学习概率和统计 请务必完成涉及 R 或 Python 中大量应用的课程。只有实现所学知识，了解概率和统计数据才能真正有用。 Python 应用程序：思考统计数据 (免费 pdf） （Python 焦点） R 应用： 统计学习导论 (免费 pdf)(MOOC） （R 焦点） 打印出概率备忘表 步骤 5.完成哈佛数据科学课程 自 2015 年秋季起，该课程已进入第三年，力求对有兴趣成为数据科学家的学生尽可能适用和有帮助。从今年开始引入 Spark 和 SQL，就是如何发生这种情况的一个示例。 我建议从2015年做实验室和讲座，从2013年做家庭作业（2015年家庭作业不向公众开放，2014年的家庭作业写在一个不同于原来的导师的指导下）。 本课程部分由Quora用户乔·布利茨坦教授开发。这里是所有的材料！ 课堂简介 设计数据科学类是什么样的？特别是，设计由乔·布利茨坦教授和汉斯佩特·普菲斯特教授教授的哈佛新数据科学课程是什么感觉？ 拿哈佛大学的CS 109/统计121（数据科学）是什么样的？ 课程材料 类主页：CS109 数据科学 讲座、幻灯片和实验室：类材料 作业 Python、 Numpy、 Matplotlib （家庭作业 0) (解决 方案) 轮询聚合、Web 抓取、绘图、模型评估和预测 （家庭作业 1) (解决 方案) 数据预测、操作和评估 （家庭作业 2) (解决 方案) 预测建模、模型校准、情绪分析（家庭作业 3) (解决 方案) 建议引擎，使用映射缩减 （家庭作业 4) (解决 方案) 网络可视化和分析（家庭作业 5) (解决 方案) 实验室 （这些是2013年的实验室。对于 2015 年实验室，请查看类材料) 实验 2：网络刮削 实验3：EDA，熊猫，马特普洛特利布 实验 4： 科学学习， 回归， PCA 实验 5：偏差、方差、交叉验证 实验 6：贝叶、线性回归和大都市采样 实验7：吉布斯采样 实验 8：地图减少 实验 9：网络 实验 10：支持矢量机 步骤 6.做所有卡格尔的入门和游乐场比赛 我不建议参加任何奖金竞赛。它们通常具有太大、复杂或恼人的数据集，并且不适合学习。比赛可在以下任何方面进行。比赛 |卡格尔 首先学习学习，四处玩耍，阅读教程和论坛，了解你正在做的比赛。接下来，玩一些更多，并检查教程泰坦尼克号：从灾难中机器学习对于二进制分类任务（具有分类变量、缺失值等） 之后，尝试一些多类分类森林覆盖类型预测.现在，尝试回归任务房价：高级回归技术.尝试一些自然语言处理Quora 问题对 |卡格尔.最后，尝试任何其他您感兴趣的知识竞赛！ 步骤 7.学习一些数据科学选修课 数据科学是一个极其庞大和跨学科的领域，不同的工作需要不同的技能组合。下面是一些更常见的： 产品指标将教您公司跟踪哪些内容、他们认为重要的指标以及公司如何衡量其成功：兴趣内部增长仪表板中的 27 个指标 机器学习如何学习机器学习？这是一个极其丰富的领域，具有巨大的潜力，而且可能是当今数据科学的”最性感”领域。Andrew Ng 的 Coursera 机器学习课程是最受欢迎的 MOOC 之一，也是开始的好方法！吴安的机器学习 MOOC A/B 测试对于帮助为消费者应用制定产品决策提供信息非常重要。在此处了解有关 A/B 测试的更多详细信息：如何了解 A/B 测试？ 可视化 - 我建议在R中拿起ggplot2，使简单但美丽的图形和只是浏览数据美观 = /r/数据美观和流动数据想法和灵感。 用户行为 - 这组博客帖子看起来有用和有趣 -这解释了一切”用户行为 功能工程 - 了解功能工程中的一些最佳实践？和这个伟大的例子：http://nbviewer.ipython.org/github/aguschin/kaggle/blob/master/forestCoverType_featuresEngineering.ipynb 大数据技术 - 这些是专门为处理大量数据而开发的工具和框架。如何学习大数据技术？ 优化将帮助您了解统计数据和机器学习：凸优化 - 博伊德和范登堡 自然语言处理 - 这是将文本数据转换为数字数据，同时保留”含义”的做法。学习这一点将让你分析新的，令人兴奋的数据形式。如何学习自然语言处理 （NLP）？ 时间序列分析 - 如何了解时间序列分析？ 步骤 8.做一个顶石产品/侧项目 使用你新的数据科学和软件工程技能来构建一些让其他人说哇的东西！这可以是一个网站，新的方式看数据集，很酷的可视化，或任何东西！ 数据科学中有哪些好的玩具问题（一个周末由单个编码器完成）？我正在研究机器学习和统计，并使用公开提供的数据集/API 寻找与社会相关的内容。 如何开始构建推荐引擎？在哪里可以找到有趣的数据集？使用哪些工具/技术/算法来构建引擎是最佳工具/技术/算法？如何检查建议的有效性？ 快速周末 Python 项目的一些想法是什么？我希望获得一些经验。 衡量Twitter用户影响力的好方法是什么？ 在哪里可以找到向公众开放的大型数据集？ 对于优先级的收件箱，有哪些不错的算法？ 什么是一些好的数据科学项目？ 创建公共 github 存储库，创建博客，并发布您的工作、附带项目、Kaggle 解决方案、见解和想法！这有助于您获得可见性，为您的简历构建投资组合，并与执行相同任务的其他人员建立联系。 步骤 9.获得数据科学实习或工作 如何为数据科学家面试做好准备？ 如何为数据科学面试准备统计问题 在数据科学家访谈中，我应该期待什么样的 A/B 测试问题，我应该如何为此类问题做好准备？ 哪些公司为本科生提供数据科学实习？ 是想申请数据科学还是软件工程实习，有哪些提示？ 什么时候是申请数据科学暑期实习的最佳时机？ 查看官方 Quora 数据科学常见问题解答，了解有关实习、工作和数据科学面试流程的更多讨论！数据科学常见问题解答还链接到此问题的更具体版本，例如我如何成为没有博士学位的数据科学家？或者同行，作为博士生，我如何成为数据科学家？ 步骤 10.与数据科学社区分享您的智慧 如果你已经做到了这一点，恭喜你成为一名数据科学家！我鼓励你与数据科学界分享你的知识以及你学到的知识。数据科学作为一个新生领域依赖于知识共享！ 像数据科学家一样思考 除了上面列出的具体步骤，以开发数据科学家的技能集，我包括以下七个挑战，以便您可以学会像数据科学家一样思考，并培养正确的态度，成为一个。 （1） 通过数据满足您的好奇心 作为一名数据科学家，您编写自己的问题和答案。数据科学家自然对正在研究的数据感到好奇，并且创造性地处理和解决任何需要解决的问题。 数据科学的大部分不是分析本身，而是发现一个有趣的问题，并找出如何回答它。 下面是两个很好的例子： 希拉里：美国历史上中毒最严重的婴儿名字 查看火灾响应数据 挑战：想想你感兴趣的问题或话题，用数据来回答！ （2） 用怀疑的眼光阅读新闻 数据科学家（以及为什么很难用机器取代数据科学家）的贡献很大，就是数据科学家会告诉你什么是重要的，什么是虚假的。这种持续的怀疑在所有科学中都是健康的，尤其是在快节奏的环境中，让虚假的结果被曲解太容易了。 你可以通过批判性地阅读新闻来采用这种心态。许多新闻文章本身都有缺陷的主要前提。试试这两篇文章。注释中提供了示例答案。 容易：你喜欢你的iPhone从 字面 上。 难：谁预测俄罗斯的军事干预？ 挑战：当你遇到新闻文章时，每天都这样做。评论这篇文章，指出缺陷。 （3） 将数据视为改进消费品的工具 访问一个消费类的互联网产品（可能你知道没有做广泛的A/B测试已经），然后想想他们的主要漏斗。他们有结帐漏斗吗？他们有注册漏斗吗？他们有活力机制吗？他们有订婚漏斗吗？ 多次浏览漏斗，并假设不同方法可以更好地增加核心指标（转化率、股票、注册等）。设计一个实验，以验证建议的更改是否实际可以更改核心指标。 挑战： 分享它与消费者互联网网站的反馈电子邮件！ （4） 像贝叶斯人一样思考 想像贝叶斯人，避免基本费率谬误.这意味着要形成新的信念，你必须合并新观察到的信息和通过直觉和经验形成的优先信息。 检查仪表板时，用户参与度数字今天显著下降。以下哪一项最有可能？ 1. 用户突然参与度降低2。网站功能打破了3。日志记录功能中断 尽管解释#1完全解释了下降的原因，但#2和#3的可能性应该更大，因为它们的先前概率要高得多。 你在特斯拉的高级管理层，特斯拉的S型车有五个在过去五个月里着火了。哪个更可能？ 1. 制造质量下降，特斯拉现在应被视为不安全。2. 安全没有改变，特斯拉S型的火灾仍然比汽油车的同行少得多。 虽然#1是一个简单的解释（对媒体报道很好），但由于您定期进行质量测试，您的之前应该对#2很强。但是，您仍应寻求信息，以更新您对#1与#2的信仰（并且仍应设法提高安全性）。思考问题：您应该寻求哪些信息？ 挑战：确定上次提交基本费率谬误的时间。从现在开始避免犯谬论。 （5） 了解工具的局限性 “知识是知道番茄是水果，智慧不是把它放进水果沙拉里。 知识是知道如何执行普通的线性回归，智慧正在意识到它在实践中净地应用是多么罕见。 知识是知道 K - 意味着聚类的五种不同变化，智慧是意识到实际数据很少可以干净地净地聚类，以及 K - 意味着聚类的差值如何能够处理太多的特征。 知识是了解广泛的尖端技术，但智慧是能够选择一个，将给予公司最大的影响在合理的时间。 在浏览 Coursera 或 EdX 课程时，您可以开发各种工具，但在您知道要使用的工具之前，您的工具箱没有用处。 挑战：将多个工具应用于实际数据集，并发现每个工具的权衡和限制。哪些工具效果最好，您能找出原因吗？ （6） 教授一个复杂的概念 理查德·费曼如何区分他理解哪些概念，哪些概念他不明白？ 费曼是一位真正伟大的老师。他为自己能够设计方法，向开始的学生解释即使是最深刻的想法而感到自豪。有一次，我对他说，”迪克，向我解释，这样我就能理解它，为什么旋转半个粒子服从费米-狄拉克的统计数据。费曼完美地调整他的听众规模，他说，”我会准备一个新生讲座。但几天后，他回来说，”我做不到。我不能把它降到新生水平。这意味着我们并不真正理解它。 理查德·费曼的杰出成就在于他能够将复杂的概念提炼成可理解的想法。同样，顶级数据科学家与众不同的是，他们有能力令人信服地分享他们的想法并解释他们的分析。 查看https://www.quora.com/Edwin-Chen-1/answers，了解共同解释的技术概念示例。 挑战：向朋友或公共论坛（如 Quora 或 YouTube）传授技术概念。 （7） 说服他人了解什么是重要的 也许比数据科学家解释其分析的能力更重要的，是他们传达可操作见解的价值和潜在影响的能力。 随着数据科学工具的越来越好，数据科学的某些任务将被商品化。新工具将使过时的某些任务（如编写仪表板、不必要的数据争论，甚至特定类型的预测建模）过时。 但是，数据科学家提取和传达重要内容的需求永远不会过时。随着数据量和潜在见解的增加，公司始终需要数据科学家（或数据科学类似角色的人）来分流所有可以完成的工作，并根据影响确定任务的优先级。 数据科学家在公司中的角色是充当数据和公司之间的大使。数据科学家的成功取决于他/她讲述故事和产生影响的效果。所有其他技能都被这种能力放大了。 挑战：用统计数据讲述一个故事。传达数据集中的重要发现。做出听众关心的令人信服的演示。","link":"/2020/06/25/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%93%E5%AE%B6%E5%BF%85%E4%BF%AE%E4%B9%8B%E8%B7%AF/"},{"title":"每个人都是 Api 设计师： 我对 Restful Api 、 Graphql 、 Rpc Api 的想法","text":"现在，让我们来谈谈 API 的设计方式。我将提出几点，欢迎大家讨论。 1. 明确界定的规范是成功的一半以上。通常，规范是习惯标准。如果每个人都遵守这些标准，自然通信的成本将大大降低。例如，我们都希望学习 Ali 的规范，并定义我们业务中的多个域模型：VO、BO、DO、DTO。其中，DO（数据对象）一个对应于数据库表结构，并通过DAO层向上传输数据源对象。DTO（数据传输对象）是一个远程调用对象，是RPC服务提供的域模型。对于 BO（业务对象），它是在业务逻辑层中封装业务逻辑的对象。通常，它是聚合多个数据源的复合对象。然后，VO（视图对象）通常是请求处理层传输的对象，它通常是通过S春框架转换后转换的JSON对象。 事实上，如果 DO、BO、DTO 和 VO 的域模型在 Ali 的复杂业务中没有明确区分，其内部代码很容易被混淆。内部RPC在服务层的基础上增加了管理层，实现了内部标准化。但是，如果是单个域，没有太多的外部依赖关系，则不要设计它如此复杂，除非您期望它变得庞大而复杂。在这方面，特别重要的是根据当地情况调整设计过程。 规范的另一个示例是 RESTful API。在 REST 体系结构样式中，每个 URI 表示一个资源。因此，URI 是每个资源地址的唯一资源定位器。所谓的资源实际上是一个信息实体。它可以是一段文本、文件、图片、歌曲或服务器上的服务。RESTful API 通过 GET、POST、PUT、PATCH、删除等指定服务器端资源的操作。 [GET]/users# Query User Information List[GET]/users/1001_View a user's information[POST]/users# New User Information[PUT]/users/1001 # Update user information (all fields)[PATCH]/users/1001 # Update user information (partial fields)[DELETE]/users/1001 # Delete user information 事实上，RESTful API 的实现分为四个级别。0 级 Web API 服务仅使用 HTTP 作为传输手段。1 级 Web API 服务引入了资源的概念。每个资源都有一个相应的标识符和表达式。2 级 Web API 服务使用不同的 HTTP 方法来执行不同的操作，并使用 HTTP 状态代码来表示不同的结果。3 级 Web API 服务使用 HATEOAS。链接信息包含在资源的表达式中。客户端可以发现可以基于链接执行的操作。通常，伪 RESTful API 是根据第一级和第二级进行设计的。例如，我们在 Web API 中使用各种动词，例如，在真实意义上，RESTful API 需要满足第三级或以上。如果我们遵守这组规范，我们很可能设计一个易于理解的 API。get_menu``````save_menu 请注意，我们已经取得了超过一半的成功与明确的规范。如果这套标准是行业标准，那么我们可以大胆实践，不用担心别人不会用，只要把行业标准留给他学好。例如，在Java生态系统中，春天已经变得非常重要，如果一个新来者不了解春天，那它就有点让人不知所措了。但是，很多时候由于业务约束和公司技术，我们可以使用基于第一和第二层次的伪再创新API设计，但它不一定是落后的，不好的，只要在团队内部形成规范，降低每个人的学习成本。很多时候，我们试图改变团队的习惯，学习一个新的规范，和好处（投入产出比）非常小，这是不值得的。 总之，定义明确的规范的目的是降低学习成本，使 API 尽可能具有可访问性。当然，还有其他方法可以设计易于理解的 API，例如我们定义的 API 的名称易于理解，并且 API 的实现尽可能笼统。 二、探讨API接口的兼容性API 接口正在不断发展。因此，我们需要在一定程度上适应变化。在 RESTful API 中，API 接口应与以前的版本尽可能兼容。但是，在实际的业务开发方案中，随着业务需求的不断迭代，现有的 API 接口无法支持对旧版本的改编。此时，如果强制升级服务器的 API 接口，则客户端的旧功能将失败。事实上，Web 端部署在服务器上，因此可以轻松地升级以适应服务器端的新 API 接口。但是，其他客户端（如 Android、IOS、PC 等）正在用户计算机上运行。因此，当前产品很难适应新服务器端的 API 接口，从而导致功能故障。在这种情况下，用户必须升级。一级产品不能正确使用，直到最新版本。要解决此版本不兼容问题，设计 RESTful API 的一个实用方法就是使用版本号。通常，我们会将版本号保留在 URL 中，并同时与多个版本兼容。 [GET]/v1/users/{user_id}//version V1 API interface for querying user list API interface for querying user list in [GET]/v2/users/{user_id}//version V2 现在，在不更改版本 v1 的查询用户列表的 API 接口的情况下，我们可以添加版本 V2 的查询用户列表的 API 接口，以满足新的业务需求。此时，客户端产品的新功能将请求新服务器的 API 接口地址。尽管服务器将同时与多个版本兼容，但同时维护太多版本对服务器来说是一个很大的负担，因为服务器必须维护多组代码。在这种情况下，通常的做法不是维护所有兼容版本，而是只维护最新的兼容版本，如最新的三个兼容版本。一段时间后，当绝大多数用户升级到较新版本时，放弃一些较旧的 API 接口版本的较少使用的服务器端，并要求使用非常旧版本的产品的用户强制升级。请注意，”在不更改版本 v1 的情况下查询用户列表的 API 接口”主要是指客户端的调用方似乎未更改该接口。事实上，如果业务变化太大，服务端开发人员需要使用旧版本的 API 接口的适配器模式将请求调整到新的 API 接口。 有趣的是，GraphQL 提供了不同的想法。为了解决服务 API 接炸和将多个 HTTP 请求聚合到一个请求中的问题， GraphQL 建议只公开一个服务 API 接口，并在单个请求中进行多个查询。GraphQL 定义了我们可以在前端更灵活地调用的 API 接口。例如，我们可以选择和加载需要根据不同业务呈现的字段。因此，前端可以按需获取服务器提供的字段的完整数量。GraphQL 可以通过基于这些类型添加新类型和新字段来添加新函数，而不会导致兼容性问题。 此外，在使用RPC API的过程中，需要特别注意兼容性问题，双方库不能依赖父级，此外，本地开发可以使用SSYPN，而在线环境是被禁止的，以避免更改，导致版本不兼容的问题。我们需要为每个接口定义版本号，以确保版本可以在后续不兼容的情况下升级。例如，Dubbo 建议第三个版本号通常表示兼容性升级，并且只需要更改不兼容的服务版本。 在规范方面，我们可以查看 k8s 和 github，其中 k8s 使用 RESTful API，GitHub 使用 GraphQL。 https://kubernetes.io/docs/reference/generated/kubernetes-[api](https://zshipu.com/t?url=https://developpaper.com/tag/api/ “View all posts in api”)/v1.10/ https://developer.github.com/v4/ 3. 提供清晰的思维模式所谓的思维模型，我的理解是对于问题域抽象模型，对域模型的功能有统一的认识，对问题建立一个现实的映射，并划定模型的边界，而域模型的价值之一是统一思想，明确界限。假设您没有明确的思维模型，那么对 API 没有统一的理解，那么下图中很可能存在真正的问题。 4. 抽象地屏蔽业务实施我认为好的 API 接口是抽象的，因此我们需要尽可能多地屏蔽业务实现。因此，问题出现了。我们如何理解抽象？在这方面，我们可以考虑java的设计。Sql。司机。这里，爪哇。Sql。驱动程序是一个规范的界面，而 com. mysql。Jdbc。驱动程序它是 mysql-连接器-java-xxx.jar 的此规范的实现接口。因此，切换到 Oracle 的成本非常低。 一般来说，我们将通过 API 提供服务。在这里，提供服务的 API 接口的逻辑是固定的，换句话说，它是通用的。但是，当我们遇到具有类似业务逻辑的方案时，也就是说，核心骨干逻辑是相同的，细节的实现略有不同，那么我们应该去哪里呢？很多时候，我们选择为不同的业务方提供多个 API 接口。事实上，我们可以通过SPI扩展点实现更优雅。什么是斯皮？SPI 的完整英文名称是 Serivce 提供程序接口，它是服务提供商接口。它是一种动态发现机制，可以在程序执行过程中动态地发现扩展点的实现类。因此，当调用 API 时，它会动态加载和调用 SPI 的特定实现。 此时，您是否关联模板方法模式？模板方法模式的核心思想是定义骨架并传递实现。换句话说，它通过定义流程的框架将某些步骤的实现推迟到子类。事实上，在微服务落地过程中，这一理念也为我们提供了很好的理论基础。 现在，让我们来看看一个案例：电子商务业务方案中未交付的商品只退还。这是电力业务中很常见的情况，用户在下订单付款后可能会申请退款。此时，由于没有退货，只有用户需要申请退款并填写退款理由，然后让卖家审核退款。然后，由于不同平台上的退款原因可能不同，我们可以考虑使用SPI扩展点来实现。 此外，我们经常使用工厂方法+策略模式来屏蔽外部复杂性。例如，如果我们公开 API 接口 getTask（int 操作），那么我们可以按工厂方法创建实例，并按策略方法定义不同的实现。 @Componentpublic class TaskManager { private static final Logger logger = LoggerFactory.getLogger(TaskManager.class); private static TaskManager instance; public MapInteger, ITask&gt; taskMap = new HashMap&lt;Integer, ITask&gt;(); public static TaskManager getInstance() { return instance; } public ITask getTask(int operation) { return taskMap.get(operation); } /** * Initialization process */ @PostConstruct private void init() { logger.info(&quot;init task manager&quot;); instance = new TaskManager(); // Task of chatting news instance.taskMap.put(EventEnum.CHAT_REQ.getValue(), new ChatTask()); // Group Chat Message Task instance.taskMap.put(EventEnum.GROUP_CHAT_REQ.getValue(), new GroupChatTask()); // Heart beat task instance.taskMap.put(EventEnum.HEART_BEAT_REQ.getValue(), new HeatBeatTask()); } } 保护内部复杂性的另一个设计是外观接口，它封装和集成了多个服务的接口，并为客户端提供了一个简单的调用接口供使用。此设计的优点是客户端不再需要知道这么多的服务接口，而只需要调用外观接口。但是，缺点是显而易见的，即它增加了服务器的业务复杂性，接口性能不高，可重复性不高。因此，根据当地情况，尽可能保证单一的责任，并在客户”乐高”组装。如果有SEO优化产品，需要包括像百度这样的搜索引擎。当第一个屏幕打开时，服务器可以呈现 HTML，以便搜索引擎可以包含它。如果它不在第一个屏幕上，服务器可以调用 RESTful API 接口来呈现页面。 此外，随着微服务的普及，我们的服务也越来越多，许多较小的服务都有更多的跨服务电话。因此，微服务体系结构使此问题更加常见。为了解决这个问题，我们可以考虑引入一个”聚合服务”，这是一个复合服务，可以合并来自多个微服务的数据。此设计的优点是，某些信息通过”聚合服务”集成，然后返回给调用方。请注意，聚合服务也可以有自己的缓存和数据库。事实上，聚合服务的想法无处不在，例如无服务器体系结构。实际上，我们可以使用 AWS Lambda 作为无服务器服务背后的计算引擎，而 AWS Lambda 是一个功能即服务 （FaaS） 计算服务。我们直接编写在云中运行的功能。然后，此函数可以组装用于服务聚合的现有功能。 当然，有很多好的设计，我将继续补充和探索他们在公共数字。 5. 考虑其背后的性能我们需要考虑由包含的各种字段组合导致的数据库的性能问题。有时，我们可能会公开太多外部组合的字段，从而导致数据库中没有相应索引的完整表扫描。事实上，这在查询方案中尤其常见。因此，我们只能提供具有外部调用索引的字段的组合，或者在以下情况下，调用方需要填写任务 Id 和 caseId，以确保数据库中索引的合理使用，进一步保证服务提供商的服务性能。 ResultVoid> agree(Long taskId, Long caseId, Configger configger); 同时，对于报表操作、批处理操作和冷数据查询等 API，应考虑异步功能。 此外，尽管 GraphQL 解决了将多个 HTTP 请求聚合到一个请求中的问题，但架构以按层分析的方式递归地检索所有数据。例如，可以执行一次的分页查询的统计总数已演变为数据库的 N + 1 查询。此外，不正确的写作会导致性能不佳的问题，因此我们需要特别注意设计过程。 6. 异常响应和错误机制对于 RPC API 是引发异常还是错误代码，业界争论不下。《阿里巴巴Java开发手册》建议，对于跨应用程序RPC调用，应优先考虑成功（）方法、错误代码和错误短消息。在 RPC 方法返回模式下使用 Result 模式的原因：1） 使用引发异常返回模式，如果调用方未捕获它，将发生运行时错误。2）如果你不添加堆栈信息，只是新的自定义异常，添加自己对错误消息的理解，对于调用方解决问题不会有太大帮助。如果添加堆栈信息，数据序列化和传输的性能损失也是频繁调用错误的问题。当然，我也支持这个论点的从业者。 public ResultXxxDTO> getXxx(String param) { try { // ... return Result.create(xxxDTO); } catch (BizException e) { log.error(\"...\", e); return Result.createErrorResult(e.getErrorCode(), e.getErrorInfo(), true); }} 在 Web API 设计过程中，我们将使用控制器建议来统一包装错误消息。在微服务的复杂链调用中，跟踪和定位问题比单个体系结构更难。因此，应特别注意设计。更好的解决方案是当 RESTful API 接口中有非 2xx HTTP 错误代码响应时使用全局异常结构响应信息。代码字段用于表示某些类型的错误的错误代码，并且前缀”{biz_name/‘应添加到微服务中，以查找错误发生在哪个业务系统上。让我们看看用户中心的接口没有访问资源的权限并发生错误的情况。我们的业务系统可以通过自动生成 UUID 值的 request_id字段来响应”UC/AUTH_DENIED”，并获取有关日志系统中错误的详细信息。 HTTP/1.1 400 Bad RequestContent-Type: application/json { \"code\": \"INVALID_ARGUMENT\", \"message\": \"{error message}\", \"cause\": \"{cause message}\", \"request_id\": \"01234567-89ab-cdef-0123-456789abcdef\", \"host_id\": \"{server identity}\", \"server_time\": \"2014-01-01T12:00:00Z\"} 7. 考虑 API 的通用性幂等机制的核心是确保资源的唯一性，例如客户端重复提交或服务器重复重读只产生一个结果。付款方案、退款方案、涉及金额的交易不能出现多次扣减等问题。事实上，查询接口用于获取资源，因为它只查询数据，不会影响资源的更改，因此无论调用接口多少次，资源都不会改变，因此它是幂等的。新接口不是幂等的，因为如果多次调用，它将更改资源。因此，当重复提交发生时，我们需要幂等处理。那么，如何保证幂等机制呢？事实上，我们有许多实现。其中一个解决方案是创建唯一的索引。在数据库中为需要限制的资源字段创建唯一索引可防止插入重复数据。但是，对于子数据库和子表，唯一的索引不是那么好。此时，我们可以先查询数据库，然后确定受限资源字段中是否有重复，然后在没有重复时插入。请注意，为了避免并发场景，我们可以通过锁定机制（如悲观锁和乐观锁）保证数据的唯一性。在这里，分布式锁定是一个常用的解决方案，它通常是一个悲观的锁实现。然而，许多人往往认为悲观锁、乐观锁和分布式锁是幂等解决方案，这是不正确的。此外，我们还可以引入一个状态机，通过它可以执行状态约束和状态跳转，以确保同一业务的进程执行，从而实现数据幂等。事实上，并非所有接口都需要幂等。换句话说，是否可以考虑一个幂等机制，以确保资源的唯一性。例如，行为日志不能考虑幂等性。当然，另一种设计方案是，接口不考虑幂等机制，而是确保在实现业务时通过业务级别，例如允许多个数据副本，但在处理业务时获取用于处理的最新版本。","link":"/2020/07/02/%E6%AF%8F%E4%B8%AA%E4%BA%BA%E9%83%BD%E6%98%AF%20Api%20%E8%AE%BE%E8%AE%A1%E5%B8%88%EF%BC%9A%20%E6%88%91%E5%AF%B9%20Restful%20Api%20%E3%80%81%20Graphql%20%E3%80%81%20Rpc%20Api%20%E7%9A%84%E6%83%B3%E6%B3%95/"},{"title":"7.深入Java系列JVM、JVM、JRE区别","text":"java_面试 _JDK,JRE,JVM_三者的_区别 - 小蓝的博客 - CSDN博客 2018年6月11日 - JDK: java development kit, java_开发工具包,用来开发_Java_程序的,针对_java_开发者。 _JRE: java runtime environment, java_运行时环境,针对_java_用户 _JVM… 浅谈_JDK_、_JRE_、_JVM区别_与联系 - ancientear的博客 - CSDN博客 2019年2月10日 - 摘要:JDK_是 _Java 语言的软件开发工具包(SDK)。在JDK_的安装目录下有一个_jre_目录,里面有两个文件夹bin和lib,在这里可以认为bin里的就是_jvm,lib中则是_jvm_工作所需… 弄懂JRE_、_JDK_、_JVM 之间的_区别_与联系 - Single_Yam - 博客园 2018年3月5日 - 其实很多 Java 程序员在写了很多代码后,你问他 jre 和 jdk 之间有什么关系,jvm 又是什么东西,很多人不知所云。本篇不会讲述 jvm 底层是如何与不同的系… Java_中_JVM,JRE_和_JDK_的_区别 2020年3月14日 - JVM:java_虚拟机,负责把.class 二进制文件翻译成不同系统上的机器操作指令 _JRE:包含了JVM_和一些类库,如果不对代码进行编译只是运行,那么只需要_jre_就可以了 _JDK:包含… jvm_、_jre_、_jdk区别 - luckyna - 博客园 2019年9月21日 - jvm_、_jre_、_jdk区别 1、jvm:_java_虚拟机,负责把.class 二进制文件翻译成不同系统上的机器操作指令。因此_JVM_实现了_java_的跨平台运行,它把它可识别的.clas… jdk,jre_与_jvm_的_区别-百度经验 2016年8月1日 - 介绍jdk jre jvm_的_区别_。 步骤阅读 工具/原料 _jdk 操作系统 方法/步骤 1 JVM – java virtual machine JVM_就是我们常说的_java_虚拟机,它是整个_java… _JDK_、_JRE_和_JVM_的_区别_与相互之间的联系 - 知乎 2018年11月2日 - 并发、多线程、分布式、框架等这些东西,但是突然被人问到_jdk_、_jre_、_jvm_的_区别_与联系,应该也会瞬间觉得一脸懵逼,感觉还是有必要重新整理一下一些比较基本的_java_知识… 你知道JDK,JRE,_JVM_的_区别_吗?-CSDN论坛 java_面试 _JDK,JRE,JVM_三者的_区别 简单粗暴的理解 JDK_包含了_JRE,JRE_包含了_JVM 详解 JDK: java development kit, _java_开发工具包,用来开发_Java_程序的,针对_java_开发… 简单谈谈_JVM_、_JRE_和_JDK_的_区别_与联系__java__脚本之家 2016年5月11日 - 简单的说JDK_是用于开发的而_JRE_是用于运行_Java_程序的。_JDK_和_JRE_都包含了_JVM,从而使得我们可以运行_Java_程序。_JVM_是_Java_编程语言的核心并且具有平台独立… 本人菜鸟一枚,想知道下_jvm_、_jdk_及_jre_之间的_区别__博问_博客园 2018年8月4日 - 为啥我电脑安装了jdk,就可以运行java_程序了,难道_jre_和_jvm_不用安装吗?… 为啥我电脑安装了_jdk,就可以运行_java_程序了,难道_jre_和_jvm_不用安装吗?小包子哈 | 菜鸟二级… _Java_中_JVM_、_JRE_和_JDK_三者有什么_区别_和联系? 在《JVM_及_Java_跨平台原理》一节中,我们学习了 _Java 虚拟机 JVM_。那么 _JDK,JVM 和 JRE,那他们三个有什么_区别_呢?又有什么联系呢?如果你学到这里产生这样一个… JDK,_JRE_和_JVM_之间的_区别_是什么-_java_教程-PHP中文网 2018年11月21日 - 本篇文章给大家带来的内容是介绍JDK,JRE_和_JVM_分别是什么,让大家了解_JDK,JRE_和_JVM_的_区别_。有一定的参考价值,有需要的朋友可以参考一下,希望对你们有所帮助。 _JVM … JDK, _JRE_和_JVM_的_区别_与联系详解 2018年3月16日 - JDK: java development kit, java_开发工具包,针对开发者,里面主要包含了_jre, jvm, _jdk_源码包,以及bin文件夹下用于开发,编译运行的一些指令器。里面主要包含了_jvm_和… java_面试 _JDK,JRE,_JVM_三者的_区别__码神岛 2019年5月15日 - 详解JDK: java development kit, java_开发工具包,用来开发_Java_程序的,针对_java_开发者。 _JRE: java runtime environment, _java_运行时环境,针对_java_用户… JDK_与_JRE_与_JVM_的_区别 - 走在命运的左岸 - ITeye博客 2015年5月19日 - jdkjvmjre 1.JDK (1)概念 JDK : Java Development ToolKit(Java_开发工具包)。_JDK_是整个_JAVA_的核心,包括了_Java_运行环境(_Java Runtime Envirnment),一堆… JVM,JDK,JRE_和Open_JDK_有什么_区别?_慕课猿问 2019年10月12日 - JVM,JDK,JRE_和Open_JDK_有什么_区别?我在用Java_编程时遇到了这些短语,它们之间有什么_区别? JDK_和_JRE_和_JVM_的_区别-oop_ming-ChinaUnix博客 简言之:JDK:程序员使用,包括调试工具、运行你编写的JAVA_程序和_JVM &amp;nb… 简言之:JDK:程序员使用,包括调试工具、运行你编写的JAVA_程序和_JVM JRE:运行你编写的JA… JRE 和 JDK 的_区别_是什么? - 知乎 2012年6月27日 - 简单来说,JRE_可以支撑_Java_程序的运行,包括_JVM_虚拟机(_java.exe等)和基本的类库(…JDK:Java Development Kit_JRE_:Java Runtime Environment从全称可以看… Java_基础–_JDK_的安装和配置弄懂 _JRE_、_JDK_、_JVM 之间的_区别_与联系 2019年9月29日 - 虚拟机就是Java_运行的环境,这里分为_JDK_和_JRE_两种,还有一个_JVM_的概念大家都熟悉的,这里简单做一个_区分,从图中可以看出,JDK_、_JRE_、_JVM_的关系是:_JDK&gt;JRE&gt;… _JRE_与_JVM_、_JDK_的_区别__百度文库 JRE 与 JVM_、_JDK 的区别_一、 详细介绍 1、_JVM – java virtual machine JVM 就是我们常说的 java 虚拟机,它是整个 java 实现跨平台的 最核心的部分,所 有… 【_JAVA_】_JVM_、_JRE_与_JDK_的_区别___Java__阳阳的博客-CSDN博客 2018年9月13日 - JVM_、_JRE_与_JDK_的_区别_相信初学者一直搞不懂这三者的_区别,导致了在安装过程中,有些人安装了JDKJava [Java] JRE_、_JDK_和_JVM_的_区别 - 果壳里的熊猫 - 博客园 2019年8月19日 - _JVM_作为_JDK_和_JRE_的重要组成,无论_Java_程序使用_JRE_还是_JDK_运行,都会由_JVM_去一行一行地执行_Java_程序,_JVM_被作为一个解释器(interpreter)。 _JRE_与_JDK_的运行… Java-_JdkJreJvm区别_和联系_浣熊不是小熊猫-CSDN博客 2018年10月14日 - JDK(Java Development Kit )(Java_开发工具) _JDK,是整个JAVA_的核心,包括了_Java_运行环境(_JRE),JAVA_工具(_JAVA_C/_JAVA/JDB等)和JAVA_基础类库(即_JAVA API 包… 理解Java_里面的_jvm,jre,_jdk_的_区别_和联系 - 三劫散仙 - CSDN博客 2018年1月17日 - jdk_包含_jre,而jre_又包含_jvm,如果只需要运行_java_程序,其实只安装一个_jre_即可,如果还要开发和调试那就必须安装_JDK_了。接下来思考一个问题我们写的_java_源… jdk_与_jre_与_jvm_的_区别 - excellent_1 - 博客园 2019年12月5日 - 员敲代码敲得很6,但到现在都可能搞不清楚jre_和_jdk_和_jvm_之间到底有什么_区别?…jdk 是整个 Java 开发的核心,它集成了 jre 和一些好用的小工具。例如:ja… java jvm/jre/jdk_的_区别 - xyx107的博客 - CSDN博客 2019年5月20日 - jvm jre jdk_的_区别JVM:英文名字(java Virtual Machine),即使java_的虚拟机,只能识别.class文件._java_能跨平台就是依靠_jvm_实现的._jre:英文名字(jav… 博… JDK_与_JRE_和_JVM_的_区别 - _java_初级学习 - CSDN博客 2018年12月7日 - JDK_与_JRE_和_JVM_的_区别 JVM(java Virtual Machine)是java_虚拟机,用来执行bytecode字节码的虚拟计算机,和操作系统打交道。 _JRE (java Runtime Enviro… JDK_、_JRE_、_JVM_有什么_区别?有什么关系-百度经验 2017年10月25日 - JDK_、_JRE_、_JVM_有什么_区别?有什么关系,新学java_的朋友可能分不清_JDK_、_JRE_、_JVM_的_区别,下面详细介绍一下 JVM_、_JRE_、_JDK_的_区别 - 莫等、闲 - 博客园 2019年2月26日 - JVM_、_JRE_、_JDK_的_区别 1、JVM – java virtual machine_jvm_即_java_虚拟机,它主要有一个功能就是将编译好的class文件进行解释执行,因为class文件不能由操… 搞清楚JDK_、_JRE_、_JVM_的_区别 - 西瓜的博客_CSDN博客 2018年7月24日 - 需求:新学java_的朋友可能分不清_JDK_、_JRE_、_JVM_的_区别,下面详细介绍一下 JDK:Java_DevelopmentKit //_Java_开发工具包_JRE:_Java_runtimeenvironment //_Java_运… java_开发_jdk&amp;jre&amp;_jvm_的_区别_和联系 - 黄阿玛 - 博客园 2016年4月22日 - (调用JAVA API)开发了属于我们自己的_JAVA_程序后,通过_JDK_中的编译程序(_java_c)将我们的文本_java_文件编译成_JAVA_字节码,在_JRE_上运行这些_JAVA_字节码,_JVM_解析这些字节码,… 弄懂JRE_、_JDK_、_JVM 之间的_区别_与联系_Walker_YAM-CSDN博客 2018年3月5日 - 其实很多 Java 程序员在写了很多代码后,你问他 jre 和 jdk 之间有什么关系,jvm 又是什么东西,很多人不知所云。本篇不会讲述 jvm 底层是如何与不同的系… java_中 _jvm jre jdk_的_区别? - super_ligengchen的博客 - CSDN博客 2019年7月9日 - JVMJREJDK_的_区别Java_语言是跨平台的语言,即同样的程序无论在哪种操作系统平台都能运行。_JVM:_Java_VirtualMachine,_java_虚拟机,充当一个跨平台的一个翻译… _Java_基础:_JDK_、_JRE_、_JVM_的_区别_与联系__Java__JackChan-CSDN博客 2017年3月5日 - include:java_和_JVM_交互用的头文件 lib:类库 _jre:_java_运行环境 注意:这里的bin、lib文件夹和_jre_里的bin、lib是 不同的,总的来说_JDK_是用于_java_程序的开… JDK,JRE,_JVM区别_与联系_Gick-CSDN博客 2018年5月15日 - 很多朋友可能跟我一样,已经使用JAVA_开发很久了,可是对_JDK,JRE,JVM_这三者的联系与_区别,一 JDK,JRE,_JVM区别_与联系? JDK,JRE,JVM区别_与联系 白衣染霜花 浏览239回答1 1回答 慕斯709654 _JDK : Java Development ToolKit(_Java_开发工具包)。_JDK_是整个_JAVA_的核心,包括了_Java_运行环境(… jdk jre _jvm_之间的_区别_你真的了解吗 - 程序员大本营 而jre_内部包含了_jvm(java_虚拟机 _Java Virtual Machine) 看不同 jdk_比_jre_多了: _Java Language(我们常见的_java_语法规范)、java、_java_c(_java_编译工具,将_java_源代码编… JAVA_基础—_JDK_和_JRE_的_区别 - 无量的IT生活 - ITeye博客 2019年5月19日 - JDK_和_JRE_的_区别(转) JRE – java runtime environment _JRE_是指_java_运行环境。光有_JVM_还不能成class的执行,因为在解释class的时候_JVM_需要调用解释所需… JDK_、_JRE_、_JVM_三者的_区别 - _Java_天堂 2019年4月20日 - 在Java_中,理解_JDK_、_JRE_、_JVM_三者的_区别_是十分重要的,但是很多人并未注意到这一点。其实三者的_区别_很简单,也很明显。 _JVM JVM(Java Virtual Machine,Ja… JDK,JRE_和_JVM_之间的_区别 - _Java_教程™ 好多开发者学习 Java 编程有若干个年头了,但真正了解JDK,_JRE_和_JVM_之间的_区别_应该不多,别不服,大概是因为平时都是在Coding &lt;=&gt; Bug,没有时间去阅读相关资料吧… 有什么区别JVM,JDK,JRE&amp; Open_JDK_的? - IT屋-程序员软件开发… 2018年11月26日 - JVM , JDK , JRE &amp; Open_JDK_ ? 我是用Java_编程的,我遇到了这些短语,它们之间有什么_区别? 解决方案 JVM Java_虚拟机(_JVM)是​​虚拟的运行_Java_字节码的… JAVA_的_JDK, JRE, JVM 的区别,Linux到底要安装什么版本的_JDK_和RPM? 2019年8月5日 - JDK:JAVA Development Kit , JAVA_开发工具套装(开发者使用) _JRE:JAVA Runtime environment, JAVA_运行环境(普通用户使用) _JVM:JAVA Virtual Mechine, _JAVA_虚拟机(普… …JVM,三者的区别_于联系? - 无线&amp;移动互联网技术研发 - Blog_Java 2009年5月17日 - 各个平台的操作系统,SUN都有不同的JVM_来应对,所以_java_就不需要去考虑这些问题了。 下面是一些图解: 下图是_JVM_的原理: 下图是_JDK,JRE,_JVM_的关系:… JVM/JDK/JRE/IDE—区别(很经典) 2016年12月23日 - include:java_和_JVM_交互用的头文件 lib:类库 _jre:_java_运行环境 (注意:这里的bin、lib文件夹和_jre_里的bin、lib是不同的)总的来说_JDK_是用于_java_程序的开… 浅谈_JDK_、_JRE_、_JVM区别_与联系 - 好文 - 码工具 2019年2月10日 - 摘要:JDK_是 _Java 语言的软件开发工具包(SDK)。在JDK_的安装目录下有一个_jre_目录,里面有两个文件夹bin和lib,在这里可以认为bin里的就是_jvm,lib中则是jvm… _JDK_与之间的差异 _JRE_比 _JVM__ITPUB博客 2018年11月22日 - 今天,我们将讨论JDK vs JRE_与_JVM_的介绍。 什么是_Java_开发工具包(_JDK)? JDK_代表用于开发_Java applet和应用程序的Java Development Kit。 它基本上是… Java_中_JDK,_JRE_和_JVM_之间的关系 - 51Testing软件测试网 2014年11月12日 - 一下吧,JDK(Java Development Kit)简单理解就是Java_开发工具包,_JRE(Java Runtime Enviroment)是Java_的运行环境,_JVM( java virtual machine)也就是常常… JDK,JRE,JVM,JMM关系与区别-布布扣-bubuko.com 2017年11月25日 - 标签:nta too java_工具 runt _jvm jdk devel kit evel JVM: Java Virtual Machine, 将java_文件编译成class文件并运行class文件的软件 _JRE:Java Runtim… Java_组件(_JRE,JDK,JVM,JIT,java_c)之间的_区别? - CocoaChina_一站… 2019年11月14日 - 在理解JVM(Java_虚拟机),_JRE(Java_运行时环境),_JDK(_Java_开发工具包),JIT(及时编译器)和_java_c(_Java_编译器)之间的_区别_时,我遇到了很多困难.有人可以告诉我… 不同平台下JDK JRE JVM 的差别 - J2SE 2015年2月15日 - Mac OS的JDK JRE JVM,Windows的JDK JRE JVM,在不同平台下JDK JRE JVM 的区别_有哪些?—解决思路—_java 号称跨平台的语言 其实java_的跨平台就是通过_jd… Java 中JRE_、_JDK_、_JVM,以及java_、javascript、js、jsp的_区别-建站… 2018年8月26日 - 也许很多 Java 程序员在写了很多代码后,你问他 jre 和 jdk 之间有什么关系,jvm 又是什么东西,很多人不知所云。对应前段端知识_java_、javascript、js、jsp一样是… jre_与_jdk_的_区别 - 阿劫 - OSCHINA 2019年5月28日 - JDK 1. 定义 JRE(Java Runtime Enviroment)是_Java_运行时环境。面向_Java_程序的使用者,而不是开发者。_JRE_是运行_Java_程序所必须环境集合,包含_JVM_标准实现及_Java_核心库… 【Java_虚拟机】_JDK ,JVM,JRE_的_区别,堆,何为新生代,老年代,面试…Java | _JVM_、_JRE_、_JDK_的初步认识 - 陈陈菌 博客 2019年8月29日 - Java Development Kit(JDK) 包含:包含JRE,以及增加编译器和调试器等用于程序开发的文件 JDK_、_JRE_和_JVM 关系如图所示: JDK(_Java_开发工具包)它本身包含… java_的概念和_jdk,jre,jse,jss的区别 – 网络生活 2018年6月26日 - JRE(Java Runtime Environment)是包含了JVM_和其他一些简单功能的_JAVA_运行环境,它适用于只运行_java_程序时。_JDK(Java Development Kit)比_JRE_包含了更多… JVM _JRE_和_JDK区别_与联系 - 知乎 2018年11月4日 - JRE + java_开发工具(_java_c.exe/jar.exe) = _JDK 什么是JVM? Java Virtual Machine 即_Java_虚拟机 我们知道_Java_语言有一个独特的优点就是可以跨平台 像其它语言,… 分清Java_EE,Tomcat,_JVM,JRE,JDK,SDK等基本概念-爱上极客 2015年7月23日 - JVM Java Virtual Machine(Java_虚拟机),包含一套字节码指令集、一组寄存器、一…_jdk_与_jre_的_区别 如果安装了JDK,会发现你的电脑有两套JRE,一套位于 jr… 不同平台下JDK JRE JVM 的区别-CSDN论坛 2015年2月6日 - Mac OS的JDK JRE JVM,Windows的JDK JRE JVM,在不同平台下JDK JRE JVM 的…_jdk_的bin操作,其实就是去执行一些具体的_java_类,不过那些类被封装为exe可执… _JVM_、_JRE_、_JDK_的_区别_和联系 - 51CTO.COM 2010年9月25日 - 你对_JVM_、_JRE_、_JDK_的概念和_区别_是否了解,这里向大家简单介绍一下,_JVM_指的是_Java_虚拟机;_JRE_指的是_Java_运行环境;而_JDK_指的是_Java_开发工具包。 _JVM_、_JRE_、_JDK_如何一起支持_JAVA_运行? - 知乎 2020年2月25日 - 三者是套娃结构,JDK_包含_JRE,_JRE_包含_JVM_。_java_程序的运行只需要编译后的字节码+_JRE_即可,_JDK_比_JRE_多了些类似_java_c等开发工具,如dt.jar、tools.jar、visu… JVM,JRE,JDK_三者的_区别 - 知乎 java runtime environment(java 运行环境)jvm_在执行.class类文件的时候还需要调用所需的类库,因此在_jdk_的安装目录中能找到_jre_的目录。有两个文件夹bin(_jvm),lib(… 如何正确区别JVM,JDK,JRE-百度经验 2015年7月15日 - 如何正确区别JVM,JDK,JRE,在学校_Java_的过程中,往往一些最基础的概念没有弄清楚,将使得初学者在学习开发过程中出现许多困惑。学习_JAVA_开发前,必须弄清… JVM,JRE,JDK 三者之间的_区别_和定义 | 学步园 2019年7月15日 - _JVM_就是模拟了电脑的硬件,它同样有着像CPU一样可以执行代码的功能。它的实现具体有:指令集 寄存器组 类文件格式 栈 垃圾收集堆 内存区。可以把它理… jre_和_jdk_的_区别 - 云+社区 - 腾讯云 jre_和_jdk_的_区别jre:(java runtime environment),java_运行环境。 包括_java_虚拟机(_jvm java virtual machine)和java_程序所需的核心类库等,如果想要运行一个开发好的_j… JDK,JRE_和_JVM_之间的_区别 - 简书 2017年9月12日 - 基本区别: JVM JVM(Java_虚拟机)是一个抽象机器。它是一个提供可以执行_Java_字节码的运行时环境的规范。 _JVM_可用于许多硬件和软件平台。_JVM,_JRE_和_JDK_是… JDK-JRE_与_JRE_的_JVM_及lib的_区别?-CSDN论坛 2009年9月30日 - JDK_会安装两份_JRE,一份在JDK_目录下(这里称其为_JDK-JRE),另一份(公共JRE)自行指定位置(还会释放java.exe到系统目录下)…JDK-JRE_的bin里有份server _jvm… 通过示例学习Java_编程(2):_Java_虚拟机(_JVM),JDK,JRE_和_JVM_的_区别 2019年4月11日 - Java_虚拟机(_JVM),JDK,JRE_和_JVM_的_区别_作者:CHAITANYASINGH来源:https://beginnersbook.com/2013/05/_jvm/_Java_是一种高级编程语言。用高级语言编写的程序不能直接在… _jre_、_JDK_、SDK、_JVM区别_详解_百度文库 jre_、_JDK_、SDK、_JVM 区别_详解 一、_JDK 与 jre JDK(Java Development Kit)就是开发人员使用的 SDK,它提供可 Java 的开发环 境和运行环境。 jre (Java Runtime… JDK,JRE,_JVM_如何理解-百度经验 2016年4月7日 - JDK,JRE,JVM_如何理解 方法/步骤 1 _JDK:Java Development Tookit,java_开发工具包,是整个_java_核心,包括了_java_运行环境(_JRE,java runtime environment),…","link":"/2020/04/03/%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97JVM%E3%80%81JVM%E3%80%81JRE%E5%8C%BA%E5%88%AB/"},{"title":"11.深入Java系列Java 命令知多少","text":"java命令行知多少(反正我知道的比较少) - yznkaixin的…_CSDN博客 2010年12月29日 - 打开%_java__home%\\bin 下面,看一堆的命令 windows下是一堆exe文件。 挑几个主要的来学习记录下,蛮有用的,居家旅行,调错装x,必备!~ java :忽略 _java_c :… _java命令行知多少__百度知道 2017年1月3日 - 回答：那到底是想_知多少_呢 ~ Java知多少(47)多重catch语句的使用 - Coda - 博客园 2015年4月28日 - 该程序在没有命令行_参数的起始条件下运行导致被零除异常,因为a为0。如果你提供…« 上一篇: _Java知多少(46)try和catch的使用 » 下一篇: Java知多少… Java知多少(82)标签、按钮和按钮事件简介 - Coda - 博客园 2015年6月4日 - 在默认情况下,按钮的命令_字符串就是按钮上的文字。如有必要可以用方法 setActionCommand()为界面组件设置_命令_字符串。 系列文章: _Java知多少(上) Java… java_解惑你_知多少(七) - u011383372的博客 - CSDN博客 2014年1月11日 - _Java_代码 BigInteger total = BigInteger.ZERO; total.add(new BigInteger(“1”)); total.add(new BigInteger(“10”)); System.out.println(total);… Java_关键字_知多少 - 知乎 2017年4月17日 - Java_关键字_知多少 Yukon 写作爱好者/阅读者/多语言目标者 2人赞同了该文章 …②goto指定跳转到标签,找到标签后,程序将处理从下一行开始的_命令_。 2.访… _java命令_总结(经典篇) 2018年4月2日 - 功能说明: 为Java 归档 (JAR) 文件产生签名,并校验已签名的 JAR 文件的签名。 语法: jarsigner [ 命令_选项 ] jar-file alias jarsigner -verify [ _命… _Java_程序员必须知道的5个JVM_命令行_标志__java__脚本之家 2015年3月24日 - 这篇文章主要介绍了每个_Java_程序员必须知道的5个JVM_命令行_标志,需要的朋友可以参考下… 这篇文章主要介绍了每个_Java_程序员必须知道的5个JVM_命令行_标… Java_架构的路上必学知识点,你又知道_多少? - 简书 你如何搭建Redis集群Redis主从复制原理分析Redis的优化建议、最佳实践Redis的JAVA_客户端使用Redis集成Spring的使用MemcachedMemcached的介绍和安装、基本配置、常用运维_… _java_解惑你_知多少__百度文库 评分:3.5/5 7页 2012年4月6日 - java_解惑你_知多少__IT/计算机_专业资料。_java_解惑你_知多少 java 解惑你_知多少_数值表达式 1. 奇偶判断 不要使用 i % 2 == 1 来判断是否是奇数,因为 i 为… Java_中rcp_命令_和rm_命令_的应用你_知多少 天津阿甲科技为你妙解… 2018年5月4日 - 并且它们的实际代码又是什么?本文中洛阳阿甲科技_Java_程序员将会与大家分享关于rcp_命令_和rm_命令_的实际代码应用。rcp_命令_和rm_命令_分别是用于远程复制和… java命令行知多少(反正我知道的比较少) - 柒馨轩 - ITeye博客 2013年1月7日 - 打开%_java__home%\\bin 下面,看一堆的命令_windows下是一堆exe文件。挑几个主要的来学习记录下,蛮有用的,居家旅行,调错装x,必备!~_java :忽略… java命令行知多少(反正我知道的比较少) - it610.com 2010年12月29日 - 打开%_java__home%\\bin 下面,看一堆的命令 windows下是一堆exe文件。 挑几个主要的来学习记录下,蛮有用的,居家旅行,调错装x,必备!~ &amp;nbsp… java命令行知多少(反正我知道的比较少) - jvm-java-thread - Coin… 打开%_java__home%\\bin 下面,看一堆的命令 windows下是一堆exe文件。 挑几个主要的来学习记录下,蛮有用的,居家旅行,调错装x,必备!~ java :忽略 _java_c :忽略… java命令行知多少(反正我知道的比较少) - jvm-java-thread - IT… 2010年12月29日 - 打开%_java__home%\\bin 下面,看一堆的命令 windows下是一堆exe文件。 挑几个主要的来学习记录下,蛮有用的,居家旅行,调错装x,必备!~ java :忽略 _java_c :… _JAVA_和_JAVA_C_命令_分别起什么作用-CSDN论坛 2008年6月27日 - cmd中java_c和_java_使用及注意事项 一、简述: cmd中,执行_java命令_与_java_c_命令_的区别: _java_c:是编译_命令,将java_源文件编译成.class字节码文件。 例如:_jav… 50 种不同编程语言的“Hello World”,你知多少?__Java__朱小厮的… 2019年11月28日 - 就编程语言而言,1995年无疑是极其重要的一年,因为在_Java_和JavaScript之后,PHP也在这一年诞生。PHP主要用于Web,是一种面向对象的_命令_式语言,可以像其他… _Java_学到什么程度才能叫精通? - 知乎 2015年3月20日 - _Java_语言已经从大三开始学习,到现在研一下了,不知道…但是在 JVM 的即时编译器中存在_指令_重排序的优化。…如果每个用户都占用一个连接的话, 那可想… Java_开发,Redis知识你知道_多少?经典_操作 2018年12月28日 - Redis支持主从复制,具有非常快速非阻塞同步、网络断开链接自动重新连等。并且Redis还有其它一些特性,包括简单的发布订阅、事物支持、虚拟内存。为了获得高速… 【_知多少_】_Java_8 lambda表达式是否影响程序性能? 2019年4月30日 - 有许许多多关于 Java 8 中流效率的讨论,但根据 Alex Zhitnitsky 的测试结果…_命令_式风格iteratorMaxInteger()——使用迭代器遍历列表:publicintitera… Java知多少(48)try语句的嵌套 - Coda - 博客园 2015年4月30日 - 程序工作如下:当你在没有命令行_参数的情况下执行该程序,外面的try块将产生一…« 上一篇: _Java知多少(47)多重catch语句的使用 » 下一篇: Java知多… Java知多少(109)数据库更新 - weixin_33743248的博客 - CSDN博客 2015年7月1日 - 如果利用数据 SQL_命令_实现,则利用Statement对旬的executeUpdate()方法,执行SQL的…Java知多少(92)滚动条 Java知多少(93)鼠标事件 Java知多少(94)键盘… Java知多少(80)图形界面设计基础 - Coda - 博客园 2015年6月2日 - 界面中有菜单、按钮等,用户通过鼠标选择菜单中的选项和点击按钮,命令_程序功能模块…_Java知多少(78)Java_向量(Vector)及其应用 _Java知多少(79)哈希表及… Java知多少(81)框架窗口基础 - weixin_34117211的博客 - CSDN博客 2015年6月3日 - Java知多少(78)Java_向量(Vector)及其应用 _Java知多少(79)哈希表及其应用 Java_知…每天一个linux_命令(4):mkdir_命令_ WebAPI 和 WebService的区别 cen… Java_常用_命令 - 简书 2018年7月14日 - java_c_命令 说到常用命令,首先就不得不提java_c_命令,它是java_的编译_命令,开发人员编写的_java_源码,经过_java_c的_命令_处理后,会生成对应的字节码文件,文件… Java知多少(47)多重catch语句的使用_weixin_34324081的…_CSDN博客 2015年4月28日 - 该程序在没有命令行_参数的起始条件下运行导致被零除异常,因为a为0。如果你提供…Array index oob: _java.lang.ArrayIndexOutOfBoundsException After … _java_c_命令_详解(下) - LiuYanYGZ - 博客园 2016年11月11日 - _java_c_命令_详解(下) -verbose冗长输出。开启该参数,你将看到编译器编译_java_源码…D:\\project\\test&gt;_java_c -cp lib-classes -sourcepath src -verbose -… _Java_常用_命令__忧郁王子的专栏-CSDN博客 2019年1月7日 - jdk安装后会自带一些小工具,jmap_命令_主要用于打印指定_Java_进程的共享对象内存映射或堆内存细节。 jmap_命令_可以获得运行中的jvm的堆的快照,从而可以离线分析堆,以检查内… _JAVA_语言之JVM调优中经常用到的几个_命令__百度知道 2018年11月14日 - JAVA_语言之JVM调优中经常用到的几个_命令 我来答 答题抽奖 首次认真答题后 即可获得3次抽奖机会,100%中奖。 更多问题 分享 微信扫一扫 新浪微博 QQ… 使用if-else语句编写一个_JAVA_应用程序,用户从_命令行_输入一个1到99…Java_虚拟机(JVM)_知多少 - 北辰Root - 博客园 2019年8月20日 - class文件为8位字节码(ByteCode)组成,_Java_所有_指令_有200个左右,8位可以表示256种_指令_信息。前4个字节CAFE BABE为Gosling定义的一个魔法数,标志位一个_Java_类文件,… 每个Java_程序员必须知道的5个JVM_命令行_标志__Java___Java…_CSDN博客 2015年3月20日 - 本文是Neward &amp; Associates的总裁Ted Neward为developerworks_Java_… 本文将介绍一些_命令行_标志,您可以使用它们来诊断和调优您的_Java_虚拟机性能。 1.D… Java_开发人员必须掌握的Linux_命令(一) - 阿飞云 - 博客园 2019年3月13日 - scp_命令_用于Linux服务器之间复制文件和目录。scp是 secure…» 下一篇: Java_开发人员必须掌握的Linux_命令(二)… 最火的16个_JAVA_工具类,你知道_多少_个? - 简书 2019年3月18日 - 在_Java_中,工具类定义了一组公共方法,这篇文章将介绍_Java_中使用最频繁及最通用的…concat:按_命令行_风格组合文件路径(详见方法注释) removeExtension:… Java_学习笔记(一)–基本知识 | 常见dos_命令 | 运算符 |…-CSDN博客 2017年9月23日 - Java_学习笔记(一)–基本知识 | 常见dos_命令 | …本科计算机专业学生,我大学四年到底走了_多少_弯路 …©1999-2019 北京创新乐知网络技术有限公司 经… _java命令_详解_Trival_dreamy的博客-CSDN博客 2019年2月1日 - Java_是通过_java_虚拟机来装载和执行编译文件(class文件)的,_java_虚拟机通过_命令java… 虚拟机参数分为基本和扩展两类,在命令行_中输入_java 可得到基本参数列表,java X… Java_集合框架_知多少? - 技术宅星云 - CSDN博客 2019年10月24日 - 1. Java_集合框架_知多少? Java_集合框架大致可分为四种类型: List,Map,Set, Queue…ClassCastExeption是的代码整洁,不需要显示转换和instanceOf操作_指… _Java_常用_命令行_工具 - 简书 常用的_Java命令行_工具的使用梳理,方便以后线上问题排查处理. 示例使用的虚拟机版本(JVM自带_命令行_工具在bin目录下) 常用_Java命令行_工具 javap : _java_字… _java_里的_命令_式 是什么意思_百度知道 2013年9月6日 - 回答：java java_c _java -version 求一道简单的_java_程序从_命令行_输入四个整数,输出最大…_爱问知识人 2018年4月7日 - 从_命令行_输入四个整数,输出最大值和最小值!…能量消耗慢,食欲比较旺盛,活动又少,不知不觉脂肪…电脑/网络 程序设计 _JAVA_相关 电脑一天24小时_多少_度… _java_通过Linux获取_命令_信息并显示出来-知止内明-51CTO博客 2018年8月6日 - 7DGroup性能&amp;测试开发文章持续更新 mapper一对多简单写法笔记 Linux基本_命令_总结(一) 下载豆,了解它,收获它【51CTO下载中心帮助】 _Java_多线程编程总结… Java_程序员必须知道的linux_命令 - 兵阳的个人页面 - OSCHINA 2016年1月11日 - pkill java (在有反串改的时候可以用,杀死所有java…17. rm -rf_命令_递归删除目录文件。 直接rm就可以了…-r 就是向下递归,不管有_多少_级目录,一并删除 -f… 网络常见的 9 大命令,非常实用!你知道几个? 2020年3月23日 - 点击上方蓝色“小哈学Java_”,选择“设为星标” 回复…1.ping _命令 ping 是个使用频率极高的实用程序,主要…值,通过 TTL 值可以推算数据包通过了多少… _Java命令行_监控工具(jmap,jstack,jstat,jinfo,jps)_慕课手记 2018年7月11日 - 因此监控是非常重要的一个环节,有了监控,我们才能更好的定位系统中的问题,从而排查。监控的工具有很多种, 但是_java_自带的_命令行_监控工具,是必须要掌握的。… java_程序员必知必会常见linux_命令 - 云+社区 - 腾讯云 2019年10月19日 - 自己的这个服务器也是有段时间了,我想看下自己的磁盘空间用了多少_了,df -h一…或许你的屏幕早已被各种英文信息霸屏了,不知不觉你又学会了这条clear_命… _java_在dos_命令_下中文显示乱码怎么办-百度经验 2017年10月26日 - 新开_命令行_窗口,再次输入_java_c_命令_。 效果: 步骤阅读 END 注意事项 本教程是在win7环境下。win8或win10请自行查找我的电脑属性… java 如何通过_命令行_传递一个文本文件名字,进而找到这个类,并读取… 2016年3月16日 - 执行_java命令_时,要在包名所在的目录下执行加上包名…先退回src目录下,再运行全路径_java_类名就OK了。 发布… 18_java_c_命令_和_java命令_的讲解-教育视频-搜狐视频如何用Cmd_命令行_编译_Java_代码程序_酷知经验网 2018年11月6日 - 在初学Java_的时候,会使用cmd_命令_的模式来编译运行代码,下面就来介绍下如何_命令行_编译… 在初学_Java_的时候,会使用cmd_命令_的模式来编译运行代码,下面就来介绍下如何_命… _Java_调用Shell_命令_和脚本 - - ITeye博客 2017年7月23日 - _Java_调用Shell_命令_和脚本 http://blog.csdn.net/u010376788/article/details/51337312 _Java_中ProcessBuilder使用 http://shensy.iteye.com/blog/17567… 基本上涉及到_java_的所有知识点资源-CSDN下载 2018年8月31日 - 1.2 java_程序设计环境 1.2.1 _命令行_工具——jdk…的内容并不费力,您就已经具备了看懂本书的预备知 …26、math.round(11.5)等於_多少? math.round(-11… 编程语言的Docker_命令_你知道几个_编程语言__Java__Javascript_课课家 2019年9月3日 - 标签: 编程语言_JavaJava_script Docker_命令行_入门大全:这18条,你不得不知.编程语言(programming language),是用来定义计算机程序的形式语言。它是一种被标… 春眠不觉晓,RCE_知多少_? - 先知社区 2020年3月9日 - 春眠不觉晓,RCE_知多少_?清水 / 2020-03-09 09:46:00 / 浏览数 34 前言 … 通过Java_执行系统_命令,与cmd中或者终端上一样执行shell_命令_,最典型的用… _Java_常见的面试问题和答案,你知道几个?_达内北京_Java_培训 2019年5月31日 - static: _Java_平台调用这个方法时不会创建这个类的一个实例,因此这个方法必须声明为static。 void: main方法没有返回值。 String是_命令行_传进参数的类型,args是指… 金三银四_Java_求职必备技能:基础面试+JVM+Spring+算法+消息队列 1天前 - _JAVA_基础 _JAVA_中的几种基本数据类型是什么,各自占用_多少_字节。 String类能被继承…用一行_命令_输出正在运行的_java_进程。 介绍下你理解的操作系统中线程切换过程。 进… 深层理解在_java_中的 “”i=i++;”的运算结果及运行原理 2018年8月2日 - 浅谈java_中的 “i=i++;” 首先有一下代码: 1 …你可以试想这段代码是_多少 大多数同学可能会回答是…我们利用javap _指令_反编译后可以看清楚其中发生… Java 并发进阶常见面试题总结-布布扣-bubuko.com 10小时前 - 当执行 monitorenter _指令_时,线程试图获取锁也就是获取 monitor(monitor对象存在于每个_Java_对象的对象头中,synchronized 锁便是通过这种方式获取锁的,也是为什么_Java_中任… _java_开发需要知道的linux知识(一) - 个人文章 - SegmentFault 思否 2019年3月20日 - 如果有对学_JAVA_方面有什么疑惑问题的,或者有什么想…_命令_一: top 这个像是windows里面的任务管理器一样…vim有很多强大的功能,但实际使用中,也没记… _Java命令行__sign_77777123的博客-CSDN博客 2018年4月27日 - Java命令行_笔记。多个类来编译编译:_java_csrc/com/ai/cmdtest/Test.ja… _Java命令行_笔记。 多个类来编译 编译:_java_c src/com/ai/cmdtest/Test._java -s… _命令java_c参数的用途 - a214704的博客_CSDN博客 2018年8月1日 - 我会用这两个命令,但不知他们的作用是什么? 论坛 _Java_中——_java_c、_java命令_以及-classpath参数总结 阅读数 1万+ 在最近学习Maven的过程中,对_java_是… Java知多少(96)绘图之设置字型和颜色 - weixin_33759269的博客… 2015年6月18日 - Java知多少(91)对话框 Java知多少(92)滚动条 Java知多少(93)鼠标事件 Java_知…linux 启动 pycharm程序的_命令(pycharm已安装好) 阅读数 2万+ 方法一:…","link":"/2020/04/03/%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97Java-%E5%91%BD%E4%BB%A4%E7%9F%A5%E5%A4%9A%E5%B0%91/"},{"title":"12.深入Java系列Java内存结构","text":"JAVA_的_内存结构 - 黄雄杰 - CSDN博客 2018年8月1日 - 图一:_java内存结构_划分由上图可知,java内存主要分为6部分,分别是程序计数器,虚拟机栈,本地方法栈,堆,方法区和直接内存,下面将逐一详细描述。1、程序计… 【面试】你了解_Java内存结构_么(Java7、8、9内存结构的…_CSDN博客 2018年10月16日 - _Java内存结构_是每个java程序员必须掌握理解的,这是Java的核心基础,对我们编写代码特别是并发编程时有很大帮助。由于Java程序是交由JVM执行的,所以我们在谈Java内存… JVM之Java内存结构 - 自带锋芒 - 博客园 2018年12月19日 - 2、虚拟机栈:是线程私有的,该区域所描述的是_Java_方法执行的动态_内存_模型,每个方法在执行的时候都会创建一个栈帧,用来_存储_局部变量表,操作数栈,动态链接,方法出口等… _Java内存结构_详解 - 国民老公骚颖 - 博客园 2019年7月3日 - Java_把_内存_分成:栈_内存,堆内存,方法区,本地方法区和寄存器等。 下面分别介绍栈内存,堆内存,方法区各自一些特性: 1、栈内存 (1)一些基本类型的变量和对… jvm之_内存结构_讲解 2019年10月30日 - jvm之_内存结构_讲解 _java_技术阅读 发布时间:10-3017:56 前言 前文_java_类加载机制和类加载器我们介绍了类加载到JVM内存中的过程。那你是不是好奇,jvm是如何运行这… jvm如何划分内存结构-百度经验 2019年5月11日 - jvm如何划分内存结构 方法/步骤 1 首先jvm结构分三部分:类装载器子系统,运行…然后运行时数据区下有分为5个模块:方法区、堆、_Java_栈、PC寄存器、本… java内存结构 - 简书 2018年11月3日 - 大多数 JVM 将内存_区域划分为Method Area(Non-Heap)(方法区),Heap(堆),Program Counter Register(程序计数器),VM Stack(虚拟机栈,也有翻译成_JAVA 方法栈的),Na… 深入理解java内存结构 - 简书 对于_Java_程序员来说,在虚拟机自动_内存_管理机制的帮助下,不再需要为每一个new操作去写配对的delete/free代码,不容易出现_内存_泄漏和_内存_溢出问题,由虚拟机管理_内存_这… JAVA_的_内存_模型及_结构 | 并发编程网 – ifeve.com _Java内存_模型在JVM specification, Java SE 7 Edition, and mainly in the chapters “2.5 Runtime Data Areas” and “2.6 Frames”中有详细的说明。对象和类… _java_的JVM_内存结构_详解 2019年4月23日 - 在实际项目开发中,通常会出现Out of Memery问题,而内存管理是_JAVA_自己运行管理,要定位问题,前提必须了解_JAVA_的内存模型,本文将分享JVM_内存结构_以及一些参数的具体说明… JVM_内存结构_和_Java内存_模型 - 知乎 2018年7月7日 - 所有的Java_开发人员可能都会遇到这样的困惑:我该为堆_内存_设置多大空间?OutOfMemoryError的异常到底涉及到运行时数据的哪块区域?我该怎么解决线上_内存… _Java内存结构_详解 - Voole的个人页面 - 开源中国 2016年3月11日 - Java_把_内存_分成:栈_内存,堆内存,方法区,本地方法区和寄存器等。 下面分别介绍栈内存,堆内存,方法区各自一些特性: 1、栈内存 (1)一些基本类型的变量和对… _java_程序的_内存结构_是什么?-CSDN论坛 2010年3月17日 - jvm的内存结构 JVM是按照是按照运行时数据的_存储结构_来划分_内存结构_的,JVM在运行_java_程序的时候,将它们划分成了几种不同的数据结构,分别存储在不同的… _Java内存结构_【整理】 2010年7月13日 - 最典型的Stack应用是方法的调用,_Java_虚拟机每调用一次方法就创建一个方法帧(frame),退出该方法则对应的 方法帧被弹出(pop)。栈中_存储_的数据也是运行时… _Java内存结构_详解_百度文库 评分:4/5 3页 2017年4月4日 - _Java 内存结构_详解 广州疯狂软件学院拥有三大课程体系包括:java 课程,android 课程,ios 课程,疯狂软件年终钜惠,报名 java 就业班,免费赠送基础班,名额… 彻底搞懂 CPU 中的内存结构 _Java 内存_模型 ,一篇就够了!_慕课手记 2019年3月10日 - 类比到我们的 Java 项目中来,可能有些任务我们可以抽离出来,独立执行,而这就可以引入线程的概念,又因为万物皆是对象,于是 Java 中就定义了 Thread 对象来表示线程… _JAVA内存结构_之运行时栈帧结构 - - ITeye博客 2016年7月23日 - 栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构,它是虚拟机运行时数据区中的虚拟机栈(Virtual Machine Stack)的栈元素。栈帧存… 这一次,终于系统的学习了 JVM 内存结构 - 51CTO.COM 2019年11月5日 - 最近在看《 JAVA并发编程实践 》这本书,里面涉及到了 Java 内存_模型,通过 _Java 内存_模型顺理成章的了解到 JVM _内存结构,关于 JVM _内存结构_也许大学的… _Java_虚拟机的_内存结构_由哪些组成的? - 知乎 2017年9月14日 - 下面是官方所给的虚拟机的_内存结构_图 从图中可以看到有5大内存区域,按照是否被线程所共享可分为两部分,一部分是线程独占区域,包括_Java_栈,本地方法栈和… _Java内存结构_和数据类型_java_脚本之家 2016年12月28日 - 本文重点给大家介绍_java内存结构_和数据类型知识,非常不错,具有参考借鉴价值,需要的朋友参考下 JVM系列(1)_java_8_内存结构__冯冬冬的博客-CSDN博客 2019年6月5日 - 然后,使用一个例子来详解我们在运行一个程序的时候,代码在java_虚拟机中的存储和转化。 最后,我们给出_java_8的_内存结构,看一看做了哪些改动,并和_java_7进… jvm(1)—java内存结构 - 白露非霜 - 博客园 2019年6月16日 - 3._java_栈:_java_线程执行方法的_内存_模型,一个线程对应一个栈,每个方法在执行时都会创建一个栈帧,用于_存储_局部变量表(引用),操作数栈,动态链接,方法出口… 一文搞懂JVM_内存结构___Rt-CSDN博客 2019年4月11日 - Java 虚拟机是中、高级开发人员必须修炼的知识,有着较高的学习门槛,很多人都不…然而你对JVM的_内存结构_都不清楚,就妄想解决JVM引发的故障问题,是不切实际的。… 快速带你分清java内存结构,java内存模型,java对象模型…-CSDN博客 2018年9月23日 - JVM这块知识绝对是学习java过程中的重点和难点,我习惯把这块的知识叫做javaSE高级基础,在学习jvm这块的知识,你一定会遇到几个概念,那就是java内存结构,java内存模型… java_的_内存结构 - JVM_内存结构_分析 - 纪煜楷 - 博客园 2017年4月4日 - 对于_Java_程序员来说,内存是由JVM自动管理的,所以一旦出现内存泄漏或溢出的问题,不了解JVM的_内存结构_和各个内存区域的工作职责,将对解决问题带来很大的… _JAVA内存结构_和JAVA内存模型_xiaojia_wahaha_的博客-CSDN博客 2018年1月18日 - JAVA内存结构:堆、栈、方法区; 堆:存放所有 new出来的东西(堆空间是所有线程共享,虚拟机气动 jvm系列(二):JVM_内存结构_ - 纯洁的微笑 - 博客园 2016年6月23日 - keep pure, keep smile 万事皆因忙中错,好人半自苦中来 博客园 首页 新随笔 联系 订阅 管理 jvm系列(二):JVM_内存结构_ JVM_内存结构_ 所有的_Java_开发人员可能会… JVM_内存结构_(基于JDK8) - 秋风扫落叶的博客 - CSDN博客 2018年8月15日 - Java_虚拟机详解02—JVM_内存结构 主要内容如下:JVM启动流程JVM基本_结构内存_模型编译和解释运行的概念 一、JVM启动流程:JVM启动时,是由_java_命令/javaw… Java内存结构 - Chris,Cai - 博客园 2019年7月1日 - Java内存结构 Java 堆(Java Heap): 概念:Java 堆是Java 虚拟机管理的内存中最大的一块。是被所有线程共享的一块内存区域。在Java 虚拟机启动时候创建… _Java内存结构_详解 - 国民老公骚颖 - 博客园 2019年7月3日 - Java_把_内存_分成:栈_内存,堆内存,方法区,本地方法区和寄存器等。 下面分别介绍栈内存,堆内存,方法区各自一些特性: 1、栈内存 (1)一些基本类型的变量和对… Java内存结构-Java文档类资源-CSDN下载 2019年5月29日 - Java内存结构: 深入理解Java内存模型一基础并发编程模型的分类Java内存模型的抽象重排序处理器重排序与内存屏障指令happens-before深入理解Java内存模… _Java 内存结构_备忘录-图灵社区 2015年11月16日 - 本文详细描述了 Java 堆内存模型,垃圾回收算法以及处理内存泄露的最佳方案,并辅之以图表,希望能对理解 _Java 内存结构_有所帮助。原文作者Sumith Puri,… 关于java内存结构,为什么java的内存结构_百度知道 2017年12月18日 - 回答：能不能把问题描述清楚一点呢? 网页链接 _java_数组_内存_分配_内存结构_详解_笑面树骑士_新浪博客 2018年12月3日 - Java 语言是典型的静态语言,因此 Java 数组是静态的,即当数组被初始化之后,该数组所占的内存_空间、数组长度都是不可变的。_Java 程序中的数组必须经过… Java内存_模型(JMM)和JVM_内存结构 - Java 技术驿站-Java 技术驿站 2019年12月10日 - _Java内存_模型(JMM),Java Memory Model,指的在java程序运行过程中,计算机有主内存,每个java线程有自己的工作内存。java线程的工作内存是计算机主内存的… Java 虚拟机系列之 _Java 内存结构_简介 - V2EX 2019年3月1日 - Java 虚拟机栈是干嘛的? Java 虚拟机栈描述的是 _Java 内存_模型,每个方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法返… _Java_虚拟机(JVM)_内存结构_和垃圾回收机制(GC)详解以及内存溢出(out… 2019年7月15日 - 一、JVM介绍 jvm是java virtual machine 的简称,它是_java_虚构出来的计算机,有自己的指令集,寄存器和堆栈_内存_。它屏蔽了_java_应用程序与具体的操作平台… Java:多个对象的_内存结构_图Java-深入HashMap原理及内部_存储结构_丶一个站在_Java_后端设计之路… 2019年1月22日 - 站长的个人微信公众号:_Java_云库,每天分享技术文章和学习视频。让我们一起走向架构师之路!!Hi,欢迎来到梁钟霖个人博客网站。本博客是自己通过代码构建… java内存结构 | ProcessOn免费在线作图,在线流程图,在线思维导图 | 2019年11月4日 - ProcessOn免费在线作图,在线流程图,在线思维导图 | jvm内存模型java内存结构… 运行时常量池 用户评论0 U 发表评论 戎马书生IT发布于 2019-11-04 14… java内存结构 | ProcessOn免费在线作图,在线流程图,在线思维导图 | 2019年11月4日 - ProcessOn免费在线作图,在线流程图,在线思维导图 | jvm内存模型java内存结构… 运行时常量池 用户评论0 U 发表评论 戎马书生IT发布于 2019-11-04 14… JVM面试JVM_内存结构_详解视频全集(280分钟干货讲解)_哔哩哔哩 (…比较jvm_内存结构_&amp;_java内存_模型&amp;java对象模型 - 个人文章… 2019年8月27日 - 学习java过程中有三个概念,分别是jvm_内存结构_、_java内存_模型、java对象模型。我们系统的学习完之后,如果不加以总结对比,很容易混淆,相信不光是自己有… 浅析_java内存_模型–JMM(Java Memory Model)_码神岛 2019年3月12日 - 在说Java内存_模型之前,我们先说一下Java的_内存结构,也就是运行时的数据区域: Java虚拟机在执行Java程序的过程中,会把它管理的内存划分为几个不同的数据区域,这些… 匠心之作java_基础强化之JVM_内存结构 2020年1月4日 - 匠心之作_java_基础强化之JVM_内存结构_是传智播客和黑马程序员精心录制的_java_中级程序员教程 至简Java-Java 对象内存结构-胡杨的在线视频教程-CSDN学院 08. Java Object 类 [ 14:17 ] 09. Java instanceof 关键字 [ 11:11 ] 10. Java 对象内存结构 [ 30:14 ] 第八章:Java 异常处理 1. Java 运… java_8的_内存结构,这一篇文章就够了_济南达内_Java_培训 2019年6月6日 - 首先对这个图有一个认识,从上面可以看到_java_8的_内存结构_大致分了五个部分:PC寄存器,_java_虚拟机栈、本地方法栈、_java_堆、方法区。其中PC寄存器、_java_虚拟机栈和本… 万万没想到,JVM_内存结构_的面试题可以问的这么难? - 好文 - 码工具 2019年8月8日 - 在我的博客中,之前有很多文章介绍过JVM_内存结构_,相信很多看多我文章的朋友对这部分知识都有一定的了解了。 那么,请大家尝试着回答一下以下问题: 1、JV… _Java_的_内存结构_是什么,全局变量,临时变量,静态变量分别存__牛客网 2018年12月25日 - Java内存_的_结构: Java把内存划分为4个部分 1. 代码区 1、栈区 3、堆区 4、静态区域 其中栈的存取速度是最快的,所以局部变量以及一些小型的数据都 保存… 高级java_程序员必备面试官常问的知识:JVM_内存结构 2017年5月20日 - JVM_内存结构_——堆(所有线程共享) 上面的图有点复杂,简单一点: 启动一个虚拟机对应一个进程,线程共享进程所拥有的所有资源,_java_程序不管是主线程还是… Java 虚拟机之三:_Java_虚拟机的_内存结构__ITPUB博客 2018年9月2日 - 一:简介内存(Memory)也被称为_内存储_器,其作用是用于暂时存放CPU中的运算数据,以及与硬盘等外部_存储_器交换的数据。只要计算机在运行中,CPU就会把需要运… 终于有人把_Java_虚拟机JVM_内存结构_讲清楚了_腾讯视频老师这几章讲的是_Java内存_模型还是JVM_内存结构_啊?_实战问答 2019年4月18日 - 拥有丰富的大型网站架构经验,先后参与并负责过_Java_、PHP、Go等项目的开发,自己曾创过业,也曾在汤森路透负责金融产品的研发工作,现就职于某知名大型互… 深入理解JVM_内存结构_及运行原理【云析学院】-学习视频…_腾讯课堂 1.开门见山,JVM大厂高频面试题_Java内存_区域分布与概述,动手实战各个区域 2.JAVA工程师不可不知的对象创建底层步骤细节,生动剖析对象_结构_和访问方式 3.内功深厚招数… _Java内存结构_和数据类型_java_脚本之家 2016年12月28日 - 本文重点给大家介绍_java内存结构_和数据类型知识,非常不错,具有参考借鉴价值,需要的朋友参考下 【JVM】——内存结构 - 我爱吃土豆 2018年8月29日 - 一、JVM启动流程:JVM启动时,是由java_命令/javaw命令来启动的。二、_Java_的_内存结构:JVM基本结构图:JVM_内存结构_主要有三大块:堆内存、方法区和栈。1.堆… 详解JVM_内存结构_组成 - 51CTO.COM 2010年9月27日 - 这里向大家描述一下JVM_内存结构_,JVM_内存结构_主要包括两个子系统和两个组件。两个子系统分别是Classloader子系统和Executionengine(执行引擎)子系统。 「每日一面」面试中对_Java 内存结构_的认识 2018年6月12日 - 当在一段代码块定义一个变量时,_Java_就在栈中为这个变量分配_内存_空间,当超过变量的作用域后,_Java_会自动释放掉为该变量所分配的_内存_空间,该_内存_空间可以… 算是闲聊吧,关于java内存结构,为什么java的内存结构会…_CSDN论坛 2013年3月8日 - 《Java_虚拟机规范(_Java SE 7)》 《深入JAVA_虚拟机 第二版》 《深入理解_JAVA…码内容、常量池和静态变量_存储_在该位置,方法区和堆一样都是运行时_内存_区… 188-Java_零基础教程-JVM_内存结构-教育视频-搜狐视频 4天前 - 188-Java_零基础教程-JVM_内存结构_分享: 手机看 下载 顶 教育 &gt; 职场技能 &gt; 计算机编程 |动力节点 推荐 推广 10:26 188-_Java_零基础教程-JVM_内存结构 02:56 … 188-Java_零基础教程-JVM_内存结构-教育视频-搜狐视频 4天前 - 188-Java_零基础教程-JVM_内存结构_分享: 手机看 下载 顶 教育 &gt; 职场技能 &gt; 计算机编程 |动力节点 推荐 推广 10:26 188-_Java_零基础教程-JVM_内存结构 02:56 … Java:static_内存结构_图深入理解JVM_内存结构_及运行原理全套视频加资料.txt-_Java_其他资源… 2019年5月29日 - 2019最新深入理解JVM_内存结构_及运行原理(JVM调优)高级核心课程视频教程下载。JVM是Java_知识体系中的重要部分,对JVM底层的了解是每一位_Java_程序员深入_J… JVM:图文详解Java_虚拟机的_内存结构 - 云+社区 - 腾讯云 2019年10月25日 - JVM:图文详解_Java_虚拟机的_内存结构_。了解_Java_中的对象、变量等存放的内存区域十分重要 在运行时数据区里,会根据用途进行划分: 下面,我将详细介绍每个… Java_虚拟机详解之JVM_内存结构 - 综合编程类其他综合 - 红黑联盟 2018年8月24日 - _Java_虚拟机详解之JVM_内存结构_主要内容如下:JVM启动流程JVM基本_结构内存_模型编译和解释运行的概念一、JVM启动流程:JVM启动时,是由_java_命令 javaw命令来… 分享~~黑马程序员-_java内存结构_和对象创建的过程 - OSCHINA 2014年5月22日 - 在学到毕老师视频中介绍关于_java内存结构_的时候,感觉这些内容特别重要。结合视频和对《深入理解java虚拟机》这本书的一些理解写了这篇日记。 java内存… JVM(2):JVM_内存结构_所有的_Java_开发… 来自lateeyaT - 微博 2017年3月11日 - 《JVM(2):JVM_内存结构_》所有的_Java_开发人员可能会遇到这样的困惑?我该为堆内存设置多大空间呢?OutOfMemoryError的异常到底涉及到运行时数据的哪块区域… JVM面试JVM_内存结构_详解视频全集(280分钟干货讲解)_哔哩哔哩 (…_Java_虚拟机详解—JVM_内存结构__百度文库 评分:3/5 9页 2017年7月28日 - _Java_虚拟机详解—JVM_内存结构__计算机软件及应用IT/计算机_专业资料。主要内容如下: 一、JVM 启动流程: JVM 启动时,是由 _Java 命令/javaw 命令来启动… JVM_内存结构_,_Java_程序员必须掌握的基础【乐字节吧】_百度贴吧 2019年8月2日 - JVM_内存结构_,Ja..JVM_内存结构_是_Java_程序员必须掌握的基础。程序计数器(PC 寄存器)程序计数器是一块较小的内存空间,可以看作当前线程所执行的字节码的…","link":"/2020/04/04/%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"},{"title":"10.深入Java系列Java变量深入理解","text":"java变量深入理解 - THISISPAN - 博客园 2016年9月26日 - java变量深入理解 4,变量:其实就是内存中的一个存储空间,用于存储常量数据。 作用:方便于运算。因为有些数据不确定。所以确定该数据的名词和存储空间… java变量深入理解 - weixin_34138255的博客 - CSDN博客 2016年9月26日 - java变量深入理解 2016年09月26日 15:39:00 weixin_34138255 阅读数:5 4,变量:其实就是内存中的一个存储空间,用于存储常量数据。 作用:方便于运算。因… java变量深入理解 - weixin_30945039的博客 - CSDN博客 2016年9月26日 - 使用javap_深入理解Java_整型常量和整型_变量_的区别 阅读数 623 我下图代码第五行和第九行分别定义了一个整型_变量_和一个整型常量:staticfinalintnumber1… java变量_与内存_深入了解 - 浴血卫国 - 博客园 2017年11月15日 - (2)._变量_的数据类型=这个空间要存储什么数据? (3)._变量_名称=这个空间叫什么名字…· _java_基本数据类型存储范围· _深入了解_JVM—内存区域· _Java_中的… java变量深入理解-布布扣-bubuko.com 2016年9月26日 - 标签:style 使用 sp java 数据 bs 一个 on / 4,变量:其实就是内存中的一个存储空间,用于存储常量数据。 作用:方便于运算。因为有些数据不确定。所以… 深入理解java:线程本地变量 java.lang.ThreadLocal类 2018年12月10日 - 深入理解java:线程本地变量 java.lang.ThreadLocal类丶一个站在web后端设计之路的男青年个人博客网站 _深入理解Java_内存模型(一)——基础 | 并发编程网 – ifeve.com _Java_线程之间的通信由_Java_内存模型(本文简称为JMM)控制,JMM决定一个线程对共享_变量_的写入何时对另一个线程可见。从抽象的角度来看,JMM定义了线程和主内存之间的抽象… 学习笔记 | _深入理解Java_内存模型 - 知乎 2019年10月12日 - 虚拟机栈描述的是 Java 方法执行的内存模型:每个方法被执行的时候都会同时创建一个栈帧(Stack Frame)用于存储局部_变量_表、操作数栈、动态链接、方法出口等信息。每… 对Java_方法内部使用this访问成员_变量_的_深入理解 - - ITeye博客 2010年12月13日 - 1、在Java_中,直接访问域或静态成员(包括静态方法和静态成员_变量)永远都是前期绑定。 2、在_Java_中,访问方法是后期绑定。 不过这样容易出现一个疑点:若… 《_Java_架构筑基》从_Java_基础讲起——_深入理解_Finial-未来可期_的… 2019年12月18日 - 1. final可以修饰类,方法,变量 final修饰类代表类不可以继承拓展 final修饰_变量_表示_变量_不可以修改 final修饰方法表示方法不可以被重写 2. finally则是_Java_保证重点代… _深入理解Java_内存模型.程晓明(带书签文字版).pdf-_Java_文档类资源… 2019年3月18日 - 《_深入理解JAVA_内存模型》PDF 在_java_中,所有实例域、静态域和数组元素存储在堆内存中,堆内存在线程之间共享(本文使用“共享_变量_”这个术语代指实例域… _深入理解Java_内存模型 - 简书 2018年9月24日 - 主内存:java_虚拟机规定所有的_变量(不是程序中的变量)都必须在主内存中产生,为了方便理解,可以认为是堆区。可以与前面说的物理机的主内存相比,只不过物… 年薪百万大牛带你_深入理解Java_原子_变量_原理解析_哔哩哔哩 (゜-゜… 获取完整资源java_技术交流群:940577921 验证:【09】… 年薪百万 _java 原理解析 深入理解 Java_架构师学习路线 原子_变量 评论查看删除日志_Java_小提莫发消息 … _深入理解java_泛型详解__java__脚本之家 2017年4月13日 - 深入理解java_泛型详解更新时间:2017年04月13日 15:55:08 作者:一休哥 我要…前一屏 类型通配符 中引入了类型通配符,这让您可以声明 List&lt;?&gt; 类型的_变… _Java_语言的_深入理解__图文_百度文库 评分:3.5/5 40页 2011年4月2日 - Java_语言的_深入理解 _Java_程序设计 华中科技大学机械学院工业工程系 内容 ? ? ?…不同对象的类_变量_将共享同一内存 _Java_程序设计 华中科技大学机械学院… JVM_深入理解_:_JAVA_语言内存模型JMM学习讲解 2018年9月26日 - 本文主要向大家介绍了JVM_深入理解_:_JAVA_语言内存模型JMM学习讲解,通过具体的内容向…_Java_内存模型的主要目标是定义程序中各个_变量_的访问规则,即在虚拟… _深入理解Java_虚拟机 - 码农登陆 2018年10月29日 - 今天是来自我学弟的一篇关于《深入理解Java_虚拟机》的内容。 因为篇幅比较长,这…LocalVariableTable 属性用于描述栈帧中局部_变量_表中的_变量_与 _Java … _深入理解Java_自定义注解(一):入门 - 高伟的个人空间 - OSCHINA 2018年1月2日 - (方法、构造方法、成员变量_、枚举值)、方法参数和本地_变量(如循环_变量_、catch…上一篇: _深入理解Java_自定义注解(二)-使用自定义注解 下一篇: Intell… 《_深入理解JAVA_内存模型》PDF 下载__Java_知识分享网-免费_Java_资源… 2016年2月29日 - 《深入理解JAVA_内存模型》PDF 下载失效链接处理 《_深入理解JAVA_内存模型》PDF …12.3.3 对于volatile型_变量_的特殊规则 12.3.4 对于long和double型_变… …我的第一个Java_程序-8-_深入理解_下环境_变量-朱祚华的在线视频… 本课程是从零学JAVA_的第一章,是_JAVA_的一个入门课程… 我的第一个_java_程序—helloword (15:14) 谈谈这个helloword (12:39) _深入理解_下环境_变量 (13:47) … _java_常量与_变量深入理解__dragon4466的博客-CSDN博客 2018年9月29日 - _java_常量与_变量深入理解_常量常量 :其值不会发生改变的值,称为常量.比如:整数常量,浮点型类型,字 深入理解Java_中配置环境_变量 - 范仁义 - 博客园 2017年5月19日 - 深入理解Java_中配置环境_变量 打赏目录 配置的目的: 配置的解决途径: 找所需命令的过程: 通俗理解:回到顶部 配置的目的:本来只在安装JDK的bin目下能运… _Java深入理解_类、_变量_、方法的声明 - CSDN博客 2018年3月10日 - 原 _Java深入理解_类、_变量_、方法的声明 2018年03月10日 14:02:30 阅读数:22 声明描述了类的访问范围,以此限定此类与他类的可见范围,也可以使用extends… 深入理解Java变量 - 翱翔云端的专栏_CSDN博客 2016年4月10日 - 深入理解Java变量 原创 翱翔云端 发布于2016-04-10 22:37:26 阅读数 940 收藏 展开 一、总述 形象地说,_变量_就是一个盒子,我们可以往里面放东西。专业… Java_程序员应该_深入理解_的 _Java final _变量_的内存模型_CSDN博客 2018年9月25日 - 深入理解 Java final _变量_的内存模型 阅读数 392 转载地址:http://www.importnew.com/16989.html对于 final 域,编译器和处理器要遵守两个重排序规则:… java 成员_变量_和局部_变量深入理解__qq_33458228的博客-CSDN博客 2018年6月20日 - 私有化成员变量_系统不会将成员_变量_自动初始化 2.因为成员_变量_不是静态_变量,不会独立与实例而存在,而该类实例化后放在堆中,所有存放在堆成员_变量_就中 3… _深入理解Java_内存(图解)_堆,JVM,值传递_K_天道酬勤-CSDN博客 2016年11月10日 - 以上就是Java_程序运行时内存分配的大致情况。其实也没什么,掌握了思想就很简单了。无非就是两种类型的_变量:基本类型和引用类型。二者作为局部变量,都… _Java变量_的_理解__浪灬迹-红尘少年的博客-CSDN博客 2018年12月17日 - Java_中的_变量理解:基本数据类型:基本类型包括四类八种:整数类型:byte,short,int,l… _java_语言中除基本类型之外所有的_变量_类型都为引用类型,所有对象… _深入理解Java_的环境_变量_配置 - nomousewch的专栏 - CSDN博客 2012年8月14日 - 对于每一个_Java_开发者,在开始接触_Java_时,基本上都要先做一件事,那就是配置_Java_开发环境,windows环境下,我们首先下载安装JDK,然后再计算机高级_变量_中添… 深入理解 Java 基本数据类型 - 静默虚空 - 博客园 2019年3月10日 - 基本类型:变量_名指向具体的数值。 引用类型:_变量_名指向存数据对象的内存地址。 从内存方面来说 基本类型:_变量_在声明之后,_Java 就会立刻分配给他内存… _深入理解Java_内存(图解堆栈) - 万物为铜 - 博客园 2018年1月26日 - 深入理解Java_内存(图解) \b这篇文章是转自http://blog.csdn.net/shimiso/article...2.无论是普通类型的_变量_还是引用类型的_变量(俗称实例),都可以作为局部变量,他… _Java_入门——_深入理解Java_三大特性 - 聪哥聪哥 - 博客园 2016年9月16日 - 多态就是指程序中定义的引用变量所指向的具体类型和通过该引用_变量_发出的方法调用…_Java_开发中最基础也是最重要的概念,对这三个概念的_理解_只能越来越… _深入理解Java_引用类型 - (牛_牛).NET - 博客园 2015年10月7日 - _深入理解Java_引用类型 在_Java_中类型可分为两大类:值类型与引用类型。值类型就是基本数据类型(如int ,double 等),而引用类型,是指除了基本的_变量_类型之… Java Static 深入理解 - SoulCoder - 博客园 2016年6月30日 - Java Static 深入理解 static修饰的成员_变量_和成员方法独立于该类的任何对象。也就是说,它不依赖类特定的实例,被类的所有实例共享。 只要这个类被加载… _深入理解Java_引用(一) - alphadjz的博客 - CSDN博客 2018年9月22日 - 在C/C++中是通过指针,而是Java_中是通过引用,引用指向了对象在内存(heap)中的…_理解_方法执行时栈帧的局部_变量_表内存数据结构对这两个概念会有_深入_的_理… 深入理解 Java final _变量_的内存模型_u010746364的博客-CSDN博客 2016年1月18日 - _深入理解Java_内存模型(六)——final 阅读数 393 与前面介绍的锁和 volatile 相比较,对 final 域的读和写更像是普通的_变量_访问。对于 final 域,编译器… 【Java_核心技术卷】_深入理解Java_数据类型、_变量 (扩展讲解,结合… 2019年11月10日 - 这个与类相关 很好理解 二,基元数据类型 和 非基元数据类型 语言中的数据类型…三,变量 同样的错误: _变量_未初始化 对于c语言好_Java_语言有所不同 C… 深入理解_为什么_Java_中方法内定义的内部类可以访问方法中的局部_变量 2016年7月11日 - _深入理解_为什么_Java_中方法内定义的内部类可以访问方法中的局部_变量_public class Test1 {public static void main(String[] args){final int a=1;class… _Java_Sript中_变量_的作用域闭包的_深入理解___Java__软件编程 - 编程客栈 2018年7月26日 - js中的变量_都是公用的没有静态_变量,下面为大家介绍下_变量_的作用域闭包,需要的朋友可以参考下 深入理解 Java 内存模型_程晓明_InfoQ在线阅读_爱问共享资料 2013年11月28日 - 爱问共享资料硬件及网络频道提供深入理解 Java 内存模型_程晓明_InfoQ.pdf文档免费…_Java_线程之间的通信由_Java_内存模型(本文简称为JMM)控制JMM决定一… 深入理解 Java 内存模型_程晓明_InfoQ在线阅读_爱问共享资料 2013年11月28日 - 爱问共享资料硬件及网络频道提供深入理解 Java 内存模型_程晓明_InfoQ.pdf文档免费…_Java_线程之间的通信由_Java_内存模型(本文简称为JMM)控制JMM决定一… _深入理解Java_闭包概念 - OrcHome 2018年8月10日 - 注:&lt;自由_变量_&gt;:除了局部变量_的其他_变量 简单理解:闭包能够将一个方法作为一个_变量_去存储,这个方法有能力去访问所在类的自由_变量_。 _Java_中闭包实现 如… Java_Sript中_变量_的作用域闭包的_深入理解 Java_Sript中_变量_的作用域闭包的_深入理解 Javascript中的回调函数和匿名函数的回调示例介绍 JavaScript中对象属性的添加和删除示例 构造函数+原型模式构造js自定义对象(最… _深入理解Java_虚拟机 - 程序员大本营 _深入理解Java_虚拟机,程序员大本营,技术文章内容聚合第一站。… 每个虚拟机线程都有一个私有栈,一个线程的_Java_栈在线程被创建的时候被创建,_Java_栈保存着局部_变量_、… Java_Sript中_变量_的作用域闭包的_深入理解 / 张生荣 2014年5月9日 - Java_Sript中_变量_的作用域闭包的_深入理解 复制代码 代码如下: Insert title here … 深入理解java:3.NIO编程(一)_燎野_新浪博客 2018年9月19日 - 控制buffer状态的三个变量 position:跟踪已经写了多少数据或已经读了多少数据,它…前一篇:可重入锁 后一篇… 深入理解 Java 函数式编程,第 2 部分: 函数式编程中的重要概念 2018年12月3日 - 在 JavaScript 中,闭包可以用来实现真正意义上的私有变量_。 从闭包的使用方式可以…Zone=_Java technology ArticleID=1063656 ArticleTitle=深入理解 … _深入理解Java_中的volatile关键字-HollisChuang’s Blog 2018年8月12日 - 我们在再有人问你_Java_内存模型是什么,就把这篇文章发给他中分析过:_Java_内存模型规定了所有的_变量_都存储在主内存中,每条线程还有自己的工作内存,线程的… _深入理解Java_内存模型(四)——volatile | 并发编程网 – ifeve.com 当我们声明共享_变量_为volatile后,对这个_变量_的读/写将会很特别。_理解_volatile特性…在JSR-133之前的旧_Java_内存模型中,虽然不允许volatile_变量_之间重排序,但旧的… _深入理解java_虚拟机,关于常量池的字面量值和栈帧的局部_变量_表的… 2017年9月11日 - _深入理解java_虚拟机中写道:1.运行时常量池存放的是各种字面量值和符号引用,这部分内容将在类加载后进入… _深入理解Java_的protected修饰符 2015年2月8日 - 其实Java_的protected修饰符,权限定义的很微妙,大致有以下几种:(1)protected控制符用于修饰方法和成员_变量;(2)一个类的protected方法或成员变量,在包外… 深入理解 Java 内存模型-_Java_文档类资源-CSDN下载 2019年5月6日 - 深入理解 Java 内存模型,由程晓明编著,_深入理解java_内存模型JMM更多下载资源、学习资料请访问CSDN下载频道. _深入理解Java_虚拟机-学习笔记-3内存模型和线程@慕课网 原创_慕课… 2018年12月6日 - 7.store 工作内存中变量_到主内存 8.write _变量_值到主内存的_变量 原子操作的规则…2.抢占式 _Java_选用 线程状态: 1.new 2.Runnable 3.Waiting/Timed Wa… _深入理解Java_堆栈_码神岛 2019年3月29日 - JVM在启动时,会开启虚拟机自身的线程,例如垃圾回收线程,还有java_程序的线程,创建的线程名,同时创建对象和_变量,这些都会放在JVM的栈中,而线程对象字符… _深入理解Java_内存模型(一)_百度文库 _深入理解Java_内存模型(一)_计算机软件及应用_IT/计算机_专业资料。_Java_内存模型的主要目标是定义程序中各个_变量_的访问规则,即在JVM中将_变量_存储到内存和从内存中取出… JAVA_程序运行原理:各种配置 环境_变量 jdk jre classpath 深入理解… 2013年1月11日 - 简单精辟:JAVA_编译过程_理解:Java_源文件 xxx._java —&gt;java_c.exe编译器—&gt;xxx.class文件 (字节码文件,JVM可以看懂的)—&gt;_java.exe解释执行器(需CLASSP… _Java_Sript中_变量的作用域闭包的深入理解 JavaScript_网络编程_IT… 2016年6月7日 - js中的变量_都是公用的没有静态_变量,下面为大家介绍下变量_的作用域闭包,需要的朋友可以参考下 Insert title here /* * 1.js中的_变… 深入理解 Java 并发核心机制,看完后好爽 2020年1月9日 - volatile 是轻量级的 synchronized,它在多处理器开发中保证了共享变量_的“可见性”…《_Java 并发编程实战》《Java 并发编程的艺术》《深入理解 Java 虚拟机》Java … _深入理解Java_内存模型(七)——总结 | 并发编程网 – ifeve.com _深入理解Java_内存模型(七)——总结处理器内存模型顺序一致性内存模型是一个理论…JSR-133严格限制volatile_变量_与普通_变量_的重排序,使volatile的写-读和锁的释放-… _深入理解java_虚拟机(22):volatitle_变量_规则 | 易学教程 2019年12月6日 - volatitle_变量_在线程工作内存里面也存在不一致性,但由于每次使用前要刷新,执行引擎看不到不一致的情况,但是java_里面的运算并非原子操作,volatitle_变量… Java_Sript中_变量_的作用域闭包的_深入理解 - JavaScript 2019年8月3日 - js中的变量_都是公用的没有静态_变量,下面为大家介绍下_变量_的作用域闭包,需要的朋友可以参考下 _深入理解Java_序列化机制_慕课手记 2018年7月25日 - _深入理解Java_序列化机制1、_Java_序列化介绍序列化是指对象通过写出描述自己状态的数值来记录自己的过程,即将对象表示成一系列有序字节,_Java_提供了将对… 深入理解Java final_变量_的内存模型 - 51Testing软件测试网 2015年10月26日 - 在构造函数内对一个 final 域的写,与随后把这个构造对象的引用赋值给一个变量,这两个操作之间不能重排序 初次读一个包含 final 域的对象的引用,与随后… JAVA_语言之_深入理解Java Class文件格式(八) 2018年8月6日 - 由于这个属性相对较为复杂, 而对于我们理解class文件又不具有很大的意义, 所以我们只是简单的介绍一下。 如果想深入理解_这个属性, 请参考 《深入_Java… _深入理解JAVA_内存模型(PDF版)-_Java_文档类资源-CSDN下载 2017年10月3日 - _深入理解JAVA_内存模型.pdf (高清版) 1.基础 2.重排序 3.顺序一致性 4.vol…堆内存在线程之间共享(本文使用“共享_变量_”这个术语代指实例域,静态域和… java_中Static关键字的_深入理解-码迷移动版-m.mamicode.com 2018年5月29日 - java_中Static关键字的_深入理解_时间:2018-05-29 01:41:22 收藏:0 阅读:66 static 声明类的成员_变量 以及方法的特点。 1.1:static声明的方法是静态方法,… 从内存分配_深入理解JAVA_反射知识_百度文库 2018年7月13日 - 从内存分配_深入理解JAVA_反射知识_数学_自然科学_专业资料。学习知识点:_Java_内存分配、管理_变量_被释放,该_变量_对应的对象,也就失去了引用,也就变成 了可… _深入理解java_中值传递与引用传递 - 偶尔诗文的个人空间 - OSCHINA 2017年10月28日 - _深入理解java_中值传递与引用传递 转偶尔诗文 发布于 2017/10/28 16:59…值传递是将_变量_的一个副本传递到方法中,方法中如何操作该_变量_副本,都不会改变原…","link":"/2020/04/03/%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97Java%E5%8F%98%E9%87%8F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"},{"title":"14.深入Java系列Java堆内存","text":"_java堆内存_详解 - xiaobingli - 博客园 2017年11月30日 - Java堆(Java Heap)是java虚拟机所管理的内存_中最大的一块 _java堆_被所有线程共享的一块_内存_区域 虚拟机启动时创建_java堆 _java堆_的唯一目的就是存放对象… Java_之_内存_模型之_堆内存(Heap) - - ITeye博客 2019年11月13日 - Java 内存模型之堆内存(Heap) 一、背景知识:内存类型介绍 1、什么是 Perm Gen? Perm Gen : Permanent Generation Perm Gen 区是一个特殊的JVM内存区,… _Java堆内存__朱小厮的博客-CSDN博客 2016年2月29日 - Java 中的堆是 JVM 所管理的最大的一块_内存_空间,主要用于存放各种类的实例对象。 在 Ja _Java堆内存_又溢出了!教你一招必杀技 - 皇问天 - 博客园 2019年2月14日 - _JAVA堆内存_管理是影响性能主要因素之一。堆内存溢出是JAVA项目非常常见的故障,在解决该问题之前,必须先了解下_JAVA堆内存_是怎么工作的。 先看下_JAVA堆内存_是如何划分… _Java内存_分配详解(_堆内存_、栈内存、常量池) - jian_she…_CSDN博客 2017年10月23日 - _Java_中有两种类型,分别是基本类型和引用类型。如果是基本类型则直接在栈中保存值,如果是引用类型,则真正new出来的对象会存放在_堆内存_中,栈内存中会保… 超干货!Cassandra _Java堆_外_内存_排查经历全记录 - 阿里云云栖号 2019年8月19日 - 可以针对小规格ECS降低heap配置或者关闭mmap特性(disk_access_mode=standard)排查_Java堆_外_内存_还是比较麻烦的,推荐先用NMT查查,用起来比较简单,配置JVM参数即可,可以… Java 堆内存(Heap) - 286 - ITeye博客 2018年6月25日 - 在JVM 中,堆(Heap)是可供各条线程共享的运行时_内存_区域,也是供所有类实例和数组对象分配_内存_的区域。 _Java堆_在虚拟机启动的时候就被创建,它存储了被自… _Java堆内存_又溢出了!教你一招必杀技-李振良的技术博客-51CTO博客 2018年8月27日 - _JAVA堆内存_管理是影响性能主要因素之一。堆内存溢出是JAVA项目非常常见的故障,该怎么处理呢? 请教大家一个_java_面试题,关于_堆内存_。-CSDN论坛 再仔细看下报错的堆栈信息,第一行就是java.util.Arrays.copyOf(Arrays.java:3332…然后copy char数组导致的_堆内存_空间不足导致的 第二个程序,自己加上打印语句就… _Java堆内存_的10个要点-CSDN.NET 2012年2月20日 - 正式了写一些程序后,经常会遇到java.lang.outOfMemoryError等错误,我才开始关注_堆内存_。 对大多数程序员都经历过这样的过程,因为学习一种语言是非常… _Java_中的_堆内存_、栈内存和方法区总结 - - ITeye博客 2017年5月2日 - _Java_中内存分成两种,一种叫做栈内存,一种叫做_堆内存_。还有一个方法区,也叫做静态区。1.栈内存中放哪些东西? ①基本类型的变量,例如int a=3中的a; ②对… 如何永久增加java堆内存? - IT屋-程序员软件开发技术分享社区 2018年12月5日 - 本文地址:IT屋 » 如何永久增加java堆内存? 问题 我有一个_java堆内存_问题。我在java中开发了一个客户端服务器应用程序,它作为Windows服务运行,需要… 详解_Java_的_堆内存_与栈内存的存储机制__java__脚本之家 2016年1月3日 - 这篇文章主要介绍了_Java_的_堆内存_与栈内存的存储机制,包括JVM的内存优化和GC等相关方面内容,需要的朋友可以参考下 java_中为什么分栈内存和_堆内存? - 知乎 2014年8月11日 - 为什么引用名都放在栈内存而值放堆内存?其他语言也这样分还是内存本身是这样设计的?如果是,内存为什么… _JAVA堆_外_内存_的简介和使用 - 简书 2018年3月6日 - 最近看了一篇文章《蚂蚁消息中间件 (MsgBroker) 在 YGC 优化上的探索》。 文章涉及JVM的垃圾回收,主要讲的是通过使用「_堆_外_内存_」对Young GC进行优化… _java堆内存_溢出的几种情况 - 青年IT男 - ITeye博客 2018年1月17日 - 【情况一】:java.lang.OutOfMemoryError: Java heap space:这种是_java堆内存_不够,一个原因是真不够,另一个原因是程序中有死循环;如果是_java堆内存_不够… java_使用_java heap外(堆外)_内存_导致的_内存_泄露 - badqiu - ITeye… 2011年5月23日 - java可以通过 java.nio.ByteBuffer.allocateDirect(capacity) 直接使用non java heap(java堆_外)的_内存 。 一.使用目的: 1。开辟数据缓冲区 2。可以突… _Java堆_空间与堆栈 - Java中的_内存_分配_慕课手记 2019年3月9日 - _Java堆_空间与堆栈 - Java中的_内存_分配不久之后,我写了几篇关于Java垃圾收集的帖子,而Java则是Pass by Value。之后我收到了很多关于_Java堆_空间,Java 搞定面试官(Java)——对象_堆内存_分配过程 - 知乎 2019年8月25日 - 引言我们平时最常听说的“栈”和“堆”, 其中的这个堆指的就是_Java堆_这块_内存_区域,该区域是所有线程共享的一块_内存_区域(线程共享区域如下图绿色区域所示) Java… 深入理解_Java_的_堆内存_和线程内存 - weixin_36666151的…_CSDN博客 2018年1月5日 - 我们都知道_Java_对象都是在堆中创建的(开启逃逸分析的情况除外),我们也知道比如一个线程中有一段这样的代码:publicclassA{publicintxxx;}Aa=newA();会… _Java_中_堆内存_和栈内存详解 - coco_xu - 博客园 2019年4月2日 - _Java_把内存分成两种,一种叫做栈内存,一种叫做_堆内存_。 在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。当在一段代码块… _Java内存_分配详解(_堆内存_、栈内存、常量池) - jian_she…_CSDN博客 2017年10月23日 - _Java_中有两种类型,分别是基本类型和引用类型。如果是基本类型则直接在栈中保存值,如果是引用类型,则真正new出来的对象会存放在_堆内存_中,栈内存中会保… _Java堆内存_设置 - blog - CSDN博客 2018年7月12日 - _堆内存_设置原理JVM_堆内存_分为2块:永久空间和堆空间。永久即持久代(PermanentGeneration),主要存放的是_Java_类定义信息,与垃圾收集器要收集的_Java_对象关… _JAVA_面试、进阶必备——_堆内存_与栈内存_u011277123的博客-CSDN博客 2017年5月10日 - IT小修 2017-05-09 14:51java堆栈_java_面试过程中经常会被问到关于堆栈的问题,… _java_面试过程中经常会被问到关于堆栈的…Heap(堆)是JVM的_内存_数据区… _java内存_管理(堆、栈、方法区) - 杨洛平 - 博客园 2017年9月8日 - 在栈内存中保存的是_堆内存_空间的访问地址,或者说栈中的变量指向_堆内存_中的变量(_Java_中的指针)(重点)。 _Java_栈是_Java_方法执行的内存模型每个方法在执行… _java 堆内存_划分 - xx_star1204的博客_CSDN博客 2017年9月28日 - 转载自http://blog.csdn.net/sunny243788557/article/details/52796904在JVM中_堆_空间划分如下图所示上图中,刻画了_Java_程序运行时的堆空间,可以简述成… _Java堆内存_的分配_sinat_33603657的博客-CSDN博客 2019年4月14日 - _Java堆内存_的分配堆可以细分为:新生代和老年代;其中新生代可以进一步分为Eden空间、From S Java 堆内存 - 甜菜波波 - 博客园 2018年7月6日 - 堆内存 Java 中的堆是 JVM 所管理的最大的一块内存空间,主要用于存放各种类的实例对象。 在Java 中,堆被划分成两个不同的区域:新生代 ( Young )、老年… 【_Java_基础】_堆内存_详解 - 程序猿开发日志【学习永无止…_CSDN博客 2016年6月23日 - Java 中的堆是 JVM 所管理的最大的一块内存_空间,主要用于存放各种类的实例对象。 在_Java 中,堆被划分成两个不同的区域:新生代 ( Young )、老年代 ( Ol… Java堆内存 - wochunyang的专栏_CSDN博客 2016年6月17日 - Java 中的堆是 JVM 所管理的最大的一块内存_空间,主要用于存放各种类的实例对象。 在 _Java 中,堆被划分成两个不同的区域:新生代 ( Young )、老年代 ( O… Java堆内存 - CSniper - 博客园 2016年5月12日 - Java 中的堆是 JVM 所管理的最大的一块内存_空间,主要用于存放各种类的实例对象。在_Java 中,堆被划分成两个不同的区域:新生代 ( Young )、老年代 ( O… _java 堆内存_的转换和分析 - weixiaoyeah的个人空间 - 51Testing… 2011年5月24日 - 基于_java_的应用进行性能测试的时候,都会去观察她的_内存_使用情况,以免出现_内存_溢出或者_内存_使用的异常,那么jvm对于_内存_空间的使用,是怎么样的机制呢,下面是我看到过的… _Java堆内存_分配与回收策略 - 大骨浓汤 - SegmentFault 思否 2018年5月20日 - java主要在堆上分配内存,而_Java堆_又分为新生代(YoungGen)和老年代(OldGen)两个部分,新生代又再分为Eden区和Survivor区两部分,本文根据_java堆_的划分,描… _Java内存_区域总结(堆、栈、方法区等) - 程序员大本营 _Java 堆_是被所有线程共享的一块_内存_区域,在虚拟机启动时创建。 此_内存_区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配_内存_。 数组引用变量是存放在… _Java堆_外_内存_增长问题排查Case - Su的技术博客 2019年3月4日 - 最近排查一个线上java服务常驻_内存_异常高的问题,大概现象是:_java堆_Xmx配置了8G,但运行一段时间后常驻_内存_RES从5G逐渐增长到13G #补图#,导致机器开始sw… _Java_虚拟机的_内存_组成以及_堆内存_介绍-HollisChuang’s Blog 2015年4月14日 - 什么是Java_虚拟机这里就不介绍了,不明白的可以另外一篇博文:JDK,JRE,JVM区别与联系 一、_java内存_组成介绍:堆(Heap)和非堆(Non-heap)_内存 按照官方的说… Jvm的内存_可以分为_堆内存_和非_堆内存 - _Java_软件开发 云豆网,北大… 2018年7月24日 - 1) 堆内存Java 堆_是被所有线程共享的一块内存区域,在虚拟机启动时创建。Java所以实例和数组的内存均在此处分配。对象的对_内存java_垃圾回收器回收。_堆… _java_的JVM_内存_结构详解 2019年4月23日 - 本地方法栈与java_虚拟机栈一样,只是记录native方法执行。 _堆内存 _堆内存_结构 _堆内存_是存放所有对象实例,也是jvm的GC主要对象。_堆内存_主要由新生代、生存代、老年代… 有谁知道_java_中_堆内存_与栈内存的区别呢?-CSDN问答 2017年7月11日 - _java_中基本类型在栈内存上,对象在_堆内存_上,那么,栈内存和_堆内存_在运行上有什么区别呢?与平常说的运行内存又有什么关系呢? 优化_Java堆内存_大小的五个技巧-Java文档类资源-CSDN下载 2016年6月28日 - 优化_Java堆内存_大小的五个技巧 GCJava性能调优JVMHeapJava编程语言 摘要:Java堆容量不足可以对性能造成很大影响,这样无疑就给程序带来不可必要的麻烦… 深入理解_Java_之JVM_堆内存_分配-云栖社区-阿里云 2017年4月24日 - _Java堆_是被所有线程共享的一块内存区域,所有对象和数组都在堆上进行内存分配。为了进行高效的垃圾回收,虚拟机把_堆内存_划分成新生代、老年代和永久代(1… _java堆内存_的几个区域_新网 2018年6月11日 - _java堆内存_的几个区域专题详细内容由工具聚合而成,希望能给您带来帮助,帮您了解_java堆内存_的几个区域相关内容细节 _Java 堆内存_溢出梗概分析 - OSCHINA 2018年3月19日 - 当内存_溢出时,获取到 _Java 进程中的堆转储。 明白应用程序正在遭遇的_内存_问题的类型。 使用一个堆分析器,可以使用 Eclipse MAT 这个优秀的开源项目来… _Java_高级课程——_Java堆内存_和栈内存的区别 2018年5月11日 - 对于JVM_内存_模型来说,只要记住下面这张图就足够了, 对于左边黄色的部分,就是JVM中的“堆”,相对应的右边的则是”栈”。堆 在_Java_中,Heap用来表示 … 使用Java堆_外_内存(自己管理内存)的一些方法 | 学步园 2013年12月5日 - 使用_Java_的一大好处就是自动_内存_管理,程序员不用太关心_内存_的是否,JVM的Garbage Collector(GC)帮我们找到不被引用的垃圾对象并清除掉。但是有得必有失… _java内存堆_区栈区 - 云+社区 - 腾讯云 _java内存_分配中的堆 _堆内存_用来存放由new创建的对象和数组。 在堆中分配的内存,由_java_虚拟机的自动垃圾回收期来管理。 在堆中产生了一个数组或对象后,还可以在… java _内存_溢出,但是监控到_java_的堆并没有增长,只是window任务管理… 2009年4月21日 - _java内存_溢出。经过监控发现,_java_的堆并没有增长,只是window任务管理器中_java_进程的_内存_一直在增长,直到_内存_溢出 请问各位大虾遇到过这种情况没有,谢… 死磕_内存_篇 — _JAVA_进程和linux_内存_间的大小关系 - fengbin2005… 2018年9月18日 - 提高_JAVA_的_堆内存_分配,影响的只是VIRT内存的使用情况。 详附1 实验二: 观察_JAVA_的实际使用内存, _JAVA_进程的实际使用内存应该包括, JVM的内存+_JAVA_程序… tomcat服务器配置_java堆内存_大小 2017年7月18日 - Java_中的堆空间是什么? 当_Java_程序开始运行时,JVM会从操作系统获取一些内存.JVM使用这些内存,这些内存的一部分就是_堆内存._堆内存_通常在存储地址的底层… _Java_系列技术之JVM调优-2-_堆内存_内部结构-钟洪发的在线视频教程… 该课程主要讲解Java JVM方面的知识,包括_堆内存_、内存溢出、泄漏、垃圾回收机制、引用计数垃圾回收算法等所有知识点。_Java_虚拟机应该说是学习到一定程度的_Java_程序员… 关于JAVA堆,下面说法错误的是()?__牛客网 2017年9月22日 - 关于JAVA堆,下面说法错误的是()? ,完美世界2017校招技术综合A卷… _堆内存_用来存放由 new 创建的对象和数组,在堆中分配的内存,由 Java 虚拟机的自动垃… 什么是_java堆内存__网友(匿名用户)职场问答-职Q! 2019年7月1日 - 网友(匿名用户)在线提问(什么是java堆内存),欢迎大家在【职Q】互动问答平台在线交流。… Java 虚拟机具有一个堆,堆是运行时数据区域,所有类实例和数… Java–_堆内存_的10个要点,有哪些-百度经验 2013年4月16日 - _Java_中的_堆内存_是什么? 当_Java_程序开始运行时,JVM会从操作系统获取一些内存。JVM使用这些内存,这些内存的一部分就是_堆内存_。_堆内存_通常在存储地址的底… 浅谈_Java堆内存_分代回收 2018年7月14日 - 与C++不同的是:在_Java_中我们无需关心对象占用空间的释放,这主要得益于_Java_中的…_堆内存_是如何分代的? 各分代之间是如何配合工作的? 1、_堆内存_是如何分代的?… 关于js 与 _Java 堆_栈_内存_的一些疑惑 - V2EX 2017年4月26日 - 在 js 中对象是存在堆内存_中的,变量只是个引用,那对象的属性是存在哪的呢,假设该属性是个数字 3 ,函数作用域中的变量又是存在哪里呢。 再说_java , sta… 优化_Java堆_大小的5个技巧-CSDN.NET 2012年7月25日 - _Java堆_容量不足可以对性能造成很大影响,这样无疑就给程序带来不可必要的麻烦,本文总结了影响_Java堆_容量不足的五大原因以及巧妙地去优化? _java_里的静态变量是放在了_堆内存_还是栈内存?-CSDN论坛 2011年6月8日 - 2.jvm只有一个_堆_区(heap)被所有线程共享,_堆_中不存放基本类型和对象引用,只存放对象本身 栈区: 1.每个线程包含一个栈区,栈中只保存基础数据类型的对… _java堆内存_设置优化 - 北游运维 - OSCHINA 2013年4月12日 - 在前天我在公司内部做了一个分享,好久没有更新博客,主要是工作太忙,没有时间去总结,这篇博客也是这次分享时内容。 对于_java堆内存_设置,首先需要对java内存解构有… _java堆内存_设置优化 - 北游运维 - OSCHINA 2013年4月12日 - 在前天我在公司内部做了一个分享,好久没有更新博客,主要是工作太忙,没有时间去总结,这篇博客也是这次分享时内容。 对于_java堆内存_设置,首先需要对java内存解构有… _java堆_外_内存_查看__java堆_外_内存_查看【价格,厂家,图片,批…_丁香通 丁香通为您找到12条java堆_外_内存_查看信息,包括_java堆_外_内存_查看报价行情,优质供应商,图片,品牌等最新信息,丁香通为买家提供用户服务,诚信保障等服务,批发采购_java堆… 有谁知道_java_中_堆内存_与栈内存的区别呢?-CSDN问答 2017年7月11日 - _java_中基本类型在栈内存上,对象在_堆内存_上,那么,栈内存和_堆内存_在运行上有什么区别呢?与平常说的运行内存又有什么关系呢? 优化_Java堆内存_大小的五个技巧-Java文档类资源-CSDN下载 2012年11月3日 - GCJava性能调优JVMHeapJava编程语言 摘要:_Java堆_容量不足可以对性能造成很大影响,这样无疑就给程序带来不可必要的麻烦,本文总结了影响_Java堆_容量不足… java 打印_堆内存__新网 2018年6月13日 - java 打印堆内存_专题详细内容由工具聚合而成,希望能给您带来帮助,帮您了解_java 打印_堆内存_相关内容细节 java gc只负责堆的内存,那栈的_内存_是怎么释放-CSDN论坛 2017年5月22日 - JAVA_虚拟机就会自动在_内存_中分配对应的一块空间,那么这块空间就是一个栈帧,也就自然属于栈了,而当方法调用结束后,对应的栈帧就会被释放掉,那么因为_JAV… java_获取_堆内存 - 云+社区 - 腾讯云 获取“_Java堆_空间”和“_内存_不足”时的Eclipse_内存_设置(2 个回答) 当试图在eclipse中启动并运行flex java项目时,我一直使用eclipse,tomcat和jre获取“_内存_不足”和… _JAVA_7、_JAVA_8的_堆内存_有啥变化 - 简书 快速过一遍JVM的_内存_结构,JVM中的_内存_分为5个虚拟的区域: 堆 你的_Java_程序中所分配的每一个对象都需要存储在_内存_里。堆是这些实例化的对象所存储的地方。是的… _java_查看_堆内存_的命令及方法 - 王小明的个人页面 - OSCHINA 2013年12月3日 - 最近一个项目总发出_堆内存_过大报警,dump出了内存也一直没时间研究,今天正好整理下相关用到的命令和代码 这里有几个主要的命令和工具 jinfo:可以输出并… jvm 参数设置(_堆内存_相关) - 程序员大本营 jvm 参数设置(_堆内存_相关),程序员大本营,技术文章内容聚合第一站。… 在_java_8之前的_堆内存_分为:新生代内存(young generation)、老年代内存(old generation)、永久…","link":"/2020/04/04/%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97Java%E5%A0%86%E5%86%85%E5%AD%98/"},{"title":"13.深入Java系列Java栈内存","text":"_java_中_堆栈内存_分析(二)让你彻底明白_JAVA_中堆与栈的区…_CSDN博客 2019年3月9日 - 简单的说:Java_把内存划分成两种:一种是_栈内存,一种是堆内存。在函数中定义的一些基本类型的变量和对象的引用变量都在函数的_栈内存_中分配。当在一段代… _JAVA_中_堆栈_和_内存_分配原理_栈堆_geomon的博客-CSDN博客 2019年3月11日 - 在函数中定义的一些基本类型的变量数据和对象的引用变量都在函数的_栈内存_中分配。 当在一段代码块定义一个变量时,_Java_在栈中为这个变量分配内存空间,… _Java_中堆内存和_栈内存_详解 - 蛊惑Into - 博客园 2011年9月29日 - Java_把内存分成两种,一种叫做_栈内存,一种叫做堆内存 在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的_栈内存_中分配。当在一段代码块中… 深入理解Java内存(图解堆栈) - 万物为铜 - 博客园 2018年1月26日 - » 下一篇: _Java内存_管理的进一步理解-模拟过程图解 posted @ 2018-01-26 11:13 万物为铜 阅读(17826) 评论(2) 编辑 收藏评论… 谈谈_java_的_栈_和堆 - php中文网 2019年4月27日 - 虚拟机栈:表示_Java_方法执行的_内存_模型,每调用一个方法就会为每个方法生成一个栈帧(Stack Frame),用来存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法… java gc只负责堆的内存,那栈的_内存_是怎么释放-CSDN论坛 2017年5月22日 - JAVA_虚拟机就会自动在_内存_中分配对应的一块空间,那么这块空间就是一个栈帧,也就自然属于栈了,而当方法调用结束后,对应的栈帧就会被释放掉,那么因为_JAV… 详解_Java_的堆内存与_栈内存_的存储机制__java__脚本之家 2016年1月3日 - 这篇文章主要介绍了_Java_的堆内存与_栈内存_的存储机制,包括JVM的内存优化和GC等相关方面内容,需要的朋友可以参考下 java内存(栈,堆,方法区) - 简书 2019年1月9日 - _java_中_内存_分为3块分别为:栈、堆、方法区(实际上方法区存在在堆当中也可以说_内存_分为栈、堆,但是方法区比较特殊所以单独拿出来说)。1)栈1、表示方法执… 查看java栈内存 - 云+社区 - 腾讯云 有人把 java 内存区分为堆内存和栈内存,而所指的“栈”就是这里的虚拟机栈,或者说是虚拟机栈中局部变量表部分。 局部变量表存放了编译期可知的各种基本数据类型… _Java_中 _栈内存_的存取速度仅次于寄存器,如何做到的? - 知乎 2015年5月8日 - “_栈内存_的存取速度仅次于寄存器”,这一结论来自于某些文章,google下有很多_栈内存_的存取速度仅次于寄存… _堆栈_与堆:了解_Java内存_分配-NopSmile的博客-51CTO博客 2018年8月16日 - 原文地址:https://dzone.com/articles/stack-vs-heap-understanding-_java_-memory...堆和栈都在RAM中,堆用于动态_内存_分配,而栈用于静态分配。 栈上分配… Java_堆空间与_堆栈 - _Java_中的_内存_分配_慕课手记 2019年3月9日 - Java_堆空间与_堆栈 - Java_中的_内存_分配不久之后,我写了几篇关于_Java_垃圾收集的帖子,而_Java_则是Pass by Value。之后我收到了很多关于_Java_堆空间,_Java Java _内存堆栈_查看 - godlewis - ITeye博客 2014年11月29日 - Java _内存堆栈_查看 (1). jmap -dump:format=b,file=heap.bin :生成_内存_快照 (2). jhat -port 8888 heap.bin:通过jhat把_内存_快照生成网页文件,并… _java栈_上分配_内存_大小_新网 2018年6月13日 - _java栈_上分配_内存_大小专题详细内容由工具聚合而成,希望能给您带来帮助,帮您了解_java栈_上分配_内存_大小相关内容细节 _Java内存_管理: _Java栈__尚学堂it吧_百度贴吧 2017年3月15日 - Java内存_管理: .. _Java栈 _Java栈_也称作虚拟机栈(Java Vitual Machine Stack),也就是我们常常所说的栈,跟C语言的数据段中的栈类似。事实上,_Java栈_是Jav… _java堆栈_溢出怎么解决-百度经验 2018年1月3日 - _java堆栈_溢出怎么解决,当一个Java程序没有_内存_可用时就会导致堆栈溢出,从而抛出异常:java.lag.OutOfMemoryError:Javaheaace,error,此时可以通过增大jvm的堆_内存_来… java-内存-栈介绍-_Java_文档类资源-CSDN下载 2018年2月23日 - java-内存-栈介绍 评分 存放方法栈、成员基本数据类型变量的引用和值、成员引用数据类型变量的引用 java 编程语言 web 开发 栈 所需积分/C币:1 上传… _Java栈内存_与堆内存的区别 | 易学教程 2019年12月2日 - _java_中 栈(stack)是由编译器自动分配和释放的一块_内存_区域,主要用于存放一些基本类型(如 int、float等)的变量、指令代码、常量以及对象句柄――(对象… _Java内存_分配之堆、栈和常量池 - Sara早安 - 博客园 2016年7月20日 - 在函数中定义的一些基本类型的变量数据和对象的引用变量都在函数的_栈内存_中分配。当在一段代码块定义一个变量时,_Java_就在栈中为这个变量分配内存空间,当该变量退出… 浅析_Java_堆内存和_栈内存_的区别 - 姜兴琪的博客 - CSDN博客 2018年3月6日 - 参考堆内存:https://baike.baidu.com/item/%E5%A0%86%E5%86%85%E5%AD%98/7270805?fr=aladdin_栈内存_:https://baike.baidu.com/item/%E6%A0%88%E5%86%85… _Java内存_分配详解(堆内存、_栈内存_、常量池) - jian_she…_CSDN博客 2017年10月23日 - _Java_中有两种类型,分别是基本类型和引用类型。如果是基本类型则直接在栈中保存值,如果是引用类型,则真正new出来的对象会存放在堆内存中,_栈内存_中会保… _java_中_栈内存_和堆内存 - ILittleFairy - 博客园 2019年5月17日 - 栈内存_中存的变量的数据大小和声明周期必须是确定的,并且它的寄存速度快。 原博客地址: https://www.cnblogs.com/joyco773/p/6752037.html 分类: _java… _java内存_管理(堆、栈、方法区) - 杨洛平 - 博客园 2017年9月8日 - 虚拟机栈描述的是_Java_方法执行的_内存_模型:每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链表、方法出口信息等。每一个方… _JAVA堆栈内存_机制 - 奥利奥泡馍的专栏 - CSDN博客 2016年6月30日 - Java 把内存划分成两种:一种是栈内存,另一种是堆内存。在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的_栈内存_中分配,当在一段代码块定… _Java栈内存_和堆内存的区别 - 志不坚者智不达 - 博客园 2019年6月3日 - _Java栈内存_和堆内存的区别 总结:1栈:为编译器自动分配和释放,如函数参数、局部变量、临时变量等等2堆:为成员分配和释放,由程序员自己申请、自己释放。… _java_堆内存与_栈内存__落尘曦的博客-CSDN博客 2017年10月3日 - java_堆内存与_栈内存Java_把内存分成两种,一种叫做_栈内存,一种叫做堆内存在函数中定义的一些基本类 栈内存_和堆_内存Java(详细实例讲解)_摸金校尉的博客-CSDN博客 2019年5月2日 - 定义栈内存:存放基本类型的变量、对象的引用(引用变量)。(如何回收?) 在一段代码块中定义一个变量 _JAVA_面试、进阶必备——堆内存与_栈内存__u011277123的博客-CSDN博客 2017年5月10日 - IT小修 2017-05-09 14:51_java堆栈java_面试过程中经常会被问到关于堆栈的问题,… java面试过程中经常会被问到关于堆栈的问题,这里我稍微总结一下,供大… 浅谈_java堆栈_和_内存_分配原理_DreamKing_Walking的博客-CSDN博客 2018年8月31日 - 在java中我们把java内存_分为两种一种是_栈内存,一种则是堆内存 1.在谈_java堆栈_知识之前我 _Java_中堆内存和_栈内存_详解 - coco_xu - 博客园 2019年4月2日 - Java_把内存分成两种,一种叫做_栈内存,一种叫做堆内存。 在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的_栈内存_中分配。当在一段代码块… _JAVA_中_堆栈_和_内存_分配原理 - rhino - 博客园 2015年4月21日 - 在函数中定义的一些基本类型的变量数据和对象的引用变量都在函数的_栈内存_中分配。 当在一段代码块定义一个变量时,_Java_在栈中为这个变量分配内存空间,… _Java_中堆内存和_栈内存_详解 - 每天进步一丶 - 博客园 2017年8月1日 - Java_把内存分成两种,一种叫做_栈内存,一种叫做堆内存 在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的_栈内存_中分配。当在一段代码块中… _Java_中堆内存和_栈内存_详解 - little fat - 博客园 2016年9月21日 - Java_把内存分成两种,一种叫做_栈内存,一种叫做堆内存 在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的_栈内存_中分配。当在一段代码块中… _java_堆内存和_栈内存_的区别 - 菜鸟程序员成长路 - CSDN博客 2018年4月22日 - 总结:1_栈_:为编译器自动分配和释放,如函数参数、局部变量、临时变量等等2堆:为成员分配和释放,由程序员自己申请、自己释放。否则发生_内存_泄露。典型为… 【_java_怎么解决_堆栈_溢出】-博文推荐-CSDN博客 2019年8月31日 - 本次公开课将向您详细介绍来自赛灵思公司的 reVISION™ _堆栈_。它包含了从开发套件到设计工具和IP库在内的整套解决方案,能够让没有或者很少硬件设计专… java gc负责堆的_内存_释放,那栈的_内存_是怎么管理,释放的。-CSDN问答 2017年5月22日 - java gc负责堆的_内存_释放,那栈的_内存_如果一个栈帧导致其满了,怎么办? 在其他人在哪里看到了这个答复: ``` _Java_中是通过栈帧来维护的,每调用方法的时候,就会… Java堆栈 - _Java内存_管理_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili https://www.youtube.com/watch?v=450maTzSIvAhttps://www.youtube.com/redirect?v=450maTzSIvA&amp;redir_token=bYdwlRtuek8beskMuGXVnptFRDp8MTU1NTg2OTI… _Java_高级课程——_Java_堆内存和_栈内存_的区别 2018年5月11日 - 堆栈,这个名词很多_Java_开发者在一开始学习_Java_的时候就经常听说了。 对于这个名词来说,它描述的其实是JVM的_内存_模型, 如果面试中问到,_堆栈_具体对应着… Java_之_内存_模型之堆_内存(Heap) - - ITeye博客 2019年11月13日 - Java 内存_模型之堆_内存(Heap) 一、背景知识:_内存_类型介绍 1、什么是 Perm Gen? Perm Gen : Permanent Generation Perm Gen 区是一个特殊的JVM_内存_区,… java _内存_溢出 栈溢出的原因与排查方法 - oswebgod的个人空间… 2018年2月13日 - 下面从以下几个方面来配合代码实战演示内存溢出及如何定位: Java堆内存异常 _Java栈内存_异常 方法区内存异常 Java堆内存异常 /** VM Args: //这两个参… 史上最详细_Java内存_区域讲解_网易订阅 2019年4月5日 - · OutOfMemoryError: 若Java 虚拟机栈的内存_大小允许动态扩展,且当线程请求栈时_内存_用完了,无法再动态扩展了,此时抛出OutOfMemoryError异常。 _Java 虚… _java栈内存_工作原理_新网移动 2018年6月10日 - _java栈内存_工作原理专题详细内容由工具聚合而成,希望能给您带来帮助,帮您了解_java栈内存_工作原理相关内容细节 04-Java_基础(数组-_栈内存) 2013年1月17日 - 04-Java_基础(数组-_栈内存)简介 热度24 评论 极清 缓存 分享为你推荐 刘老根王大锤附体,用尽十八般武艺,立志成为最有魅力的男人!01:30 APP内观看热度46… JAVA_中 引用的_内存(栈中的)大小是多少-CSDN论坛 2009年4月19日 - 【JVM原理与优化】Java_堆空间VS栈空间 - _Java_中的内存分配 近期在学习JVM,看到JVM堆内存和_栈内存,但是对于堆内存和_栈内存_的解释不是很足,现在翻译一篇… _java栈内存_溢出怎么产生? - 知乎 2015年3月10日 - _java栈内存_溢出场景是什么,怎么验证?堆内存溢出和stackoverflow就不说啦。说的是outOfMemory补充下我谈… _java_中堆内存与_栈内存_的知识点总结__java__脚本之家 2019年12月27日 - 在本篇文章里小编给大家整理的是关于_java_中堆内存与_栈内存_的知识点总结,有需要的朋友们可以跟着学习下。 Java内存(栈、堆) - 简书 Java_把内存分为两种,一种是_栈内存,一种是堆内存 栈内存:在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的_栈内存_中分配。定义一个变量就在栈中给… _Java内存_区域总结(堆、栈、方法区等) - 程序员大本营 Java 虚拟机栈描述的是 Java 方法执行的内存模型:每个方法执行的同时会创建一个栈帧。 对于我们来说,主要关注的 stack 栈内存,就是虚拟机栈中局部变量表部分。 … _java内存_分配详解__java内存_分配__java内存_分配栈堆 - 云+社区… 跟cc++不同,_java_中分配堆_内存_是自动初始化的。 _java_中所有对象的存储空间都是在堆中分配的,但是这个对象的引用却是在_堆栈_中分配,也就是说在建立一个对象时从两… 关于java_中_栈内存,main方法一定会是压栈的吗? - OSCHINA 2016年11月26日 - 关于_栈内存_是后进先出的准则,那么main方法是_java_程序的入口,_java_程序中main方法帧是不是一定会压栈,最后弹栈。 _java栈内存_共享?_java吧_百度贴吧 2017年3月8日 - _java栈内存_共享?..这个要分两种情况1. 类变量a个b的符号引用,以及98被存入常量池a和b对应图中的#2和#3jdk1.7中常量池被移入堆中2. 局部变量局部变量会… _JAVA 堆栈内存_分析-Java文档类资源-CSDN下载 2018年6月22日 - _JAVA 堆栈内存_分析 评分 如何调优JVM - 优化Java 虚拟机(大全+ 实例)堆设置 -Xmx3550m :设置JVM 最大堆内存为3550M 。 -Xms3550m :设置JVM 初始堆内… _java_如何进行_内存_分配-百度经验 2018年9月1日 - _java_如何进行_内存_分配,每运行一个_java_程序会产生一个_java_进程,每个_java_进程可能包含一个或者多个线程,每一个_Java_进程对应唯一一个JVM实例,每一个JVM实例唯一对应一… java-_Java_关于_栈内存_管理问题——CSDN问答频道 2019年2月24日 - _Java_关于_栈内存_管理问题 在网上看到这段话 int a=3; int b=3; 编译器先处理int a = 3;首先它会在栈中创建一个变量为a的引用,然后查找有没有字面值为3… _java_中为什么分_栈内存_和堆内存? - 知乎 2014年8月11日 - 为什么引用名都放在_栈内存_而值放堆内存?其他语言也这样分还是内存本身是这样设计的?如果是,内存为什么… JAVA _内存堆栈_结构_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili_java_如何查看_栈内存_中当前运行的函数-CSDN论坛 2013年4月1日 - 这里的0表示取出栈顶方法,写个for循环就可以取出_栈内存_中的全部方法: StackTraceElement[] sTraceElements = new Exception().getStackTrace(); for (…","link":"/2020/04/04/%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97Java%E6%A0%88%E5%86%85%E5%AD%98/"},{"title":"16.深入Java系列Java栈内存溢出分析","text":"Java内存溢出_与_栈溢出分析 - binglong_world的专栏 - CSDN博客 2018年6月14日 - b)、OutOfMemoryError(线程太多,内存_不够新建线程) 1、_java.lang.StackOverflowError 栈溢出_抛出_java.lang.StackOverflowError错误,出现此种情况是因… java 内存溢出 _栈溢出_的原因与排查方法 - oswebgod…-开源中国社区 2018年2月13日 - 今天就基于上篇文章JVM系列之Java内存_结构详解讲解的各个内存区域重点实战_分析_下…_内存溢出: 虚拟机由于堆中拥有太多不可回收对象没有回收,导致无法… java 内存溢出 _栈溢出_的原因与排查方法__Java__yanlove_j…_CSDN博客 2016年6月11日 - 1、 内存溢出_的原因是什么? _内存溢出_是由于没被引用的对象(垃圾)过多造成JVM没有及时_Java java内存溢出_示例(_堆溢出_、_栈溢出) - THISISPAN - 博客园 2016年9月18日 - /** * @author LXA * 堆溢出 */ public class Heap { public static void…Java_中对_内存_对象的访问,使用的是引用的方式。在 _Java 代码中我们维护一个… _Java内存溢出分析_方法(Eclipse Memory Analyzer 使用简单…_博客园 2017年9月5日 - java:208) at java.util.ArrayList.add(ArrayList.java:440) at com.valentine.jvm.analyzer.exception.HeapOOM.main(HeapOOM.java:16) _Java堆溢出_内… _java栈内存溢出_怎么产生? - 知乎 2015年3月10日 - _java栈内存溢出_场景是什么,怎么验证?堆内存溢出和stackoverflow就不说啦。说的是outOfMemory补充下我谈… java内存溢出_示例(_堆溢出_、_栈溢出) - java 2019年8月5日 - 这篇文章主要介绍了java内存溢出_示例(_堆溢出_、_栈溢出),需要的朋友可以参考下… java.lang.OutOfMemoryError: Java heap space 栈溢出: 复制代码 代码如下: /**… Java 堆内存溢出_梗概_分析 - 编程语言 - ITeye资讯 2018年3月30日 - 当内存溢出_时,获取到 _Java 进程中的堆转储。 明白应用程序正在遭遇的内存问题的类型。 使用一个_堆分析_器,可以使用 Eclipse MAT 这个优秀的开源项目… java 内存溢出 _栈溢出_的原因与排查方法 | IT瘾 2014年10月18日 - _内存溢出_是由于没被引用的对象(垃圾)过多造成JVM没有及时回收,造成的_内存溢出_。…七)使用 DDMS工具进行查找_内存溢出_的大概位置 2、_栈溢出_的原因 一)… java内存溢出_示例(_堆溢出_、_栈溢出) - 脚本之家 以上是脚本之家为你收集整理的java内存溢出_示例(_堆溢出_、_栈溢出)全部内容,希望文章能够帮你解决java内存溢出_示例(_堆溢出_、_栈溢出)所遇到的程序开发问题。 如果觉得脚… [总结]-第二章 _Java内存_区域与_内存溢出_异常丶一个站在_Java_后端… 2018年10月12日 - 分别怎么分析_定位?_java.lang.OutOfMemoryError: Java heap space 堆内存溢出(最常见的),可以Dump堆转储快照信息查看具体问题。 java.lang.StackOverfl… java内存溢出_示例(_堆溢出_、_栈溢出) - _Java_开发社区 | CTOLib码库 2017年3月22日 - java内存溢出_示例(_堆溢出_、_栈溢出) lazyleopard 发布于3年前 0 人点赞 0 条问题 堆溢出: /** * @author LXA * 堆溢出 */ public class Heap { public … _java内存溢出_排查方法解析-电子发烧友网 2017年11月28日 - 为了解决_Java_中_内存溢出_问题,我们首先必须了解_Java_是如何管理内存的。_Java_的内存…七)使用 DDMS工具进行查找_内存溢出_的大概位置 2、_栈溢出_的原因 一)、是否有递归… _JAVA内存溢出分析_之OutOfMemoryError异常 - - ITeye博客 2014年1月14日 - Java堆内存的OOM异常是实际应用中最常见的内存溢出异常情况。出现_Java堆内存溢出_时,异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Ja… 《深入理解_Java_虚拟机》读书笔记:第二章_Java内存_区域与_内存溢出_异常 2019年12月22日 - _Java_虚拟机在执行_Java_程序的过程中会把它所管理的_内存_划分为若干个不同的数据区域:方法区、虚拟机_栈_、本地方法_栈_、_堆_、程序计数器 程序计数器(Program… _Java堆内存_又_溢出_了!教你一招必杀技-李振良的技术博客-51CTO博客 2018年8月27日 - _JAVA堆内存_管理是影响性能主要因素之一。_堆内存溢出_是JAVA项目非常常见的故障,该怎么处理呢? tomcat_内存溢出_原因_分析_与解决以及_java内存溢出_、_栈_溢…_CSDN博客 2017年3月17日 - tomcat_内存溢出_原因_分析_与解决以及_java内存溢出_、_栈溢出_的原因与排查方法… 对于前两种情况,在应用本身没有内存泄露的情况下可以用设置tomcat jvm参… _Java堆内存_又_溢出_了!教你一招必杀技-李振良的技术博客-51CTO博客 2018年8月27日 - _JAVA堆内存_管理是影响性能主要因素之一。_堆内存溢出_是JAVA项目非常常见的故障,该怎么处理呢? tomcat_内存溢出_原因_分析_与解决以及_java内存溢出_、_栈_溢…_CSDN博客 2017年3月17日 - tomcat_内存溢出_原因_分析_与解决以及_java内存溢出_、_栈溢出_的原因与排查方法… 对于前两种情况,在应用本身没有内存泄露的情况下可以用设置tomcat jvm参… Java内存溢出_及_分析 - 那一阵风 - 博客园 java内存_有几种:程序计数器,虚拟机栈,方法常量区,堆,本地方法栈,直接内存。既然_分析内存溢出,那就从这几种内存逐一_分析_。 1,程序计数器:是一个较小的内存空间… Java 堆内存溢出_梗概_分析 - OSCHINA_开源中国 2018年3月19日 - 当内存溢出_时,获取到 _Java 进程中的堆转储。 明白应用程序正在遭遇的内存问题的类型。 使用一个堆分析器,可以使用 Eclipse MAT 这个优秀的开源项目来… java 内存溢出 _栈溢出_的原因与排查方法_BabyNiu411的专栏-CSDN博客 2015年3月11日 - 1、 _内存溢出_的原因是什么? _内存溢出_是由于没被引用的对象(垃圾)过多造成JVM没有及时… _内存溢出_是由于没被引用的对象(垃圾)过多造成JVM没有及时回收… JVM _内存溢出_追踪调优与 _内存溢出_、_栈溢出_原因_Len Zho…_CSDN博客 2018年3月1日 - 出处1:http://www.iteye.com写_java_程序时大家一定对一下两条异常并不陌生: j… 下面写些代码来演示一下内存溢出_的产生,堆转储文件的生成,_堆内存_的_分… _Java 堆内存溢出_梗概_分析__java,堆内存,内存溢出_大白兔…_CSDN博客 2018年4月16日 - 当内存溢出_时,获取到 _Java 进程中的堆转储。 明白应用程序正在遭遇的内存问题的类型。 使用一个堆分析器,可以使用 Eclipse MAT 这个优秀的开源项目来… java内存溢出_示例(_堆溢出_、_栈溢出)_u012102536的博客-CSDN博客 2016年12月28日 - 在 Java 程序中,这个引用变量本身既可以存放_堆内存_中,又可以放在代码栈的内存中(与基本数据类型相同)。 GC 线程会从代码栈中的引用变量开始跟踪,从而… 如何_分析Java_的_内存溢出_问题(OutofMemory)_孤独键客-CSDN博客 2018年9月5日 - 我们开发一个测试程序,来模拟OutofMemory情况。程序很简单,代码如下:import java… 在解决_java内存溢出_问题之前,需要对jvm(_java_虚拟机)的内存管理有一定的认识。jvm… Java 内存溢出分析 - 沉毅寡言 - 博客园 java.lang.StackOverflowError 【原因】:这也_内存溢出_错误的一种,即线程_栈_的溢出,要么是方法调用层次过多(比如存在无限递归调用),要么是线程_栈_太小。 【解决】… Java内存溢出(OOM)异常排查指南 - pbuzhidaol的博客 - CSDN博客 2017年6月5日 - 如果你的程序存在内存泄漏,一味的增加堆空间也只是推迟java.lang.OutOfMemory…如果你已经确保JVM可以卸载类,但是仍然出现_内存溢出_问题,那么你应该继… Java内存溢出_与_栈溢出 - z69183787的专栏 - CSDN博客 2017年7月20日 - b)、OutOfMemoryError(线程太多,内存_不够新建线程) 1、_java.lang.StackOverflowError 栈溢出_抛出_java.lang.StackOverflowError错误,出现此种情况是因… java 内存溢出 _栈溢出_的原因与排查方法 - yanlove_jing…_CSDN博客 2016年6月11日 - 1、 _内存溢出_的原因是什么?_内存溢出_是由于没被引用的对象(垃圾)过多造成JVM没有及时回收,造成的_内存溢出_。如果出现这种现象可行代码排查:… java 内存溢出 _栈溢出_的原因与排查方法 - weixin_33748…_CSDN博客 2018年2月13日 - 上篇文章JVM系列之_Java内存_结构详解讲解的各个内存区域重点实战_分析_下_内存溢出_的…栈的过程,那么有两种情况可以导致StackOverFlowError,当一个方法帧… java 内存溢出 _栈溢出_的原因_xiaobao5214的博客-CSDN博客 2019年3月4日 - _内存溢出_是由于没被引用的对象(垃圾)过多造成JVM没有及时回收,造成的_内存溢出_。…tomcat_内存溢出_原因_分析_与解决以及_java内存溢出_、_栈溢出_的原因与排… 通过eclipse MemoryAnalyzer插件对内存溢出_进行_堆栈_轨迹异常_分析… 2019年7月10日 - 通过eclipse中安装MemoryAnalyzer插件,对下面内存溢出_代码产生的dump错误文件进行_分析..代码示例..-Xms40m -Xmx40m -XX:+HeapDumpOnOutOfMemoryError.._java__pid… JVM之_Java内存_区域及_内存溢出_异常 程序运行时数据区域…_新浪博客 2015年12月29日 - 如果虚拟机栈_可以动态扩展(当前大部分的_Java_虚拟机都可动态扩展,只不过_Java_虚拟机规范中也允许固定长度的虚拟机_栈),如果扩展时无法申请到足够的内存,… 栈内存溢出: java.lang.OutOfMemoryErro 2018年5月6日 - 后来看到日志发现,原来是 OOM 的闪退,但怎么好像是线程的_栈内存溢出_了?😥查找了关键日志:Throwing OutOfMemoryError “pthread_create (1040KB stack) … java内存溢出_示例(_堆溢出_、_栈溢出)-java_求数组元素重复次数和_java… 阿里云云栖社区为您免费提供java内存溢出_示例(_堆溢出_、_栈溢出)的相关博客问答等,同时为你提供java内存溢出_示例(_堆溢出_、_栈溢出)-_java_求数组元素重复次数和_java_字符… Java堆内存溢出 - 『编程语言区』 - 吾爱破解 - LCG - LSG |安卓… 2016年9月18日 - 最近在研究Java虚拟机,下面演示个_Java堆内存溢出_的实例,Java堆内存用于存储对象实例,只有不断的创建对象并且保证GC Roots到对象之间有可达路径来避免… JAVA_语言-jvm之虚拟机_栈_和本地方法_栈溢出,方法区和运行时常量池… 2019年1月9日 - 本文主要向大家介绍了JAVA_语言-jvm之虚拟机栈和本地方法_栈溢出,方法区和运行时常量池溢出,本机直接_内存溢出_讲解,通过具体的内容向大家展示,希望对大家学习_JAVA_语言… 用一段时间后java内存溢出_问题_分析(转)-程序员一代码搬运工 2014年8月11日 - 几乎每个月都有出现因为_内存溢出_的问题,除了需要多分配内存外, 是不是要考虑对代码进行一些处理。。 下面是参考网络资源总结的一些在_Java_编程中尽可能… _java栈内存溢出_咋产生?jvm给每个socket连接的receive缓存区分37KB… 2018年2月10日 - _java栈内存溢出_场景是什么,怎么验证?堆内存溢出和stackoverflow就不说啦。说的是outOfMemory 补充下我谈①下自己的看法(我们的讨论限定于比较常见的Ho… 《JVM笔记》之一:_Java内存_区域与_内存溢出_异常 - 野猪林 - ITeye… 2014年5月7日 - 注:出现Java堆内存溢出_时,异常堆栈信息 java.lang.OutOfMemoryError 后面会紧跟着 Java heap space。 要解决这个异常,一般手段是首先通过内存映像_分析… Java 内存_区域与_内存溢出 - 深入理解 Java 虚拟机 - 极客学院Wiki 另外,该内存区域是唯一一个在 Java 虚拟机规范中么有规定任何 OOM(内存溢出:OutOfMemoryError)情况的区域。Java 虚拟机_栈_该区域也是线程私有的,它的生命周期也与… _java内存溢出_至permgen OOM解析 - - ITeye博客 2015年3月4日 - 现在,有关讨论JAVA内存_泄漏的文章很多。_java_的_内存_泄漏基本上按照_内存_区域的划分可以分为: _堆(heap)内存_泄漏:大家都比较熟悉 _栈(stack)_内存_泄漏:当前… 怎么设置增加_JAVA栈_的容量,以防止_内存溢出_的有关问题 - J2SE 2013年12月24日 - 如何设置增加_JAVA栈_的容量,以防止_内存溢出_的问题 我在用 img=getImage(getCodeBase(), “bb.jpg “); 装入一个图象文件bb.jpg 如果文件较大(如8M),则产… 记一次_内存溢出_的_分析_经历 – 零一海 2019年11月25日 - 说在前面的话朋友,你经历过部署好的服务突然_内存溢出_吗?你经历过没有看过_Java_虚拟机,来解决_内存溢出_的痛苦吗?你经历过一个BUG,百思不得其解,头发一根… JVM_内存溢出_诊断方法 - a javaer - ITeye博客 2018年11月1日 - 1.查看各个代的内存使用情况(一般情况都是堆内存溢出) jmap -heap pid 2.查看…MAT(linux)_分析内存_步骤: 1.通过jmap -dump 将运行的_java_进程的内存数… 深入理解_java_虚拟机-_Java内存_区域与_内存溢出_异常_码神岛 2019年3月23日 - Java堆溢出 产生原因: java堆_用于存储对象实例,只要不断地创建对象,并且保证GC …先通过_内存_映像_分析_工具(EMA)对Dump出来的堆快照进行_分析,重点是确… _Java内存_区域与_内存溢出_异常_ITPUB博客 2018年9月28日 - 前言 本文是对«深入理解_Java_虚拟机»第二章以及其他博客的阅读总结 重点是需要去理解各区域存储的是什么, 以此从底层理解对象的创建与引用等过程; 同… _Java_虚拟机JVM:有哪些_内存_监视手段及各区域_内存溢出_解决?-天天快报 2018年4月7日 - 3.本地方法栈 作用:与虚拟机栈_唯一的不同是虚拟机_栈_执行的是_java_方法,而本地方法_栈_执行的是本地的C/C++方法 _内存溢出:StackOverflowError和OutOfMemoryError 溢出… _内存溢出_详解-_Java_文档类资源-CSDN下载 2007年11月23日 - 内存溢出详解参见安全中国更多下载资源、学习资料请访问CSDN下载频道…. Java 把内存划分成两种:一种是栈内存,另一种…用于本机_内存溢出分析_工具(原… 一次_堆内存溢出_问题_分析_——虚拟机优化 技术新闻_记录那些我们一… 2019年5月30日 - 器应用是单独部署的,几乎没有人访问),偶然间看到命令窗口报异常,java.lang.OutOfMemoryError:heap space,还包括一大堆的其他错误——后面发现其他错误… _Java堆内存溢出_模拟-布布扣-bubuko.com 2018年7月26日 - 关于_Java内存_区域的分配,可以查看Java运行时数据区域一篇文章。 _Java堆_是虚拟机_内存_管理中最大的一块区域,该区域是线程共享的,某Java进程中所有的线程… Java内存溢出_与_栈溢出 | IT瘾 2015年1月23日 - java -Xms10M -Xmx10M -XX:-UseGCOverheadLimit OOMTest 2、内存溢出 _内存溢出_是指当我们新建一个实力对象时,实例对象所需占用的内存空间大于_堆_的可用… Java_常见_内存溢出_异常_分析 - 编程语言 - ITeye资讯 2015年1月19日 - _Java_虚拟机规范规定JVM的内存分为了好几块,比如堆,栈,程序计数器,方法区等,而Hotspot jvm的实现中,将_堆内存_分为了三部分,新生代,老年代,持久带,其中持… 任务执行中报_栈内存溢出_导致任务执行失败_MapReduce服务 MRS_故障… 2019年12月23日 - Hive执行查询操作时报错Error running child : java.lang.StackOverflowError,具体报错信息如下:java.lang.StackOverflowError这是_内存溢出_错误的一种… 关于_栈内存溢出_的问题,有大神来看看吗?-CSDN论坛 2017年12月31日 - 所以会导致栈溢出_。 1 2017-12-31 08:19:53 只看TA 引用 举报 #2 得分 0 什么情况下会发生_栈内存溢出 java_中的栈一般存储的是栈帧。所以_栈内存溢出… …se基础强化-JVM_内存结构 07__栈_帧过多导致_栈内存溢出…_爱奇艺 2020年1月8日 - _java_se基础强化-JVM内存结构 07_栈帧过多导致_栈内存溢出_是教育类高清视频,于2020-01-08上映,视频画面清晰,播放流畅,内容质量高。视频主要内容:主页获… _Java内存_管理与_内存溢出_异常_Linux编程_Linux公社-Linux系统门户… 2017年10月18日 - 在_Java_中,程序员无需考虑_内存_的控制和维护,而是交由JVM自动管理,这样就不容易出现_内存_泄漏和_溢出_的问题。然而,一旦出现_内存_泄 深入理解java_虚拟机-_Java内存_区域与_内存溢出_异常丶一个站在_Java… 2019年3月23日 - Java堆溢出 产生原因: java堆_用于存储对象实例,只要不断地创建对象,并且保证GC …先通过_内存_映像_分析_工具(EMA)对Dump出来的堆快照进行_分析,重点是确… java内存溢出_示例(_堆溢出_、_栈溢出)__java__脚本之家 2014年4月29日 - 这篇文章主要介绍了java内存溢出_示例(_堆溢出_、_栈溢出),需要的朋友可以参考下… 这篇文章主要介绍了java内存溢出_示例(_堆溢出_、_栈溢出),需要的朋友可以… java内存溢出分析 - 云+社区 - 腾讯云 Java_常见_内存溢出_异常_分析 栈溢出(stackoverflowerror)栈溢出_抛出_java.lang.stackoverflowerror错误,出现此种情况是因为方法运行的时候栈的深度超过了虚拟机容许的最大深… _java内存溢出_解决方案 - 豆丁网 2015年11月19日 - JAVA内存溢出 解决方案 内存溢出_类型1.1. _java.lang.OutOfMemoryError: PermGen space JVM 管理两种类型的内存,堆和非_堆_。_堆_是给开发人员用的上面说的… java 导出_堆内存溢出__新网移动 2018年6月10日 - java 导出堆内存溢出_专题详细内容由工具聚合而成,希望能给您带来帮助,帮您了解_java 导出_堆内存溢出_相关内容细节 面试题:JVM_内存溢出的解决方法__java 2018年12月21日 - 对于_java_程序员来说,在虚拟机自动内存管理机制的帮助下,不需要自己实现释放内存,不容易出现内存泄漏和_内存溢出_的问题,由虚拟机管理内存这一切看起来非… 中软国际:深度解析_Java堆内存溢出_的本质 2018年4月3日 - 下面分析_如何使用一个_堆分析_工具来_分析堆_转储。 使用MAT 进行_堆分析 …_Java堆内存溢出_的本质这篇写的还是不够完全的,关注中软国际官网获取更多干货。… 【赵强老师】如何_分析Java_的_内存溢出_问题_哔哩哔哩 (゜-゜)つロ… 2019年5月30日 - 【赵强老师】如何_分析Java_的_内存溢出_问题科技演讲·…011.引用的本质__栈内存_和_堆内存__内存示意图【高淇讲解… JSTACK 内存溢出分析 2015年11月9日 - jstack用于打印出给定的java进程ID或core file或远程调试服务的_Java堆栈_信息,如果…从而找到了_内存溢出_点,是一次往内存里读取了一千万多条数据,,额的… 程序员遇到_java内存溢出_的问题应该如何解决_运城达内计算机编程… 2020年1月19日 - _java_编程开发语言是目前使用范围非常广泛的一种编程开发语言,而今天我们就一起来了解一下,当程序员遇到_java内存溢出_的问题应该如何解决。 java内存_的_分析___java内存分析___java内存溢出分析 - 云+社区 - 腾讯云 一个堆转储文件这里使用方式一来获得java_中outofmemoryerror(_内存溢出_的三种情况…_java_运行原理及_内存分析_一、_java_运行原理? 二、_java内存分析?… _Java_中数组的… Java_虚拟机_内存溢出 | 学步园 2013年6月8日 - Exception in thread “main” java.lang.OutOfMemoryError: Java heap space 同样也是堆内存溢出,不过速度就快了好多好多,因为堆大小被设置为不可扩展… _java内存溢出_的问题如何排查?-CSDN论坛 2010年6月24日 - 1,Java_内存溢出包括:_堆内存溢出_和_栈内存溢出 首先说下:内存溢出和内存泄露 内存溢出:out of memory 是指程序申请内存时没有足够的空间了 内存泄露: me… _Java内存溢出_的详细解决方案_百度文库 评分:4/5 9页 2010年12月21日 - 一、内存溢出_类型 1、_java.lang.OutOfMemoryError: PermGen space JVM管理两种类型的内存,堆和非_堆_。_堆_是给开发人员用的上面说的就是,是在JVM启动时创… Java JVM:内存溢出(栈溢出,堆溢出,持久代溢出以及 nable…_博客园 2016年8月26日 - 堆内存溢出_的时候,虚拟机会抛出_java.lang.OutOfMemoryError:java heap space,出现此种情况的时候,我们需要根据内存溢出的时候产生的dump文件来具体分… java 内存溢出,但是监控到_java_的_堆_并没有增长,只是window任务管理… 2009年4月21日 - java内存溢出_。经过监控发现,_java_的_堆_并没有增长,只是window任务管理器中_java_进程的内存一直在增长,直到_内存溢出 请问各位大虾遇到过这种情况没有,谢… _java栈内存溢出_怎么产生_百度知道 2016年11月14日 - 回答：堆(heap),主要用来存放类的对象实例信息(包括new操作实例化的对象和定义的数组)。 _堆_分为Old Space(又名,Tenured Generation)和Young Space。 O…","link":"/2020/04/05/%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97Java%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/"},{"title":"8.深入Java系列java path classpath作用","text":"_java_中_path_和_CLASSPATH_的配置和意义解析_eclipse_yin的…_CSDN博客 2016年5月18日 - 3. path_与_CLASSPATH_各自的_作用_和之间的区别: _path_的_作用:_path_是系统用来指定可执行文件的完整路径,即使不在_path_中设置JDK的路径也可执行_Java_文件,但必… _java_中_path_和_classpath_的_作用_以及区别:_weixin_4475025…_CSDN博客 2019年3月10日 - PATH_的主要_作用:_PATH_环境变量,_作用_是指定命令搜索路径,在命令行下面执行命令如_java_c、ja 浅析_JAVA__HOME,CLASSPATH_和_PATH_的_作用 - mdong - 博客园 2016年11月3日 - 2,设置CLASSPATH: 为了找到执行目标,_java_不同于linux上的可执行文件,linux的可执行文件提前都编译链接好了,最终是一个打包好的文件。_java_有一堆可执行… Java_中的环境变量_path 与 classpath 有何作用?-CSDN论坛 2010年4月28日 - 2. _CLASSPATH_环境变量。_作用_是指定类搜索路径,要使用已经编写好的类,前提当然是…3. _JAVA__HOME环境变量。它指向jdk的安装目录,Eclipse/NetBeans/Tomc… 理解java_环境变量的意义,_Path _JAVA__HOME ,_Classpath_的_作用_分别是… 1._Path_环境变量 _作用_是指定【命令】搜索路径;设置_Path_环境变量之后就可以在任何目录下执行_java_c/_java_等工具命令了。 2._JAVA__HOME 【1】为了方便引用… 在_Java_程序设计中,设定环境变量_path_和_classpath_的_作用_分别是什么… 3条回答:【推荐答案】_path_和_classpath_的_作用_分别是:1、_PATH_环境变量。_作用_是指定命令搜索路径,在i命令行下面执行命令如_java_c编译_java_程序时,它会到_PATH_变量所指定… 简述_Java_中_path_及_classpath_的_作用_。_考试资料网 2018年12月21日 - 简述Java_中_path_及_classpath_的_作用_。 参考答案 _P.ath:是操作系统的环境属性,指的是可以执行命令的程序路径。C.LASSPATH:是所有*.class文件… 查看详… 浅析_JAVA__HOME,_CLASSPATH_和_PATH_的_作用___java__脚本之家 2013年7月22日 - 以下是对_JAVA__HOME,_CLASSPATH_和_PATH_的_作用_进行了详细的分析介绍,需要的朋友可以过来参考下 Java_开发环境配置之_Path_和_classpath-百度经验 2014年7月25日 - 在进行Java_环境配置时,都会遇到_Path_和_classpath_的配置,为什么要这两个系统环境变量,以及如何配置呢?特作以下总结。 1、_Path_的_作用: _Path_是一个十分重… JAVA_中设置_CLASSPATH PATH _JAVA__HOME的_作用__百度文库 评分:4.5/5 1页 2016年12月5日 - JAVA_中设置_CLASSPATH PATH JAVA__HOME的_作用__电子/电路_工程科技_专业资料。_path 环境变量的作用–帮助系统操作 java 用 _java_c 将源码编译成.class 文… path,classpath,_java__home设置_作用_和目的-_Java_文档类资源-CSDN下载 2012年2月26日 - 很多初学者对于java_路径问题存在很大的不理解。本文可以有你想要的解答 立即下载 _path classpath _java__home 上传时间: 2012-02-26 资源大小: 24KB J… _java_建立环境变量中_classpath_最前面的点有什么_作用_。? - 知乎 2017年3月13日 - _java_建立环境变量中_classpath_最前面的点有什么_作用_。? 我看到有说是当前目录,我…可是,现在配置环境变量不都只需要_JAVA__HOME和_PATH_就足够了吗? 还要… 浅谈_Java_中_path_、_classpath_环境变量的配置问题-云飞墨舞-51CTO博客 2014年12月23日 - 当我们执行java_命令时,若没有配置_classpath_环境变量,则_java_虚拟机会在当前目录下查找class文件(即_Java_类),若当前目录下没有,则会出错;若我们配置了_cla… 你真的知道_path_和_classpath_的区别吗? 2016年11月29日 - 此处的OS是Windows_path_有什么用:木用神马用,就是省点事,少敲几个字符。&amp;nbsp…既然是新兄弟,作用_也相似吧?是的!_classpath,就是告诉java.exe在哪些目录查找clas… 环境变量classpath 的_作用_是什么?-黑马程序员技术交流社区 2015年7月7日 - JAVA_HOME _PATH,CLASSPATH 在配置环境变量时又分别有什么区别,起什么_作用_呢?ps:之前安装jdk是都是按照网上教程装,可从没想 … _JAVA__HOME,CLASSPATH_和_PATH作用 | 學步園 2013年5月30日 - 設置從當前所在目錄查找(java_1.5後默認):set _classpath=. 3,設置PATH:(必須設置) 道理很簡單, 你想在任何時候都使用%_JAVA__HOME%\\bin… path,_classpath_变量设置详解 - 江南听雨 - ITeye博客 2019年5月12日 - 为什么要设置JAVA__HOME&amp;Path&amp;CLASSPATH&amp;CATALINA_HOME 首先得介绍下面几个参数的_作用: current directory(当前目录): 当前在用的目录就是当前目录。比… 简述path_和_classpath_环境变量的_作用 - path-classpath - ITkeyowrd 2016年4月14日 - 推荐:java_设置_classpath,path,_java__home环境变量 首先介绍一下环境变量的设置方法: (这里以jdk1.6来安装,其他版本一样) 在把jdk安装到计算机中之后,我… 简述path_和_classpath_环境变量的_作用 - path-classpath - ITkeyowrd 2016年4月14日 - 推荐:java_设置_classpath,path,_java__home环境变量 首先介绍一下环境变量的设置方法: (这里以jdk1.6来安装,其他版本一样) 在把jdk安装到计算机中之后,我… _Java_中_JAVA__HOME, PATH,_CLASSPATH_的_作用_和配置值。_hai…_CSDN博客 2019年3月23日 - 如图,点击新建之后,上面是变量名,如path,classpath,_java__home。下面是变量的值。 _JAVA__HOME 的值是JDK的安装目录,C:\\Program Files_Java_\\jdk1.8.0_92… _java_环境配置_classpath_和_path_变量的_作用_及设置方法 - 锟…_博客园 2014年4月26日 - java_环境配置_classpath_和_path_变量的_作用_及设置方法 1、_path:指定cmd中命令执行文件所在的路径。比如java_c、_java_两个可执行文件在jdk的bin目录下,如果_p… _java_中的环境变量_path_和_classpath_的_作用___Java__菜到怀疑…_CSDN博客 2018年2月9日 - 配置JAVA_环境变量中_CLASSPATH_变量的_作用 阅读数 2万+ 在了解_CLASSPATH_变量之前,我们要先设置_JAVA__HOME和_path_这两个环境变量,让_JAVA_环境可以成功地运… _java_的_classpath_和_path_理解 - lz3018 - 博客园 2016年1月21日 - 因为在eclipse中添加了依赖的jar包之后,eclipse会自动生成一个classpath_文件。 2)_path_的_作用_就是配置jdk的bin目录,这个目录下包含了一些命令,例如_java… 简述_path_与_classpath_的区别及其意义 - weixin_40171603的博客… 2018年7月31日 - 本机是win10打开环境配置看看存在_CLASSPATH_和_Path_两个东西_path_是什么东西比如我们打开cmd输入一个命令_java_然后系统就会去找这个名字叫_java_可执行文件… 配置_JAVA_环境变量中_CLASSPATH_变量的_作用__Czuaphe的博客-CSDN博客 2017年7月8日 - 在了解_CLASSPATH_变量之前,我们要先设置_JAVA__HOME和path_这两个环境变量,让_JAVA… 在了解_CLASSPATH_变量之前,我们要先设置_JAVA__HOME和_path_这两个环境变量,让_JAVA_环境… 【细说Java_】_path_和_classpath_的_作用 - DarkHorse_pxf - 博客园 2015年3月26日 - 【细说Java_】_path_和_classpath_的_作用 path:java_c.exe和_java.exe等可执行文件存放路径,通过_path_变量让系统寻找该路径的可执行文件,然后对_Java_代码进行编… 配置JDK环境变量配置及path_和_classpath_的_作用 - owens - 博客园 2014年7月13日 - 说明Java_环境变量配置出错了。 2、_path_和_classpath_的_作用 运行路径_path_变量记录的是各个程序所在的路径,系统根据这个变量的值来查找运行程序(各种命… java_中_path_和_classpath - 沧海一滴 - 博客园 2014年8月3日 - Path 路径,是java_编译时需要调用的程序(如_java,_java_c等)所在的地方;_CLASSPATH_的_作用_是指定查找类的路径:当使用_java_命令执行一个类(类中的main方法)时,… _java_的_classpath_的_作用__final dream-CSDN博客 2017年3月27日 - classpath_不需要配置 _classpath_的主要_作用 设置_Classpath_的目的,在于告诉J… 在了解_CLASSPATH_变量之前,我们要先设置_JAVA__HOME和_path_这两个环境变量,… _Java_环境配置的_Path_、_CLASSPATH_、_JAVA__HOME的_作用__衍陶…_CSDN博客 2019年6月5日 - _Java_需要配置_path_、_classpath_、_JAVA__HOME等多个环境变量,初学者可以按照教程一步一步配置,但是因为不明白这些变量的具体含义,所以过段时间又忘记怎样配置,反复查询资料… _java_中_path_和_CLASSPATH_的配置和意义解析 - 向上的蜗牛 - 博客园 2018年7月10日 - path_与_CLASSPATH_各自的_作用_和之间的区别: _path_的_作用:_path_是系统用来指定可执行文件的完整路径,即使不在_path_中设置JDK的路径也可执行_Java_文件,但必须… _classpath_、_path_、_JAVA__HOME的_作用_及_JAVA_环境变量配置…_博客园 2010年9月8日 - 上述只有红色部分;C:/Program Files/Java/jdk1.6.0_21/bin是_java_的_PATH_变量,注意变量之间需要用”;”隔开。 2. _CLASSPATH_环境变量。_作用_是指定类搜索路… 【转】java 环境变量:_path_与_classpath_区别 - Xavier-Xu - 博客园 2018年10月29日 - path_指示_java_命令的路径,像_java_c、_java_、javaw等; _classpath_是_java_c编译器的一个环境变量,它的_作用_与import、package关键字有关,当你写下improt _java… JDK 安装时设置_PATH_和_CLASSPATH_的_作用___java_吧_百度贴吧 我们大多数java_初学者朋友,可能只是知道要配置环境变量 ,但是却不了解设置_PATH_和_CLASSPATH_的_作用,下面就简单介绍一下 () 916017127 淼淼水 7 1、_PATH_环境变量… _java_中_classpath_路径 - 走在命运的左岸 - ITeye博客 2015年8月12日 - 问题: 1.服务化程序启动程序,start.java,利用IoC容器机制加载,设计_classpath_路径下的配置文件,_classpath_具体指什么路径? 2.开发过程中,在main与test包… 怎样配置java_环境变量_path_和_classpath_及其_作用 - 豆丁网 2017年8月13日 - 怎样配置j‎ava 环境‎ 变量pat h_和cla‎sspat‎ h及其_作用_‎ _Path=C:_java_\\jdk8\\bin;C:_java_\\jdk8\\jre\\bin; Class_‎_path=.;C:_java_\\jdk8... java_坏境变量中的_java_home_pathclasspath_的设置与_作用-金锄头文库 2019年2月15日 - _JAVA_坏境变量中的 _JAVA__HOME,PATH,CLASSPATH_的设置与_作用 从所周知,使用_Java_语言进行软件开发,一定需要使用到SUN公司的Jdk,那么安装Jdk和设置相关的系… 环境变量PATH, CLASSPATH_的_作用,以及它们的设置方法_360问答 2016年10月24日 - 我们如果把“D:\\develop_Java_\\jdk1.7.0_72\\bin”路径保存到_PATH_变量中,那么在我们使用_java_c或_java_时,Windows系统就会自动到“D:\\develop_Java_\\jdk1.7… 怎样配置java_环境变量_path_和_classpath_及其_作用.docx_人人文库网 2019年3月12日 - 怎样配置java_环境变量_path_和_classpath_及其_作用 Path_C_java_\\jdk8\\bin;C_java_\\jdk8\\jre\\bin; _Classpath.;C_java_\\jdk8\\lib;C_java_\\jdk8\\jre\\lib;C_java_\\j… _java_中_Path_和_ClassPath_的简单比较__Java_ 2019年1月24日 - 1、path_变量用于设置所有_Java_软件工具的路径,定位JDK二进制文件,如_java_c.exe,_java.exe,_java_doc.exe等。_classpath_变量用于设置_java_类的路径,用于定位和… _classpath_和jar - 廖雪峰的官方网站 在Java_中,我们经常听到_classpath_这个东西。网上有很多关于“如何设置_classpath_”的文章,但大部分设置都不靠谱。 到底什么是_classpath? _classpath_是JVM用到的一个环境… _Java_环境配置与设置_JAVA__HOME,CLASSPATH,_PATH_的目的 - 道客巴巴 2012年5月18日 - Java 环境配置与设置 _JAVA__HOME,CLASSPATH,PATH 的目的钵拔 酞民眉绸洛削质搽椒枝波迹 倒砚釉够桶河哮难逼搓逃绽 虫秋贷儡纤痰疗嘱眯缝堆扒退稗钟假夹… 环境变量_path_和_classpath_的_作用_是什么?求指教-CSDN论坛 2015年5月27日 - 2.classpath_环境变量的_作用–告诉java_虚拟机所有的可执行文件.class都在哪 它的…jdk1.6.0_22.如果设置了_java__home,那么_path_环境变量可以配置为“%_ja… Java-_ClassPath作用_及配置-百度经验 2019年2月2日 - Java-_ClassPath作用_及配置,配置Cla_Path_环境变量,可以使claath目录中的.cla文件可以在任意目录下运行 Java_中JDK为何要配_Path_和_ClassPath? - 简书 然后JDK中的Java_命令运行此x._class_文件,_java_代码就可以被执行。 2.为什么要配置_Path? 平时使用cmd运行JDK中的命令时,只能在JDK的安装目录下运行如 _java_c和_java_命令… _Java_中设置_classpath_、_path_、_JAVA__HOME的作用? 2020年3月12日 - CLASSPATH_的_作用_是指定类搜索路径,要使用已经编写好的类,前提当然是能够找到它们…配置_Java_环境变量的时候我们不再需要配置_classpath,只需要配置_Java__Home以及path… JAVA_中_path_和_classpath(_Java_环境变量的配置)- 道客巴巴 java applications, we need to set up twoenvironment variables, one path and one classpath. set up the path variable sothat we can run java …","link":"/2020/04/03/%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97java-path-classpath%E4%BD%9C%E7%94%A8/"},{"title":"9.深入Java系列java &amp; &amp;&amp;区别","text":"Java_中_&amp;&amp;和&amp;_的_区别 - Cherishforchen - 博客园 2019年5月5日 - Java_中_&amp;&amp;_和&amp;的_区别 _Java_中_&amp;&amp;_和&amp;都是表示与的逻辑运算符,都表示逻辑运输符and,当两边的表达式都为true的时候,整个运算结果才为true,否则为false。 _&amp;&amp;_的… _Java_中_&amp;和&amp;&amp;_的_区别__u014683368的博客-CSDN博客 2018年7月19日 - java_中&amp;和&amp;&amp;的_区别? 阅读数 420 &amp;&amp;:短路逻辑与,当_&amp;&amp;_两边的表达式结果都为true时整体才为true,并且有短路的作用即当第一个表达式结果为f… Java__&amp;和&amp;&amp;_的_区别__两颗葡萄有多甜美-CSDN博客 2019年10月26日 - &amp;逻辑运算符,当其两边为Boolean类型且同为true时,结果为true。位运算符,同为0… &amp;与&amp;&amp;的_区别java_中&amp;和&amp;&amp;_的_区别,&amp;和_&amp;&amp;_虽然都是逻辑运算符,都是判断两边为真,… Java | Oracle 现在就开始使用 Java… Java 与您, 立即下载免费Java 下载 » 什么是 Java? » 我有Java 吗? » 是否需要帮助? 所有Java 下载 … Java_中,_&amp;&amp;与&amp;,||与|的区别 , == 比较的是什么? 2018年11月26日 - _java_的逻辑运算符: 1 . _&amp;&amp;和&amp;都是表示与,_区别_是&amp;&amp;_只要有一个条件不一样就是不满足,如果第一个条件就是不满足就不判断后面的条件。而&amp;要对所有… java_中_&amp;&amp;和&amp;_的_区别 - 以苦做舟 - 博客园 2019年3月15日 - 今天遇到_&amp;&amp;和&amp;的_区别_这个问题,在这里做个记录。&amp;&amp;_和&amp;都是用于“与”运算,不…_java_刚产生的初衷是嵌入计算机机顶盒内,需要用于直接操作硬件,设置硬件… java_中_&amp;和&amp;&amp;_的_区别-百度经验 2017年4月20日 - java_中&amp;和_&amp;&amp;_的_区别,java_中am和amam的_区别,am和amam虽然都是逻辑运算符,都是判断两边为真,则语句成立,但是在运行的时候,还是有_差别_的,下面举例来说明。 java_中_&amp;和&amp;&amp;_的_区别(|和|同理) 2019年11月11日 - 在java_的基础面试题中肯定有这个问题: &amp;和_&amp;&amp;_的_区别? 这个问题很好回答,核心思想就是一个不短路一个短路的问题。 首先说下&amp;, 1、它可以表示二进制中的… 菜鸟,java_中|| 和 _&amp;&amp; 的_区别_是什么?-CSDN论坛 2016年11月27日 - java_中&amp;与_&amp;&amp;_和|与||的_区别 _&amp;_amp;amp;和|属于位运算符 不管前面的条件是否正确,后面都执行&amp; 如果相对应位都是1,则结果为1,否则为0 | 如果相对应位都是0… _java_中_&amp;与&amp;&amp;_的_区别___java__脚本之家 2017年3月3日 - 本文主要介绍了java_中&amp;与_&amp;&amp;_的_区别,具有很好的参考价值。下面跟着小编一起来看下吧… 本文主要介绍了java_中&amp;与_&amp;&amp;_的_区别,具有很好的参考价值。下面跟着… _java_中_&amp;和&amp;&amp;_的_区别_和联系 - 云+社区 - 腾讯云 2018年9月13日 - 我想很多人在学习java_的时候,或者其他语言(如:C#,.Net等)都会遇到 &amp;和_&amp;&amp; 然而,如果你没有真正的理解他们的意思,这会给你思路上面带来很大的麻烦 在这… _Java_开发运算符_&amp;和&amp;&amp;_的_区别_是什么?-_Java_资讯-博学谷 2019年5月23日 - _Java_开发运算符&amp;和_&amp;&amp;的_区别_是什么?&amp;和&amp;&amp;_都可以用作逻辑与的运算符,表示逻辑与(and),当运算符两边的表达式的结果都为 true 时,整个运算结果才… java &amp;与&amp;&amp; |与||的区别 - 简书 参考:http://www.cnblogs.com/libertycode/articles/5059169.html… java &amp;与&amp;&amp; |与||的区别 参考:http://www.cnblogs.com/libertycode/articles/5059169.html … _java_中_&amp;&amp;和&amp;_的_区别__百度文库 2018年6月29日 - Java 中&amp;和&amp;&amp;_的_区别_在 _java 语言程序中,&amp;和&amp;&amp;_都是逻辑运算符,都是判断两边同时真则 为真,否则为假。平时我们用的时候不会注意这二者的_区别,以至于 会… _Java_中符号”_&amp;&amp;”和”&amp;_” 以及”||”和”|”的_区别__stu…_新浪博客 2006年5月18日 - 在_java_中”_&amp;&amp;”和”&amp;”都是逻辑运算符,两者的_区别_是前者在执行过程中会出现“短路”的现象。即若符号”&amp;&amp;_”前的表达式如果为假,那么后面的那个表达式… Java_中_&amp;和&amp;&amp;_有什么_区别-_java_类库-PHP中文网 2019年4月17日 - _Java_中&amp;和_&amp;&amp;的_区别_有:&amp;&amp;_运算中当第一个表达式为假时则后面一个表达式不执行;而&amp;运算不管第一个表达式是否为真都会执行后一个表达式 _Java_中_&amp;与&amp;&amp;_、|与||的_区别_与联系 2019年10月21日 - Java_中逻辑操作符有_&amp;&amp;(与)、||(或)、!(非),按位操作符有&amp;(与)、|(或)、~(非)、^(异或)。它们长得很像,不过它们有很大的区别,逻辑操作符主要面向的是… java_里的_&amp;&amp;,||和!()什么意思,还有==和=又什么区别 java_里的_&amp;&amp;,||和!()什么意思,还有==和=又什么区别_德玛西亚99 浏览461回答1 1回答 MMMHUHU _&amp;&amp;: 是逻辑运算符,代表与(就是并且),条件都成立,返回值是 true… java_里的_&amp;&amp;,||和!()什么意思,还有==和=又什么区别 java_里的_&amp;&amp;,||和!()什么意思,还有==和=又什么区别_德玛西亚99 浏览461回答1 1回答 MMMHUHU _&amp;&amp;: 是逻辑运算符,代表与(就是并且),条件都成立,返回值是 true… JAVA_中_&amp;&amp;和&amp;_、||和|的_区别? - ShyTan的博客 - CSDN博客 2018年8月12日 - 问题一:JAVA_中&amp;&amp;和&amp;、||和|(短路与和逻辑与、短路或和逻辑或)的_区别?首先名称是不同的_&amp;&amp;_逻辑与 ||逻辑或 它们都是逻辑运算符&amp; 按位与 | … _Java_中 _&amp;与&amp;&amp;_、|与|| 的_区别__ARES的博客-CSDN博客 2019年6月14日 - 首先&amp; 和 | 是位运算符, 而 &amp;&amp; 和 || 是逻辑运算符先介绍与运算… |、||、&amp;、&amp;&amp;是_java_的逻辑运算符,分别表示|(或),||(短路或),&amp;(与),&amp;&amp;(短路与)… _java_中_&amp;和&amp;&amp;_的_区别_和联系 - Hongten - 博客园 2013年11月2日 - java_中&amp;和_&amp;&amp;的_区别_和联系 我想很多人在学习_java_的时候,或者其他语言(如:C#,.Net等)都会遇到 &amp;和&amp;&amp; 然而,如果你没有真正的理解他们的意思,这会给你思路… java_中_&amp;与&amp;&amp;_的_区别 - 奔跑滴蜗牛 - 博客园 2017年3月3日 - 在java_中&amp;和_&amp;&amp;都属于逻辑运算符,都是判断两边条件为真时为真,否则则为假…它们之间的_区别_在与:&amp;&amp;:当前后两个判断条件前一个为假时,后面不执行,得出最… _java_中_&amp;与&amp;&amp;_和|与||的_区别__qq_40595055的博客-CSDN博客 2018年9月29日 - Java_中,&amp;&amp;与&amp;,||与|的_区别 阅读数 17万+ 在java_的逻辑运算符中,有这么四类:_&amp;&amp;(短路与),&amp;,|,||(短路或)。&amp;&amp;和&amp;都是表示于,_区别_是&amp;&amp;… java_中_&amp;、&amp;&amp;_、|、||_区别 - 下一站_jn - 博客园 2017年12月14日 - java_中&amp;、_&amp;&amp;_、|、||_区别 一、与操作和或操作的区别 (1)在_Java_程序中,使用与操作,要求所有表达式的判断结果都是TRUE,才为真,若有一个为FALSE,那么最终… java_中_&amp;和&amp;&amp;_的_区别,|和||的_区别__myzksky的专栏-CSDN博客 2018年6月9日 - 在java_的逻辑运算符中:&amp;&amp;(短路并),&amp;(并)是… 在_java_的逻辑运算符中:_&amp;&amp;(短路并),&amp;(并)是有_区别的 _&amp;&amp;_和&amp;都是表示并且,_区别_是&amp;&amp;_只要第一个… _java_中_&amp;与&amp;&amp;_的_区别__周厉的技术人生-CSDN博客 2017年3月8日 - 在java_的逻辑运算符中,有这么四类:_&amp;&amp;(短路与),&amp;,|,||(短路或)。_&amp;&amp;和&amp;都是表示于,_区别_是&amp;&amp;_只要满足第一个条件,后面条件就不再判断。而&amp;要对所有的条件… Java_中_&amp;&amp;和&amp;_的_区别 - 夏日的微笑 - 博客园 2016年11月2日 - _Java_中_&amp;&amp;和&amp;都是表示与的逻辑运算符,都表示逻辑运输符and,当两边的表达式都为true的时候,整个运算结果才为true,否则为false。&amp;&amp;_的短路功能,当第一个表… Java_中_&amp;&amp;和&amp;_的_区别 - Cherishforchen - 博客园 2019年5月5日 - Java_中_&amp;&amp;_和&amp;的_区别 _Java_中_&amp;&amp;_和&amp;都是表示与的逻辑运算符,都表示逻辑运输符and,当两边的表达式都为true的时候,整个运算结果才为true,否则为false。 _&amp;&amp;_的… Java_中_&amp;&amp;和&amp;_的_区别 - 夏日的微笑 - 博客园 2016年11月2日 - _Java_中_&amp;&amp;和&amp;都是表示与的逻辑运算符,都表示逻辑运输符and,当两边的表达式都为true的时候,整个运算结果才为true,否则为false。&amp;&amp;_的短路功能,当第一个表… java__详解_java_中&amp;和&amp;&amp;的区别,&amp;&amp;(短路与)、&amp;_、||(短路或)、|… 详解java_中&amp;和_&amp;&amp;_的_区别,&amp;&amp;(短路与)、&amp;、||(短路或)、|,这几种运算符在_Java_程序开发中经常用到,下面小编主要给大家介绍下&amp;和_&amp;&amp;的_区别_。其中&amp;&amp;_与&amp;都表示逻辑… java_中_&amp;&amp;和&amp;_的_区别-_Java_文档类资源-CSDN下载 2014年8月28日 - java_中的&amp;&amp;与&amp;两者的_区别更多下载资源、学习资料请访问CSDN下载频道…. _java_中的&amp;&amp;_与&amp;两者的_区别 &amp;&amp;和&amp;区别 所需积分/C币:9 上传时间:2… _Java_中_&amp;与&amp;&amp;_的_区别_与联系详解 - yoodb - 素文宅博客 2016年9月26日 - 我想每个人在面试的时候都会遇到问运算符的问题吧,如果你没有真正的理解他们的意思,可以参考一下下面的代码与解答,举例&amp;与_&amp;&amp;_的_区别_于联系,本人通过代… Java_语言中_&amp;&amp;与&amp; ||与|的_区别_是什么_易贤网 2017年4月8日 - 易贤网手机网站地址:_Java_语言中_&amp;&amp;_与&amp; ||与|的_区别_是什么 由于各方面情况的不断调整与变化,易贤网提供的所有考试信息和咨询回复仅供参考,敬请考生以权… Java 运算符 &amp;与&amp;&amp; &lt;&lt; &gt;&gt; &gt;&gt;&gt;区别 -年少的风-51CTO博客 2013年9月2日 - &amp;和_&amp;&amp;_都可以用作逻辑与的运算符,表示逻辑与(and),当运算符两边的表达式的结果都为true时,整个运算结果才为true,否则,只要有一方为false,则结果为false… _java_中_&amp;&amp;_什么意思 2010年6月10日 - _&amp;&amp;在_Java_中是逻辑操作符,也叫条件操作符 使用方法是 x&amp;&amp;y 功能描述: “条件与”:x和y均为true,取值是true,否则取值是false &amp;和&amp;&amp;_都需要两个操作数的值… Java_中,_&amp;&amp;, &amp;, |, || 之间的区别 - leiline的个人空间 - OSCHINA 2017年12月15日 - Java EE 3月,跳不动了?&gt;&gt;&gt; 逻辑运算中有两个问题,按位与/或 以及逻辑…_&amp;&amp;和&amp;都是表示与,_区别_是&amp;&amp;_只要第一个条件不满足,后面条件就不再判断(即短路与… Java_中已经有_&amp;&amp;为什么还要用&amp;?||同? - 知乎 2014年12月25日 - 举个例子 true &amp;&amp; true = true; 10101 &amp; 11100 = 10100;(当然这个数字是2进制的不是十进制)。不知道你从这个例子中能不能看出这两个的_区别_。… _Java_逻辑运算符(_&amp;&amp;_、||和!) &amp;&amp; 与 &amp; 区别:如果 a 为 false,则不计算 b(因为不论 b 为何值,结果都为…&lt; _Java_赋值运算符 _Java_关系运算符 &gt; 爱面试的程序媛,一个分享面试经验的公众号… Java_逻辑运算符中_&amp;&amp;与&amp;,||与|的区别 - 动力节点_Java_学院 2019年9月25日 - 今天动力节点java_培训机构小编为大家介绍_Java_逻辑运算符中_&amp;&amp;_与&amp;,||与|的_区别,希望通过此文大家能够掌握Java_逻辑运算符中_&amp;&amp;_与&amp;,||与|的_区别,下面就… 3、说说_&amp;和&amp;&amp;_的_区别_。 · _Java_面试宝典 · 看云 运算,_&amp;&amp;符号主要用于逻辑运算,他们两个最大的_区别_在于,&amp;是用于非短路的,而&amp;&amp;_是用于短路的,短路就是当运算符两边的表达式,第一个表达式为false则不再计算第二个表… 谈谈java_与js中的_&amp;&amp;、&amp; ||、| 2015年1月4日 - js中的逻辑与是_java_中短路与“_&amp;&amp;_”逻辑或是_java_中短路或“||”而_java_中逻辑与或在js中是按位运算的来计算的,而在_java_中则是根据表达式值的类型来判断… Java 逻辑运算符中&amp;&amp;与&amp;,||与|的区别 / 张生荣 2017年5月19日 - Java 逻辑运算符中&amp;&amp;_与&amp;,||与|的_区别 在Java_的逻辑运算符中,有这么四类:_&amp;&amp;(短路与),&amp;,|,||(短路或). _&amp;&amp;和&amp;都是表示与,_区别_是&amp;&amp;_只要第一个条件不满足… _java_中_&amp;&amp;、&amp;_、||、|的_区别_以及优先级_码神岛 2019年7月8日 - 通过这个例子我们可以得出结论: 首先假设&amp;&amp;_和||是平级的,从左到右依次计算:a||c—&gt;true _&amp;&amp; b—&gt;false, 假设||比&amp;&amp;_的优先级高,a||c—&gt;true _&amp;&amp; b—&gt;fal… Java_编写中运算符_&amp;和&amp;&amp;_它俩有什么_区别?_达内_Java_培训机构 2020年2月20日 - &amp;和_&amp;&amp;_都可以用作逻辑与的运算符,表示逻辑与(and),当运算符两边的表达式的结果都为true时,整个运算结果才为true,否则,只要有一方为false,则结果为… Java_面试题:_&amp;和&amp;&amp;_的_区别? - Break易站 2018年3月16日 - _Java_面试题:解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。 _Java_面试题:Math.round(11.5) 等于多少?Math.round(-11.5)等于多少… java_逻辑运算符 | 跟 ||以及 _&amp;跟&amp;&amp;_有什么_区别,它们具体分别在什么… 2016年4月12日 - java_逻辑运算符 | 跟 || 以及 &amp;跟_&amp;&amp;_有什么_区别,它们功能好像是一样的为啥要弄出两个来,它们具体分别在什么时候运用? _java_的 | 跟 || 符号都是表示逻辑…","link":"/2020/04/03/%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97java-%E5%8C%BA%E5%88%AB/"},{"title":"17.深入Java系列java方法区","text":"_java方法区_详解 - dshf_1的博客 - CSDN博客 2019年2月13日 - _方法区_保存在着被加载过的每一个类的信息;这些信息由类加载器在加载类的时候,从类的源文件中抽取出来;static变量信息也保存在_方法区_中;可以看做是将类… _Java方法区_、栈及堆 - 蜗牛 - CSDN博客 2017年11月19日 - 1. 什么是方法区(Method Area)? 《深入理解JVM》书中对方法区(Method Area)描述如下: 方法区(Method Area)与_Java_堆一样,是各个线程共享的内存区域。 2… Java方法区 - wangguoning - 博客园 2016年11月28日 - Java方法区 方法区 在一个jvm实例的内部,类型信息被存储在一个称为方法区的内存逻辑区中。类型信息是由类加载器在类加载时从类文件中提取出来的。类(… Java_内存管理运行时区域之_方法区 2019年9月11日 - 方法区(Method Area)同Java 堆,是各个线程共享的内存区域,用于存储虚拟机已经加载的类信息,常量,静态变量,即时编译器编译后的代码等数据。虽然_Java_虚拟机规范把方法… _Java方法区_和永久代 - 鹏鹏进阶 - 博客园 2018年10月25日 - 在_Java_虚拟机规范中,_方法区_在虚拟机启动的时候创建,虽然_方法区_是堆的逻辑组成部分,但是简单的虚拟机实现可以选择不在_方法区_实现垃圾回收与压缩。这个… 一文捋清_Java_虚拟机内存模型 - 码农登陆 2018年10月14日 - 程序计数器虚拟机栈本地方法栈_Java_堆_方法区_等部分。程序计数器用于存放下一条运行的指令;虚拟机栈和本地方法栈用于存放函数调用堆栈信息;_Java_堆用于存… _java方法区_存的是什么样的 方法区在堆中吗-IT培训网 2018年4月3日 - _Java方法区_存的是什么?方法区在堆中吗?最近一直被方法区里面存着什么东西困扰着,为了解开这个谜题,我查阅了大量资料,总算是解开了心里的那把锁,下面… _Java方法区_和永久代 - 简书 在_Java_虚拟机规范中,_方法区_在虚拟机启动的时候创建,虽然_方法区_是堆的逻辑组成部分,但是简单的虚拟机实现可以选择不在_方法区_实现垃圾回收与压缩。这个版本的虚拟机规范… _java方法区_有什么 - 云+社区 - 腾讯云 _java方法区_和永久代这里只讨论hotspot虚拟机,这也是目前使用的最多的jvm。 sun jdk7 hotspot虚拟机的内存模型如下图所示:? 1、什么是方法区在java虚拟机中,方法… _java方法区__百度文库 2018年10月3日 - java 方法区 java 程序运行时, 数据会分区存放, heap、 stack、 method。 类的对象放在 heap(堆)中,所有的类对象都是通过 new 方法创建,创建后,在 sta… _Java方法区_、堆、栈、本地方法区及新生代、老年代、元空间整合… 预热过程:我们java_c了一个Demo._java,这个时候编译器将java_文件转为Demo.class,…我这就去_方法区_找它去。JVM来到了尚在混沌状态的_方法区,大喊一声ClassTest方法… (4)java方法区 2015年8月16日 - _java方法区_【名词解析】 —&gt;和java堆一样,方法区是一块所有线程共享的内存区域。 —&gt;保存系统的类信息,比如,类的字段,方法,常量池等。 —&gt;方法区的… 关于java_的_方法区,为什么叫方法区,是否与实际用途相悖? - 知乎 2017年1月5日 - 在_java_中,栈中存放的是用来保存方法运行时状态的栈帧,存储了局部变量表,操作数栈等,而_方法区_存… _java方法区_中放什么_新网 2018年6月12日 - _java方法区_中放什么专题详细内容由工具聚合而成,希望能给您带来帮助,帮您了解_java方法区_中放什么相关内容细节 java方法区 - freedomranch - OSCHINA 2012年5月21日 - _java_程序运行时,数据会分区存放,heap、stack、method。 类的对象放在heap(堆)中,所有的类对象都是通过new_方法_创建,创建后,在stack(栈)会创建类对象的… 【java_中堆 _方法区 栈】-博文推荐-CSDN博客 2019年6月9日 - CSDN提供了精准java_中堆 _方法区 栈信息,主要包含: java_中堆 _方法区 栈信等内容,查询最新最全的java_中堆 _方法区 栈信解决方案,就上CSDN热门排行榜频道. Java 内存之_方法区_和运行时常量池 - 漠然的博客 | mritd Blog 方法区_的作用是存储 _Java 类的结构信息,当我们创建对象实例后,对象的类型信息存储在方法堆之中,实例数据存放在堆中;实例数据指的是在 Java 中创建的各种实例对象… _JAVA 方法区_与堆–java7前,java7,java8各不相同 - 算法网 2019年6月20日 - 三种情况: _java_7之前,_方法区_位于永久代(PermGen),永久代和堆相互隔离,永久代的大小在启动JVM时可以设置一个固定值,不可变; _java_7中,存储在永久代的部… 详谈java 堆区、方法区_和栈区 - _java 2019年8月5日 - 下面小编就为大家带来一篇详谈java 堆区、_方法区_和栈区。小编觉得挺不错的,现在就分享给大家,也给大家做个参考。一起跟随小编过来看看吧 \b【JVM】java方法区 - 无信不立 - 博客园 _java方法区_【名词解析】 —&gt;和java堆一样,方法区是一块所有线程共享的内存区域。 —&gt;保存系统的类信息,比如,类的字段,方法,常量池等。 —&gt;方法区的… Java_虚拟机–_方法区(运行时常量池) - DemoTransfer - CSDN博客 2018年7月15日 - 文章引用:深入理解Java_虚拟机一_方法区_描述_方法区(MethodArea)与_Java_堆一样,是各个线程共享的内存区域,它用于存储已经被虚拟机加载的类信息/常量//静态… JAVA方法区 - Double5的博客 - CSDN博客 2018年12月3日 - _方法区_1)_方法区_是线程共享的2)用以储存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等3)_方法区_是堆的一个逻辑部分,但是又称为Non… Java_里的堆(heap)栈(stack)和_方法区(method) - 龙v战 - 博客园 2011年2月25日 - 当JAVA_虚拟机执行test1.printName()_方法_时,_JAVA_虚拟机根据局部变量test1持有的引用,定位到堆区中的Sample实例,再根据Sample实例持有的引用,定位到_方法… _JAVA 方法区_是在堆里面吗 - 诚 - CSDN博客 2019年1月8日 - 三种情况:1、_java_7之前,_方法区_位于永久代(PermGen),永久代和堆相互隔离,永久代的大小在启动JVM时可以设置一个固定值,不可变;2、_java_7中,static变量从永久代移… _java方法区_究竟存储了什么? - qingtiantianqing的博客 - CSDN博客 2016年5月14日 - 首先要说明的是,此文章转载自http://blog.csdn.net/zzhangxiaoyun/article/details/7518917谢谢作者。另外,这里ps一下,Class对象是存放在堆区的,不是… _java方法区_存储了什么?_sunming0129的博客-CSDN博客 2018年3月23日 - 例如,假如你有一个java.lang.Integer的对象引用,可以激活getClass()得到对应的类引用。 通过类对象的引用,你可以在运行中获得相应类存储在_方法区_中的… java方法区 - 付石头的博客 - CSDN博客 2019年4月11日 - 目录_方法区_图例(_方法区_中都保存什么)类型信息类型的常量池(即运行时常量池)字段信息方法信息类变量(即static变量)对类加载器的引用对Class类的引用方… 方法区(关于_java_虚拟机内存的那些事) - young-youth的…_CSDN博客 2018年4月13日 - 《深入理解_java_虚拟机》读书扩展作者:淮左白衣写于2018年4月13日21:26:05目录_方法区_图例(_方法区_中都保存什么)类型信息类型的常量池(即运行时常量池)字… _Java方法区__u012501054的博客-CSDN博客 2018年11月25日 - 方法区 在一个jvm实例的内部,类型信息被存储在一个称为_方法区_的内存逻辑区中。类型信息是由类加载器在 _java方法区_能清理么_新网移动 2018年6月14日 - _java方法区_能清理么专题详细内容由工具聚合而成,希望能给您带来帮助,帮您了解_java方法区_能清理么相关内容细节 关于_方法区_的详细介绍-_java_教程-PHP中文网 2017年6月10日 - 下面小编就为大家带来一篇详谈java 堆区、_方法区_和栈区。小编觉得挺不错的,现在就分享给大家,也给大家做个参考。一起跟随小编过来看看吧堆区:只存放类对象,… 详谈java 堆区、_方法区_和栈区__java__脚本之家 2017年5月20日 - 下面小编就为大家带来一篇详谈java 堆区、_方法区_和栈区。小编觉得挺不错的,现在就分享给大家,也给大家做个参考。一起跟随小编过来看看吧 _java_中堆、栈和_方法区_的理解-CSDN问答 2017年10月18日 - 百度上的答案太多,说的都比较抽象,请假大神们给我举例说明下 我自己的理解: 堆:存放对象、数组 栈:存放基础数据类型的对象和自定义对象的引用(不是对… 怎么让jvm中的_方法区_直接爆满_技术交流_牛客网 2019年3月6日 - 阿里巴巴菜鸟网络社招内推-_java_工程师 全部&gt; 大家都在关注 校招日程表 笔试…_方法区_已经被取消了,在jdk8的时候。 发表于 2019-03-06 14:05:20回复(… jvm的内存原理(_方法区_和常量池)???-CSDN论坛 _java方法区_详解 方法区 保存在着被加载过的每一个类的信息;这些信息由类加载器在加载类的时候,从类的源文件中抽取出来;static变量信息也保存在方法区中; 可以看… java_虚拟机_方法区_内存模型 - _Java 技术驿站-Java 技术驿站 2019年12月10日 - 版权归原创作者所有,任何形式的转载请联系博主:daming_90:Java 技术驿站 » java_虚拟机_方法区_内存模型标签:_javaJava Core_Java_ 内存模型Java 源码… _java_的方法有什么__java方法区_有什么_java方法里有方法 - 云+社区… _java_的_方法_有什么 _Java_是一门面向对象编程语言,不仅吸收了C++语言的各种优点,还摒弃了C++里难以理解的多继承、指针等概念,因此_Java_语言具有功能强大和简单易用两个特… _Java 方法区_中存放哪些东西?JVM 如何控制方法区的大小以及内存… 2019年11月8日 - 通过配置 PermGenspace可以控制方法区_的大小 StackOverflowError 异常:如果线程的方法嵌套调用层次太多(如递归调用),随着 _Java 栈中帧的逐渐增多,最终… _java_中栈、堆、_方法区_的区别是什么?有图解的话就更好了_慕课问答 2016年12月28日 - _java_源代码 经过编译 成 .class 文件时,都在通过 jvm 运行。 栈、堆、_方法区_是内存不同区域, 1、栈 :是放类中的局部变量的; 2、堆:是放对象属性的; 3… 【_Java_】栈区、堆区和_方法区_的解析 - 记录笔记 - SegmentFault 思否 2019年11月11日 - 栈区描述的是_方法_执行的内存模型。每个_方法_在执行时都会创建一个栈帧(存放存储局部变量、操作数栈、动态链接、_方法_出口等) Java_中堆区 | 栈区 | _方法区-布布扣-bubuko.com 2019年6月15日 - 在方法_体内定义的(局部变量)一些基本类型的变量和对象的引用变量都是在_方法_的栈内存中分配的。当在一段_方法_块中定义一个变量时,_Java 就会在栈中为该… _java_类变量的在_方法区_中分配的内存地址存在哪? - ITeye问答 2012年3月8日 - 在装载阶段会在堆区创建一个java.lang.Class的对象指向作为方法区_类对象的入口,testStaticInt 存储在_方法区,它的应用存储在堆区中对应的Class对象中。… _JAVA_里的_方法区_可以理解为类信息表吗?-CSDN论坛 2014年12月15日 - 在《JVM 之(1)运行时数据区》提到,虚拟机栈是描述_Java方法_执行的内存模型:每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操… JVM学习笔记-_方法区_示例与常量池解析 - chunguo.wang - ITeye博客 2013年8月16日 - JVM学习笔记-方法区示例与常量池解析(Method Area Use And Constant Pool Resolution) 博客分类: jvm_java方法区_ As an example of how the Java Virtu… _Java方法区_是什么 - 红黑联盟 _Java方法区_是什么:java里截取字符串的方法有substring和substr,它俩的区别和各自的用法具体是什么 百度贴吧__方法区_ 2017年3月15日 - 静态方法是在类加载时加入到类方法区,非静态方法是在创建实例时加入到对象区的,所以没有创建对象,类加载时是找不到对象方法区_的方法的。… 贴吧:_java… java_堆,栈,_方法区 - 简书 栈区: 每个线程包含一个栈区,栈中只保存_方法_中(不包括对象的成员变量)的基础数据类型和自定义对象的引用(不是对象),对象都存放在堆区中每个栈中的数据(原始… 深入讲解Java_虚拟机系列之_方法区.doc 2017年4月8日 - 深入讲解Java_虚拟机系列之_方法区.doc,深入讲解Java_虚拟机系列之_方法区 作者:张文道 目录 .1介绍 3 2._方法区_结构 3 3._方法区_概念图 4 1.介绍 _方法区_就… 深入讲解Java_虚拟机系列之_方法区-_Java_文档类资源-CSDN下载 2013年1月20日 - 深入讲解Java_虚拟机系列之_方法区 评分 深入讲解Java_虚拟机系列之_方法区 _Java_虚拟机 所需积分/C币:4 上传时间:2013-01-20 资源大小:61KB … _Java_内存区域总结(堆、栈、_方法区_等) | 码农网 2018年12月5日 - 虽然JVM规范把方法区_描述为堆的一个逻辑部分, 但是它却又一个别名叫做 Non-Heap(非堆) , 目的应该是与 _Java 堆区分开来. 方法区 和 永久代(Permanent… _Java_的_方法区_和本地_方法区_有何不同?什么是Native Method?_百度知道 2020年2月1日 - _Java_的_方法区_和本地_方法区_有何不同?什么是Native Method?  我来答 分享 …native method的存在并不会对其他类调用这些本地方法产生任何影响,实际… 【上海校区】细说java_内存区域划分(堆,栈,_方法区)-黑马程序员技术… 2018年10月25日 - _java_虚拟机在执行_java_程序的过程中会把它所管理的内存划分成若干个不同的数据区域。这些区域各有用途,以及创建和销毁的时间。有 … 什么是堆?什么是方法区?JVM内存模型中堆与_方法区_的介绍-_java_教程… 2018年9月15日 - java.lang.OutOfMemoryError: Java heap space 二、方法区(Method Area) 2.1.什么是方法区 方法区,也称非堆(Non-Heap),又是一个被线程共享的内存区域。其中… Java 8 是否没有_方法区_的概念和提法了?-CSDN论坛 2016年8月15日 - 前段时间看一本书,好像说Java 8没有_方法区_的概念和提法了,想详细了解这方面的描述和内存分配,谁了解的或有这方法资料的? 十分感谢 … _JAVA_虚拟机中_方法区_存储哪些内容? 爱问知识人 _JAVA_虚拟机中_方法区_存储哪些内容?:_java_虚拟机_方法区方法区_与传统语言中的编译后代码或是Unix进程中的正文段类似? java-_Java_的内存模型之_方法区_——CSDN问答频道 2015年7月7日 - 这两天看_Java_的内存模型,越看越迷糊,到底_Java_文件里的_方法区_是如何存储的,又是如何管理的呢?","link":"/2020/04/05/%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97java%E6%96%B9%E6%B3%95%E5%8C%BA/"},{"title":"18.深入Java系列java方法区内存溢出分析","text":"关于方法区内存溢出! - 张-晓 - 博客园 2016年3月1日 - 关于方法区内存溢出!方法区与_java_堆一样,是各个线程共享的内存区域,它用于存储已被虚拟机加载的 类信息,常量,静态变量,即时编译器编译后的代码等数据… java 内存溢出(_方法区_溢出)_iteye_171的博客-CSDN博客 2012年7月26日 - package jvm;import java.lang.reflect.Method;import… jvm_内存溢出_JVM管理的几个内存区域分为:方法区:用于存储_JAVA_类信息、常量、静态变量。这个区… _java内存溢出_的解决思路 - kszsa - 博客园 2018年1月16日 - 内存溢出_是指应用系统中存在无法回收的内存或使用的内存过多,最终使得程序运行要…在运行时的内存区域有5个部分,Method Area(_方法区),Java stack(jav… Java_常见的几种_内存溢出_及解决_方法-百度经验 2017年3月26日 - Java_常见的几种_内存溢出_及解决_方法_【情况一】:_java.lang.OutOfMemoryError:_Java_heapspace:这种是_java_堆内存不够,一个原因是真不够(如递归的层数太多等… _java_堆、栈、_方法区内存溢出__zhanghc_kedamaomao的博客-CSDN博客 2016年12月6日 - 1.java_堆_内存溢出 java_堆用于存储对象,只要不断的创建对象,并且保证GC Roots到对象… 1._java_堆_内存溢出 _java_堆用于存储对象,只要不断的创建对象,并且… java 内存溢出 栈溢出的原因与排查方法 - oswebgod…-开源中国社区 2018年2月13日 - 下面从以下几个方面来配合代码实战演示_内存溢出_及如何定位: _Java_堆内存异常 _Java_栈内存异常 _方法区内存_异常 _Java_堆内存异常 /** VM Args: //这两个参… java 内存溢出(_方法区_溢出) - - ITeye博客 2012年7月26日 - import java.lang.reflect.Method; import net.sf.cglib.proxy.Enhancer; import…使用字节码技术,来增加类,jvm保证方法区_可以动态加载这些类到_内… Java 内存_区域与_内存溢出 - 深入理解 Java 虚拟机 - 极客学院Wiki 2018年11月28日 - 另外,该内存区域是唯一一个在 Java 虚拟机规范中么有规定任何 OOM(内存溢出:…_方法区_也是各个线程共享的内存区域,它用于存储已经被虚拟机加载的类信息、常量、… _Java内存_区域与_内存溢出_异常_ITPUB博客 2018年9月28日 - 前言 本文是对«深入理解_Java_虚拟机»第二章以及其他博客的阅读总结 重点是需要去理解各区域存储的是什么, 以此从底层理解对象的创建与引用等过程; 同… _Java内存_区域和_内存溢出_异常(1) - 人生何处不相逢 - ITeye博客 2017年8月4日 - 1.首先java_的运行时存储区域大致分为:_java_堆,虚拟机栈,本地方法栈,_方法区,程序计数器这几个区域,下面对这几块区域的存储信息和可能抛出的异常� … JVM_内存_区域介绍以及_内存溢出_示例 - 简书 2016年11月20日 - 在JVM的管控下,Java_程序员不再需要管理内存的分配与释放,这和在C和C++的世界是完全不一样的。所以,在JVM的帮助下,_Java_程序员很少会关注内存泄露和_内存… Java内存_区域及_内存溢出 - 大骨浓汤 - SegmentFault 思否 2018年5月16日 - 堆溢出 Java_堆用于存储对象实例,只要不断地创建对象,并且保证GC Roots到对象之间…通常为操作系统限制总_内存-最大堆容量(Xmx)-最大_方法区_容量(MaxPer… Java内存_管理运行时区域之_方法区 2019年9月11日 - 方法区(Method Area)同Java 堆,是各个线程共享的_内存_区域,用于存储虚拟机已经加载的类信息,常量,静态变量,即时编译器编译后的代码等数据。虽然_Java_虚拟机规范把方法… JAVA_语言-jvm之虚拟机栈和本地_方法_栈_溢出,_方法区_和运行时常量池… 2019年1月9日 - 本文主要向大家介绍了_JAVA_语言-jvm之虚拟机栈和本地方法栈溢出,_方法区_和运行时常量池溢出,本机直接_内存溢出_讲解,通过具体的内容向大家展示,希望对大家学习_JAVA_语言… JVM之_Java内存_区域及_内存溢出_异常 程序运行时数据区域…_新浪博客 2015年12月29日 - 一、Java_虚拟机在执行_Java_程序的过程中会把它所管理的内存划分为若干个不同的数据…使用永久代来实现_方法区,并不好,因为这样更容易遇到_内存溢出_问题(… _Java内存_区域与_内存溢出_异常 - crawler - ITeye博客 之前根据平时的积累总结了篇博文“Java内存_管理”,都是来自于平时的理解和积累,抽周末休息之余,翻阅了《深入理解_Java_虚拟机》第二章“_Java内存区 … 《JVM笔记》之一:_Java内存_区域与_内存溢出_异常 - 野猪林 - ITeye… 2014年5月7日 - 当方法区_无法满足内存分配需求时,将抛出OutOfMemoryError。 运行时常量池: Runtime…注:出现_Java_堆_内存溢出_时,异常堆栈信息 _java.lang.OutOfMemoryEr… Java 方法区_中存放哪些东西?JVM 如何控制方法区的大小以及_内存… 2019年11月8日 - 内存溢出_解决方法:减少用于程序中 class 的数量。尽量较少的使用静态变量。修改 -XX:MaxPermSize,调大,随着-XX:MaxPermSize 参数值的增大,_Java 方法区… _Java内存_区域与_内存溢出_异常_Linux编程_Linux公社-Linux系统门户… 2016年1月4日 - _方法区_的内存回收目标主要针对常量池的回收和对类型的卸载,当_方法区_无法满足内存…_Java内存_管理与_内存溢出_异常 (10/18/2017 07:42:40) 本文评论 查看… _Java方法区_和运行时常量池_内存溢出_出现的原因,现象,以…_CSDN博客 2019年12月13日 - Java 永久代是非堆_内存_的组成部分,用来存放类名、访问修饰符、常量池、字段描述、方法描述等,因运行时常量池是_方法区_的一部分,所以这里也包含运行时常… _JAVA内存_区域与_内存溢出_异常 - 简单爱_wxg - 博客园 2016年7月1日 - Java_虚拟机在执行_Java_程序的过程中把它所管理的内存划分为若干个不同的数据区域…来实现_方法区,现在看来并不是一个好 主意,因为这样更容易遇到_内存溢出_问题(… jvm 内存溢出 - _方法区_及运行时常量池溢出_木村的博客-CSDN博客 2019年3月21日 - jvm 内存溢出 - 方法区_及运行时常量池_溢出Java 永久代是非堆内存的组成部分,用来存放类名、访 Java _内存_区域与_内存溢出_异常 - 张宗星 - 博客园 2016年5月27日 - 运行时常量池是_方法区_的一部分。Class文件中存在:类的版本、字段、方法、接口等…· 深入理解_java_虚拟机(一)—_java内存_区域以及_内存溢出_异常· 【深… _java方法区_和运行时常量池直接_内存溢出__weixin_2987926…_CSDN博客 2019年5月6日 - 常量池:String.intern()是一个Native方法,他的作用是如果常量池中已经包含一个等于… jvm 内存溢出 - 方法区_及运行时常量池_溢出Java 永久代是非堆内… _Java_常见的几种_内存溢出_及解决方案 - 平凡希 - 博客园 2017年9月4日 - 1.JVM Heap(堆)溢出:java.lang.OutOfMemoryError: Java heap space JVM在…当需要存储类信息而_方法区_的_内存_占用又已经达到-XX:MaxPermSize设置的最大… _Java内存_区域与_内存溢出_异常(jdk 6,7,8) - tlk20071 - CSDN博客 2017年9月4日 - 而在Java_8中,已经彻底没有了永久代,将_方法区_直接放在一个与堆不相连的本地_内存_区域,这个区域叫元空间。 实战OutOfMemoryError异常 2.1_Java_堆_溢出 Java… JVM总结-_内存_监视手段及各区域_内存溢出_解决 - xuqu_vol…_CSDN博客 2016年12月21日 - 引言本文仅关注一些常见的虚拟机内存监视手段,以及JVM运行时数据区各个部分_内存溢出_的发生和对应的解决方案,总体来说属于概括性总结,涉及相对不是很深… 【JVM】 _java内存_区域与_内存溢出_异常 - Elsa_CSDN博客 2018年5月7日 - java内存_区域与_内存溢出_异常 阅读数 2443 _java_虚拟机的基本结构类加载子系统类加载子系统负责从文件系统或者网络中加载Class信息,加载的类信息存放于一块称为_方法区… _Java内存_区域和_内存溢出_异常 - 菜菜菜鸡 - 博客园 2019年10月13日 - 在周志明老师的书中是这么讲解的:虽然Java_虚拟机“规范”把_方法区_描述为堆的一…本案例使用递归的方式让主线程的栈中存储大量的实例方法,导致_内存溢… _方法区内存溢出_测试 - cuseronline的专栏 - CSDN博客 2011年9月29日 - package com.jfans;import java.util.ArrayList;import java.util.List;/* * 如果要向运行时常量池(位于_方法区_Method Area)中添加内容,最简单的做法是… Java—(内存_区域 与 _内存溢出_异常) - _Unique 2019年1月22日 - _Java内存_区域与_内存溢出_异常运行时数据区域程序计数器(线程私有)_Java_虚拟机栈本地方法栈_Java_堆_方法区_运行时数据区域 线程私有区域:程序计数器,_Java_虚… _Java内存溢出_的几种情况 - lima - 博客园 2016年3月13日 - 本文通过几段代码模拟实际的_内存溢出_异常。…_Java_堆用于存储对象,只要不断的创建对象,并保证GC …下面一段代码借助CGLib使_方法区_出现_内存溢出_异常。… _java内存溢出_的解决思路 - kszsa - 博客园 2018年1月16日 - 内存溢出_是指应用系统中存在无法回收的内存或使用的内存过多,最终使得程序运行要…在运行时的内存区域有5个部分,Method Area(_方法区),Java stack(jav… _Java内存溢出_异常实例源码堆_方法区_虚拟机栈 | 红颜丽人 2014年7月2日 - Java内存溢出_异常实例源码堆_方法区_虚拟机栈 _Java内存溢出_异常实例源码堆_方法区_虚拟机栈,JVM内存几个重要区域:堆,_方法区,虚拟机栈,本地方法栈,程序计数… _java_栈_内存溢出_怎么产生? - 知乎 2015年3月10日 - _java_栈_内存溢出_场景是什么,怎么验证?堆_内存溢出_和stackoverflow就不说啦。说的是outOfMemory补充下我谈… JVM中的_内存溢出_详解 - 云+社区 - 腾讯云 2019年5月15日 - Java_中使用直接_内存_最多的就是NIO。 如何解决? 使用-XX:MaxDirectMemorySize属性指定直接_内存_的大小 _方法区溢出 java.lang.OutOfMemoryError: PermGen… 《深入理解_Java_虚拟机》读书笔记:第二章_Java内存_区域与_内存溢出_异常 2019年12月22日 - _Java_虚拟机在执行_Java_程序的过程中会把它所管理的_内存_划分为若干个不同的数据区域:_方法区_、虚拟机栈、本地方法栈、堆、程序计数器 程序计数器(Program… _方法区_和运行时常量池_内存溢出_异常_昆明达内官网 2016年11月30日 - 昆明IT培训的老师知道,_方法区_的作用是存储_Java_类的结构信息,当我们创建对象实例后,对象的类型信息存储在_方法区_之中,实例数据存放在堆中 _JAVA内存_区域与_内存溢出_异常_百度文库 评分:3.5/5 9页 2016年12月12日 - JAVA 内存区域与_内存溢出_异常转自 http://mynotes.iteye.com/blog/1207772 1…运行时常量池(Runtime Constant Pool)是_方法区_的一部分,Class 文件中除… _java_se基础强化-JVM_内存结构 14__方法区内存溢出-教育-高…_爱奇艺 _java_se基础强化-JVM内存结构 14__方法区内存溢出_是教育类高清视频,于2020-01-08上映,视频画面清晰,播放流畅,内容质量高。视频主要内容:主页获取全集教程… 深入理解_Java_虚拟机——_Java内存_区域与_内存溢出_异常.xmind-iteye 深入理解_Java_虚拟机——_Java内存_区域与_内存溢出_异常.xmind 评分: 这是自己读《深入理解_Java_虚拟机》时候用XMind建立的思维导图,目的是为了能够帮助自己整理、… 深入理解JVM虚拟机——JVM_内存_区域(运行时数据区) - 知乎 2019年11月21日 - 用jdk1.6运行后会报错,永久代这个区域_内存溢出_会报: Exception in thread “main…而在_Java_8中,已经彻底没有了永久代,将_方法区_直接放在一个与堆不相连的本地… 代码清单2-5 借助CGLib使得_方法区_出现_内存溢出_异常 中的例子… 2012年3月18日 - “标题:”代码清单2-5 借助CGLib使得方法区_出现_内存溢出_异常 中的例子console里没有打印出错误 我的环境: Mac系统,Eclipse Helios _java version “1.6.0_… _Java内存_区域与_内存溢出_异常 - 简书 Java_虚拟机五块_内存区 1、方法区(线程共享) 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虚拟机规范把_方法区_描述为堆的一… [总结]-第二章 _Java内存_区域与_内存溢出_异常 - GMar…-开源中国社区 2018年8月21日 - [总结]-第二章 Java内存_区域与_内存溢出_异常 一、知识点 1、虚拟机运行时数据区 _方法区:运行时常量池(JDK1.7被移出) 堆:存放对象实例或数组、新生代和… Java_堆_内存溢出 - 『编程语言区』 - 吾爱破解 - LCG - LSG |安卓… 2016年9月18日 - 最近在研究_Java_虚拟机,下面演示个_Java_堆_内存溢出_的实例,_Java_堆内存用于存储对象实例,只有不断的创建对象并且保证GC Roots到对象之间有可达路径来避免… _java内存溢出_问题(工作中常用、面试中常问的一个知识点) 2019年12月11日 - 内存溢出_是指应用系统中存在无法回收的内存或使用的内存过多,最终使得程序运行要…(3)_java_堆和_方法区:_java_堆区主要存放对象实例和数组等,_方法区_保存类信息、常量… java_有垃圾回收机制,为什么还会出现_内存溢出-黑马程序员技术交流… 2014年5月7日 - java_有垃圾回收机制,为什么还会出现_内存溢出 © 曾欢欢 中级黑马 / 2014-5-7…system类里面有一个gc()方法,运行垃圾回收器,调用这个_方法_垃圾回收器不… JVM:_内存_监视手段及各区域_内存溢出_解决 - _java_7__java_7…_红黑联盟 2017年2月27日 - JVM:内存监视手段及各区域_内存溢出_解决,本文仅关注一些常见的虚拟机内存监视手段,以及JVM运行时数据区各个部分_内存溢出_的发生和对应的解决方案,总体来… 什么是堆?什么是方法区?JVM_内存_模型中堆与_方法区_的介绍-_java_教程… 2018年9月15日 - JVM_内存_模型中堆与_方法区_的介绍,有一定的参考价值,有需要的朋友可以参考一下,…* _java_堆_溢出_demo * JVM参数:-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemory… _java内存_区域与_内存溢出_异常_百度文库 评分:3/5 2页 2017年1月4日 - ? 使用句柄访问对象: Java_堆中会划出一块_内存作为句柄池, reference中存储的是 对象的句柄地址,句柄中包含了对象实例数据(_Java_堆中)与对象类型数据 (… Java_虚拟机笔记-_内存区_与_内存溢出 - 一个年轻hacker的世界… 2015年11月13日 - _方法区_和_Java_堆一样,也是各个线程共享的_内存_区域,它用于存储已经被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据。一般也称作为“… 方法区_和运行时常量池_溢出 - 简书 2017年12月13日 - 对于这个区域的测试,基本思路是运行时产生大量的类去填满方法区,知道溢出_。虽然…笔者尝试在_java 1.8下运行发现,一直没有报错信息出现,直到电脑内存… JVM-_Java内存_区域与_内存溢出_异常 - haidao1992的个…-开源中国社区 2017年8月14日 - 根据_Java_虚拟机规范的规定,当_方法区_无法满足_内存_分配需求时,将抛出OutOfMemoryError异常。 运行时常量池 是_方法区_的一部分。Class文件中除了有类的版… java_栈、堆、常量池、_方法区-云海天教程 2020年3月28日 - 栈(stack):主要保存基本类型(或者叫内置类型)(char、byte、short、int、long、float、double、boolean)和对象的引用,数据可以共享,速度仅次于寄存器(… 深入理解 Java 虚拟机学习(一) – java 内存区域与_内存溢出_异常 2017年9月28日 - Java 虚拟机规范对方法区_的限制非常宽松,除了和 _Java 堆一样不需要连续的_内存_和可以选择固定大小或者可扩展外,还可以选择不实现垃圾收集。这区域…","link":"/2020/04/05/%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97java%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/"},{"title":"19.深入Java系列java类的信息全解","text":"java_获取_类的信息 - 胡峻峥 - 博客园 2016年1月15日 - java获取类的信息 关键技术剖析 1.java.lang.reflect包实现了_java的_反射机制,在使用反射机制时,需要导入该包。 2.Class类的forName方法能够根据类名加… 深入理解Java类型信息(Class对象)与反射机制__Java__zeji…_CSDN博客 2017年5月1日 - Java_》一书,其作用是在运行时识别一个对象_的类型_和_类的信息,这里分两种:传统的”RRTI”,它假定我们在编译期已知道了所有类型(在没有反射机制创建和使用类对象时… Java类型信息 - 坦然就好 - 博客园 2017年10月31日 - Java类型信息 RTTI——运行时类型信息(Run-Time Type Information),通过运行时_类型信息_程序能够使用基类的指针或引用来检查这些指针或引用所指的对象… 深入理解Java类型信息(Class对象)_赶路人儿-CSDN博客 2019年5月19日 - )运行时类型识别,对于这个词一直是 C++ 中的概念,至于Java中出现RRTI的说法则是源于《Thinking in Java》一书,其作用是在运行时识别一个对象_的类型_和… Java_获得_类的_详细_信息(类似Eclipse的代码提示)-百度经验 2017年7月4日 - 标签:java eclipse 最近要写一款类似代码编辑器的工具,其中要用到代码提示功能。于是就写了一个解析类详细方法,字段,抛错的分析类,其中运用到的就是J… _Java类型信息_详解 - 简书 2017年2月14日 - 2.3 Java类型信息_详解 运行时_类型信息(RTTI)使得我们可以在程序运行时发现和使用类型信息,其工作原理是Class对象中包含了与类有关_的信息_。 2.3.1 Clas… _Java_通过反射查看_类的信息_示例__java__脚本之家 2019年7月17日 - 这篇文章主要介绍了Java_通过反射查看_类的信息,结合实例形式详细分析了_java_基于反射获取_类信息_的相关原理与实现技巧,需要的朋友可以参考下 java_获取类列表_信息 - Clarences的个人空间 - OSCHINA 2018年3月29日 - package com.example.daconfigclient.Collection; import java.lang.reflect.Constructor…类信息,首先要获取_类的类_类型 Class c1 = obj.getClass();… _JAVA_里的方法区可以理解为_类信息_表吗?-CSDN论坛 2014年12月15日 - 深入理解Java类型信息(Class对象) RTTI(Run-Time Type Identification)运行时_类型_识别,对于这个词一直是 C++ 中的概念,至于_Java中_出现RRTI的说法则是… java 类型信息 2019年2月1日 - 本章主要学习如何让我么在运行时识别对象和类的信息_的.主要有两种方式:一种是传统的RTTI它假定我们在编译时已经知道了所有_的类型. 另一种是反射机制它… java中消息类型 - 云+社区 - 腾讯云 java中消息类型 Java是一门面向对象编程语言,不仅吸收了C++语言的各种优点,还摒弃了C++里难以理解的多继承、指针等概念,因此Java语言具有功能强大和简单易用两个特征… _java类的_加载和_类型信息_、反射_Sebastian_新浪博客 2018年11月14日 - _java类的_加载和_类型信息_、反射(2018-11-14 14:51:08) 转载▼-唯一的原生类加载器加载同名.class文件。 -当… java_获取数据库的列名,_类型_等_信息 - _java_sky - ITeye博客 2012年2月16日 - Java_数据结构SQLMySQLJDBC 阅读更多 最近有同事问我怎么获取数据库中某数据表的某一列字段名称及数据_类型,这种问题我还是第一次听别人问起,不过既然… Java 类型信息 | IT瘾 2013年12月17日 - Java 类型信息,, IT社区推荐资讯… 这个信息_保存着每个独享所属_的类_足迹 虚拟机利用运行时_信息_选择相应的方法(?类)执行 参考资料: 详解reflect _Java… java Object.getClass()方法是如何获取_类的_所有_信息_的? - 知乎 2016年12月16日 - java Object对象中并没有像Objective-C NSObject中包含指向该类的信息_的属性字段,那么 _java Object.get… _Java_类库中,将_信息_写入内存_的类_是( )。 2015年8月20日 - [题库]2020年3月全国计算机等级考试《二级_Java_语言程序设计》题库【历年真题+章节题库+模拟试题】 扫码在手机上阅读 _Java_类库中,将_信息_写入内存_的类_是… java_获取_类的信息-云栖社区-阿里云 2016年4月29日 - v关键技术剖析 1.java.lang.reflect包实现了_java的_反射机制,在使用反射机制时,需要导入该包。 2.Class_类的_forName方法能够根据类名加载类,获得_类的_Cla… java_基础——_类型信息 - joyce_xr的个人空间 - 51Testing软件测试… 2015年1月23日 - java_在运行时识别对象和_类的信息,主要有两种方式:1、传统的RTTI:假定我们再编译时已经知道了所有的类型; 2、反射机制:在运行时发现和使用_类的信息_。14… Java类型信息 - 坦然就好 - 博客园 2017年10月31日 - Java类型信息 RTTI——运行时类型信息(Run-Time Type Information),通过运行时_类型信息_程序能够使用基类的指针或引用来检查这些指针或引用所指的对象… java_获取_类的信息 - weixin_34072857的博客 - CSDN博客 2017年11月15日 - Class_类的_getSuperclass方法获得父类的_Class对象;getDeclaredFields方法获取类声明的属性,返回的是一组_java.lang.Field对象;getDeclaredConstructors… java 类型信息 - 江期玉 - 博客园 2019年2月1日 - 3.传统的RTTI 在编译期通过Class文件识别类型信息,反射在运行期通过Class文件识别_类型信息_。 4._Java类型_转换都发生在运行时期。 二.Class对象 Class对… Java 类型信息 - 我的小人生 - 博客园 2013年12月17日 - Java 类型信息 * 为什么需要运行时识别对象和类的信息? 1. 多态 - 实例都被向上转型为父类引用,实例调用相应方法时,需要知道当前父类型引用的具体类型… _Java_之通过Class类获取_类信息__LemonSnm的博客-CSDN博客 2019年6月28日 - 1、获取类信息_Class peopleClass = People.cl… //获取_类信息 Class peopleClass = People.class; /* //获取_类的_包名 Package apack… Java类型信息(Class对象)与反射机制 - u013728021的博客 - CSDN博客 2018年9月17日 - )运行时类型识别,对于这个词一直是 C++ 中的概念,至于_Java中_出现RRTI的说法则是源于《Thinking in Java》一书,其作用是在运行时识别一个对象_的类型_和_类的信息_。… _java类型信息__千霜的博客-CSDN博客 2018年9月4日 - _java类型信息_是运行时也可以获得,不像c++在编译时确定。运行时_类型信息_可以让你在程序运行时发现和 _Java类型信息_详解 - weixin_34242819的博客 - CSDN博客 2018年5月6日 - 反射:运行时的类信息 Class类与java.lang.reflect类库一起对反射的概念进行了支持,该类库包含了Field、Method以及Constructor类(每个类都实现了Member… Java类型信息 - qq_30118563的博客 - CSDN博客 2018年9月19日 - 类加载器子系统,是一个类加载器链,但只有一个原生类加载器,它是JVM实现的一部分。原生类加载器加载的是所谓可信类,含_Java_API,它从本地磁盘加载类。其… Java类型信息 - TooLateToLearn! - 博客园 2017年6月21日 - Java类型信息 P316)Class fancyToyClass = Class.forName(“FancyToy”); 这个方法是Class_类的_一个成员static成员。forName()是取得Class对象引用的一种… _java_获取类列表_信息__weixin_34067049的博客-CSDN博客 2018年3月29日 - java_获取类列表_信息 转载 weixin_34067049 发布于2018-03-29 16:21:00 阅读数 55 收藏 展开 2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 为什么会研… Java类型信息 - TooLateToLearn! - 博客园 2017年6月21日 - Java类型信息 P316)Class fancyToyClass = Class.forName(“FancyToy”); 这个方法是Class_类的_一个成员static成员。forName()是取得Class对象引用的一种… Java– 类型信息 - FireEgg - 博客园 2014年6月27日 - Java– 类型信息 不想写文字啊! 1 package typeinfo; 2 3 import java.util.*; 4 5 abstract class Shape{ 6 void draw(){ System.out.println(this +… java类型信息 - weixin_33923148的博客 - CSDN博客 2017年11月13日 - 运行时类型信息_使得你能够在程序运行时发现和使用_类型信息; _java_在运行中识别_类型信息_主要有两类,一是从传统的RTTI,另一种是反射机制; 1、Class对象 … Java 类型信息 - weixin_30486037的博客 - CSDN博客 2016年4月14日 - 在向List中插入Shape对象时,list把每个对象作为Object_类型_存储,取出时自动转换为Shape_类型_,_类型_转换正确性是在运行时动态检查的,编译时由_Java_容器和范… java 类型信息 - weixin_30716141的博客 - CSDN博客 2019年2月1日 - 2.反射 允许在运行时发现和使用类型信息 3.传统的RTTI 在编译期通过Class文件识别类型信息,反射在运行期通过Class文件识别_类型信息_。 4._Java类型_转换… _java_实现_短信信息_的发送-_Java_工具类资源-CSDN下载 本资源为用_java_实现短息_信息_的发送,已整理为一个工具类,改一下properties里的id以及key直接加入项目就能用,提供相关jar包和完整源代码。更多下载资源、学习资料请… java_文件_类型信息 - it610.com 2012年4月22日 - java_文件_类型信息java String File express flv rtf package com.oem.test; import java.io.FileInputStream; import java.io.FileNotFoundExcep… _java_语言的学生_信息_管理系统(集合类)_百度文库 _Java 的_学生_信息_管理源代码:必须配合学生类才可以运行,学生类 在下方,我建议最好还是把学生类分成另一个类来运行比较好! package com.geminno.day12.homework; … _Java_类库中,将_信息_写入内存_的类_是___。_考试资料网 2015年10月27日 - _Java_类库中,将_信息写入内存_的类_是___。 A._java.io.FileOutputstream B.java.io.ByteArrayOutputStream C.java.io.BufferedOutputstream D.java.io.Da… _Java_类库中,将_信息_写入内存_的类_是( )。 - 问答库 B。【解析】在java.i0中,提供了ByteArrayInputStream、ByteArrayOutputStream和StringBuffednput Stream类可以直接访问内存,其中用ByteArrayOutputStream可以向字节数组(… 查找有关Java中的类,软件设计的信息? - CocoaChina_一站式开发者… 2019年10月28日 - 找出类所需数组长度的最佳方法是什么?我可以:(A)要求每个派生类都有一个静态方法,返回长度.但是,基类无法强制执行此操作,因为抽象静态方法在_Java中_不… _java_写一个类,包括_信息_为手机的型号,价格和颜色。功能为打电话给… 2018年3月25日 - package henu.rjxy.demo01;public class Demo01Phone Java… _java_写一个类,包括_信息_为手机的型号,价格和颜色。功能为打电话给某人和发_信息_给某人 … Java Properties 类读取和修改配置文件信息 - 志在必得 - ITeye… 2011年7月14日 - 因为他内部有一个nfigParser 类来支持 .ini 文件的读写,根据该类提供的方法程序员可以自由的来操作 .ini 文件。而在 Java 中, Java 支持的是 .propert… java_各种类定义-_java_各种类定义文档介绍_内容-阿里云 阿里云为您提供java_各种类定义相关的3条产品文档_内容_及常见问题解答_内容,还有19阿里学生怎么买邮箱,19阿里双十一首次购买邮箱,19阿里双11如何买邮箱,19阿里双11学生… Java_笔记-_类型信息 | 大专栏 2020年1月30日 - _Java_笔记-泛型 泛型实现了参数化_类型的_概念。核心概念:告诉编译器想使用什么类型,然后编译器帮你处理一切细节。 简单泛型 一个堆栈类例子: 此例子使用… Java Character 类 | 菜鸟教程 Java Character 类 Character 类用于对单个字符进行操作。 Character 类在对象中包装一个基本类型 char 的值 实例 [mycode3 type=’java‘] char ch = ‘a’; /… Java 消息_服务(底层技术、_Java 类和接口、编程模型)_IT教程网 2019年4月8日 - Java消息_服务 pdf,深入浅出地讲解了JMS1.1 规范的底层技术、_Java 类和接口、编程模型及其不同实现等_Java消息_服务(JMS )和_消息_传送机制关键技术。通过对支持点对点… Java 反射获取_类的_所有_信息_【广东_信息_科技职业培训学院吧】_百度… 2019年6月9日 - Java 反射获取类..反射就是在运行中能动态获取到一个_类的_所有_信息_。能够调用这个_类的_任意方法,属性和构造方法等。还可以反编译,就是 .class&gt;&gt;._java_我… _java_编程定义一个表示学生_信息的类_student要求如下_新网 2018年6月10日 - java_编程定义一个表示学生_信息的类_student要求如下专题详细_内容_由工具聚合而成,希望能给您带来帮助,帮您了解_java_编程定义一个表示学生_信息的类_student要求如下相关_内容…","link":"/2020/04/05/%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97java%E7%B1%BB%E7%9A%84%E4%BF%A1%E6%81%AF%E5%85%A8%E8%A7%A3/"},{"title":"1.深入Java系列之JVM","text":"Java_虚拟机(_JVM)你只要看这一篇就够了!_运维__Java_笔记-CSDN博客 2018年8月14日 - 1.1.4 Java 堆 对于绝大多数应用来说,这块区域是 JVM 所管理的内存中最大的一块。线程共享,主要是存放对象实例和数组。内部会划分出多个线程私有的分… _Java_基础之_JVM_运行机制 - - ITeye博客 2015年2月28日 - Java_基础之_JVM_运行机制 作者:忆辛 _Java Virtual Machine简称JVM,它是一种规范,是一种计算的仿真。我们知道_java_语言是跨平台的,而JV … Java _JVM_及相关概念 - 简书 2018年6月24日 - 1、概述 JVM_是_Java Virtual Machine(_Java_虚拟机)的缩写,是一种用于计算设备的规范,它是一个虚构出来的计算机,是通过在实际的计算机上仿真模拟各种计算… _java_中_JVM_的原理重温【转】 - eastday - 博客园 2017年12月27日 - _java_中_JVM_的原理重温【转】 一、基础理论知识 1、_java_虚拟机的生命周期: _Java_虚拟机的生命周期 一个运行中的_Java_虚拟机有着一个清晰的任务:执行_Java_程序。程序… java - _JVM_知识总结 - A__B__C__的博客 2019年3月6日 - JVM ( Java Virtual Machine):_Java_虚拟机目录一、_java_内存区域与内存溢出异常1、运行时数据区域1.1 程序计数器(线程私有)1.2 _java_虚拟机栈(线程私有)1… Java _JVM_怎么学习啊?从哪方面入手? - 知乎 2019年6月1日 - 看到这里,你应该明白了不少知识,我们的源文件(java_文件)也顺利编译成了字节码文件(class文件)。接下来就是运行程序并输出结果了,那么 _JVM 是如何将字… Java_后端开发三年,你不得不了解的_JVM - 51CTO.COM 2019年6月6日 - _JAVA_程序员,三年是个坎,如果过了三年你还没有去研究_JVM_的话,那么你这个程序员只能是板砖的工具了。下面来个_JVM_的解析可好? _java_中_jvm_的工作原理 - DreamingSoftWare - 博客园 2017年11月28日 - Java 虚拟机 Java 虚拟机(Java virtual machine,JVM)是运行 Java 程序必不可少的机制。JVM_实现了_Java_语言最重要的特征:即平台无关性。原理:编译后的 _J… _Java_面试必备——_JVM_篇 - 简书 2018年12月11日 - 1. Java_的内存模型以及GC算法 一、_Java_内存模型 _Java 虚拟机具有一个堆,堆是运行时数据区域,所有类实例和数组的内存均从此处分配 _JVM_主要管理两种类型… _java_的_JVM_原理和_java_常识-百度经验 2018年7月18日 - _java_的_JVM_原理和_java_常识,_JVM_是_Java_VirtualMachie(_Java_虚拟机)的缩写,_JVM_是一种用于计算设备的规范,它是一个虚构出来的计算机,是通过在实际的计算机上… _java_必看:_JVM_作为_java_运行的基础_了解 2018年11月2日 - 对于刚刚接触_Java_的人来说,_JVM_相关的知识不一定需要理解很深,对此里面的概念有一些简单的了解即可。在_JVM_这个大类中,需要掌握的知识有: _JVM_内存模型和… 专题:_JVM_详解 _Java_虚拟机原理与优化_51CTO.COM - 技术成就梦想… _Java_之所以能够崛起,_JVM_功不可没。_Java_虚拟机最初服务于让_Java_语言凌驾于平台之上,实现“编写一次,到处运行”;而随着时间的推移,_JVM_经过不同公司和团体以不同方式… 如果在_java_程序中取得_JVM_的内存信息呢?-CSDN论坛 如何dump jvm 内存及线程栈 如何dump jvm 内存及线程栈 目前很多企业的后台服务都是 java 服务,在故障出现时能及时 dump jvm 内存和线程栈对于故障的分析及定位是… Java JVM 运行机制及基本原理 - 知乎 2017年3月21日 - 将知识用文字记录下来,供以后温故知新。 _JVM_的基础概念_JVM_的中文名称叫_Java_虚拟机,它是由软件技术模拟出计算机运行的一个虚拟的计算机。_JVM_也充当着一… java _jvm_的知识详细介绍__java__脚本之家 2016年11月14日 - 这篇文章主要介绍了java jvm_的知识详细介绍的相关资料,这里对_java _jvm_中的堆内存和栈内存等基础知识做了详细介绍,需要的朋友可以参考下 _JVM_内幕:_Java_虚拟机详解丶一个站在_Java_后端设计之路的男青年个人… 2019年6月15日 - 这篇文章解释了Java 虚拟机(JVM)的内部架构。下图显示了遵守 Java SE 7 规范的典型的 JVM 核心内部组件。上图显示的组件分两个章节解释。第一章讨论针… 深入Java_虚拟机(_JVM) - - ITeye博客 2018年12月24日 - 一.Java 整体的运行结构以及与 JVM 的关系 ClassLoader的在关键是告诉你,我要进行类加载,而在进行类加载的时候,就一定有一个正常的环境属性CLASSPATH,没有CLASS… _java_中_jvm_在哪?是包含在jdk里面吗?_慕课猿问 2018年12月12日 - 在我们的jdk目录中jre\\bin\\server和jre\\bin\\client都有jvm.dll文件存在,而java_正是通过_jvm.cfg配置文件来管理这些不同版本的jvm.dll的.通过文件我们可… 在_JAVA_中_JVM_的作用是什么?-ZOL问答 2019年12月31日 - 8条回答:【推荐答案】_JVM_是_JAVA_虚拟机,它将.class字节码文件编译成机器语言,以便机器识别!_JAVA_程序就是在_JVM_里运行的 JVM 运行机制及其原理_xiangzhihong8的专栏-CSDN博客 2018年5月22日 - 最近出去面试,总被问到_JavaJVM_相关的东西,什么_JVM_的内存模型、_JVM_的内存分配、内存回收、内 java _jvm_学习 - 左手编程右手诗 - 博客园 2019年5月21日 - java _jvm_学习 在并发编程中,多个线程之间采取什么机制进行通信(信息交换),什么机制进行数据的同步? 在_Java_语言中,采用的是共享内存模型来实现多线程之… JVM(java 虚拟机)_lv_hulk的博客-CSDN博客 2019年2月16日 - JVM(java 虚拟机)一.JVM_简介1._JVM:Java Virtual Machine (ja… 一.JVM_简介 1._JVM:Java Virtual Machine (java 虚拟机) 通过软件来模拟出来的具有完整… JVM-五大区 - yangkai的博客 - CSDN博客 2018年5月24日 - _Java_程序执行流程:谈一谈_Java_内存区域的划分实际上是指_JVM_内存区域的划分,首先_Java_先介绍一下_Java_程序具体执行的过程如上图所示,首先_Java_源代码们(._java_后缀)会被… 【_JAVA_】_JVM___Java__屎蛋的铲屎官-CSDN博客 2019年7月8日 - 1 JVM_内存模型概括地说来,_JVM_初始运行的时候都会分配好 Method Area(方法区) 和H_Java… 前言JVM_是_Java Virtual Machine(_Java_虚拟机)的缩写,_JVM_是一种… Java–_JVM_详解 - Rocky - CSDN博客 2018年11月19日 - java 整体运行结构以及JVM_的结构 _java_的源程序 –》编译(字节码)JDK的功能 —》_JVM_解释这个字节码 怎么找到的呢? classLaoder —&gt;_java_程序的执行_… 什么是JVM? - _Java_笔记 - CSDN博客 2018年4月20日 - 说明:做_java_开发的几乎都知道_jvm_这个名词,但是由于_jvm_对实际的简单开发的来说关联的还是不多,一般工作个一两年(当然不包括爱学习的及专门做性能优化的… Java-JVM-分类 - baichoufei90的专栏_CSDN博客 2018年12月22日 - Java-JVM-分类转载声明:本文系转载自以下文章:RednaxelaFX对主流_Java_虚拟机讲解作者:RednaxelaFX来源:知乎转载仅为方便学习查看,一切权利属于原作者,… Java _JVM_启动参数 - 学而不厌 诲人不倦 - CSDN博客 2018年8月22日 - 摘要已经使用了一段时间的Java,期间也了解和用过一些JVM(_Java_VirtualMachine)参数,但是没有仔细去整理过每个参数代表的意义,为此整理成文。_Java_使用方… [ 转载 ] Java _Jvm_内存介绍 - NO-IF - 博客园 2019年3月20日 - [ 转载 ] Java _Jvm_内存介绍 一、基础理论知识 1、_java_虚拟机的生命周期: _Java_虚拟机的生命周期 一个运行中的_Java_虚拟机有着一个清晰的任务:执行_Java_程序。程序… jvm-_java_进程之间以及跟_JVM_是什么关系——CSDN问答频道 2018年1月5日 - 1、命令启动了两个java_程序,它们之间是什么关系; 2、_java_程序又和_JVM_之间是什么关系,它们是公用一个_JVM,还是每个_java_程序,都有一个_JVM_。 ![图片说明](… java jvm - 个人文章 - SegmentFault 思否 2019年6月2日 - Java 中的堆是 JVM 所管理的最大的一块内存空间,主要用于存放各种类的实例对象。在Java 中,堆被划分成两个不同的区域:新生代 ( Young )、老年代 ( Old… _java_的_JVM_内存结构详解 2019年4月23日 - _JAVA_是一门跨平台的语言,这得归功于它的_JVM_。在实际项目开发中,通常会出现Out of Memery问题,而内存管理是_JAVA_自己运行管理,要定位问题,前提必须了解_JAVA_的内存模… Java _JVM_内存(参数)配置教程 – 业余草 2018年6月16日 - 上一篇我详细的介绍了Java_中三种常见的内存溢出异常。本文结合:OutOfMemoryError:…本文原文出处:业余草: » _Java _JVM_内存(参数)配置教程继续浏览有… 什么是_java_虚拟机?_JVM_的简单介绍-_java_教程-PHP中文网 2019年5月22日 - Java_虚拟机(_JVM)是运行Java_字节码的虚拟机,它是_java_编程语言的核心。当我们运行程序时,_JVM_负责将字节代码转换为特定于机器的代码。_JVM_还依赖于平台,并提供核心_Java… 2019全网最全_Java_虚拟机_jvm_系列视频集_哔哩哔哩 (゜-゜)つロ …请你说一下java _jvm_的内存机制_测试校招面试题目合集_牛客网 请你说一下java _jvm_的内存机制 参考答案参考回答: _Java_内存区域划分 1.程序计数器: 可以看做是当前线程所执行的字节码的行号指示器。在_JVM_的概念模型里,字节码… Java _JVM_执行流程 - 无名氏的程序员的个人空间 - OSCHINA 2019年7月25日 - _Java_字节码的执行是由_JVM_执行引擎来完成,流程图如下所示: 四、总结 _Java_虚拟机的生命周期 一个运行中的_Java_虚拟机有着一个清晰的任务:执行_Java_程序。 … _JAVA_虚拟机_JVM_介绍_图文_百度文库 JVM 自动内存管理:内存区域基础概念 Java 虚拟机栈和本地方法栈 Java 虚拟机栈和本地方法栈 ? Java 虚拟机栈的概念和特征 ? 本地方法栈的概念和特征 ? 栈帧… _JAVA_虚拟机_JVM_介绍_图文_百度文库 JVM 自动内存管理:内存区域基础概念 Java 虚拟机栈和本地方法栈 Java 虚拟机栈和本地方法栈 ? Java 虚拟机栈的概念和特征 ? 本地方法栈的概念和特征 ? 栈帧… JVM 详解 - _Java_开发 - 开发语言与工具 - 深度开源 2013年6月30日 - Java_程序运行在_JVM_之上,_JVM_的运行状况对于_Java_程序而言会产生很大的影响,因此掌握_JVM_中的关键机制对于编写稳定、高性能的_JAVA_程序至关重要。_JVM_制定了_… _Java_之_JVM_监控工具分享-云栖社区-阿里云 2019年3月22日 - _Java_之_JVM_监控工具分享VM的基本知识常用的也就是类加载机制,内存区域、分配、OOM,GC,_JVM_参数调优几个链接自己看:内存区域&amp;类加载机制分配策略&amp;垃圾回… Java JVM 参数设置大全 _JVM_给出了3种选择:串行收集器、并行收集器、并发收集器。串行收集器只适用于小…大规模的系统编译可能需要加载大量的_Java_类到内存中,所以预先分配好大量的持久代… _Java_之_JVM_知识点整理 - 云+社区 - 腾讯云 2019年8月16日 - JVM:Java Virtual Machine 什么是JMM?java memory model _java_内存模型 一提到_JVM_就不得不提_JVM_调优,GC垃圾回收 (一)GC垃圾回收 什么是垃圾? 垃圾:已… _java_查看_jvm_内存使用情况_淡定_新浪博客 2012年3月22日 - java.lang.Runtime类提供了查看当前_JVM_内存的使用情况。每个_java_实例(即虚拟机实例)只有一个Runtime的实例,通过Runtime.getRuntime()可以得到当前虚拟… Java 虚拟机(JVM) - 知乎 JVM_是_Java Virtual Machine(_Java_虚拟机)的缩写,_JVM_是一种用于计算设备的规范,它是一个虚构出来的计算机,是通过在实际的计算机上仿真模拟各种计算机功能来实现的。… Java 属性 在_JVM_中保存的地方 的问题 - ITeye问答 2013年6月22日 - 遇到一个难题,来iteye问一下,一直以来有几个疑问,关于成员变量在_jvm_中保存的位置…_JavaJVM_内存位置成员变量 2013年6月21日 21:08 successfulroof 3… _Java_技术:_JVM_的初步认识_运行 2018年11月22日 - 本地方法栈中存放的是_JVM_实际需要调用到的native方法,实际上还是和_Java_虚拟机栈很相似的.4.2.4方法区方法区是所有线程共享的一块内存分区,它的名字其实感觉不太… 了解_java_虚拟机—_JVM_的基本结构(1)-翰林小院-51CTO博客 2018年8月16日 - _JAVA_的堆在_JVM_启动的时候建立,几乎所有的_Java_对象实例都存放于_Java_堆中。堆空间是所有线程共享的。根据垃圾回收机制的不同,_JAVA_堆有可能拥有不同的结构。最为常见的… 看完这篇文章你还敢说你懂_JVM_吗? - 51CTO.COM 2019年1月30日 - 在一些物理内存为8g的服务器上,主要运行一个_Java_服务,系统内存分配如下:_Java_服务的_JVM_堆大小设置为6g,一个监控进程占用大约 600m,Linux自身使用大约800m。 java jvm GC 参数设置 - 渴死的火烈鸟 - ITeye博客 2014年1月27日 - 指定jvm heap在使用率大于n的情况下,heap进行扩张,Xmx==Xms的情况下无效,如:-XX:MaxHeapFreeRatio=70 k: -XX:LargePageSizeInBytes 指定Java heap的分… jvm(_java_虚拟机)一般在文件的什么位置-CSDN论坛 1.创建JVM_装载环境和配置 2.装载_JVM.dll 3.初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例 4.调用JNIEnv实例装载并处理class类。 在我们运行和调试_Java_程序的… sun java_虚拟机(_jvm)下载 v1.6官方版 - 多多软件站 2015年12月1日 - JVM:Java Virtual Mechinal(_JAVA_虚拟机)。_JVM_是JRE的一部分,它是一个虚构出来的计算机,是通过在实际的计算机上仿真模拟各种计算机功能来实现的。_JVM_有… java-jvm-jstack-(监视器和锁的概念) - java 学习路 - ITeye博客 2017年5月17日 - 两个线程都有有一句: java.lang.Thread.State: BLOCKED (on object monitor) 表明:两个线程都阻塞在了 对应正在操作对象的object monitor上(是因为对… Java_面试总结之_JVM 2019年5月5日 - 对于_Java_程序员来说,_JVM_是面试过程中必备考题之一,只要我们掌握了其核心知识点,万变不离其中,无论怎么考你,都能应对自如。这篇文章我会根据在实际面试过程中遇到… Java _JVM_怎么学习啊?从哪方面入手? - 知乎 2019年12月3日 - 如果_JAVA_开发是降龙十八掌,_JVM_就是九阳神功,具备九阳神功的内力基础降龙十八掌的威力会被发挥的淋漓尽… Java _JVM_是什么意思?_百度知道 2011年11月30日 - 回答：Java Virtual Machine _java_虚拟机 是_java_程序的字节码的运行环境 据我所知是使用c/c++开发的 是_java_跨平台运行的必要 java_深入篇之_JVM - 简书 _Java_源代码文件(._java_后缀)会被_Java_编译器编译为字节码文件(.class后缀),然后由_JVM_中的类加载器加载各个类的字节码文件,加载完毕之后,交由_JVM_执行引擎执行。在整…","link":"/2020/03/31/%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97%E4%B9%8BJVM/"},{"title":"4.深入Java系列之绘图","text":"开源之美!java-image-scaling - yang3wei - 博客园 2012年3月21日 - 项目主页:http://code.google.com/p/_java-image-scaling_/ Getting Started! Introduction This will guide you through how to rescale images using … Maven Repository: java-image-scaling 2020年3月25日 - The purpose of the library is to provide better image scaling options than the Java runtime provides. Last Release on Dec 1, 2014 … 开源之美!java-image-scaling - 客亦知夫水与月乎?_CSDN博客 2012年3月21日 - 项目主页:http://code.google.com/p/_java-image-scaling_/Getting Started!IntroductionThis will guide you through how to rescale images using thi… _java-image-scaling_首页、文档和下载 - 图形/图像处理…-开源中国 2009年11月30日 - java-image-scaling 可用来生成高质量的图像缩略图。… java-image-scaling 图形/图像处理 授权协议: 未知 开发语言: Java 操作系统: 跨平台 收录… java-image-scaling - 其它开源项目 - 其它 - 深度开源 这是一个高质量图片缩小开源类库。比_java_提供的更好。… 比_java_提供的更好。&lt;IMG alt=_imagescaling_logo.png src=”https://simg.open-open.com/show/249cd0b6… 开源之美!java-image-scaling - 客亦知夫水与月乎? - CSDN博客 2012年3月21日 - 项目主页:http://code.google.com/p/_java-image-scaling_/ Getting Started! Introduction This will guide you through how to rescale images using … java-image-scaling - 其它项目 - 其它 - JAVA开源项目 - 开源吧 _java-image-scaling_是一个高质量图片缩小开源类库。比java提供的更好。… _java-image-scaling_是一个高质量图片缩小开源类库。比java提供的更好。Future features * … _java-image-scaling_热门博客列表 - ITeye博客频道 - ITeye.com 2011年11月14日 - java-image-scaling 近期最受欢迎的博客,ITeye博客频道… struts2imgareaselect_java-image-scaling_图片缩放图片剪切 HotStrong 评论(4) 有8295人浏览… java-image-scaling-master-Java代码类资源-CSDN下载 2015年7月16日 - java图片处理工具类JAR包 _java-image-scaling_jar java图片处理工具类JAR包 _java-image-scaling_jar 立即下载 java-image 上传时间: 2012-11-22 资源… 图片处理 java-image-scaling.jar-Java工具类资源-CSDN下载 2016年5月31日 - 图片处理 java-image-scaling.jar 评分 java 图片处理 生成缩略图 文件放大 切割 生成水印 二维码 条形码 image 所需积分/C币:10 上传时间:2016-05-3… _java-image-scaling_是一个开源高质量的图像缩略图类库 - 豆丁网 2010年10月31日 - (apples,null); ImageIO.write(rescaled, “png”, dest); return true; catch(Exception returnfalse; java-image-scalingjava-image-scaling-0.8.5.ja… _java_图片处理工具类JAR包 _java-image-scaling_jar - Web开发… 首页-&gt; 软件开发 -&gt; Web开发 -&gt; java图片处理工具类JAR包 java-image-…java图片处理工具类JAR包 _java-image-scaling_jar(其他文档,42KB,免1积分) 请… Download java-image-scaling-0.8.5-sources.jar : java image… META-INF/MANIFEST.MF com.mortennobel.imagescaling.AdvancedResizeOp.java com.mortennobel.imagescaling.BSplineFilter.java com.mortennobel.imagescaling.BellFilte… java-image-scaling-0.8.6 - jar下载 - Maven Repository - IT猿网 2014年12月1日 - java-image-scaling-0.8.6.jar下载、源码下载 version:0.8.6 文件名时间大小下载 java-image-scaling-0.8.6-javadoc.jar 2014-12-01 104.57K 下载 java… Java image scaling improve quality? - Stack Overflow 2020年2月27日 - Got the best results using the java-image-scaling library. –JCS Apr 17 ‘13 at 11:58 add a comment 2 You might want to look at this image … imgscalr - Java Image-Scaling Library imgscalr is a Java Image-Scaling Library implementing Chris Campbell’s incremental scaling algorithm as well as Java_2D’s “best-practices” _image-scaling … Java:图片缩放算法(down scaling) - 逛奔的蜗牛 - C++博客 2011年1月9日 - Java:图片缩放算法(down scaling) 1. Bilinear 2. BiCubic 3. Area_Average …public static Buffered_Image_ getFasterDownScaledInstance(Buffered_Im_… com.mortennobel.imagescaling (java-image-scaling 0.8.5 API… Package com.mortennobel.imagescaling Interface Summary ProgressListener Resample…Astyanax, the Cassandra Java library Checkout one of the most used java op… Java SWT Image 图像 —— 放大 缩小 Scaling - xmind - ITeye博客 2012年1月19日 - int height) to create a new Image_Data object based on _scaling the receiver…2,Image_Data.scaledTo(int width, int height) _Java_代码 final _Image image … _JAVA_实现图片处理缩略图-三种开源实现方式 - 我心飞翔 - ITeye博客 2019年8月9日 - 第二个开源: java-image-scaling long begin2 = System.currentTimeMillis(); File fileOne = new File(“E:\\test\\photos\\阿凡达.jpg”); File hd_a… 开源之美!java-image-scaling - weixin_30399797的博客 - CSDN博客 2012年3月21日 - 项目主页:http://code.google.com/p/_java-image-scaling_/ Getting Started! Introduction This will guide you through how to rescale images using … 开源之美!java-image-scaling - yang3wei - 博客园 2012年3月21日 - 项目主页:http://code.google.com/p/_java-image-scaling_/ Getting Started! Introduction This will guide you through how to rescale images using … Image _Scaling__网络_学无止境-CSDN博客 2013年10月15日 - 百科上也介绍了一些Scaling的方法包括Spline Interpolation、SuperSamping等。 http:…11-22 java图片处理工具类JAR包 _java-image-scaling_jar 下载… 开源之美!_java-image-scaling__xumingrencai-CSDN博客 2012年3月21日 - 项目主页:http://code.google.com/p/_java-image-scaling_/G… 项目主页:http://code.google.com/p/_java-image-scaling_/ Getting Started! Introductio… Image _Scaling__人工智能_松子茶的专栏-CSDN博客 2013年9月1日 - Bilinear image scaling is about the same as neares人工智能… Bilinear image scaling is about the same as …Here is a Java snippet for 4 channels (… _java_图片处理工具类JAR包 _java-image-scaling_jar-Web开…-CSDN下载 2012年11月22日 - java图片处理工具类JAR包 _java-image-scaling_jar 评分 java图片处理工具类JAR包 _java-image-scaling_jar java-image 所需积分/C币:14 上传时间:2012-1… Download java-image-scaling-0.8.5.jar : java image « j… META-INF/MANIFEST.MF META-INF/maven/com.mortennobel/java-image-scaling/pom.properties META-INF/maven/com.mortennobel/java-image-scaling/pom.xml com.morte… Java image scaling - Stack Overflow 2020年2月5日 - in Action), this is because iText always displays the images at a resolution of 72 dpi, regardless of what the actual dpi property of the im… java-image-scaling-0.8.5.jar-Java文档类资源-CSDN下载 2015年3月31日 - java-image-scaling-0.8.5.jar 是一款针对java开发的,开源的图片处理优化jar更多下载资源、学习资料请访问CSDN下载频道. _JAVA_获取_Image_的几种方式 - 薛定谔的光粒二像性 - CSDN博客 2019年6月15日 - 解决java_中使用get_Image()导入图片失败问题 阅读数 100 解决java_中使用get_Image()导入图片失败问题在使用get_Image_(fileName)方法导入图片时,一直失败… _Java_图片缩放和处理工具 - pyzheng - ITeye博客 2016年1月9日 - java-image-scaling 0.8.6 Java代码 /** * @param originalFile * @param resized… _Java图像_缩放_了知先生_新浪博客 2013年7月26日 - 另外有一些第三方的实现了类似lanczos插值,这个链接就是一个ImageJ的插件,看起来很有趣,不过我没试过。_Java-Image-Scaling_它的说明参考作者的blog 。… _Java_对图片不失真地缩放 - 风琳博客 2015年4月21日 - java-image-scaling 0.8.6 &lt;…BufferedImage inputBufImage = ImageIO.read(originalFile); ResampleO… Java - 调整_图像_大小而不会降低质量 - IT屋-程序员软件开发技术… 2018年7月24日 - Progressive Scaling Mentioned in Chris Campbell’s blog about scaling in Java, progressive scaling is basically incrementally scaling an image in smaller steps… Java SWT Image 图像 —— 放大 缩小 Scaling - 灰信网(软件开发… Java SWT Image 图像 —— 放大 缩小 Scaling,灰信网,软件开发博客聚合,程序员专属的优秀博客文章阅读平台。 解决How can I resize an image using Java? - image-resize-java… 2017年3月12日 - FWIW I just released (Apache 2, hosted on GitHub) a simple image-scaling library for Java called imgscalr (available on Maven central). The … Java 怎么将图像(Image)缩放到所需的宽度和高度,假设它们都大于… 2019年7月17日 - import java.util.Map; public class Main{ private static final Map qual; public static Buffered_Image_ getScaledInstance(_Scaling_Options opt, Bu… java 图片压缩变色问题-布布扣-bubuko.com 2017年9月20日 - 尝试了很多方法,如JDK原生的方式及第三方组件_java-image-scaling_或thumbnailator都不解决问题。 后来采用阿里的SimpleImage解决。记录一下 SimpleImage github地址:https… _Java_图片剪裁功能实现 - 点滴积累 - ITeye博客 2017年7月31日 - return writeToTempFile(image, format); } 其中用到了Java image _scaling_开源工具,对图片进行缩放。 _Java_代码 /** * 放大缩小图片到指定宽和高 … java 图片压缩图片图片变色问题-CSDN论坛 2015年7月17日 - 呵呵,不要使用java的原生图片类库,虽然可以实现,但代码很繁琐,要你懂得图片处理…如JDK原生的方式及第三方组件_java-image-scaling_或thumbnailator都不解决问题。后来… picZoom 图像_缩放(_image scaling)是指对数字_图像_的大小进行调整的… 2016年3月1日 - 标签属性: [Java] [源码] 上传时间: 2016-03-01 文件大小: 821byte 已…zooming (image scaling) refers to adjust the size of the digital imag… Java_使用_image_io 读写_图像 2014年4月18日 - Java_中进行_图像_I/O(即读图片和写图片,不涉及到复杂_图像_处理)有三个方法: _Java Image I/O API,支持常见图片,从Java 2 version 1.4.0开始就内置了。主页… Java _图像_缩放类库 imgscalr | 码农软件 - 码农网 2019年9月7日 - 软件首页: http://www.thebuzzmedia.com/software/imgscalr-_java-image-scaling_-library/ 软件文档: http://www.thebuzzmedia.com/software/imgscalr-… _JavaImage_Filters__javaimage_filters - 云+社区 - 腾讯云 使用_java-image-scaling_生成的… 如何获得高质量的缩略图?(2 个回答) resampleop.setfilter(resamplefilters.getlanczos3filter()); resampleop.setunsharpenmask… com.mortennobel » Java Image Scaling 各版本jar包下载和pom… 2014年12月1日 - 项目简介 库的目的是提供比Java_运行时提供的更好的_图像_缩放选项 官方原文:The purpose of the library is to provide better _image scaling options … Java Code Examples com.mortennobel.imagescaling.Advanced… This page provides Java code examples for com.mortennobel.imagescaling.AdvancedResizeOp. The examples are extracted from open source Java projects. JAVA_实现图片处理缩略图-三种开源实现方式 - _java- - Coin163 第二个开源: java-image-scaling long begin2 = System.currentTimeMillis(); File fileOne = new File(“E:\\test\\photos\\阿凡达.jpg”); File hd_ad… _java_方面图形/_图像_处理 - it610.com 2015年3月8日 - 目录(?)[-]Java图像_处理类库_JavaImage_Filters指纹识别开发包SourceAFIS图片效果制作的Jar包Easy_Image_纯_Java_的VP8解码器_Java_VP8Decoder_Image_Magick的_Ja… java-image-processing _JAVA图像_处理读取BMP图像、用RGB获取灰度… 2012年8月4日 - 说明: JAVA图像_处理读取BMP_图像_、用RGB获取灰度信息、直方图均衡化、拉普拉斯2阶滤波、平滑锐化、增强滤波、局部阀值处理、全局阀值处理等(_Java image… _javaimage_变icon_新网 2018年6月13日 - _javaimage_变icon专题详细内容由工具聚合而成,希望能给您带来帮助,帮您了解_javaimage_变icon相关内容细节 【_java_黑白_图像_处理】-博文推荐-CSDN博客 2019年9月25日 - java-image-scaling java-image-scaling 可用来生成高质量的图像缩略图。 更多_java-image-scaling_信息 Java 图像处理框架 Processing Processing 是… JAVA_生成直方图_Image - 学步园 2012年11月25日 - package com.image.histogram; import java.awt.Color; import java.awt.Font;…scaling = calculateScale(v, height);//计算缩放比例 Buffered_Image_… java – 如何使用JNA正确地映射一个 2017年8月28日 - 我在我的Java_项目中使用jna.jar,jna-3.2.5.jar和jna-3.3.0-platform.jar。 这是我想要复制的Winapi函数。 BOOL WINAPI Mag_ImageScaling_Callback( _In… Image (Java Platform SE 7 ) Methods inherited from class java.lang.Object clone, equals, finalize, getClass…Use the Area Averaging image scaling algorithm. The image object is free … _java_代码实现图片处理功能。对图片质量进行压缩。 - 豌豆ip代理 2019年2月26日 - java图片处理有点头疼,找了很多资料。在这里进行一个汇总,记录下个人的体验,也…2,这种需要用到一个java-image-scaling-0.8.5.jar包。这种需要设定宽… _JAVA图像_缩放处理_百度文库 2015年12月22日 - import java.awt.image.Buffered_Image_; import java.io.File; import java.io….() // // Assumption: same horizontal and vertica l scaling facto… 使用Scalr调整大小时,透明背景的PNG会变黑 - 码客 2019年1月31日 - 使用Scalr调整大小时,透明背景的PNG会变黑 - 我使用org.imgscalr.Scalr(http://www.thebuzzmedia.com/software/imgscalr-_java-image-scaling_-library/… Java IText: Image 2014年5月24日 - This tutorial explains how to insert images into PDF files in Java using IText…. Java IText: Image_Creating an _Image Absolute Positioning S… java-pdf转png图片遇到的问题——CSDN问答频道 2018年7月13日 - (true); decode_pdf.scaling = 2f; /** set mappings for non-embedded …java.io.IOException; import java.util.Iterator; import javax._image_io.I… Jerry’s Java Image Processing Pages Java Image FiltersI have a large number of Java Image filters which are …BicubicScaleFilter - Scaling with bicubic interpolation CircleFilter - Wrap an… Java - resize image without losing quality - 码农人生 2019年6月3日 - I have 10,000 photos that need to be resized so I have a Java program to do t… Mentioned in Chris Campbell’s blog about scaling in Java, p… Java JAI image-io jpeg2000 Memory Leak fix 2011年3月24日 - One of our customers sent in a support request regarding a memory leak which was assigned to me to investigate. It actually turned out to … free_image_4_java_ download | SourceForge.net Download free_image_4_java_ for free. Java wrapper of Free_Image_ library. Free_Image_4_Java_ provides a JNI wrapper of Free_Image_ library _Java_方法android.widget._Image_View.set_Scale_Y代码示例 - 纯净天空 Java Image_View.setScaleY使用的例子?那么恭喜您, 这里整理的方法代码示例例程将…Params.WRAP_CONTENT, FrameLayout.LayoutParams.WRAP_CONTENT); if (m_Scaling… Maven Repository: com.mortennobel » java-image-scaling Java Image Scaling The purpose of the library is to provide better image scaling options than the Java runtime provides… Java SWT Image 图像 —— 放大 缩小 _Scaling__xmind-CSDN博客 2012年1月19日 - stretch or shrink the image, and there are two ways to do achieve this….开源之美!java-image-scaling 阅读数 29 项目主页:http://code.google.com/… Java_——_Image 图片合并 - atyang - 博客园 2014年4月10日 - com.tb.image; import java.awt.Image; import java.awt.image.Buffered_Image_; import java.io.File; import java.io.FileOutputStream; import… _java_方面图形/_图像_处理 - it_man的专栏 - CSDN博客 2012年5月27日 - java-image-scaling 可用来生成高质量的图像缩略图。 更多_java-image-scaling_信息 Java 图像处理框架 Processing Processing 是一个为想要图像处理程… _JAVA图像_缩放处理 - 网络大豆 - 博客园 2014年2月18日 - import java.awt.image.Buffered_Image_;import java.io.File;import java.io.File…() // // Assumption: same horizontal and vertical scaling factor // …","link":"/2020/04/02/%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BB%98%E5%9B%BE/"},{"title":"2.深入Java系列之虚拟机栈","text":"深入理解JVM-java虚拟机栈 - 姿势帝 - 博客园 2019年7月11日 - 3. _Java虚拟机栈_描述的是_Java_方法执行的内存模型:每个方法执行的同时会创建一个栈帧。 对于我们来说,主要关注的stack栈内存,就是_虚拟机栈_中局部变量… JVM 系列 - 内存区域 - Java 虚拟机栈(三) - 简书 2018年12月4日 - 特点Java 虚拟机栈(Java Virtual Machine Stacks)是线程私有的,生命周期随着线程,线程启动而产生,线程结束而消亡。 Java _虚拟机栈_描述的是… _java虚拟机栈_空间_Yohohaha的博客-CSDN博客 2019年4月20日 - 翻译自:https://www.geeksforgeeks.org/_java_-virtual-mac… _Java虚拟机栈_是线程私有的,它描述的是_Java_方法执行的内存模型:每个方法在执行的同时会创… _Java虚拟机_运行时栈帧结构–《深入理解_Java虚拟机_》学习…_博客园 2018年1月2日 - 栈帧是什么?栈帧是一种数据结构,用于_虚拟机_进行方法的调用和执行。…实例方法的调用时,局部变量表的第0位是一个指向当前对象的引用,也就是_Java_里… 深入理解_Java虚拟机栈_的栈帧_没头脑遇到不高兴-CSDN博客 2019年8月25日 - 本节将会介绍一下_Java虚拟机栈_中的栈帧,会对栈帧的组成部分(局部变量表、操作数栈、动态链接、方法出 _Java虚拟机_—栈帧、操作数栈和局部变量表 - 知乎 2018年9月27日 - 前言:在之前的文章:_Java_虚拟机—堆、栈、运行时数据区 中,我们整体介绍了JVM在运行时的一些数据区域如堆、方法区、程序计数器、_虚拟机栈_、本地方法栈。本篇… _Java虚拟机_的堆、栈、_堆栈_如何去理解? - 知乎 2016年1月21日 - 我只片面的知道堆和堆栈是一种存储结构,栈是一种数据结构… 本地方法栈(Native Method Stack)和_Java虚拟机栈_类似,区别在于_Java虚拟机栈_是为了_Java_方… 探究Java 虚拟机栈 - CSDN 2017年10月7日 - Java 虚拟机的内存模型分为两部分:一部分是线程共享的,包括 Java 堆和方法区;另一部分是线程私有的,包括_虚拟机栈_和本地方法栈,以及程序计数器这一小部分内存。… _Java虚拟机栈_的五点内部结构|其他|观点|犀牛代理 - 原创文…_站酷 2019年3月27日 - _Java_虚拟机管理的内存包括几个运行时数据内存:方法区、_虚拟机栈_、堆、本地方法栈、程序计数器(PCR Program Counter Register)。其中方法区和堆是线程… JVM_虚拟机栈_——_JAVA_方法的消亡史-沙漏半杯-51CTO博客 2019年4月1日 - Java虚拟机(JVM)是基于栈结构的,其中的“栈”指的就是操作数栈。 在代码的实际运行中,每个线程都会创建一个JVM栈存储栈帧(frame)。每当有方法调用时,frame就会… jvm - [Java]对象的实例存放在Java虚拟机栈(VM Stack)的什么位置… 2018年6月20日 - obj是对象的实例,广义上讲是存放在「栈」上,指向「堆」上的内存地址;具体讲,我的印象里obj应该是存放在运行时数据区的虚拟机栈(VM Stack)上,我知道虚… 浅析_JAVA虚拟机_的栈与堆 2017年7月14日 - 浅析_JAVA虚拟机_的栈与堆 一,数据类型 _Java虚拟机_中,数据类型可以分为两类:基本类型和引用类型。基本类型的变量保存原始值,即:他代表的值就是数值本身;而引用类型… _java虚拟机栈_溢出-CSDN论坛 2015年11月13日 - 最近在看《深入理解_java_虚拟机》,看到_虚拟机栈_溢出,有个地方很不解: 如果线程请求的栈深度大于虚拟机所允许的最大深度,将抛出StackOverFlowError异常;… 栈帧——深入理解Java虚拟机 - 程序员大本营 栈帧——深入理解Java_虚拟机,程序员大本营,技术文章内容聚合第一站。… 我们的_Java_运行时数据区包括线程独占区中的_Java虚拟机栈,_Java虚拟机栈_中的“元素”就是栈… 面试专题(JVM 虚拟机)丶一个站在_Java_后端设计之路的男青年个人… 2018年11月7日 - java 栈:线程私有,生命周期和线程,每个方法在执行的同时都会创建一个 栈帧用于…方法区:也叫永久区,用于存储已经被_虚拟机_加载的类信息,常量(“zdy”,”123”等)… Java _虚拟机栈_的垃圾是怎样回收的? - V2EX 2019年3月21日 - 注意,是_虚拟机栈_314 次点击所在节点 问与答Ad 0 条回复 第1 页/共 1 页Ad 这是一个专为移动设备优化的页面(即为了让你能够在 Google 搜索结果里秒开这… _Java虚拟机_的堆,栈,_堆栈_如何去理解? 堆内存用来存储_Java_中的对象。无论是成员变量,局部变量,还是类变量,它们指向的对象都存储在堆内存中。独有还是共享_栈_内存归属于单个线程,每个线程都会有一个_栈_内存… jvm中_虚拟机栈_的使用-虚拟机- 阿里云 jvm中_虚拟机栈_的使用阿里云虚拟主机主要用于搭建网站。提供预装网站运行环境、赠送正版数据库、可通过图形化控制面板管理,包括独享系列虚机和共享系列虚机。独享系列适合… JVM之_虚拟机栈__云博客_云社区-华为云 2019年12月24日 - 【推荐】2019_Java_开发者跳槽指南.pdf(吐血整理)&gt;&gt;&gt; _java虚拟机栈_描述的是_java_方法执行的是内存模型,它也是线 Java虚拟机(JVM)_堆栈_区域 - Break易站 2018年4月27日 - 对于每个线程,JVM在线程创建时创建一个单独的堆栈。_Java虚拟机堆栈_的内存不需要是连续的。_Java_虚拟机仅在_Java堆栈_上直接执行两个操作:它推送和弹出帧… _Java虚拟机_的堆、栈、_堆栈_如何去理解? - 素染年华 - 博客园 2018年4月12日 - _Java虚拟机_的堆、栈、_堆栈_如何去理解? 堆是堆(heap),栈是栈(stack),_堆栈_是栈。 栈中分配的是基本类型和自定义对象的引用。 堆中分配的是对象,也就是ne… _Java_虚拟机之_虚拟机栈_与本地方法栈 - IBLiplus的博客 - CSDN博客 2018年8月13日 - 虚拟机栈 与程序计数器一样,_Java虚拟机栈_也是线程私有的,它的生命周期与线程相同。虚拟机描述的是_Java_方法执行的内存模型: 每个方法在执行的同时都会… _JAVA虚拟机_结构之栈帧_LZ的博客-CSDN博客 2018年9月12日 - 概述(Stack Frame)栈帧(Stack Frame) 是用于虚拟机_执行时方法调用和方法执行时… _Java _虚拟机_的解释执行引擎称为“基于栈的执行引擎”,这里的栈就是… Java虚拟机栈 - 立志变成_java_巨头_CSDN博客 2019年3月29日 - 一_Java虚拟机栈_概念。_Java虚拟机栈_中存储的内容,它用于存储数据和部分过程结果的数据结构,同时也被用来处理动态链接/方法返回值和异常分派.一个完整的栈帧包括:局部… java虚拟机栈 - FigSprite - 博客园 2019年3月2日 - java虚拟机栈 作用: 用于存储局部变量、操作数栈、动态链接、方法出口等信息。 特点: 1.线程私有 2.生命周期与线程相同 工作特点: 1.局部变量表(虚拟… _Java虚拟机之栈帧的组成结构__java,虚拟机,栈帧_mine_so…_CSDN博客 2017年5月10日 - 在Java_虚拟机规范中,_Java_栈(_Java Stack)也可以被称之为Java虚拟机栈(Java Virtual Machine Stack),它同PC寄存器一样都是线程私有的,并且生命周期与线… _Java虚拟机栈_和本地方法栈 - 托马斯的半亩地 - 博客园 2016年9月9日 - 4. Re:_Java虚拟机栈_和本地方法栈 @ 黄登科别理我之前的胡说八道;我自己再去了解了一下,大致理解如下:一个Native Method就是一个_java_调用非_java_代码的… JVM _虚拟机栈_详解 - 奔波儿灞_CSDN博客 2017年11月28日 - 当Java_虚拟机运行程序时。每当一个新的线程被创建时。_Java 虚拟机都会分配一个虚拟机栈,_Java虚拟机栈_是以帧为单位来保存线程的运行状态。_Java_栈只会有… Java 虚拟机栈 - luzhensmart的专栏_CSDN博客 2018年7月27日 - java栈_保存的主要内容为栈帧,每一次函数调用,都会有一个对应的栈帧被压入_java…无论是_Java虚拟机_内部产生的异常,还是代码中使用athrow字节码指令产生… JVM _虚拟机栈_详解_向振华的博客-CSDN博客 2018年11月9日 - 栈帧(Stack Frame) 是用于支持_虚拟机_进行方法调用和方法执行的数据结构,它是虚拟…在 _Java_程序被编译为 Class文件时,就在方法的 Code属性的max_local… _Java虚拟机_之栈帧 - Code菜菜的世界 - 博客园 2019年1月31日 - _Java虚拟机_之栈帧 写在前面的话:_Java虚拟机_是一门学问,是众多_Java_大神们的杰作,由于我个人水平有限,精力有限,不能保证所有的东西都是正确的,这里内容… 深入理解JVM-java虚拟机栈 - 姿势帝 - 博客园 2019年7月11日 - 3. _Java虚拟机栈_描述的是_Java_方法执行的内存模型:每个方法执行的同时会创建一个栈帧。 对于我们来说,主要关注的stack栈内存,就是_虚拟机栈_中局部变量… _Java虚拟机栈_动态扩展是个什么概念?汗血宝马 2018年3月28日 - 看到有说:如果虚拟机栈_可以动态扩展(大部分虚拟机允许动态扩展,也可以设置固定大小的_虚拟机栈) 这个动态扩展是个什么概念?jvm中如何设置? Warning: Il… _java虚拟机栈_栈帧过大(线程私有的数据区)StackOve…_ChinaUnix博客 2013年11月13日 - 虚拟机栈_和本地方法栈溢出 StackOverflowError 关于_虚拟机栈_和本地方法栈,在 _Java 虚拟机规范中描述了两种异常: 如果线程请求的栈深度大于虚拟机所允… 深入Java虚拟机(十):运行时栈帧结构 - 码农教程 2019年2月17日 - 本文章向大家介绍深入Java虚拟机(十):运行时栈帧结构,主要包括深入Java虚拟机(十):运行时栈帧结构使用实例、应用技巧、基本知识点总结和需要注意事项,… 理解_java虚拟机_内存分配堆,栈和方法区 2016年5月30日 - _java虚拟机_就会在栈中 根据类的模板 加载出一个类信息 stu1 类中方法实现是固定的,_java_给每一个方法都分配了一个地址,需要使用方法的时候… _Java虚拟机_的堆、栈、_堆栈_如何去理解? - 知乎 2015年4月25日 - 普通Java 程序使用的就是process virtual memory. 上图中最顶端的一部分内存叫做user stack. 这就是题目问的 stack. 中间有个 runtime heap。就是题目… _Java虚拟机_如何执行的-百度经验 2019年7月16日 - _Java虚拟机_如何执行的,在_java_开发中,理解jvm的运行是非常重要的,这里一起探讨下,通过编写一个_java_类,然后编译成cla文件,通过工具,查看cla文件的指令步… jvm 本地方法栈(native Method stacks) 基本概念 - java 技术细节… 2014年9月3日 - Java 虚拟机 运行时数据区域 一般可区分为 :方法区,堆,Java虚拟机栈,本地方法栈和程序计数器。 其中Java虚拟机栈 为虚拟机执行Java 方法服务,本地方法… 深入理解_Java虚拟机_之类运行时栈帧结构-简祥-51CTO博客 2018年9月16日 - 栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构,它是虚拟机运行时数据区中的虚拟机栈(Virtual Machine Stack)的栈元素。栈帧存… _java虚拟机栈_深度是什么意思?-CSDN论坛 2013年4月20日 - 对_Java虚拟机栈_深度的理解 在读“深入理解_Java_虚拟机”一书时看到这个概念:在_Java_虚拟机规范中,对这个区域规定了两种异常状况:如果线程请求的栈深度大… 详细解析_Java虚拟机_的栈帧结构 - 知乎 2020年1月14日 - 什么是栈帧? 正如大家所了解的,_Java_虚拟机的内存区域被划分为程序计数器、_虚拟机栈_、本地方法栈、堆和方法区。(什么?你还不知道,赶紧去看看《_Java_虚拟… Java _虚拟机栈_的垃圾是怎样回收的? - V2EX 2019年3月21日 - 问与答 - @tlriavsihd - 注意,是虚拟机栈… 注意,是虚拟机栈 目前尚无回复 机栈_Java_回收垃圾关于 · FAQ · API · 我们的愿景 · 广告投放 · 感谢 ·… 深入了解_Java_之_虚拟机_内存_VMStack 2018年9月3日 - 作者:feifei 来自:http://itfeifei.win/2017/03/13/深入了解_Java_之_虚拟机_内存/ 在讨论JVM内存区域分析之前,先来看一下_Java_程序具体执行的过程: _Java_程… _JAVA虚拟机_内存(栈,堆,方法区) - 程序员大本营 _JAVA虚拟机_内存(栈,堆,方法区),程序员大本营,技术文章内容聚合第一站。… 一、_java虚拟机_的内存可以分为三个区域:栈stack 、堆heap、方法区method area 1. 栈… _Java_内存管理运行时数据区域之_Java虚拟机栈_与本地方法栈 2019年9月9日 - 通常我们说的栈(Stack),即Java虚拟机栈(Java Vritual Stacks) ,与程序计数器类似,也是“线程私有”的,与线程生死与共,依赖于线程的启动和结束而建立与销毁。虚拟… _Java虚拟机栈_动态扩展是个什么概念? - 的回答 - SegmentFault 思否 2018年2月11日 - 看到有说:如果虚拟机栈_可以动态扩展(大部分虚拟机允许动态扩展,也可以设置固定大小的_虚拟机栈) 这个动态扩展是个什么概念?jvm中如何设置?阅读… _JAVA虚拟机_规范_百度文库 此区域是虚拟机规范中没有规定 任何 OutOfMemoryError 情况的区域。 Java 虚拟机栈 Java 虚拟机栈_也是线程私有的,生命周期与线程相同。_虚拟机栈_描述的是 _Java …","link":"/2020/03/31/%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97%E4%B9%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"},{"title":"用于 Flutter 开发人员的新工具，内置于 Flutter","text":"发布新版本的 Dart DevTools，我们的工具套件用于对 Dart 和 Flutter 代码进行调试和性能分析。它在Flutter中从零开始重建。此版本添加了一些改进，例如对性能和内存页的更新，以及一个全新的网络页。 许多人知道 Flutter 的热重新加载功能，允许您在移动应用运行时对其进行更改。但是，热重新加载只是我们为您提供的一套工具之一，可帮助您编写、测试、调试和分析你的应用。 让我们先花点时间讨论一下为什么我们首先重建了 DevTools。简短的回答是生产力和质量。Flutter 团队了解 Flutter 在构建美观、高性能的 UIs 时带来的生产力优势，我们希望这些好处。这种工作效率不仅使我们能够重建 DevTools，而且在此过程中添加新功能。 我们选择将 DevTools 作为 Web 应用程序发货，因为我们很容易集成到所有目标平台和 IDEs 的现有工具体验中。以网络为头脑的建设也使我们能够走在客户的立场上;在此过程中，我们了解了（并修复了）一些性能问题，如滚动性能。 我们还一直在评估作为编译的桌面应用程序运输 DevTools 的好处，到目前为止，结果很有希望。选择 Flutter 的一个主要好处是，选择分发模型是我们在编写代码_后_可以做的事情，而不是我们必须做出的第一个决定。许多客户还告诉我们，这是一个有吸引力的功能，Flutter。 现在，我们已经讨论了一些关于 DevTools 的近过去和新的未来，让我们深入了解每个 Flutter 开发人员可用的_所有主要_工具的快速概述。因为 DevTools 并不是唯一值得您关注的工具。 基础知识当然，有该工具，它在调试模式下运行你的应用，执行热重新加载，生成APK和IPA，以及更多。该工具以 Dart 编写，并在命令行上运行，因此无论您喜欢哪个操作系统或编辑器，您都可以使用 Flutter。 Dart 分析服务器在各种 IDE 中提供静态分析和智能。这意味着您能够完成代码… 这恰好是VS代码，但这里的所有示例当然在 Android Studio 中也起作用。 …错误突出显示链接到有关如何修复它们的文档… 对于最常见的静态错误，IEs 链接到错误消息的较长版本，包括示例代码和常见修补程序。 …和聪明的绒毛。 在这里，分析器检测创建 Sink 但从不关闭 - 可能存在内存泄漏。 分析服务器也可以使用语言服务器协议，这意味着使用它的所有开发人员工具（并且有许多）可以很容易地支持它。 UI 代码帮助器使用 Flutter，您可以通过创建小部件树在代码中构建 UI。这意味着许多 Dart 代码以嵌套构造函数的形式出现，如下所示： return MaterialApp( title: ‘My app’, home: Scaffold( appBar: AppBar( title: Text(‘Welcome’), ), body: Column( … ), ),); 颤动工具使使用这样的代码变得更加容易。UI 指南突出显示要构建的小部件树。 左侧的行称为 UI 参考线，显式可视化小部件树。 尾随注释可以显示哪个方括号属于哪个小部件。 此处的注释由 IDE 显示，但实际上不是文件的一部分。 智能重构可帮助您在几个笔画中修改树，例如用新父项包装树的一部分… 用大小框包装图标按钮。 …和移动小部件周围。 开发工具然后是 DevTools，一套在浏览器中运行的独立工具套件。它们提供了其他遥测和功能，这些遥测和功能在 IDE 中不实用。 开发人员工具在浏览器窗口中打开。 我们本周推出的 DevTools 是用”颤动”编写的。（它们以前用飞镖编写，但不使用 Flutter 框架。这是从头开始完全重写，这为改进 UI 和添加全新的功能提供了机会。 第一个选项卡是“飘飘”检查器，它是一个用于可视化和探索飞溅小部件树的工具。在此处，您可以在正在运行的应用中选择小部件、减慢所有动画速度、查看文本基线等。 新功能之一是布局资源管理器，您可以在”详细信息树”旁边的”飘动检查器”选项卡中找到该功能。布局资源管理器允许您检查 Flutter 的灵活布局模型。当您不确定为什么一排小部件看起来不像您预期的那样时，或者为什么您收到”RenderFlex 溢出 42 像素”错误时，这可能是一个救命稻草。 在”动态检查器”选项卡旁边，您将找到三个专用于性能分析的选项卡：时间轴视图、内存视图和性能视图。 “时间轴”视图现在显示每个帧的生成时间以及火焰图。这样，在上下文中查看有问题的帧时，可以轻松地识别有问题的帧。 “时间轴”窗格还具有新的”轨道小部件生成”按钮，该按钮将应用中所有小部件的生成时间添加到时间线（牺牲配置文件生成性能为代价 - 这是默认情况下不打开的原因）。当您试图找出哪些小部件，确切地说，在慢帧后面时，这很方便。 通过“内存”视图，您可以查看应用在给定时刻如何使用内存。此视图现在显示已分配内存的热图，并允许跟踪平台内存。 性能视图是传统的 CPU 探查器。它允许您记录应用的会话，并查看 CPU 在哪些功能中花费了大部分时间。这通常用于决定将优化工作花费在何处。 DevTools甚至包括它自己的调试器。如果您不使用 IDE 进行开发，但仍希望添加断点、单步执行代码、查看变量值等，则此功能非常有用。 下一个选项卡是完全新的。”网络”视图允许您检查网络流量。您猜到了。您可以看到应用自启动以来发出的请求的整个历史记录，以及有关每个请求的详细信息。这样，在尝试调试网络问题时，您不必自行记录这些事件。”网络”选项卡当前显示 HTTP 流量;”网络”选项卡当前显示 HTTP 流量。未来的改进包括显示一般套接字 I/O 流量。 现在，您还可以在时间轴视图中查找网络请求，以便在上下文中看到这些请求。 “日志记录”视图显示来自应用和框架的事件。有了它，您可以轻松地筛选消息（例如，您可以指定筛选出垃圾回收器事件，或仅显示帧事件）。在 Dart 中，日志记录消息可以结构化，日志记录视图会利用这一点。 1-gc 1flutter.frame DevTools 适用于移动应用、桌面应用_和_Web 应用。 将 DevTools 重写为 Flutter 具有许多好处：提高生产率、在客户的鞋子中行走以及自由选择目标平台。我们没有提到的一个好处是：在 Flutter 中重建 DevTools 会邀请社区更轻松地做出贡献。DevTools 总是在开放中开发，但今天，大多数用户将熟悉其结构（从 ） 中开始。 1runApp(DevToolsApp(…) 1[lib/main.dart](https://zshipu.com/t?url=https://github.com/flutter/devtools/blob/master/packages/devtools_app/lib/main.dart#L14-L16) 总结工具对于 Flutter 开发人员体验至关重要。我们投入巨资，使之天更美好。但是，我们只能根据您的反馈做到这一点。 因此，立即升级到最新的 DevTools，并在你的应用中进行测试。 阅读文档以了解所有隐藏的宝石。文件错误，如果你找到他们，或投票给GitHub上的新功能。","link":"/2020/06/25/%E7%94%A8%E4%BA%8E%20Flutter%20%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84%E6%96%B0%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%86%85%E7%BD%AE%E4%BA%8E%20Flutter/"},{"title":"拜读无闻大神Go web编程 - 第 02 课：基础模板用法","text":"初识文本模板引擎标准库中的 text/template 包是 Go 语言内置的文本模板引擎，虽然在灵活性上不如其它语言中第三方框架自带的模板引擎（如 Django、Ruby on Rails 等等），但功能依旧十分强大。根据标准库给出的定义，它的主要特性如下： 将模板应用于给定的数据结构来执行模板，模板的编码与 Go 语言源代码文件相同，需为 UTF-8 编码 模板中的注解（Annotation）会根据数据结构中的元素来执行并派生具体的显示结构，这些元素一般指结构体中的字段或 map 中的键名 模板的执行逻辑会依据点（Dot，&quot;.&quot;）操作符来设定当前的执行位置，并按序完成所有逻辑的执行。 模板中的行为（Action）包括数据评估（Data Evaluation）和控制逻辑，且需要使用双层大括号（{.{ 和 }}）包裹。除行为以外的任何内容都会原样输出不做修改。 模板解析完成后，从设计上可以并发地进行渲染，但要注意被渲染对象的并发安全性。例如，一个模板可以同时为多个客户端的响应进行渲染，因为输出对象（Writer）是相互独立的，但是被渲染的对象可能有各自的状态和时效性。 接下来，让我们结合上节课所学的知识，从一个最简单的例子开始学习使用 Go 语言中的文本模板引擎。简单起见，我们依旧从输出 “Hello world!” 字符串开始。 1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot; &quot;text/template&quot;)func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { // 创建模板对象并解析模板内容 tmpl, err := template.New(&quot;test&quot;).Parse(&quot;Hello world!&quot;) if err != nil { fmt.Fprintf(w, &quot;Parse: %v&quot;, err) return } // 调用模板对象的渲染方法 err = tmpl.Execute(w, nil) if err != nil { fmt.Fprintf(w, &quot;Execute: %v&quot;, err) return } }) log.Println(&quot;Starting HTTP server...&quot;) log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))} 如果运行上面的代码，就会发现和上节课的输出毫无区别，并且在作为处理器的匿名函数中增加了更多的逻辑。 ➜ curl http://localhost:4000Hello world! 相比之前多出来的这部分逻辑便是创建、解析和渲染模板的必要步骤： template.New 的作用就是根据用户给定的名称创建一个模板对象，本例中我们使用了 “test” 字符串作为这个模板对象的名称。另外，由于 template.New 函数会直接返回一个 *template.Template 对象，因此可以直接链式操作调用该对象的 Parse 方法 template.Parse 方法接受一个 string 类型的参数，即文本模板的内容，然后对内容进行解析并返回解析过程中发生的任何错误。本例中，我们使用了没有任何模板语法的 “Hello world!” 字符串，同时获得了两个返回值。第一个返回值依旧是一个 *template.Template 对象，此时该对象已经包含了模板解析后的数据结构。第二个返回值便是在解析过程中可能出现的错误，这要求我们对该错误进行检查判断。 如果模板解析过程没有产生任何错误则表示模板可以被用于渲染了，template.Execute 就是用于渲染模板的方法，该方法接受两个参数：输出对象和指定数据对象（或根对象）。简单起见，本例中我们只使用到了第一个参数，即输出对象。凡是实现了 io.Writer 接口的实例均可以作为输出对象，这在 Go 语言中是非常常见的一种编码模式。 在模板中渲染变量学会了模板渲染的基本操作之后，我们就可以开始向模板中输出一些动态的内容了。首先，我们来快速了解一下怎么获取 HTTP 协议中 GET 请求的 URL 查询参数（即问号 “?” 之后的内容）。例如，我们想要获取 “/?val=123” 中的 “val” 的值，并返回给客户端。 123456789101112131415package mainimport ( &quot;log&quot; &quot;net/http&quot;)func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(r.URL.Query().Get(&quot;val&quot;))) }) log.Println(&quot;Starting HTTP server...&quot;) log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))} 我们这里用到的方法就是 *http.Request 对象的 URL.Query().Get 方法。通过终端执行可以获得如下结果，你还可以尝试赋予 “val” 其它的值，服务端也会输出对应的内容。 ➜ curl http://localhost:4000/?val=123123 现在，我们可以结合模板语法，将这个 “val” 的值进行渲染了。 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot; &quot;text/template&quot;)func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { // 创建模板对象并解析模板内容 tmpl, err := template.New(&quot;test&quot;).Parse(&quot;The value is: {.{.}}&quot;) if err != nil { fmt.Fprintf(w, &quot;Parse: %v&quot;, err) return } // 获取 URL 参数的值 val := r.URL.Query().Get(&quot;val&quot;) // 调用模板对象的渲染方法 err = tmpl.Execute(w, val) if err != nil { fmt.Fprintf(w, &quot;Execute: %v&quot;, err) return } }) log.Println(&quot;Starting HTTP server...&quot;) log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))} 在上面的代码中，你可以注意到模板的内容被替换为了 The value is: {.{.}}，即使用了分隔符将点操作符包裹起来。在 Go 语言的标准库模板引擎中，点操作符默认指向的是根对象，即我们在调用 template.Execute 方法时传入的第二个参数。本例中，我们传入的根对象是一个单纯的 string 类型的变量 val，那么点操作符的渲染对象就是变量 val。 尝试运行以上代码可以在终端获得以下结果： ➜ curl http://localhost:4000/?val=666The value is: 666 至此，我们就成功地对 text/template 包提供的文本模板引擎实现了第一次动态输出啦！ 在模板中渲染复杂对象你是否也正在思考，除了简单类型的变量，根对象还可以是什么类型呢？细心的你可能已经发现，template.Execute 方法的第二个参数类型为 interface{}，也就是说可以传入任何类型。这代表 text/template 包提供的文本模板引擎会根据所提供的根对象进行底层类型分析，然后自动判断应该以什么样的形式去理解模板中的语法。以点操作符为例，如果根对象为变量，那么点操作符代表的就是一个变量；而如果根对象为一个复合类型，那么点操作符所代表的也就是这个复合类型。 让我们来创建一个名为 Inventory 的复合类型，然后通过 URL 查询参数的值创建一个实例，最后通过模板渲染出各个字段的值： 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( ... &quot;strconv&quot;)type Inventory struct { SKU string Name string UnitPrice float64 Quantity int64}func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { // 创建模板对象并解析模板内容 tmpl, err := template.New(&quot;test&quot;).Parse(`InventorySKU: {.{.SKU}}Name: {.{.Name}}UnitPrice: {.{.UnitPrice}}Quantity: {.{.Quantity}}`) ... // 根据 URL 查询参数的值创建 Inventory 实例 inventory := &amp;Inventory{ SKU: r.URL.Query().Get(&quot;sku&quot;), Name: r.URL.Query().Get(&quot;name&quot;), } // 注意：为了简化代码逻辑，这里并没有进行错误处理 inventory.UnitPrice, _ = strconv.ParseFloat(r.URL.Query().Get(&quot;unitPrice&quot;), 64) inventory.Quantity, _ = strconv.ParseInt(r.URL.Query().Get(&quot;quantity&quot;), 10, 64) // 调用模板对象的渲染方法 ... }) log.Println(&quot;Starting HTTP server...&quot;) log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))} （为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。） 以上代码主要有两部分变动，第一部分是修改了模板内容（注意代码中使用反引号而非双引号）： InventorySKU: {.{.SKU}}Name: {.{.Name}}UnitPrice: {.{.UnitPrice}}Quantity: {.{.Quantity}} 你可以注意到，使用分隔符包裹起来的内容和 Inventory 类型中的字段名称是一一对应的，且大小写保持一致（Go 语言是一门大小写敏感的语言）。模板中使用了点操作符指代根对象 inventory，即通过 URL 查询参数的值所创建的一个变量。这里用到了 strconv 包中的 ParseFloat 和 ParseInt 函数，主要作用为解析字符串为浮点型和整型数字，感兴趣的同学可以自行阅读文档进行更加深入了解。 尝试运行以上代码可以在终端获得以下结果： ➜ curl http://localhost:4000/?sku=1122334&amp;name=phone&amp;unitPrice=649.99&amp;quantity=833InventorySKU: 1122334Name: phoneUnitPrice: 649.99Quantity: 833 我们看到，修改根对象为一个复合类型也可以轻易地使用标准库的文本模板引擎进行渲染。 在模板中调用结构的方法我们已经讲解了如何在模板中显示具体对象的字段值，那么，是不是也可以使用同样的方式来调用对象所具有的方法呢？答案当然是肯定的。 我们需要先为 Inventory 类型添加一个方法，称为 Subtotal，即根据该商品的单价和数量来显示当前库存所具有的价值。 1234// Subtotal 根据单价和数量计算出总价值func (i *Inventory) Subtotal() float64 { return i.UnitPrice * float64(i.Quantity)} 然后在模板中添加相关的内容，使得计算结果能够通过模板渲染展示给客户端。 12345678910... // 创建模板对象并解析模板内容 tmpl, err := template.New(&quot;test&quot;).Parse(`InventorySKU: {.{.SKU}}Name: {.{.Name}}UnitPrice: {.{.UnitPrice}}Quantity: {.{.Quantity}}Subtotal: {.{.Subtotal}}`)... （为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。） 可以注意到，在 text/template 包提供的文本模板引擎中，显示方法调用结果的值和字段的值的语法是完全相同的，即不需要在方法名称后使用括号表示调用。该模板引擎会在渲染时自动识别所调用对象的具体类型，然后做出相应的操作。 尝试运行以上代码可以在终端获得以下结果： ➜ curl http://localhost:4000/?sku=1122334&amp;name=phone&amp;unitPrice=649.99&amp;quantity=833InventorySKU: 1122334Name: phoneUnitPrice: 649.99Quantity: 833Subtotal: 541441.67 使用 map 类型作为模板根对象我想聪明的你已经意识到将某个具体类型作为模板根对象的局限性，因为不论想要展示什么内容，都需要通过修改添加类型的字段或方法才能实现，在操作上非常的不灵活。但是，如果你还记得根对象的参数类型为 interface{} 的话，应该就不难理解通过利用一个 map[string]interface{} 类型的根对象，可以实现灵活地向模板中添加需要被渲染的子对象。 这种方案可行的根本原因是因为在 Go 语言中，当 interface{} 类型作为参数时，调用者可以传入任意类型的值，效果类似 Java 中的 Object 类型。 接下来，让我们通过使用 map[string]interface{} 类型作为根对象，实现之前展示 Inventory 类型中字段值的效果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot; &quot;strconv&quot; &quot;text/template&quot;)func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { // 创建模板对象并解析模板内容 tmpl, err := template.New(&quot;test&quot;).Parse(`InventorySKU: {.{.SKU}}Name: {.{.Name}}UnitPrice: {.{.UnitPrice}}Quantity: {.{.Quantity}}`) if err != nil { fmt.Fprintf(w, &quot;Parse: %v&quot;, err) return } // 获取 URL 查询参数的值 // 注意：为了简化代码逻辑，这里并没有进行错误处理 sku := r.URL.Query().Get(&quot;sku&quot;) name := r.URL.Query().Get(&quot;name&quot;) unitPrice, _ := strconv.ParseFloat(r.URL.Query().Get(&quot;unitPrice&quot;), 64) quantity, _ := strconv.ParseInt(r.URL.Query().Get(&quot;quantity&quot;), 10, 64) // 调用模板对象的渲染方法，并创建一个 map[string]interface{} 类型的临时变量作为根对象 err = tmpl.Execute(w, map[string]interface{}{ &quot;SKU&quot;: sku, &quot;Name&quot;: name, &quot;UnitPrice&quot;: unitPrice, &quot;Quantity&quot;: quantity, }) if err != nil { fmt.Fprintf(w, &quot;Execute: %v&quot;, err) return } }) log.Println(&quot;Starting HTTP server...&quot;) log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))} 在以上代码中，我们将 URL 查询参数赋值给多个变量，然后将所有变量以键值对的形式生成一个 map[string]interface{} 类型的临时对象作为模板的根对象。相比之前需要先定义一个 Inventory 类型而言，这种方式可以更加灵活便利地将对象放置到模板中用于渲染。 尝试运行以上代码可以在终端获得与之前相同的结果： ➜ curl http://localhost:4000/?sku=1122334&amp;name=phone&amp;unitPrice=649.99&amp;quantity=833InventorySKU: 1122334Name: phoneUnitPrice: 649.99Quantity: 833 许多 Web 框架的实现都是基于这个小技巧，如果之前还不明所以的话，现在应该知道这其中的原理了吧？ 在模板中使用注释虽然目前我们所使用的模板文本还都非常简单，但当模板内容变多、逻辑更加复杂的时候就会想要使用注释来进行辅助理解，便于后期的维护和开发。在这节课的最后，我们来学习如何在 text/template 包提供的文本模板引擎中进行注释的语法。 注释的语法和 Go 语言程序代码中的块注释语法相同，即使用 /* 和 */ 将注释内容包括起来，例如：{.{/* 这是注释内容 */}}。 简单修改一下我们已有的模板文本，就可以发现如同源代码中的注释一样，模板中的注释会在模板的解析阶段被剔除： 12345678910... // 创建模板对象并解析模板内容 tmpl, err := template.New(&quot;test&quot;).Parse(`{.{/* 打印参数的值 */}}InventorySKU: {.{.SKU}}Name: {.{.Name}}UnitPrice: {.{.UnitPrice}}Quantity: {.{.Quantity}}`)... （为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。） 尝试运行以上代码可以在终端获得与之前相同的结果： ➜ curl http://localhost:4000/?sku=1122334&amp;name=phone&amp;unitPrice=649.99&amp;quantity=833 InventorySKU: 1122334Name: phoneUnitPrice: 649.99Quantity: 833 注意 “Inventory” 字符串之前多了一个空行，就是模板文本中注释所在的那一行。 小结这节课，我们学习了标准库中 text/template 包提供的文本模板引擎的基础用法，了解了模板渲染和根对象的概念，并学会了有关根对象类型的一个小技巧。","link":"/2019/11/11/%E7%AC%AC-02-%E8%AF%BE%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF%E7%94%A8%E6%B3%95/"},{"title":"拜读无闻大神Go web编程 - 第 03 课：进阶模板用法","text":"在模板中定义变量变量不仅是 Go 语言中程序代码的重要组成部分，同样也是模板引擎中的主要元素。因为只有通过定义和操作变量，才能使得模板引擎在逻辑和用法上更加灵活和便利。 text/template 包提供的文本模板引擎支持使用字母数字（Alphanumeric）作为变量的名称，并使用一个美元符号（$）作为前缀，例如：$name、$age 和 $round2。在模板中的定义语法和程序代码中类似，即使用 := 连接变量名和赋值语句。 123456789101112131415161718192021222324252627282930313233343536package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot; &quot;text/template&quot;)func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { // 创建模板对象并解析模板内容 tmpl, err := template.New(&quot;test&quot;).Parse(`{{$name := &quot;Alice&quot;}}{{$age := 18}}{{$round2 := true}}Name: {{$name}}Age: {{$age}}Round2: {{$round2}}`) if err != nil { fmt.Fprintf(w, &quot;Parse: %v&quot;, err) return } // 调用模板对象的渲染方法 err = tmpl.Execute(w, nil) if err != nil { fmt.Fprintf(w, &quot;Execute: %v&quot;, err) return } }) log.Println(&quot;Starting HTTP server...&quot;) log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))} 尝试运行以上代码可以在终端获得以下结果： ➜ curl http://localhost:4000Name: AliceAge: 18Round2: true不难发现，这个示例的核心就是包含变量使用的模板内容： 123456{{$name := &quot;Alice&quot;}}{{$age := 18}}{{$round2 := true}}Name: {{$name}}Age: {{$age}}Round2: {{$round2}} 在这里，我们需要注意的是以下三点： 变量的定义（或首次获得赋值）必须使用 := 的语法。获取变量值时，直接在相应位置使用美元符号加上变量名称即可。所有有关变量的操作都属于模板语法的一部分，因此需要使用双层大括号将其包裹起来。那么，在变量被定义之后，如何修改变量的值呢？很简单，只需要和程序代码中那样，直接使用等号（=）即可。 1234567891011121314... // 创建模板对象并解析模板内容 tmpl, err := template.New(&quot;test&quot;).Parse(`{{$name := &quot;Alice&quot;}}{{$age := 18}}{{$round2 := true}}Name: {{$name}}Age: {{$age}}Round2: {{$round2}}{{$name = &quot;Bob&quot;}}Name: {{$name}}`)... （为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。） 尝试运行变动后的代码可以在终端获得以下结果： ➜ curl http://localhost:4000Name: AliceAge: 18Round2: trueName: Bob感兴趣的同学可以尝试一下，如果重复使用 := 的语法给相同名称的变量多次赋值会发生什么呢？ 在模板中使用条件判断（if 语句）标准库 text/template 包供的文本模板引擎除了可以进行单纯的数据展示外，还能够像程序代码那样进行基本的逻辑控制，而逻辑控制语句中最常见的便是 if 语句了。 接下来，我们需要编写一个能够进行除法运算的 Web 服务，即通过 URL 查询参数接收两个值，分别为 x 和 y（被除数与除数），然后进行 x/y 的运算，再将运算结果返回给客户端。由于除法的特殊性，当 y 为 0 的时候是无法进行运算的。因此，我们需要在 y 等于 0 的时候提示客户端参数错误（利用模板的 if 语句）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( ... &quot;strconv&quot;)func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { // 创建模板对象并解析模板内容 tmpl, err := template.New(&quot;test&quot;).Parse(`{{if .yIsZero}} 除数不能为 0{{else}} {{.result}}{{end}}`) if err != nil { fmt.Fprintf(w, &quot;Parse: %v&quot;, err) return } // 获取 URL 查询参数的值 // 注意：为了简化代码逻辑，这里并没有进行错误处理 x, _ := strconv.ParseInt(r.URL.Query().Get(&quot;x&quot;), 10, 64) y, _ := strconv.ParseInt(r.URL.Query().Get(&quot;y&quot;), 10, 64) // 当 y 不为 0 时进行除法运算 yIsZero := y == 0 result := 0.0 if !yIsZero { result = float64(x) / float64(y) } // 调用模板对象的渲染方法 err = tmpl.Execute(w, map[string]interface{}{ &quot;yIsZero&quot;: yIsZero, &quot;result&quot;: result, }) if err != nil { fmt.Fprintf(w, &quot;Execute: %v&quot;, err) return } }) ...} （为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。） 以上代码的逻辑非常简单，即首先通过程序判断除数 y 是否为 0，然后将判断结果和可能的除法运算结果都赋值到 map 类型的根对象中。 在模板中，我们需要将条件语句放置在 if 关键字之后，使用空格将它们分隔，并将整个语句使用分隔符 进行包裹。需要注意的是，条件语句必须要返回一个布尔类型（bool）的值，本例中 yIsZero 变量自身即是 bool 类型的值，因此不需要再做额外的类型转换。 尝试运行以上代码可以在终端获得以下结果： ➜ curl http://localhost:4000?x=1&amp;y=20.5➜ curl http://localhost:4000?x=1&amp;y=0除数不能为 0本例中展示的条件语句十分简单，但在实际开发过程中，if 语句通常会被大量使用，然后根据给定的条件判断渲染出不同的内容。 模板中的等式与不等式如果所有的条件判断都只能在程序代码中完成，然后直接输出给模板计算好的条件，未免有点太不方便了。因此，Go 语言的文本模板引擎同样可以在模板中完成等式与不等式的判断，为更加复杂的条件判断提供了必要的支持。 用于等式与不等式判断的函数主要有以下六种（均接受两个，分别名为 arg1 和 arg2 的参数）： eq：当等式 arg1 == arg2 成立时，返回 true，否则返回 falsene：当不等式 arg1 != arg2 成立时，返回 true，否则返回 falselt：当不等式 arg1 &lt; arg2 成立时，返回 true，否则返回 falsele：当不等式 arg1 &lt;= arg2 成立时，返回 true，否则返回 falsegt：当不等式 arg1 &gt; arg2 成立时，返回 true，否则返回 falsege：当不等式 arg1 &gt;= arg2 成立时，返回 true，否则返回 false如果你对这些函数的名字感到奇怪，其实不难发现这些名字本质上就是相关英文的缩写。如 “eq” 是 “equal” 的缩写，”ne” 表示 “not equal”，”lt” 表示 “less than“，”le” 表示 “less than or equal” 等等。 接下来，我们就结合目前所学的知识，将更多的判断逻辑放置到模板当中完成。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot; &quot;text/template&quot;)func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { // 创建模板对象并解析模板内容 tmpl, err := template.New(&quot;test&quot;).Parse(`{{$name1 := &quot;alice&quot;}}{{$name2 := &quot;bob&quot;}}{{$age1 := 18}}{{$age2 := 23}}{{if eq $age1 $age2}} 年龄相同{{else}} 年龄不相同{{end}}{{if ne $name1 $name2}} 名字不相同{{end}}{{if gt $age1 $age2}} alice 年龄比较大{{else}} bob 年龄比较大{{end}}`) if err != nil { fmt.Fprintf(w, &quot;Parse: %v&quot;, err) return } // 调用模板对象的渲染方法 err = tmpl.Execute(w, nil) if err != nil { fmt.Fprintf(w, &quot;Execute: %v&quot;, err) return } }) log.Println(&quot;Starting HTTP server...&quot;) log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))} 在这个例子中，我们使用到了 eq、ne 和 gt 三个函数。尝试运行以上代码可以在终端获得以下结果： ➜ curl http://localhost:4000年龄不相同名字不相同bob 年龄比较大你可能会对这个例子中 if 条件语句的用法感到怪异，这是因为 eq、ne 和 gt 等本质上属于函数，而函数的调用都是以 函数名称（参数 1，参数 2，…） 的形式，只是在大部分情况下，Go 语言标准库提供的这套模板引擎可以在语法上省略括号的使用。 在模板中使用迭代操作（range 语句）除了可以在模板中进行条件判断以外，Go 语言标准库提供的模板引擎还支持通过 range 语句进行迭代操作，以方便直接在模板中对集合类型的数据进行处理和渲染。 Go 语言中一般来说有三种类型可以进行迭代操作，数组（Array）、切片（Slice）和 map 类型。 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot; &quot;text/template&quot;)func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { // 创建模板对象并解析模板内容 tmpl, err := template.New(&quot;test&quot;).Parse(`{{range $name := .Names}} {{$name}}{{end}}`) if err != nil { fmt.Fprintf(w, &quot;Parse: %v&quot;, err) return } // 调用模板对象的渲染方法 err = tmpl.Execute(w, map[string]interface{}{ &quot;Names&quot;: []string{ &quot;Alice&quot;, &quot;Bob&quot;, &quot;Carol&quot;, &quot;David&quot;, }, }) if err != nil { fmt.Fprintf(w, &quot;Execute: %v&quot;, err) return } }) log.Println(&quot;Starting HTTP server...&quot;) log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))} 上例中的代码作用非常简单，即先通过 map[string]interface{} 类型的根对象传递一个名为 “Names” 的切片，该切片包含了四个人名。然后通过模板的 range 语句对这个切片进行迭代，依次输出每个人名。 值得注意的是，这里我们使用的语法结构为 range $name := .Names，其中 .Names 是被迭代的集合，而变量 $name 则是当次迭代中获取到的单个对象。在本例中，变量 $name 实际上为 string 类型。 尝试运行以上代码可以在终端获得以下结果： ➜ curl http://localhost:4000AliceBobCarolDavidrange 语句除了可以获取到当次迭代的对象以外，还能够和 Go 语言源代码中一样，获取到一个当前迭代所对应的索引值。 123456789101112...func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { // 创建模板对象并解析模板内容 tmpl, err := template.New(&quot;test&quot;).Parse(`{{range $i, $name := .Names}} {{$i}}. {{$name}}{{end}}`)... （为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。） 尝试运行以上代码可以在终端获得以下结果： ➜ curl http://localhost:40000. Alice Bob Carol David可以看到，通过使用语法结构 range $i, $name := .Names，我们可以再获取变量 $name 的同时获取变量 $i （索引）的值。 就模板语法而言，迭代不同类型的集合是没有区别的，我们可以来看一下如何在模板中对 map 类型的集合进行迭代操作： 1234567891011121314151617181920212223242526...func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { // 创建模板对象并解析模板内容 tmpl, err := template.New(&quot;test&quot;).Parse(`{{range $name, $val := .}} {{$name}}: {{$val}}{{end}}`) ... // 调用模板对象的渲染方法 err = tmpl.Execute(w, map[string]interface{}{ &quot;Names&quot;: []string{ &quot;Alice&quot;, &quot;Bob&quot;, &quot;Carol&quot;, &quot;David&quot;, }, &quot;Numbers&quot;: []int{1, 3, 5, 7}, }) ...} （为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。） 尝试运行以上代码可以在终端获得以下结果： ➜ curl http://localhost:4000Names: [Alice Bob Carol David]Numbers: [1 3 5 7]上例中，我们通过直接迭代作为根对象的 map，然后打印其中所包含的键值对。和迭代其它类型集合的唯一不同在于，语法结构 range $name, $val := . 获得到的第一个变量不再是索引，而是当次迭代所对应的键名。 在模板中使用语境操作（with 语句）在学习如何使用语境操作（with 语句）之前，我们先来看一看下面的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot; &quot;text/template&quot;)type Inventory struct { SKU string Name string UnitPrice float64 Quantity int64}func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { // 创建模板对象并解析模板内容 tmpl, err := template.New(&quot;test&quot;).Parse(`InventorySKU: {{.Inventory.SKU}}Name: {{.Inventory.Name}}UnitPrice: {{.Inventory.UnitPrice}}Quantity: {{.Inventory.Quantity}}`) if err != nil { fmt.Fprintf(w, &quot;Parse: %v&quot;, err) return } // 调用模板对象的渲染方法 err = tmpl.Execute(w, map[string]interface{}{ &quot;Inventory&quot;: Inventory{ SKU: &quot;11000&quot;, Name: &quot;Phone&quot;, UnitPrice: 699.99, Quantity: 666, }, }) if err != nil { fmt.Fprintf(w, &quot;Execute: %v&quot;, err) return } }) log.Println(&quot;Starting HTTP server...&quot;) log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))} 本例中，我们定义和创建了一个 Inventory 类型的对象，并将它放入对根对象中，关联键名为 “Inventory”。尝试运行以上代码可以在终端获得以下结果： ➜ curl http://localhost:4000InventorySKU: 11000Name: PhoneUnitPrice: 699.99Quantity: 666这里我们要关注的并不是程序的运行结果，而是模板的内容： 12345InventorySKU: {{.Inventory.SKU}}Name: {{.Inventory.Name}}UnitPrice: {{.Inventory.UnitPrice}}Quantity: {{.Inventory.Quantity}} 不难发现，为了能够渲染 “Inventory” 的每一个值，我们都需要先通过点操作获取根对象中键名为 “Inventory” 的对象，然后再通过第二次点操作才能获取到具体某个字段的值。 在模板内容较少的情况下，这样的做法没有什么问题，但如果 “Inventory” 对象需要被使用非常多次数，或者甚至我们需要通过多次点操作才能获取到我们所要获得的值呢？例如：.Storage.Repository.Inventory。在这种情况下，模板的内容就会显得非常冗余。 为了解决这个问题，就可以使用语境操作（with 语句）啦！学习使用过 Visual Basic 的同学可能会对 with 语句的用法和作用比较熟悉。 123456789101112131415...func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { // 创建模板对象并解析模板内容 tmpl, err := template.New(&quot;test&quot;).Parse(`Inventory{{with .Inventory}} SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}}{{end}}`)... （为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。） 尝试运行以上代码可以得到和之前一模一样的运行结果。 在使用了 with 语句之后，是不是觉得模板内容更加简洁易懂了呢？ 模板中的空白符号处理细心的你可能已经发现，在运行之前示例的时候，终端得到的响应实际上会带有多余的空行，例如： ➜ curl http://localhost:4000Inventory SKU: 11000 Name: Phone UnitPrice: 699.99 Quantity: 666 这是因为我们在编写模板内容的时候，为了格式上的清晰加入了这些空行。如果我们想要更加整洁的输出结果的话，就可以使用 Go 语言标准库模板引擎的一个特殊语法，。表示剔除模板内容右侧的所有空白符号。 123456789101112131415...func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { // 创建模板对象并解析模板内容 tmpl, err := template.New(&quot;test&quot;).Parse(`Inventory{{- with .Inventory}} SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}}{{- end}}`)... （为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。） 这里需要特别注意减号两侧的空格，如果没有使用空格将减号与模板中其它内容分开的话，会被模板引擎误以为是表达式的一部分。例如，使用 则会报如下错误： unexpected bad number syntax: “-w” in command小结这节课，我们主要学习了标准库中 text/template 包提供的文本模板引擎的逻辑控制、集合对象迭代和空白符号处理的用法。 下节课，我们将基于这节课所学的基础用法上，进一步学习如何在 Go 语言提供的模板引擎中使用自定义模板、模板函数和响应 HTML 内容。","link":"/2019/11/11/%E7%AC%AC-03-%E8%AF%BE%EF%BC%9A%E8%BF%9B%E9%98%B6%E6%A8%A1%E6%9D%BF%E7%94%A8%E6%B3%95/"},{"title":"获取微信公众号 signature","text":"_微信公众号_JSSDK_获取signature_签名_Java_wang_97的博客-CSDN博客 2019年6月14日 - 1、_获取微信公众号signature_需要有三个参数—appId、appsecret、urlappId和appsecret只需登录“微信公众平台”–“开发”–“基本设置”url则是前台… _微信公众号_JSSDK_获取signature_签名以及config配置_Java…_CSDN博客 2019年4月2日 - appId: ‘’, // 必填,公众号_的唯一标识 timestamp: , // 必填,生成签名的时间戳 nonceStr: ‘’, // 必填,生成签名的随机串 _signature: ‘’,// 必填,签名… 微信公众号_开发调用jssdk,配置完成提示 invalid _signature? 2019年10月18日 - 在发起支付调用wx.chooseWXPay时,提示invalid signature;想问下_微信公众平台_上的js安全域名和_获取_JSAPI授权TICKET时的url有关系么?我的js安全域名是xx… _微信_JS-SDK_获取signature_签名以及config配置_园荐_博客园 2019年12月18日 - _微信_JS-SDK_获取signature_签名以及config配置 2019-12-18 13:48 − jsapi_ticket 生成签名之前必须先了解一下jsapi_ticket,jsapi_ticket是_公众号_用于调… 关于微信_签名_signature获取 - zhangchenguang - 博客园 2017年9月13日 - 关于微信签名_signature获取 微信_分享的签名算法微信也写有,主要是调用接口需要使用服务器(微信官方文档是这么说的,试了下前端居然特么也可以),不过微… _微信获取signature_并自定义分享功能 - ThinkPHP框架 2016年12月6日 - 微信_要求我们要_获取,因为微信_的access_token和jsapi…下来就要开始_获取signature_值,也是最重要的一步… _微信_JS-SDK_获取signature_签名以及config配置 - 总有一天,你的日积… 2017年12月15日 - 生成签名之前必须先了解一下jsapi_ticket,jsapi_ticket是_公众号_用于调用_微信_JS接口…戳、随机数、签名一定要跟main方法中_获取_到的一致,否则会报inval… _微信公众号_之:JSSDK接入以及invalid _signature_等常见错误…_博客园 2018年8月20日 - 最近在搞微信公众号_开发,进行到网页开发部分被坑了一天,最坑的问题就是invalid _signature,而网上大部分解答这个问题的都没有说清楚,都直接丢文档。博… _微信公众号_实战:生成_signature_、_获取_access_token并缓存… 2018年6月3日 - { // 将微信_服务器的请求数据分别存为变量 $_signature = input(‘get.signature‘); $timestamp = input(‘get.timestamp’); $nonce = input(‘get.nonce’… 基于微信_签名_signature获取(实例讲解)_java_脚本之家 2017年9月14日 - 下面就为大家带来一篇基于微信_签名_signature获取(实例讲解)。小编觉得挺不错的,现在就分享给大家,也给大家做个参考。一起跟随小编过来看看吧 解决微信_jssdk 签名错误 invalid _signature - 简书 2017年6月12日 - 按照微信的官网自定义分享功能,引入jssdk ,结果调试,一直报错 签名错误,invalid _signature_。 按照_微信公众平台_的开发文档,签名错误排查方法如下: inva… Java_获取微信_JS-SDK的_signature_签名 - 编程那点事 2018年5月2日 - debug: false, // 必填,公众号_的唯一标识 appId: “wx8d881cf642e0e22d”, …签名 _signature: data.signature, // 必填,需要使用的JS接口列表 jsApiLis… 微信_js_获得_签名_signature - java ssm ssh - ITeye博客 2017年3月14日 - 备注: jsapi_ticket是_公众号用于调用_微信_JS接口的临时票据。正常情况下,jsapi…2). 对string1进行sha1签名,得到signature:f4d90daf4b3bca3078ab1558… 微信–_获取jsapi_ticket 然后在计算出_signature 2015年3月27日 - 生成签名之前必须先了解一下jsapi_ticket,jsapi_ticket是公众号_用于调用_微信_JS…//_获取_jssdk所需签名 public string _Signature(string url) { string… 微信公众平台, config:invalid _signature_一直爆这个错误,求教如何… 2015年8月13日 - 微信公众号_之:JSSDK接入以及invalid _signature_等常见错误问题 最近在搞_微信公众号_开发,进行到网页开发部分被坑了一天,最坑的问题就是invalid _signatur… _微信_卡券JSAPI _signature_报签名错误? - 知乎 2016年7月2日 - 单独的一个api_ticket,获取_方式是不一样的,具体可见链接:_微信公众平台 中下面…2.将所有参数字符串拼接成一个字符串进行sha1加密,得到signature_。 3._… _微信_jssdk踩坑之签名错误invalid _signature__javascript技巧_脚本… 2020年5月19日 - 分享后的链接仍然是首页进入的链接,这是_微信_的BUG啊,原来在_微信_的网页中不支持 pushState ,这就导致我们在jssdk从配置时传入的 url( window.location… 微信公众号(二)config接口注入权限验证配置-_signature_无效的情况… 2019年1月25日 - 本文章向大家介绍微信公众号(二)config接口注入权限验证配置-signature_无效的情况,主要包括_微信公众号(二)config接口注入权限验证配置-_signature_无效… 微信公众平台_Java调试JS-SDK接口, 一直提示这个invalid _signature 2016年3月25日 - 微信公众平台_Java调试JS-SDK接口, 一直提示这个invalid _signature 1.利用接口签名校验工具,签名是一致的。 2.后台java签名代码 public static Map&lt;Str… 微信公众平台, config:invalid _signature_怎么解决?_百度知道 2018年1月13日 - 回答：如果是invalid _signature_签名错误。建议按如下顺序检查: 1.确认签名算法正确,可用 http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign… java 获取公众号_签名_signature,_微信_JS-SDK中config接口…_CSDN博客 2019年4月9日 - _微信公众号_token验证查看了一些_微信公众号_平台的开发文档,得知签名验证需要以下参数签名验证规则是:1.开发者服务端_获取得到signature_、timestamp、non… _微信公众号_开发之_获取微信_用户的openID - zhangzongjian - 博客园 2015年10月20日 - 微信公众号_开发之_获取微信_用户的openID (注:openID同一用户同一应用唯一,UnionID…服务端编写接口,参数为(_signature,timestamp,nonce,echostr),并原样返回echostr … _微信公众号_Token验证 _signature_验证_qq_21834227的博客-CSDN博客 2019年5月22日 - 首先去公众号的后台配置 URL,然后在 代码 的页面验证Token代码为$signature = $… _微信公众号_开发时,前端向后端发送请求_获取signature_和openID时出现… 微信_开发生成测试签名–_signature,并使用微信_jssdk_获取…_CSDN博客 2018年7月10日 - 如:_公众号_的测试appID,appSecret,域名的配置,签名生成等。进而使用_微信获取_位置接口_获取_位置。本方案适用后台服务没开发出之前测试使用,后台服务完成… _微信_JS-SDK_获取signature_签名以及config配置_CaseyWei-CSDN博客 2018年9月27日 - 生成签名之前必须先了解一下jsapi_ticket,jsapi_ticket是_公众号_用于调用_微信_JS接口…戳、随机数、签名一定要跟main方法中_获取_到的一致,否则会报inval… _微信公众号_开发:如何实现公众号的token验证和_signature_校验_Java… 2020年1月1日 - 上一篇推文中我们讲述了开发公众号_所需要的准备工作,本文讲解如何搭建工程,如何…//_获取微信_服务器传来的相关参数 String _signature = req.getParame… …进行微信_认证,_获取_签名_signature(修改版)_java_zhao…_CSDN博客 2019年9月10日 - 2.3这么说,要认证签名signature,就要获取_jsapi_ticket;要_获取_jsapi_ticket,就先…4.4碰到这样一个问题,_微信_认证的AppId和秘钥,不是小程序的,是_公众号… _微信公众号_JSSDK invalid _signature_签名问题_weixin_43…_CSDN博客 2019年5月5日 - 情况是这样的,自己负责开发的_微信公众号_一直有用微信的jssdk来_获取_用户的位置信息,本来好好的,可突然有一天发现出现了invalid _signature_无效签名的错… c#微信公众号_开发二—_获取_timestamp/nonce/_signature-布布扣… 2019年11月19日 - 二、获取_timestamp/nonce/_signature timestamp时间戳 public static string timestamp(){ TimeSpan ts = DateTime.UtcNow - new DateTime(1970, 1, 1,… JS如何获取微信signature - 讨论组 - WordPress 果酱 2017年2月19日 - JS如何获取微信signature sailolo - 2017-02-19 谢谢 推荐阅读 关于WordPress …关注公众号 WPJAM(WordPressJAM) 快速链接 联系Denis / 广告投放 微… 微信公众号 JSSDK 提示:invalid signature-云栖社区-阿里云 2017年10月12日 - 要命的invalid _signature_。其实腾讯的文档已经写了,只能怪我自己理解能力太差,掉…_微信公众平台_开发(106) 网页_获取_用户地理位置 方倍工作室 2015-05… c#微信公众号_开发二—-_获取_timestamp/nonce/_signature – 软件… 2020年1月6日 - 二、获取_timestamp/nonce/_signature timestamp时间戳 public static string timestamp(){ TimeSpan ts = DateTime.UtcNow - new DateTime(1970, 1, 1,… 微信公众平台 check_Signature_(官方验证消息真实性方法) 导致回复… 2014年3月6日 - 使用PHP开发微信公众平台, 官方提供的示例代码中的 check_Signature_ 函数,导致回复的消息经常性的丢失。 _微信_分享链接出现config:invalid _signature_错误的解决方法_余斗… 2018年4月18日 - 最多的错误而且解决最麻烦的大概就是signature_错误了…一般出现这个错误多半是签名_获取_失败,而造成签名_获取…后记:_微信公众号_官方并没有就签名错误… _微信公众号_接口学习 - 知乎 2020年4月18日 - signature * @return */ public boolean check_Signature_(String timestamp, …openid 是微信_用户在 _公众号 的唯一身份标识。 _获取_用户基本信息(Union… 【_微信_开发_获取_一个消息来源】-博文推荐-CSDN博客 2018年2月1日 - 最近开始写_微信公众号_了,作为小白的我,有些懵,参考各种大神写的博客,总算实现了…开发者_获得_加密后的字符串可与_signature_对比,标识该请求来源于微信 … 微信_js_获得_签名_signature 2015年3月12日 - 2 获取 jsapi_ticket备注: jsapi_ticket是公众号_用于调用_微信_JS接口的临时票据…3). 将wx.config接口需要的参数值都放入缓存中(即_signature,noncestr… 解决微信_jssdk 签名错误 invalid _signature - 简书 2017年6月12日 - 按照微信的官网自定义分享功能,引入jssdk ,结果调试,一直报错 签名错误,invalid _signature_。 按照_微信公众平台_的开发文档,签名错误排查方法如下: inva… NodeJS _微信_公共号开发 - _获取_并缓存 access_token 和 jsapi… 2018年4月27日 - 背景使用 NodeJS 进行_微信_公共号开发,后端调用各接口时都需使用 access_token,前端调用 js-api 则需要后端根据 jsapi_ticket 生成 _signature_。由于 ac… _微信公众号_中的JSSDK接入及invalid _signature_等常见错误问题分析(… 2020年4月11日 - 最近在搞微信公众号_开发,进行到网页开发部分被坑了一天,最坑的问题就是invalid _signature,而网上大部分解答这个问题的都没有说清楚,都直接丢文档。博… _微信_开发之使用java_获取_签名_signature_图文介绍-_微信_开发-PHP中文网 2017年3月15日 - 这篇文章主要为大家详细介绍了微信_开发之使用java_获取_签名_signature,感兴趣的小伙伴们可以参考一下 微信公众号_开发调用jssdk,配置时总是 invalid _signature ,提示… 2019年9月19日 - 差了错误代码之后,发现是非法签名,好了,我先去了https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign这个校验网站校验了,_signature_ 没有问题… 微信公众平台_一直都是invalid _signature - 的回答 - SegmentFault… 2015年8月8日 - 最近在研究微信公众平台_开发,在配置的时候遇到问题了(按照官方文档上操作的),一直都是提示:error: invalid _signature _微信公众平台_后台接入简明指南 - 廖雪峰的官方网站 2014年1月18日 - 如果_signature_计算无误,就把_微信_后台传过来的echostr原封不动地传回去,这样,就可以…关于作者 关注_公众号_不定期领红包: 关注微博_获取_实时动态:廖雪峰… _微信公众号获取_签名 - 简书 2019年7月27日 - 微信公众平台-&gt;开发-&gt;基本配置image.png3.配置ip白名单 配置该域名下的ip4…createJsapi_Signature_(url); //wxJsapi_Signature_中可以直接_获取_签名信息 … 微信–_获取jsapi_ticket 然后在计算出_signature - deerou…_博客园 2015年3月27日 - 生成签名之前必须先了解一下jsapi_ticket,jsapi_ticket是公众号_用于调用_微信_JS接口…1 //_获取_jssdk所需签名 2 public string _Signature(string url) … _微信公众平台_安全模式URL签名验证出问题的可以来看看 - 程序员… 在记录之前先先吐槽一下公众平台_的文档和demo吧,腾讯这么大个公司写的文档还是…sha1加密 3)开发者_获得_加密后的字符串可与_signature_对比,标识该请求来源于_微信… 《急》微信公众号_开发 jssdk 分享 63002,invalid _signature? 2019年11月12日 - 微信公众号_开发JSSDK 1.4.0分享接口invalid _signature 小程序WebView 调用JSSDK 提示63002,invalid signature? 相关文档 微信认证指引: 小程序/运营/… _微信公众号_开发 demo 项目示例 - 黑客派 2018年3月9日 - 本文主要分享_微信公众号_开发的 demo 项目示例,并介绍项目中的一些内容。…WeiXinFrontController 接收对应 url 的 get 请求,_获取_参数 _signature_、tim… _微信_二次分享报错invalid _signature_问题及解决方法_javascript技… 2019年4月1日 - 基于_微信公众号_开发的h5页面(使用jssdk接口),由用户A分享给用户B,用户B再次分享这个页面时,不能成功分享。这篇文章主要介绍了微信二次分享报错invalid…","link":"/2020/05/27/%E8%8E%B7%E5%8F%96%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%20signature/"},{"title":"通用编码规范","text":"[TOC] 1 前言 2 代码风格 2.1 结构 2.1.1 缩进 2.1.2 空格 2.1.3 空行 2.1.4 换行 2.2 命名 2.3 注释 3 语言特性 3.1 变量 3.2 语句 3.3 函数 4 附录 1 前言1.1 说明有些编程规范是大部分编程语言通用的，特把它独立出来。 示例中我采用 Java 语言。有时也混杂其他语言。 本编码规范完全适用于 Java 和 Javascript 的编程规范，对其他语言也有借鉴作用。 1.2 好的编码规范什么样的规范才算是好的编程规范？ “大家好，才是真的好”。不是你觉得好就是好，而是绝大部分人都觉得这个编程规范好，才是一份好的规范。当然，如果你的编程风格与主流的不符合，我的建议是：强迫自己改正。 本编程规范主要参考 Google Java 编程规范，并且绝大部分规范符合谷歌编程规范，除了以下几点与其不同： 代码缩进。谷歌建议缩进 2 个空白符；本规范建议缩进 4 个空白符。 好像没了？想到再补充。 此外，本规范还参考了百度等互联网大公司的编程规范，主要是对谷歌编程规范的补充（谷歌编程规范不够详细，所涉及的规范主要是编程风格的） 当然，也有一些个人的见解。 1.3 基本准则[建议] 坚持一致原则维护别人写的代码，应当遵守一致原则。即修改后的代码的编程风格应该与之前的代码一致。 使用必读不同的要求严格程度不同，参照 RFC2119 分成三个等级： [强制] 表示必须（MUST）或者不允许（MUST NOT）这样做。 [建议] 表示一般情况下应该（SHOULD）或者不应该（SHOULD NOT）这样做，但是在某些特定情况下可以忽视这个要求。 [可选] 表示这个要求完全是可选的，你可以（MAY）这样做，也可以不这样做，视个人喜好而定。 2 代码风格2.1 结构2.1.1 缩进[强制] 采用 4 个空格缩进而不是 2 个空格或 tab 字符虽然谷歌推荐 2 个空格的缩进，但 4 个空格缩进的代码可读性明显更强。现在很多代码编辑器支持输入时自动把 tab 字符转化为 4 个空格符。 每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。 12345678// goodvoid foo() { int a = 0;}// bad int a = 0;} [强制] 所有的块状结构都要缩进12345void foo() { if (condition) { // statement }} [强制] switch 语句缩进要合理12345678910switch (foo) { case 1: // code break; case 1: // code break; default: break; } 2.1.2 空格[强制] 注释时，注释符两边的空白符必不可少 双斜杠后面的空格必不可少。 如果在一条语句后做注释，则双斜杠两边都要一个空格。 可以允许多个空格，但没有必要。 12345678910// goodint foo = 0; // 这是一个注释示例/* 这是一个注释示例 *//** 这是一个注释示例 */// badint foo = 0; //这是一个注释示例int foo = 0;// 这是一个注释示例/*这是一个注释示例*//**这是一个注释示例*/ [强制] 任何保留字（如if, while for等等）与紧随其后的左括号之间要有一个空格123456789// goodif (foo == 0) {}// badif(foo == 0) {} [强制] 任何保留字(如else、catch等)与其前面的右大括号之间要有一个空格12345678910111213// goodif (foo == 0) {} else {}// badif(foo == 0) {}else {} [强制] 任何左大括号 { 前必须加一个空格两个例外： @SomeAnnotation({a, b})(不使用空格)。 String[][] x = foo;(大括号间没有空格)。 [强制] 在任何二元或三元运算符的两侧必须有空格这也适用于以下“类运算符”符号：类型界限中的&amp;(&lt;T extends Foo &amp; Bar&gt;)。catch块中的管道符号(catch (FooException | BarException e)。foreach语句中的分号。 12345// goodint i = 1 + 2;// badint i = 1+2; [强制] 一元运算符与操作对象之间不允许有空格1234567891011// goodif (!isOk) {}i++;// badif (! isOk) {}i ++; [强制] 在 ,、:、; 及右括号 ) 后必须空格12345for (int i = 0; i &lt; 100; i++) {}int i = (int) 3.5f; [建议] 数组初始化中，大括号内的空格是可选的123new int[] {5, 6};new int[] { 5, 6 }; [强制] 行尾不得有多余的空格[强制] 本规范没有要求的空格不要随便乱加几个经典的错误例子： 1234567891011// goodvoid foo(int i) {}// badvoid foo (int i) {}// badvoid foo( int i) {}// badvoid foo(int i ) {} [建议] 水平对齐，没这个必要，也不建议这么做虽然增加了代码的可读性，但给维护带来问题。很多时候为了保持对齐，做了一些无用功。所以即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。 1234567// goodint foo = 1;String s = &quot;foo&quot;;// badint foo = 1;String s = &quot;foo&quot;; 2.1.3 空行[强制] 类内连续成员之间，必须有 1 个空行类内连续的成员（字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块等）之间，必须有一个空行 例外：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。 [建议] 类内的第一个成员前或最后一个成员后的空行是可选的既不鼓励也不反对这样做，视个人喜好而定。 [建议] 多个连续的空行是允许的，但没必要这样做，也不推荐这样做[建议] 在函数体内，语句的逻辑分组间使用空行这样做可增强代码的可读性 [建议] 没意义的空行不要乱加2.1.4 换行[强制] 列限制：80、100，还是 120？一个项目可以选择一行80个字符或100个字符的列限制。 我推荐 100 个字符。 任何一行如果超过这个字符数限制，必须换行。 例外： 不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。package和import语句(见3.2节和3.3节)。注释中那些可能被剪切并粘贴到shell中的命令行。 [建议] 自动换行的基本准则是：更倾向于在更高的语法级别处断开[强制] 如果在非赋值运算符处断开，那么在该符号前断开这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（&lt;T extends Foo &amp; Bar&gt;)，catch块中的管道符号(catch (FooException | BarException e) 1234567// goodint i = 1 + 2 + 3 + ... + 1000000 + 1000001；// badint i = 1 + 2 + 3 + ... + 1000000 + 1000001； [强制] 如果在赋值运算符处断开，通常的做法是在该符号后断开这条规则也适用于foreach语句中的分号 1234567// good，虽然在这里没必要换行int i = 100000000;// badint i = 100000000; [强制] 自动换行时函数名与左括号留在同一行[强制] 自动换行时逗号(,)与其前面的内容留在同一行[强制] 自动换行时第一行后的每一行至少比第一行多缩进 4 个空格[强制] 非空块得换行遵守 K &amp; R 风格对于非空块，大括号遵循Kernighan和Ritchie风格 (Egyptian brackets): 左大括号前不换行 左大括号后换行 右大括号前换行 如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。 Java的enum类有一些例外，在 Java 编程规范讲解。 12345678910111213141516171819202122232425// goodclass Foo { public void foo() { if (condition) { something(); } else { other(); } }}// badclass { }// badif (condition){ something();}else{ other();} [可选] 空块可以用简洁版本，不换行一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。 例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。 1void doNothing() {} 括号[强制] 函数的返回值不可以用括号包住不然会降低可读性。 12345// goodreturn count + 100;// badreturn (count + 100); [强制] 任何标识符的命名都不能采用拼音12345// goodclass Student {}// badclass Xuesheng {} 2.2 命名2.2.1 通用命名[建议] 良好的命名应该是自解释的良好的命名应该能够顾名思义，不需要注释 12345// goodint studentCount;// badint count; // 学生数量 [建议] 谨慎使用缩略词不常见的缩略词会降低代码的可读性。尽量避免缩写，除非该缩写是众所周知的，如HTML、URL等等。 1 [建议] 命名应该是简短且有意义的1 2.2.2 编程语言中的命名[强制] 类名、接口名以 UpperCamelCase 风格编写12345// goodclass Foo {...}// badclass foo {...} [强制] 类名使用名词或名词短语[建议] 接口使用形容词或形容词短语接口命名多以able或ible结尾 123interface Runable {...}interface Accessible {...} [强制] 测试类的命名以它要测试的类的名称开始，以 Test 结束12345class HashTest {}HashIntegrationTest {} [强制] 方法名以 lowerCamelCase 风格编写[建议] 方法名使用动宾短语也可以使用动词。 下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test_，例如testPop_emptyStack。 并不存在唯一正确的方式来命名测试方法。 123456789// goodvoid initView() {}void updateData() {}// not goodvoid init() {}void update() {} [强制] 常量名以 CONSTANT_CASE 风格编写全部字母大写，用下划线分隔单词。 那，到底什么算是一个常量？ 每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。 1234567891011121314// Constantsstatic final int NUMBER = 5;static final ImmutableList&lt;String&gt; NAMES = ImmutableList.of(&quot;Ed&quot;, &quot;Ann&quot;);static final Joiner COMMA_JOINER = Joiner.on(','); // because Joiner is immutablestatic final SomeMutableType[] EMPTY_ARRAY = {};enum SomeEnum { ENUM_CONSTANT }// Not constantsstatic String nonFinal = &quot;non-final&quot;;final String nonStatic = &quot;non-static&quot;;static final Set&lt;String&gt; mutableCollection = new HashSet&lt;String&gt;();static final ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);static final Logger logger = Logger.getLogger(MyClass.getName());static final String[] nonEmptyArray = {&quot;these&quot;, &quot;can&quot;, &quot;change&quot;}; 这些名字通常是名词或名词短语。 [建议] 减少代码中的硬编码代码中不允许出现直接硬编码的字面常量， 尤其是 重复出现 的硬编码。 你需要做的是把硬编码定义成常量。 如果常量只在一个类中用到，则在类中定义。否则可以在公共类中定义常量。 [强制] 常量必须用常量修饰符修饰12345// goodfinal int MAX_COUNT = 99;// badint int MAX_COUNT = 99; [强制] 非常量字段名以 lowerCamelCase 风格编写这些名字通常是名词或名词短语。 [强制] 参数名以 lowerCamelCase 风格编写。参数应该避免用单个字符命名。 [强制] 局部变量名以 lowerCamelCase 风格编写比起其它类型的名称，局部变量名可以有更为宽松的缩写。 虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。 即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。 允许在循环中使用单个字符的变量 避免在多重循环中同时使用 i 和 j 这种容易混淆的变量名 [建议] 类型变量可用以下两种风格之一进行命名 单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。 以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。 [建议] boolean 类型的变量命名以 is 或 has 开头12345// goodboolean isReady = false;// badboolean ready = false; [建议] 集合、数组类型的变量，常用名词复数12345678910// goodStudent student;Student[] students;List&lt;Student&gt; students;// not goodList&lt;Student&gt; someStudent;// badList&lt;Student&gt; list; 2.3 注释这里的注释不包括文档注释 [强制] 单行注释用 // 而不是 /* */[强制] 块注释与其周围的代码在同一缩进级别1234567891011// goodif (condition) { // 这是一段注释 something();}// badif (condition) {// 这是一段注释 something();} [强制] 多行注释可以是/* … /风格，也可以是// …风格。对于多行的/ … /注释，后续行必须从开始， 并且与前一行的*对齐123456789/* 这是一段很长很长很长...................很长 * 很长很长的注释。 */// 这也是一段很长很长很长...................很长// 很长很长的注释。/* 我不会告诉你这三种写法都是 * 可以的 */ [强制] 注释不要封闭在由星号或其它字符绘制的框架里。这样做很可能给维护带来不必要的麻烦 123456// bad/**************************************** * 这是一个 * 很漂亮但是没什么卵用注释 ***************************************/ [建议] 禁止没意义的注释1234567// badint foo; // 定义一个变量// 创建一个Foo类class Foo {} 为什么这里是建议，而不是强制？因为很多时候，判断一句注释是不是废话还跟开发者水平有关。 举个不是很恰当的例子： 1234567// bad// 创建一个线程并执行new Thread(new Runnable() { public void run() { something(); }}).start(); 稍微懂点 Java 的都知道这句注释是句废话，但对于一个刚入门，没接触过多线程的就不这么认为了，后面这条建议是对本条建议的补充说明： [建议] 注释一般不包含语言本身的语法、语言内置的API的说明、第三方类库（如 Spring 等）某个函数的用法的说明不懂的去看相应的开发文档。 [建议] 对整段代码进行注释说明，而不是逐行注释[建议] 只进行必要的注释，注释不是越多越好3 语言特性3.1 变量[强制] 每次只声明一个变量1234567891011// goodint foo;int foo2;// badint foo, foo2;// barvar foo = 1, foo2 = 2, foo3 = 3; [强制] 需要时才声明，并尽快进行初始化不要在一个代码块的开头把局部变量一次性都声明了，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。 变量声明与使用的距离越远，代码的阅读与维护成本就越高。 从优化方面讲，这样做也是有好处的。 [建议] 尽量使用局部变量Java： 尽量使用局部变量，调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快。其他变量，如静态变量、实例变量等，都在堆（Heap）中创建，速度较慢。另外，依赖于具体的编译器/JVM，局部变量还可能得到进一步优化 [建议] 变量在真正需要的时候才开始创建1234567891011// goodif (i == 1) { String str = &quot;abc&quot;; list.add(str);}// badString str = &quot;abc&quot;;if (i == 1) { list.add(str);} 3.2 语句[强制] 一行最多一个语句123456// goodint foo;int foo2;// badint foo; int foo2; [强制] 禁止连续赋值连续赋值不仅影响可读性，而且很多时候容易出错。 123456// gooda = 1;b = 1;c = 1;a = b = c = 1; [建议] 避免深层嵌套多级嵌套降低了代码的可读性。 [强制] 使用大括号，即使大括号是可选的大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。 12345678// goodif (i &gt; 0) { i++;}// badif (i &gt; 0) i++; 条件[可选] 对于相同变量或表达式的多值条件，用 switch 代替 if123456789101112131415161718// goodswitch (i) { case 1: // ...... break; case 2: case 3: case 4: // ...... break;}// badif (i == 1) { // ......} else if (i == 1 || i == 2 || i == 3) { // ......} [可选] 如果函数或全局中的 else 块后没有任何语句，可以删除 else1234567891011121314151617// goodfunction getName() { if (name) { return name; } return 'unnamed';}// badfunction getName() { if (name) { return name; } else { return 'unnamed'; }} 循环[建议] 避免在循环中重复获取长度123456789101112// badfor (int i = 0; i &lt; list.size(); i++) {}// goodfor (int i = 0, int size = list.size(); i &lt; size; i++) {}// goodint size = list.size();for (int i = 0, ; i &lt; size; i++) {} [建议] 嵌套循环将小循环写在外层1234567891011// goodfor (int i = 0; i &lt; 5; i++) { for (int k = 0; k &lt; 5000; k++) { }}// badfor (int k = 0; k &lt; 5000; k++) { for (int i = 0; i &lt; 5; i++) { }} [建议] 避免在循环中做耗时的工作 循环中不要使用try-catch()语句 不要在循环中调用synchronized(同步)方法 循环中不要频繁声明对象，对象可以在循环外创建 循环中尽量避免数据库查询操作等耗时的操作 …… 3.3 函数[建议] 函数的长度控制在 50 行以内太长的函数难以维护。 关于一个函数的规范行数没有统一标准，40行、60行也可以。 [建议] 函数的参数控制在 6 个以内面向对象[强制] 除非必要，否则不允许使用 public 修饰类的属性4 附录4.1 驼峰式命名法（CamelCase）驼峰式命名法分大驼峰式命名法(UpperCamelCase)和小驼峰式命名法(lowerCamelCase)。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。 名字从散文形式(prose form)开始: 把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：最后将所有的单词连接起来得到一个标识符。每个单词的第一个字母都大写，来得到大驼峰式命名。除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。示例： ： 12345678910111213// goodXmlHttpRequest // XML HTTP requestnewCustomerId // new customer IDinnerStopwatch // inner stopwatchsupportsIpv6OnIos // supports IPv6 on iOSYouTubeImporter // YouTube importerYoutubeImporter // 不推荐// badXMLHTTPRequestnewCustomerIDinnerStopWatchsupportsIPv6OnIOS Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名checkNonempty和checkNonEmpty也都是正确的。","link":"/2019/11/22/%E9%80%9A%E7%94%A8%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"title":"鉴权中心：Springboot+Springsecurity+Oauth2整合","text":"Springboot+Springsecurity+Oauth2整合（并用mysql数据库实现持久化客户端数据） 本文主要讲的是，实现oauth2的工作流程，对客户端数据用mysql数据库实现持久化。需要对oauth2.0概念有一定的基础知识了解。阅读前请学习oauth2.0的理论知识。文末有此项目代码地址。 介绍 建表 权限和用户的建立 Spring Security配置 Oauth2 的配置 Authorization Server - 授权服务器 Resource Server - 资源服务器 介绍在github上许多关于用springsecurity搭建oauth2的Demo，但是几乎所有的都是把注册的Client放到内存中的，也就是带有 clients.inMemory() 这种代码的，项目启动时，会把这个Client初始化到内存中。你一定会看到以下代码： 1234567public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory().withClient(&quot;client_1&quot;) .authorizedGrantTypes(&quot;client_credentials&quot;, &quot;refresh_token&quot;) .scopes(&quot;select&quot;) .authorities(&quot;oauth2&quot;) .secret(&quot;123456&quot;);} 然而这样在生产环境肯定是不行的！因为我们要对客户开放注册Client！我们要实现Client的注册，动态的加载到Oauth服务中。所以要实现Client的持久化，本文用到的数据库是Mysql，表的建立是依照Oauth2标准来建立的。文末测试以Oauth2中grant_type=client_credentials为例说明。 建表 建表sql文件在文末项目中，点进去可以看到有 data.sql 和 schema.sql两个sql文件，既一些样例数据，和oauth建表sql。ResourceServer中的两个sql文件为受保护资源的样例数据，和建表sql 要建立起Oauth2客户端，我们需要建立以下几张表：oauth_client_detailsoauth_client_tokenoauth_access_tokenoauth_refresh_tokenoauth_code 我们以 “product_api” 命名resourceServer中的api请求路径，我们定义一个客户端叫做：read-write-client（认证权限类型：read，write） 123INSERT INTO OAUTH_CLIENT_DETAILS(CLIENT_ID, RESOURCE_IDS, CLIENT_SECRET, SCOPE, AUTHORIZED_GRANT_TYPES, AUTHORITIES, ACCESS_TOKEN_VALIDITY, REFRESH_TOKEN_VALIDITY)VALUES ('read-write-client', 'product-api','$2a$10$BurTWIy5NTF9GJJH4magz.9Bd4bBurWYG8tmXxeQh1vs7r/wnCFG2','read,write', 'client_credentials', 'ROLE_PRODUCT_ADMIN', 10800, 2592000);#password [密码为加密后的“user”] :user 权限和用户的建立SpringSecurity为我们提供了两个非常有用的接口： UserDetails-提供用户核心信息 GrantedAuthority-授予身份验证对象以权限 我们向表中加入三个用户： 12345678910INSERT INTO authority VALUES(1,'ROLE_OAUTH_ADMIN');INSERT INTO authority VALUES(2,'ROLE_ADMIN_PRODUCT');INSERT INTO authority VALUES(3,'ROLE_RESOURCE_ADMIN');INSERT INTO credentials VALUES(1,b'1','oauth_admin','$2a$10$BurTWIy5NTF9GJJH4magz.9Bd4bBurWYG8tmXxeQh1vs7r/wnCFG2','0');INSERT INTO credentials VALUES(2,b'1','resource_admin','$2a$10$BurTWIy5NTF9GJJH4magz.9Bd4bBurWYG8tmXxeQh1vs7r/wnCFG2','0');INSERT INTO credentials VALUES(3,b'1','user','$2a$10$BurTWIy5NTF9GJJH4magz.9Bd4bBurWYG8tmXxeQh1vs7r/wnCFG2','0');INSERT INTO credentials_authorities VALUES (1, 1);INSERT INTO credentials_authorities VALUES (2, 3);INSERT INTO credentials_authorities VALUES (3, 2);#Password : user Spring Security配置通过继承WebSecurityConfigurerAdapter并用@EnableWebSecurity注解来实现安全保障。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.aak.configuration;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.builders.WebSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.web.util.matcher.AntPathRequestMatcher;@EnableWebSecurity@Configurationpublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter { @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Bean @Override public UserDetailsService userDetailsServiceBean() throws Exception { return new JdbcUserDetails(); } @Override public void configure(WebSecurity web) throws Exception { web.ignoring().antMatchers(&quot;/webjars/**&quot;,&quot;/resources/**&quot;); } @Override protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(&quot;/login&quot;,&quot;/logout.do&quot;).permitAll() .antMatchers(&quot;/**&quot;).authenticated() .and() .formLogin() .loginProcessingUrl(&quot;/login.do&quot;) .usernameParameter(&quot;username&quot;) .passwordParameter(&quot;password&quot;) .loginPage(&quot;/login&quot;) .and() .logout() .logoutRequestMatcher(new AntPathRequestMatcher(&quot;/logout.do&quot;)) .and() .userDetailsService(userDetailsServiceBean()); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userDetailsServiceBean()) .passwordEncoder(passwordEncoder()); }} Oauth2 的配置还需要建立两个组件： Authorization Server - 授权服务器 Resource Server - 资源服务器 Authorization Server - 授权服务器授权服务器负责验证用户标识并提供令牌，使用@EnableAuthorizationServer注解启用授权服务器配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.aak.configuration;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;import org.springframework.security.oauth2.provider.approval.ApprovalStore;import org.springframework.security.oauth2.provider.approval.JdbcApprovalStore;import org.springframework.security.oauth2.provider.client.JdbcClientDetailsService;import org.springframework.security.oauth2.provider.code.AuthorizationCodeServices;import org.springframework.security.oauth2.provider.code.JdbcAuthorizationCodeServices;import org.springframework.security.oauth2.provider.token.TokenStore;import org.springframework.security.oauth2.provider.token.store.JdbcTokenStore;import javax.sql.DataSource;@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfiguration extends AuthorizationServerConfigurerAdapter { @Bean @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) public DataSource oauthDataSource() { return DataSourceBuilder.create().build(); } @Bean public JdbcClientDetailsService clientDetailsService() { return new JdbcClientDetailsService(oauthDataSource()); } @Bean public TokenStore tokenStore() { return new JdbcTokenStore(oauthDataSource()); } @Bean public ApprovalStore approvalStore() { return new JdbcApprovalStore(oauthDataSource()); } @Bean public AuthorizationCodeServices authorizationCodeServices() { return new JdbcAuthorizationCodeServices(oauthDataSource()); } @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.withClientDetails(clientDetailsService()); } @Override public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception { oauthServer.allowFormAuthenticationForClients(); oauthServer.checkTokenAccess(&quot;permitAll()&quot;); } @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints .approvalStore(approvalStore()) .authorizationCodeServices(authorizationCodeServices()) .tokenStore(tokenStore()); }} 在 application.yml 中配置一下数据库连接。授权服务器配置成功后，我们启动项目，就能看到这个登陆界面。输入用户名：oauth_admin 密码：user 登陆 ClientOpt Resource Server - 资源服务器资源服务器受保护于OAuth2令牌保护的资源（就是我们刚才配置的 product_api）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.aak.configuration;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.HttpMethod;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;import org.springframework.security.oauth2.provider.token.TokenStore;import org.springframework.security.oauth2.provider.token.store.JdbcTokenStore;import javax.sql.DataSource;@EnableResourceServer@Configurationpublic class ResourcesServerConfiguration extends ResourceServerConfigurerAdapter { @Bean @ConfigurationProperties(prefix=&quot;spring.datasource&quot;) public DataSource ouathDataSource(){return DataSourceBuilder.create().build();} @Override public void configure(ResourceServerSecurityConfigurer resources)throws Exception{ TokenStore tokenStore=new JdbcTokenStore(ouathDataSource()); resources.resourceId(&quot;product_api&quot;).tokenStore(tokenStore); } @Override public void configure(HttpSecurity http) throws Exception{ http .authorizeRequests() .antMatchers(HttpMethod.GET, &quot;/**&quot;).access(&quot;#oauth2.hasScope('read')&quot;) .antMatchers(HttpMethod.POST, &quot;/**&quot;).access(&quot;#oauth2.hasScope('write')&quot;) .antMatchers(HttpMethod.PATCH, &quot;/**&quot;).access(&quot;#oauth2.hasScope('write')&quot;) .antMatchers(HttpMethod.PUT, &quot;/**&quot;).access(&quot;#oauth2.hasScope('write')&quot;) .antMatchers(HttpMethod.DELETE, &quot;/**&quot;).access(&quot;#oauth2.hasScope('write')&quot;) .and() .headers().addHeaderWriter((request, response) -&gt; { response.addHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); if (request.getMethod().equals(&quot;OPTIONS&quot;)) { response.setHeader(&quot;Access-Control-Allow-Methods&quot;, request.getHeader(&quot;Access-Control-Request-Method&quot;)); response.setHeader(&quot;Access-Control-Allow-Headers&quot;, request.getHeader(&quot;Access-Control-Request-Headers&quot;)); } }); }} 接下来我们就可以测试了！！！第一步：我们启动AuthorizationServer，用账号：oauth_admin 密码：user 登陆。可以看到 OAuth Server Administration Dashboard 这个界面，可以在这里添加客户端，比如我们这里建立一个grant_type 包括 client_credentials 的客户端。 请求resourceServive时，这里我们用firefox里面的RESTClient测试： 1http://localhost:8080/oauth/token?grant_type=client_credentials&amp;client_id=newtest&amp;client_secret=user 我们从返回的json里面可以直接获取到 access_token！ 第二步：我们用另一台机器启动ResourceServer（或者可以换一个端口来启动），拿着我们刚刚获取到的token去请求我们需要的资源。首先我们不带access_token，直接请求资源路径： 我们会看到是没有权限访问的。接下来我们带着用刚才获取到的access_token去访问资源。 可以看到我们成功的访问到了受保护的资源！！！代码地址：https://github.com/victorzhgx/oauth2 完整pom123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xxx&lt;/groupId&gt; &lt;artifactId&gt;xxx-auth&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;xxx-auth&lt;/name&gt; &lt;description&gt;oauth2 authorzation sever&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.BUILD-SNAPSHOT&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;bootstrap&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt; &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt; &lt;version&gt;5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;version&gt;5.1.4.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 完整数据库表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111DROP TABLE IF EXISTS `authority`;CREATE TABLE `authority` ( `id` int(11) NOT NULL DEFAULT '0', `authority` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;DROP TABLE IF EXISTS `credentials`;CREATE TABLE `credentials` ( `id` int(11) NOT NULL DEFAULT '0', `enabled` tinyint(1) NOT NULL, `name` varchar(255) NOT NULL, `password` varchar(255) NOT NULL, `version` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;DROP TABLE IF EXISTS `credentials_authorities`;CREATE TABLE `credentials_authorities` ( `credentials_id` bigint(20) NOT NULL, `authorities_id` bigint(20) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8;DROP TABLE IF EXISTS `oauth_access_token`;CREATE TABLE `oauth_access_token` ( `token_id` varchar(255) DEFAULT NULL, `token` longblob, `authentication_id` varchar(255) DEFAULT NULL, `user_name` varchar(255) DEFAULT NULL, `client_id` varchar(255) DEFAULT NULL, `authentication` longblob, `refresh_token` varchar(255) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8;DROP TABLE IF EXISTS `oauth_approvals`;CREATE TABLE `oauth_approvals` ( `userId` varchar(255) DEFAULT NULL, `clientId` varchar(255) DEFAULT NULL, `scope` varchar(255) DEFAULT NULL, `status` varchar(10) DEFAULT NULL, `expiresAt` datetime DEFAULT NULL, `lastModifiedAt` datetime DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8;DROP TABLE IF EXISTS `oauth_client_details`;CREATE TABLE `oauth_client_details` ( `client_id` varchar(255) NOT NULL, `resource_ids` varchar(255) DEFAULT NULL, `client_secret` varchar(255) DEFAULT NULL, `scope` varchar(255) DEFAULT NULL, `authorized_grant_types` varchar(255) DEFAULT NULL, `web_server_redirect_uri` varchar(255) DEFAULT NULL, `authorities` varchar(255) DEFAULT NULL, `access_token_validity` int(11) DEFAULT NULL, `refresh_token_validity` int(11) DEFAULT NULL, `additional_information` varchar(255) DEFAULT NULL, `autoapprove` varchar(255) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8;DROP TABLE IF EXISTS `oauth_client_token`;CREATE TABLE `oauth_client_token` ( `token_id` varchar(255) DEFAULT NULL, `token` longblob, `authentication_id` varchar(255) DEFAULT NULL, `user_name` varchar(255) DEFAULT NULL, `client_id` varchar(255) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8;DROP TABLE IF EXISTS `oauth_code`;CREATE TABLE `oauth_code` ( `code` varchar(255) DEFAULT NULL, `authentication` varbinary(255) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8;DROP TABLE IF EXISTS `oauth_refresh_token`;CREATE TABLE `oauth_refresh_token` ( `token_id` varchar(255) DEFAULT NULL, `token` longblob, `authentication` longblob) ENGINE=InnoDB DEFAULT CHARSET=utf8;DROP TABLE IF EXISTS `product`;CREATE TABLE `product` ( `id` int(11) DEFAULT NULL, `version` int(11) DEFAULT NULL, `available` tinyint(1) DEFAULT NULL, `name` varchar(255) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8;","link":"/2020/04/03/%E9%89%B4%E6%9D%83%E4%B8%AD%E5%BF%83%EF%BC%9ASpringboot-Springsecurity-Oauth2%E6%95%B4%E5%90%88/"},{"title":"24.深入Java系列Java中int面试知识点","text":"_java面试题_之_int_和Integer的区别 - Roy-Xin - 博客园 2019年7月28日 - 1、Integer是_int_的包装类,_int_则是_java_的一种基本数据类型 2、Integer变量必须实例化后才能使用,而_int_变量不需要 3、Integer实际是对象的引用,当new一… _Java面试知识点_总结 - absfree - 博客园 2016年6月8日 - Java面试知识点总结 本篇文章会对面试中常遇到的_Java_技术点进行全面深入的总结…都使用_Java_虚拟机中的_int_数据类型来代替,而boolean数组将会被编码成… _Java面试知识点_总结-基础 - 简书 2018年8月8日 - _java_基础 集合承继包含图 Collection vs Collections 首先,”Collection” and “Collections”是两个不同的概念,从下面的继承关系图中我们可以看到,”Col… _Java_基础_面试题_整理__Java___Java_笔记-CSDN博客 2019年2月8日 - final也是很多面试_喜欢问的地方,但我觉得这个问题很无聊,通常能回答下以下5点就…所占用的位数和平台无关,在 32 位和64位 的_Java 虚拟机中,int 类型… _Java面试_流程及核心_面试题__开发猫-CSDN博客 2018年10月31日 - _面试_整体流程 1.1 简单的自我介绍 我是xxxx,工作xxx年.我先后在xxxx公司、… 对于你的自我介绍和项目项目经验_面试_官就…_Java中_有几种基本数据类型?8种_Int_占 4… Java _面试知识点_合集 - 云+社区 - 腾讯云 2019年7月1日 - 摘要:网上java_面试知识_杂乱而繁多,每次想看的时候总会挑挑拣拣许多时间就过去了,…6.Integer和int_的区别,Integer的缓存范围 在_java中,有八种基础类型… _Java_基础_面试知识点_总结_ITPUB博客 2019年3月9日 - 微信公众号【_Java_技术江湖】一位阿里_Java_工程师的技术小站,致力于分享_Java_后端技术文章,以及这几年学习_Java_的心得体会,偶尔也记录在阿里成长的点滴,和… Java_常见_面试题:Java_SE基础_知识(一) | 亦枫博客 2019年3月19日 - 整理了一些java_常见的_面试题_型和基础_知识,由浅入深,预计共五章。本篇为第一章…_int_是_java_的原始数据类型,Integer是_java_为_int_提供的封装类。Integer实… _Java_开发_面试_必问的_知识点_有哪些_百度文库 以下分享一些 Java 开发面试_中的常见题目,收好 了,你用得着。 1)集合相关…_int 和 Integer 的自动拆箱/装箱相关问题。 常量池相关问题。 ==和 equals … 总结_Java_常见_面试题_和答案!-CSDN论坛 总结_Java_常见_面试题_和答案 _int_和Integer有什么区别? 答:_int_是_java_的原始数据类型,Integer是_java_为_int_提供的封装类,_java_为每个原始数据类型都提供了封装类。 String和… .wa-se-st-single-video-zhanzhang-play { position: absolute; height: 40px; width: 40px; top: 50%; left: 50%; margin: -20px 0 0 -20px; background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpmOWQ4YzVjMi1kMjNiLTQ5ZjEtOWIyNi0wOGY3MmY4MTc1NTMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MDc0OTQ3OURGODgzMTFFNUFFQkZEMDZGREMzOTdFMTkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MDc0OTQ3OUNGODgzMTFFNUFFQkZEMDZGREMzOTdFMTkiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2Y2IwNzk4OC0yYjNiLTQ2MDItYTllMS0zNzI1Yzk5NTZmMmQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6ZjlkOGM1YzItZDIzYi00OWYxLTliMjYtMDhmNzJmODE3NTUzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Rtt+oAAABS5JREFUeNq8mWtIW2cYxxOXpNtUoihYbbxhzMAJ3jMvKxPnZR9Gvawdm2hhWOy+DLzPil91ImzKPq2jH1QQyqBRB4La6izzNi9RQYMzGg3qbCcuc5rNxBj3f9w53WhXzck5xwcekkPO+7y/vO95n9uRnpycSNyQV6Dp0AxoNPQK1AeqYH63Q3+HbkEXoEPQYegx14mkHAEjoGXQd61Wq3N1dXVrcnLy6cTExN74+PjB9vb2Ed0UGBgoT0lJ8UpOTlZqtdqAiIiIK56enh74aRDaCl0VGvAy9AvoOzMzM8uNjY0/63Q6C5d/VlBQ4FtXV/dGQkKCBpePoXegT4QAvAWtnp+fX8/Pz9evra3ZJDwkPDz8UldXV3xMTEwYLr+EfnvW/R5n/CaHtlsslsqampqHsbGx43zhSMgG2aqurn4I2+U0BzMXpxX0hn5nNpt9kpKShnZ2do4kIoifn58cj0xGaGgoHagPofuuANK/6TYajV7R0dHDdrv9RCKiKBQK6cLCQnpkZOQBLvOgR+cBdmDlItVq9YDD4RAVjhWZTCZdWVnJxkoacXnzrGewFM9FIk7a0EXBkdBcNCfNjcvbLwMkV1IJFzK0u7t7JLlgoTkbGhrIoVcyjv+FLW6HK7lMJ8xVozhAyqmpqT0hQWdnZ1PA8JTdanYFyXlezcvL03MxVl9fn4hIcj0kJORVoQDJ1+LjbYbpGeBn09PTy+vr65z9HFbxzbm5udvFxcUqIQCJgViIiQWkwJ9J4ctdo76+vj5tbW2fdHZ2XqUTyReSYckkNgJMR+B3IPxY+Bj1gBQWFmYsLi7ejIuL8+Zji1iIidgIMBM+6BehniGNRhM2MjLyKcKjho8dZErElEGAUQg3vwp5El+HNDU1fdzf3/+eUqmUuWMDzyGd5GgCVI2OjlqE9mtSqVSSnZ39lsFguJWVleXPdTyYKD6rCJB8mVUsBxwUFBTQ29tb2tLSEsdlHMOkJEDFxsaGqJFDDikrK7uGSV32mQyTwuMiw5m3t/drXN0QAdqDg4PlYsMNDAz8hBDWaTKZ/nLlfobJToB7iAaeImYqx62trd/n5OT0HR4eOjlEKGLaI8DNtLQ0HzHg9vf3rSUlJe3l5eWzXMcyTJvkowzIxeLxaRISbnNzczs3N/e+Xq//w53xiYmJAeQOCXAQdev7QsLhtC5gS3uQgDrctQGmICr4aYt/8PLykiHN8eULhtzyBAnDIAr2B3zgiAWFPi3esAfTjnhERTUfOJvNZq+trb1fVFQ04nQ6ef1RhuURsbF+sBV7rqGi2s10/Tcku/eam5uX+e4CCqdLxMK0SJ4lrNQreazT6eK5GlxaWjJptdp7fX19O0I8v93d3cTwI9u/+W8kuQNHGl5VVeVyYO/o6DAg93PZ+Z4nCId+xICvn7+sLqayswxFdNdFV3bUZTAajfnIzr/G5TdnFu6oC8AYeaGFO+Cyw8LCXijc/w+Qso0H1PqIiooaFhuS4JAzsq2PD6CH53W36IaPMOAQkFm09CJvaybm+pPmfB7urPYbdZmuYclXYKCgoqLCX2g4xGd/so05Vpmm0b67DcxSakdQAxOxVW82m218/VxPTw/bwPwKetfdBiYr1AFNh8EnODw3EGeTAco5+6ExNJZskC3JP034u+fWNm400akrSk30Y5SrW5j0tIk+NjZ2gAzm1DWpVCp5amrqaRMdeV2AWq2mJjo1CKiJ3iIRoYn+vLCvIaj6j5L8+xqCDZX0GLCvIQxMXB2WuPEa4m8BBgDXxE/mIU7+4wAAAABJRU5ErkJggg==) no-repeat; background-size:40px 40px; } .wa-se-st-single-video-zhanzhang-play:hover { background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpmOWQ4YzVjMi1kMjNiLTQ5ZjEtOWIyNi0wOGY3MmY4MTc1NTMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MDc0OTQ3OTlGODgzMTFFNUFFQkZEMDZGREMzOTdFMTkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MDc0OTQ3OThGODgzMTFFNUFFQkZEMDZGREMzOTdFMTkiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2Y2IwNzk4OC0yYjNiLTQ2MDItYTllMS0zNzI1Yzk5NTZmMmQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6ZjlkOGM1YzItZDIzYi00OWYxLTliMjYtMDhmNzJmODE3NTUzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+SH0i3gAABTFJREFUeNq8mVlIY1cYx3OTGE0Mneg8VEYRA3VBZYQykVKd4tQ1UnxrcV/wQaO+aNW2oL5YbEerPmlQxBUXfLSiIo4OVFtcKFoXqhYUYUaKVmPVuGXp/7M3YK0zk3tz44FPzsn1nPvLOd/5tjBWq1XEozGQMMgTSCDkEcQD4sY+P4ccQl5D1iELkCUI55cxHAEJ5AtI1OrqqmpmZsY0NzdnQt+yvb1tMRgM14upVCrGz89PHBISIg4PD5dGRERI0Tfg0UvIIAsuKCDtTgEkurGx0dzS0nK5vr5u4fLNAgMDxXl5ebLi4mIJhi8gzewuOwyohRTp9XrX8vLy85OTE146YWtKpZKpra110+l0Fxg2QUb4AkohX09OTsbU19cbR0ZGzCIBW2JioqSkpEQRHR09geH3EBMXQDnku4GBgccZGRlGk8lkFTmhSaVSpqenR5GcnPwbht9AzuwBpJ2r7erqCsvJyTHyvOX231KGEXV0dCiysrLolpff3sm7ACv6+/ufpaWlOR3uJmRvb68iJSVlCsNv3waYODExUa7Vak+cdaxvO27ouTI2NvYHDIdtn4tvmZJCmBHjfcNRo3c2NDQYWXP28C7AQjIlXG6rWq2WCwk5NjZmbmpqkqGru33E3pAe2Cjj6emp3btXVVUV5OXlpaioqFg+ODi4EgLS3d2dga1VoJsBeWXbwc9h68xc4GwNruwRzNFTuDMPIQCJgViIyXbE5PijWltbL/ku6unpqYDuflxaWvqBWCxmHIVkWaKIjQDDyPFvbGxYHFmUwGBwg7q7uz/y9fV1c2QtYiEmYiNADUUlQil6UFDQQ3iHT5KSkt53ZB0wkU4/IcAACpmEvI1QdFllZaWmpqYmRC6Xi/msASbSw0Ca7L2ysmIR2q6Rd4iLi1PDK0UGBwcruc5nmbwJULWzsyM4oK35+Pi819bW9hR+3ZfLPJZJRYBy2DCneg6ZTCYpLCx83Nzc/CFuvIs9c1gmfvrhQLAqw23nZh0oBsO3YpwNNz4+vpWbmzu7v79vl8dhmc4o9jPAbql2d3fNzgBDEGBBDrOCmG+Hyzww0eYZ6M+r0NBQpxz18fHxBbzLL1zhqLFM1754Q6PRSISGwy08QpT80/T09CGf+fDxxLROgPNw9C5Cws3Ozr5OT0//GZDnfNdgmRYIcAnbaQgICHD4mBG6WWGYfy8qKvrVaDTy1mliYRP9JTFbjniZn58vcwTu4uLCVF1dvYBQ6Q9HcxmWhaoQVtuuDVLGT0k1nwX39vZOsejM0NDQnwLYSoatPgzeDPmpVvKCMn6uC66tre0hd55eXl4+FkJ/WYZJW/3mZlZHEXEvMn7R6OioXfqD2/9gcXHx76urK0FcZXx8vAR5CXXTbHWbmxeDPmimcgSlgPYsOD8/fyQUnEQiYejd6OpvFpVu39zhmJiYic7OTjmFS/fV6F1dXV1yhGdU9frxXZUFsj/P77P00d7ersjOzqbSx1eQK3uLR8/7+vpCMjMzz8xms1Mo6ViRw8hTU1OX31Q8epNxpn/8EhOnoLRKrVYruCtMSEiQ4DIq6R0Ylt0FZ28B8zPK9BFsupaVlZ3DQzi0mwqFgqmrq3MrKCi4YC/EMN8C5n/CM7Zm8imVgPV6/eXm5ianNMHf31+s0+lsJWCyc1QCPninjvIsoj9D3voAkcoVTI2ZiuhbW1uWw8PD68U8PDwYtVp9XUSnSCkyMtIF/SM8mhI5qYj+v3mif3+G0JBvZ8GpIuVqc82Qv1iQDTKZIp4/Q/wjwAB2z0yP+KAgHAAAAABJRU5ErkJggg==); } .wa-se-st-image_single_video {overflow:hidden;position:relative;} .wa-se-st-image_single_video img {height:91px;} _Java面试题___Java_基础试题04._java中int_占几个字节_源代码教育请你说一下_Java里int_eger和int的区别,以及如何比较相等_测试校招… 首页&gt; 测试校招_面试_题目合集&gt; 请你说一下Java里…问答题 122 /413 请你说一下_Java里int_eger和int的…Object类中的equals方法定义为判断两个对象的地址是否… java面试知识点 - 个人笔记 ~ 个人博客 7天前 - 在Java 5以前,switch(expr)中,expr只能是byte、short、char、int_。从_Java 5…而是直接引用常量池中的Integer对象,所以上面的_面试题_中f1==f2的结果是t… Java 经典_面试题_及答案分析_变量 2019年6月27日 - 以下是小编为大家整理的部分Java经典_面试题_及答案分析,希望可以帮助大家在面试时…是的,我们可以做强制转换,但是_Java中int_是32位的,而byte是8位的,所… _Java中_高级_面试题_总结 2020年3月22日 - 本篇文章小编给准备跳槽的Java程序员们整理了一些Java中_高级_面试题,希望可以帮到…12、Java 中_如何将字符串转换为整数? String s=’123’; _int i; 第一… _Java面试知识点_总结 - 简书 2016年10月14日 - 本篇文章会对_面试_中常遇到的_Java_技术点进行全面深入的总结,帮助我们在_面试_中更加得心应手,不参加_面试_的同学也能够借此机会梳理一下自己的_知识_体系,进… Java面试,我应该准备哪些_知识_呢? - 知乎 2017年3月30日 - 这篇文章主要是介绍一下我自己从毕业到现在碰到的一些面试题_。 _JAVA 基础 int 占用几个字节 答案: 4个 不用第三个变量,如何交换两个变量的值 public … Java面试题-基础知识 | 并发编程网 – ifeve.com 本文来源于清英的一篇文章:你应该知道的JAVA面试题,最近自己也在面试一些候选人,发现这篇文章中的有些点我也拿不准,因此按照自己的理解整理一份参考回答。… java_基础_面试知识点 - 友人C 2019年3月30日 - java中==和equals和hashCode的区别==对于基本数据类型,是判断值是否相同,对于引用类型来说,是判断地址是否相同equals() 对于没有重写的引用类型,判断… _Java面试知识点_总结及解析 - TerryChou - 博客园 2018年7月1日 - 答:不是。_Java中_的基本数据类型只有8个:byte、short、_int_、long、float、double…而是直接引用常量池中的Integer对象,所以上面的_面试题_中f1==f2的结… _Java_基础_知识_常见_面试题_汇总 第一篇 - 申城异乡人 - 博客园 2019年5月7日 - 本篇主要整理下Java基础知识_的_面试题,主要包含以下几点: Integer和int_的区别 ==和equals的区别 String,StringBuilder,StringBuffer的区别 装箱和拆箱 _… _Java面试题_汇总_凯耐的博客-CSDN博客 2018年6月3日 - 1._Java中_有哪些基本数据类型?String是基本数据类型吗?String类是否能够继承?答:1…. 汇总:Java 初级_面试题_及答案 总汇:分享下最近面试二十多家公司总结的java高级… Java_数据类型——_面试题 - xiaostudy - 博客园 2018年6月29日 - 在s1+1运算时会自动提升表达式的类型为int,那么将_int_赋予给short类型的变量s1会…· _Java_语言中关于数据类型的一些总结· _java面试题_整理» 更多推荐… 阿里历年_Java面试题知识点_总结 - _Java_笔记 - CSDN博客 2018年11月23日 - 都使用Java_虚拟机中的_int_数据类型来代替,而boolean数组将会被编码成_Java_虚拟机的…以下为大家整理了阿里巴巴史上最全的_Java面试题,涉及大量Java面试… _java面试题_之_int_和Integer的区别 - 果冻迪迪 - 博客园 2017年6月6日 - 5. Re:_java面试题_之_int_和Integer的区别 总结的非常好,纠正了我一个错误,我以为Integer i = new Integer(100),这样的两个变量 == 也是true呢 –Numen_f… _java面试题_之_int_和Integer的区别 - aspirant - 博客园 2018年12月28日 - _java面试题_之_int_和Integer的区别 _int_和Integer的区别 1、Integer是_int_的包装类,_int_则是_java_的一种基本数据类型 2、Integer变量必须实例化后才能使用,… _java面试题_之_int_和Integer的区别 - 辉辉太郎 - 博客园 2018年11月28日 - 1、Integer是_int_的包装类,_int_则是_java_的一种基本数据类型 2、Integer变量必须实例化后才能使用,而_int_变量不需要 3、Integer实际是对象的引用,当new一… _Java_学习—_面试_基础_知识点_总结 - 小a玖拾柒 - 博客园 2018年8月30日 - Java学习—面试_基础_知识点_总结 _Java中_sleep和wait的区别 ① 这两个方法来自不…public static String valueOf(_int i) { return Integer.toString(i… 04._java中int_占几个字节_找工作不用愁_Java_面试题_视频_Java培训… 课课家教育提供04._java中int_占几个字节视频教程,所属课程:找工作不用愁_Java_面试题_视频,有一定Java基础的学员 最最最常见的_Java_基础_知识面试题_总结 - _Java_Guide - SegmentFault… 2018年8月7日 - 这里会分享一些出现频率极其极其高的面试题,初定周更一篇,什么时候更完什么时候停止。 Github地址:https://github.com/Snailclimb/_Java_-Guide/blob/ma… Java _面试题_基础_知识_集锦__java__脚本之家 2016年9月4日 - 本文主要介绍Java_基础_面试题_集锦,这里整理了_面试java_工程师的基础_知识题_锦,有需要…_int id=Integer.valueOf(numString)._int_Value();问题:SimpleTimeZ… 经典_java面试题_23道 2019年9月26日 - (1)数组中没有这个方法,使用length属性,返回的结果应该是数组的长度int[] arr…经典_java面试题_23道 nginx之负载均衡 集群,分布式,微服务概念和区别理解 相关文章… _java_最新_面试题_总结-百度经验 2017年12月6日 - _java_最新_面试题_总结,之前为大家贴出_java_的一些_面试知识点_今天继续为大家总结欢迎学习欢迎回帖 _Java_开发_面试_基础笔试题及答案分享【_java_吧】_百度贴吧 2019年12月20日 - Integer 与 int 的区别。共五道_Java_开发_面试_及答案。 博学谷小六六 淼淼 6 第一题:char 型变量中能不能存贮一个中文汉字?为什么?char 型变量是用来… _面试_刷题7:_int_和Integer有什么区别?-站长资讯中心 2020年3月25日 - _面试_刷题7:_int_和Integer有什么区别? 原始数据类型是_java_系统的重要组成元素。_java_号称一切都是对象,原始数据类型除外。我是李福春,我在准备面 _Java_中级_面试题__慕课手记 2018年11月6日 - BoostrapClassLoader,加载系统(java包下)的类,SystemClassLoader,加载系统扩展…16. Java中_一个字符占多少个字节,扩展再问_int, long, double占多少字… _Java面试题_必考50道(含答案) - 瑞查德的个人空间 - OSCHINA 2018年3月25日 - 面试中最常见的_面试题_和详细的解答过程… 以下的内容是对网上原有的Java_面试题_集及答案进行了全面修订…答:不是。_Java中_的基本数据类型只有8个:byte… Java_后台开发常见_面试题-l123j的博客-51CTO博客 2019年5月4日 - a) _Java_自动将原始数据类型值转换成对应的对象,比如将_int_类型的变量转换成Integer类型,自动装箱时调用valueOf将原始数据类型转换成对应的对象。 b) 反… 【_java_中级_面试题_及答案】-博文推荐-CSDN博客 2019年3月22日 - java中_常量池怎么定义 java随机取数 _java中_的this java线程企业_面试题 36进制 …基本数据类型的变量(_int_、short、long、byte、float、double、boolea… Java面试_基础必备_知识点,怼死_面试_官,从我做起 – 零一海 2020年3月13日 - 喜欢的就关注,想看深入研究的东西,等我更新完_面试_系列,会给大家更新点深度文章,_Java_基础_知识_分为两部分,这是第一篇,后续更新中,部分来源网络_java_codeG… Java_基础_面试题 Java基础面试题_1. _java中==和equals和hashCode的区别1、==java中_的数据类型,可分为两类:基本数据类型,也称原始数据类型 byte,short,char,_int,long,float,double… 史上最全Java中_高级_面试题(含全部答案),看完不愁系列 - 知乎 2019年5月17日 - 欢迎关注专栏:_Java_进阶之路。_里面_有大量batj_面试题_集锦,还有各种技术分享,如有好…在idk 1.7之前,switch只能支持byte,short,char,_int_或者其对应的封装类以及Enum… _Java_BAT_面试_精华汇总(内附答案) - Go语言中文网 - Golang中文社区 2019年2月19日 - 这些题目是去百度、小米、乐视、美团、58、猎豹、360、新浪、搜狐等一线互联网公司面试被问到的题目,熟悉本文中列出的_知识点_会大大增加通过前两轮技术… 20个JAVA面试题(附答案及解析) 2017年11月14日 - (一)Java部分 1、列举出_JAVA中_6个比较常用的包【天威诚信_面试题_】 【参考答案…由于s1+1运算时会自动提升表达式的类型,所以结果是_int_型,再赋值给shor… java面试_常见_知识点 - 知乎 2019年11月8日 - 准备阶段不分配类中的实例变量的内存,实例变量将会在对象实例化时随着对象一起分配在Java_堆中。 public static _int value=123;//在准备阶段value初始… _Java_基础_知识点面试_专题一 - 简书 2019年5月17日 - Integer b1 = 127;在java_编译时被编译成Integer,b1 = Integer.valueOf(127);对于-128到127之间的Integer值,用的是原生数据类型_int,会在内存_里_供重用,… _Java面试题_整理 - 云+社区 - 腾讯云 2019年4月19日 - Java面试题_整理 _Java_面向对象 19. super()与this()的区别? This():当前类的…{ _int i = getNum(); i++; try{ PrintWriter out=new PrintWriter(new … 2018年最新_java面试题_整理。。。持续更新中。。。 2018年5月7日 - 2018年最新_java面试题_整理。。。持续更新中。。。 2018-05-07 | 阅:1966 转:7 | 分享 1.1、_java_基础 ●面向对象的特征:继承、封装、多态 (… java_常见_面试题(史上最全最经典,希望对你有用)_百度文库 这是传智播客java_课堂、尚学堂马士兵课堂讲课_重点_注意,以及自己_面试_的总结。内容…而 _int 默认的默认值为 0,所以用 el 表达式在文本框中显示时,结果为 0,… _java面试_的的时候你被提过哪些问题? - 知乎 2015年4月23日 - 贴一下Java_基础常见的_面试题,详情可以查看我开源的【Java_学习+面试指南】。 …[] value; _int count; AbstractStringBuilder() { } AbstractStringBui… 【_JAVA_】_面试知识点_一 - 简书 2019年5月24日 - Java 7中switch开始支持String。 对于编译器来说,switch中其实只能使用整型,任何类型的比较都要转换成整型。比如byte。short,char(ackii码是整型)以及… _JAVA面试中_常见的经典算法题_百度文库 _JAVA面试中常见的经典算法题__面试__求职/职场_实用文档。_JAVA 面试_中常见的经典…_Java code public void nineNineMulitTable(){ for (int i = 1,j = 1; … _java_工程师-_面试知识点_总结 - 草木皆灰 2018年2月22日 - java工程师-面试知识点_总结 原创 草木皆灰 发布于2018-02-22 17:45:10 阅读…是的,我们可以做强制转换,但是 _Java 中 int 是 32 位的,而 byte 是 8 位… 高级java面试题 - 泉天下的个人空间 - OSCHINA 2018年4月23日 - 高级java面试题 原泉天下 发布于 2018/04/23 11:18 字数5427阅读6.7K…final int age = 15; String str = “http://www.weixueyuan.net&quot;; class… Java 最常见面试题 200+ 汇总_笔经面经_牛客网 2019年3月14日 - 说了这么多,下面进入我们本文的主题,我们这份面试题,包含的内容了十九了模块:Java 基础、容器、多线程、反射、对象拷贝、Java Web 模块、异常、网络、… _JAVA面试题_汇总 PDF 下载__Java知识_分享网-免费_Java_资源下载 1天前 - _java_有8种基本类型,请问byte、_int_、long、char、float、double、boolean各占多少…上一篇:阿里巴巴Android_面试题_集附答案 PDF 下载 下一篇:没有了 … _java面试题_大合集(开发者必看)-life is beautiful-51CTO博客 2018年3月7日 - 比较好的回答和好的博客,可以自己扩展思路,如果大家有一下面试题_的更好的答案,…32 位和 64 位的 JVM,_int 类型变量的长度是多数? 12、怎样通过 Java … _JAVA_学习重点和_面试重点__百度文库 评分:3.5/5 4页 2018年7月2日 - 一:java 基础部分:java 基础的时候,有些知识点_是非常重要的,比如循环系列。 …(_int 开始下标,int 结束下标); 以上方法都是本人从 API 里面选取的面试… Java _面试知识点_解析(一)——基础知识篇 - 简书 2018年5月9日 - 前言: 在遨游了一番 Java Web 的世界之后,发现了自己的一些缺失,所以就着一篇深度好文:知名互联网公司校招 Java 开发岗面试知识点_解析 ,来好好的对 _Java 知… _Java_高级_面试题_小结__java__脚本之家 2017年9月11日 - 这是一个高级_Java面试_系列题中的第一部分。这一部分论述了可变参数,断言,垃圾…请看下面例子中的求和方法。此方法可以调用1个_int_参数,或2个_int_参数,… Java 面试题(一) - 云+社区 - 腾讯云 2019年9月19日 - 概述:_Java_程序中要求参与的计算的数据,必须要保证数据类型的一致性,如果数据类型…Integer是对象而_int_不是,内存的分配位置也不一样_int_是一种基本数据… 【_java面试_实际项目问题】-博文推荐-CSDN博客 2020年2月18日 - 现在市面上的视频教程,主要有一下两类:第一类是纯理论的,比如框架、算法、虚拟机等;另一类是Demo级别的项目,如各大培训机构的项目课程。从业这么多年,… 求助,_java面试_宝典中的题,类型转换__java_吧_百度贴吧 求助,java面试_宝..Which of the following will compile correctly?A. Short myshort = 99S;B. _int t = “abc”.length();C. float z = 1.0;D. char… _Java面试题_大全(答案版)_百度文库 java_面试题_大全,包含个类面试会问到的技术问题 作者:杨金辉 1、 一个”.java…Integer 与 int 的区别 int 是 _java 中_的 8 种基本数据类型之一,默认值是 … 史上最全_Java面试题_之数据类型相关篇!(带全部答案)_String 2019年3月18日 - Java 中,int 类型变量的长度是一个固定值,与平台无关,都是 32 位。意思就是说,在 32 位和 64 位的Java 虚拟机中,int 类型的长度是相同的。 _int_和Integ… _Java_常见_面试题_总结 - 简书 2016年6月22日 - Java常见面试题_总结 @Date 2016.06.22 Java基础_知识 1._Java 中_应该使用什么数据类型来代表价格? 如果不是特别关心内存和性能的话,使用BigDec… _Java_基础_面试知识点_总结 - 知乎 2019年3月9日 - 本文主要是我最近复习_Java_基础原理过程中写的_Java_基础学习总结。_Java_的_知识点_其实…32位和64位机器的_int_是4个字节也就是32位,char是1个字节就是8位,float是4… Java_开发工程师_面试题-基础篇 2018年3月21日 - 我们可以做强制转换,但是 Java 中 int 是 32 位的,而 byte 是 8 位的,所以,如果强制转化,int 类型的高 24 位将会被丢弃,因为byte 类型的范围是从 -128… _java_常见_面试题_及答案(基础题122道,代码题19道) - 残风卷…_博客园 2018年9月2日 - java常见面试题_及答案(基础题122道,代码题19道) JAVA相关基础_知识 1、面向对象…for(int i=0;i&lt;100;i++){dec();}}} 29、Java有没有goto? _java中_的保… _java面试_基础题 - 收藏夹 - 知乎 (一) java基础面试知识点 java中==和equals和hashCode的区别_int_、char、long… 显示全部 关注专栏 3 条评论 分享 • 举报 • 去往文章页 JDBC常见面试… 2019年_JAVA_最常见_面试题_汇总 - 简书 在Java 6中Arrays.sort()和Collections.sort()使用的是MergeSort,而在Java 7中,内部实现换成了TimSort,其对对象间比较的实现要求更加严格 2.hashMap原理,_java_8… _java_基础_面试题_100道_百度文库 _java_基础_面试题100道_工学_高等教育_教育专区。_JAVA面试题_大全 1、一个”._java“源文件中是否可以包括多个类(不是内部类)?有什么限制?可以有多个类,但是只能有… Java_程序员经典_面试题+答案(全) - 冰湖一角 - 博客园 2019年8月31日 - 这套_面试题_主要目的是帮助那些还没有_java_软件开发实际工作经验,而正在努力寻找…的语法规定,并且不能被隐式转换成_int_类型,所以,它们不能作用于swtich… _JAVA面试_基础题 - time512的博客 - CSDN博客 2018年11月7日 - 基本数据类型包括byte、int_、char、long、float、double、boolean和short。 _java.lang.String类是final类型的,因此不可以继承这个类、不能修改这个类… _java_技术面试之_面试题_大全 - 风中追风_lonely - 博客园 2018年3月4日 - Java 面试知识点_总结 本篇文章会对面试中常遇到的_Java_技术点进行全面深入的总结…支持get(_int index), add(E e)等操作。 Queue: _Java_集合框架中的队列接口,… Java面试_总结(_面试_流程及核心_面试题) - 深云客 - 博客园 2019年1月25日 - Java面试_流程及核心_面试题 面试整体流程 1.1 简单的自我介绍 我是xxxx,工作xxx…2.1.3讲一下_java中int_数据占几个字节Java中有几种基本数据类型?8种 I…","link":"/2020/04/06/24-%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97Java%E4%B8%ADint%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"23.深入Java系列Java内存模型和JVM内存模型","text":"区分-JVM内存_分区和_Java内存模型(Java Memory Model)_q…_CSDN博客 2019年5月8日 - 虚拟机栈(JVM Stacks):属线程私有内存区域,与线程同时创建,总数与线程数关联,代表_Java_方法执行的_内存模型_。每一个运行在_Java_虚拟机里的线程都拥有自己.. 比较jvm内存_结构&amp;_java内存模型&amp;java对象模型 - 个人文章… 2019年8月27日 - 学习java过程中有三个概念,分别是_jvm内存_结构、_java内存模型_、java对象_模型_。我们系统的学习完之后,如果不加以总结对比,很容易混淆,相信不光是自… _JVM内存_结构、_Java内存模型和_Java对象模型的区别 - 简书 2018年12月19日 - _JVM内存_结构、_Java内存模型和_Java对象模型是截然不同的三种概念。 1. _JVM内存_结构 Java程序执行过程中,内存会被划分为不同的数据区域,各个区域有各自… _Java内存_管理-_JVM内存模型_以及JDK7和JDK8_内存模型_对比总结(三… 2019年3月22日 - 如果虚拟机栈可以动态扩展,当扩展到无法申请内存_到足够的_内存,就会抛出OutOfMemoryError异常! 4、_Java_堆 堆是_jvm内存_管理的最大的一块区域,此_内存_区域的唯一目的就… 深入理解JVM-内存模型(jmm)和GC - 简书 1 CPU和内存的交互 了解_jvm内存模型_前,了解下cpu和计算机内存的交互情况。【因为_Java_虚拟机_内存模型_定义的访问操作与计算机十分相似】 有篇很棒的文章,从cpu讲到内… JVM内存模型_、_Java内存模型 和 Java对象模型 - 水木湛清华 - 博客园 2019年9月6日 - 1.Java对象在JVM中的存储模型称之为Java对象模型。 四、总结 1.JVM内存模型,和Java虚拟机的运行时区域有关。 2.Java内存模型,和Java的并发编程有关。 … Java内存模型(JMM)_和JVM内存_结构 - Java 技术驿站-Java 技术驿站 2019年12月10日 - Java内存模型(JMM),Java Memory Model,指的在java程序运行过程中,计算机有主内存,每个java线程有自己的工作内存。java线程的工作内存是计算机主内存的… _JVM内存模型和_性能优化 - 解道Jdon JVM内存模型_优点 内置基于_内存_的并发_模型: 多线程机制 同步锁Synchronization 大量…Heap堆内存 对象实例的属性数据和数组。堆_内存_由_Java_虚拟机的自动垃圾回收器来管理… 【教程】终于有人把_Java内存模型_说清楚了! - 51CTO.COM 2018年7月26日 - 网上有很多关于 Java 内存模型_的文章,但是很多人读完之后还是搞不清楚,甚至有的人说自己更懵了。本文就来整体的介绍一下 _Java 内存模型,比如 _Java 内存模型_是什么… _java内存模型和jvm_运行时数据区对应起来谈的疑惑-CSDN问答 2018年3月28日 - 在java内存模型_中有工作_内存_和主_内存,主_内存_是所有线程共享的_内存_区域, 规定变量都必须存储在主_内存_中。但是在_jvm_运行时数据区中,又谈到所有局部 变量… 深入理解Java内存模型(一)——基础 | 并发编程网 – ifeve.com Java线程之间的通信由Java内存模型(本文简称为JMM)控制,JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看,JMM定义了线程和主_内存_之间的抽象… _JVM内存模型和_垃圾回收 - robustwang - ITeye博客 2019年2月12日 - _JAVA_堆的描述如下: _内存_由Perm和Heap组成。其中Heap = {Old + NEW = { Eden , from, to } } _JVM内存模型_中分两大块: NEW Generation:程序新创建的对 … 终于有人把_Java内存模型_说清楚了_ITPUB博客 2019年4月28日 - 内部原理JVM 中试图定义一种 JMM 来屏蔽各种硬件和操作系统的内存_访问差异,以实现让 _Java 程序在各种平台下都能达到一致的_内存_访问效果。JMM 的主要目标是定义程序… _Java内存模型与JVM_运行时数据区的区别详解_java_脚本之家 2019年10月18日 - 这篇文章主要介绍了_Java内存模型与JVM_运行时数据区的区别详解,文中通过示例代码介绍的非常详细,对大家的学习或者工作具有一定的参考学习价值,需要的朋… _JVM内存模型_——_JAVA_的根基丶一个站在_Java_后端设计之路的男青年… 2019年3月26日 - 站长的个人微信公众号:_Java_云库,每天分享技术文章和学习视频。让我们一起走向架构师之路!!Hi,欢迎来到梁钟霖个人博客网站。本博客是自己通过代码构建的。前端html,… _java内存模型和Jvm内存_分配 - 算法网 2019年3月10日 - (百度上说:在java_程序运行时,_jvm_会在系统_内存_中划定一块区域作为程序的主_内存, _java_中的所有变量都存在主_内存_中,并且对所有线程共享。而每个线程又有… 【_java_】_jvm内存模型_全面解析_哔哩哔哩 (゜-゜)つロ 干杯~-bil…_JVM内存模型_看这个就够了_技术交流_牛客网 2019年1月11日 - _内存_是非常重要的系统资源,是硬盘和CPU的中间仓库及桥梁,承载着操作系统和应用程序的实时运行_JVM内存_布局规定了_Java_在运行过程中_内存_申请、分配、管理… 区分-JVM内存_分区和_Java内存模型(Java Memory Model)_q…_CSDN博客 2019年5月8日 - 虚拟机栈(JVM Stacks):属线程私有内存区域,与线程同时创建,总数与线程数关联,代表_Java_方法执行的_内存模型_。每一个运行在_Java_虚拟机里的线程都拥有自己… 快速带你分清java内存_结构,_java内存模型,java对象模型和jvm内存… 2018年9月23日 - 过程中的重点和难点,我习惯把这块的知识叫做javaSE高级基础,在学习jvm这块的知识,你一定会遇到几个概念,那就是java内存结构,java内存模型,java对象模型和jvm内存… JVM内存模型和_JMM(_Java内存模型)的异同小结_魔临天下-CSDN博客 2018年5月20日 - 1、JVM内存模型和_JMM(_Java内存模型)不是一回事,JMM来源于JSR-133:memory_… 1、JVM内存模型和_JMM(_Java内存模型)不是一回事,JMM来源于JSR-133:memory_… _JAVA内存模型与JVM内存_结构 - 编程小可爱 - 博客园 2019年6月1日 - 这是JVM的内存结构。下面阐述了JMM_和JVM_的区别和自己对JMM的见解 1、Java内存模型(JMM):即多线程相关的。定义了一个线程对另一个线程可见,共享变量放… _Java内存_管理-_JVM内存模型_以及JDK7和JDK8_内存模型_对比…-CSDN博客 2019年3月22日 - 1、Java内存_管理-程序运行过程(一) 2、_Java内存_管理-初始JVM_和JVM_启动流程(二) 3、_Java内存_管理-_JVM内存模型_以及JDK7和JDK8_内存模型_对比总结(三) 4、_J… _JAVA内存_结构和_JAVA内存模型__xiaojia_wahaha_的博客-CSDN博客 2018年1月18日 - 有些人喜欢把_Java内存模型和_Java内存区域Java内存区域详解弄混淆,这两个是完全不…_JVM内存模型_完整图解 阅读数 915 最近研究内存模型,读了深入JVM的… JVM内存_结构 VS _Java内存模型 VS Java对象模型 - qingshanli… 2018年7月2日 - 前面几篇文章中, 系统的学习了下JVM内存_结构、_Java内存模型_、Java对象_模型, 但是发现自己还是对这三者的概念和区别比较模糊, 傻傻分不清楚。所以就有了这篇文章, … 什么是Java内存模型? - 程序员小灰的博客 - CSDN博客 2018年3月17日 - 说”_JVM内存模型_“,有人会说是关于JVM内存分布(堆栈,方法区等)这些介绍,也有地方说(深入理解JVM虚拟机)上说_Java内存模型_是JVM的抽象模型(主内存,本地… _Java内存模型和JVM内存_管理 - 鸿燕藏锋 - 博客园 2017年9月11日 - 1、主内存和工作内存(即是本地内存):_Java内存模型_的主要目标是定义程序中各个变量的访问规则,即在_JVM_中将变量存储到_内存_和从_内存_中取出变量这样的底层细节。此处的… 【JVM】JVM内存_结构 VS _Java内存模型 VS Java对象模型 2018年7月7日 - 原文:JVM内存_结构 VS _Java内存模型 VS Java对象模型 Java作为一种面向对象的,跨平台语言,其对象、内存等一直是比较难的知识点。而且很多概念的名称看起来又那么… _Java内存模型及_性能优化 - yehx - 博客园 Java内存模型及_性能优化 最近在做一个项目的性能优化,遇到好多以前没有关注过的性能问题,一头雾水,今天做个笔记,简单记录下JVM相关的参数设置。 一、_JVM内存模型 … Java内存模型_是什么,为什么要有_Java内存模型,Java_内存_…_CSDN博客 2018年7月25日 - 这里面提到的主内存和工作内存,读者可以简单的类比成计算机_内存模型_中的主存和缓存的概念。特别需要注意的是,主内存和工作内存_与JVM内存_结构中的_Java_堆、栈、方法区… _JVM内存_结构、_Java内存模型和_Java对象模型 - murphy_gb - 博客园 2019年6月22日 - 如上,做个总结,JVM内存_结构,由Java虚拟机规范定义。描述的是Java程序执行过程中,由JVM管理的不同数据区域。各个区域有其特定的功能。 _Java内存模型 Ja… JVM_——_Java内存模型 (JDK1.8) - 「dt猫」 2019年2月21日 - ​ 程序计数器(Program Counter Register)是一块较小的_内存_空间,它可以看作是当前线程所执行的字节码行号 的指示器。 2.程序计数器的作用 字节码解… 《成神之路-基础篇》JVM_——_Java内存模型(已完结)-HollisChuang’s… 2016年1月17日 - Java内存模型 本文是《成神之路系列文章》的第一篇,主要是关于JVM的一些介绍。 持续更新中 Java内存模型 JVM内存_结构 VS _Java内存模型 VS Java对象模… jvm内存模型-CSDN论坛 JVM介绍 JVM整体架构 JVM内存_结构 JVM介绍 1.虚拟机是啥 虚拟机(Virtual Machine…_内存模型,一个线程对应一个栈,用于存储_java_方法中的私有数据,它的生命周期和… _JAVA内存模型与垃圾回收_java _内存模型 垃圾回收-Java文档类资源… 2010年5月19日 - _JAVA内存模型与_垃圾回收 _JAVA内存模型与_垃圾回收 JAVA…论文研究-基于_JVM内存模型_的String分析 .pdf 基于… Java内存模型(JMM) - 云+社区 - 腾讯云 2019年7月12日 - _Java内存模型_规范了Java虚拟机与计算机内存是如何协同工作的。Java虚拟机是一个完整的计算机的一个模型,因此这个模型自然也包含一个_内存模型_——又称… 图解JAVA内存模型(JMM:JAVA Memory Model) 2019年6月30日 - _java内存模型和jvm内存模型_是不一样,要区分开。如上图所示,多个线程对共享变量并没有直接采用加锁的方式,其中 (1)实际内存(也叫主内存)中存储的是待共享的变量… 【免费】_Java内存模型_之_JVM_进阶-1-Java运行流程-李兴华的在线视频… 第一章:JVM执行分析 _Java_运行流程 (20:54) 免费 _Java_对象访问模式 (19:57) 第二章:_JVM内存模型与_垃圾收集 _Java_堆内存模型 (11:11) _Java_垃圾回收流程… 老师这几章讲的是_Java内存模型_还是_JVM内存_结构啊?_实战问答 2019年4月18日 - 拥有丰富的大型网站架构经验,先后参与并负责过_Java_、PHP、Go等项目的开发,自己曾创过业,也曾在汤森路透负责金融产品的研发工作,现就职于某知名大型互… 浅析java内存模型–JMM(Java Memory Model)_码神岛 2019年3月12日 - 主内存和工作内存: _Java内存模型_的主要目标是定义程序中各个变量的访问规则,即在_JVM_中将变量存储到_内存_和从_内存_中取出变量这样的底层细节。此处的变量与Java编程里面… 《深入理解_JAVA内存模型_》PDF 下载_Java知识分享网-免费Java资源… 2016年2月29日 - 以及如何从虚拟机外部观察和分析JIT编译的数据和结果;第五部分探讨了Java实现高效并发的原理,包括JVM内存模型_的结构和操作;原子性、可见性和有序性在_J… Java内存模型 —— 深入JVM - 网易云课堂 若不同意,将无法使用我们的产品和服务。 同意 … 深入理解Java内存模型(一)——基础-InfoQ Java线程之间的通信对程序员完全透明,内存可见性问题很容易困扰Java程序员,本文试图揭开_Java内存模型_神秘的面纱。本文大致分三部分:重 _JVM内存模型与_运行时数据区域的详解(图文)-_java_教程-PHP中文网 2018年10月16日 - 本篇文章给大家带来的内容是关于JVM内存模型与_运行时数据区域的详解(图文),有一定的参考价值,有需要的朋友可以参考一下,希望对你有所帮助。 一、_java内存模型 java… JMM(Java内存模型)中的核心概念 - guibin - ITeye博客 2011年9月15日 - 在JLS-Java Language Specification的17.4节详细描述了JMM(Java Memory Model),这个文档从语言学和实现_JVM_的角度讲非常棒,但是对于我们这些应用开发者… _Java内存模型_的历史变迁-CSDN.NET 2015年5月20日 - 旧_Java内存模型_对Java实现如何执行变量的读/写,加锁/解锁,以及volatile变量的读/写,定义了非常严格的规则。这些规则非常复杂,具体详情请参考《_JVM_规范… _java内存模型及_GC原理 和 图解_JVM_在_内存_中申请对象及垃…_新浪博客 2015年8月1日 - java内存模型 _JVM内存模型_中分两大块,一块是 NEW Generation, 另一块是Old Generation. 在New Generation中,有一个叫Eden的空间,主要是用来存放新生的… 聊聊高并发(三十五)_Java内存模型_那些事(三)理解_内存_屏障 | 学步园 2017年11月9日 - 内存屏障的概念很好理解,不同硬件实现内存屏障的方式不同,_Java内存模型_屏蔽了这种底层硬件平台的差异,由_JVM_来为不同的平台生成相应的机器码。… 深入理解_java内存模型pdf下载|深入理解_java内存模型_下载 绿色… 2017年8月3日 - 深入理解_java内存模型_是由程晓明推出的_java内存模型_介绍的软件开发图书,从基础、冲排序、JMM设计等多方面讲述了_内存模型_的建立和使用,需要的朋友快来… _jvm内存模型和_内存分配 - dancing007的个人空间 - OSCHINA 2017年11月27日 - _jvm内存模型和_内存分配 转dancing007 发布于 2017/11/27 16:45…(1)jvm是_java_的核心和基础,在_java_编译器和os平台之间的虚拟处理器,可在上面… java内存模型 新生代中的比例为什么是8:1:1?_java吧_百度贴吧 1楼: 求助，吧内的大神们？遇到一个jvm_面试题 _java内存模型 … 2楼: 之前看ibm有做过一个研究，新生代大部分都是垃圾，一次… Java 内存模型,_内存_监控,GC查看 - 禅鸣之时 - ITeye博客 2018年5月27日 - ——Java 8 后 Metaspace 代替 默认受物理_内存_限制,可以通过 -XX:MaxMetaspaceSize 设置最大使用_内存_数。 4)程序计数器 5)本地方法栈 (二)_JVM 内存_设… _JAVA内存模型_简述及总结_教程库 2019年8月5日 - JMM定义了java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。_JVM_是整个计算机虚拟模型,所以JMM是隶属于_JVM_的 _Java内存模型_定义了多线程之间共享变量的… BAT经典面试题,深入理解_Java内存模型_JMM - HelloJava菜鸟社区 2019年5月16日 - Java 内存模型(JMM)是一种抽象的概念,并不真实存在,它描述了一组规则或规范,…注意JMM_与JVM内存_区域划分的区别: JMM描述的是一组规则,围绕原子性、有序性和… 终于有人把_Java内存模型_说清楚了 - 知乎 2019年4月13日 - JVM 中试图定义一种 JMM 来屏蔽各种硬件和操作系统的内存_访问差异,以实现让 _Java 程序在各种平台下都能达到一致的_内存_访问效果。 JMM 的主要目标是定义程序中各个… _java内存模型__图文_百度文库 评分:3.5/5 14页 2011年4月29日 - 内容什么是内存模型 内存模型与_可见性 发生前关系(Happen-before) 初始化安全性 1 3 2 3 4 IBM&amp;重庆大学 9.1 _Java内存模型 _内存模型_同步和线程安全的… 浅谈_JAVA内存模型___Java 内存模型_以及应用程序常见…_爱问共享资料【Java_面试题】_Java内存模型-教育-高清完整正版视频在线观看-…Java内存模型_FAQ(一) 什么是_内存模型 | 并发编程网 – ifeve.com 和降低共享内存_在总线上的通讯(因为本地缓存能够满足许多_内存_操作)来提高CPU性能…_Java 10的类型推导 谈谈Netty的线程模型 JVM_之动态方法调用:invokedynamic _Jav… _JVM_—虚拟机_内存模型与_高效并发丶一个站在_Java_后端设计之路的男… 2018年7月25日 - Java内存模型,即Java Memory Model,简称 JMM ,它是一种抽象的概念,或者是一种协议,用来解决在并发编程过程中_内存_访问的问题,同时又可以兼容不同的硬件和操作系统,… _Java内存_区域和_内存模型_讲解_java_脚本之家 2019年1月29日 - 今天小编就为大家分享一篇关于_Java内存_区域和_内存模型_讲解,小编觉得内容挺不错的…堆(公有):是_JVM_所管理的_内存_中最大的一块。唯一目的就是存放实例对… _Java内存模型_之_JVM_进阶-李兴华的在线视频教程-CSDN学院 第一章:JVM执行分析 1. _Java_运行流程 [ 20:54 ] 免费 2. _Java_对象访问模式 [ 19:57 ] 第二章:_JVM内存模型与_垃圾收集 1. _Java_堆内存模型 [ 11:… _JVM内存模型与_运行时数据区域 - mmmming - SegmentFault 思否 2018年10月15日 - java_定义_内存模型_的目的是:为了屏蔽各种硬件和操作系统的内存访问之间的差异。 _java…参考文章:_java_8的_jvm内存_区域。 元空间和永久代的性质是一样的,… _JVM内存模型_的相关概念-创头条 2019年9月18日 - 2.JVM内存模型 JVM在执行_Java_程序时,会把它管理的_内存_划分为若干个的区域,每个区域都有自己的用途和创建销毁时间。如下图所示,可以分为两大部分,线程… Java(JVM)内存模型 - _Java_中的_内存_管理_慕课手记 2019年3月9日 - 了解JVM内存模型,如果您想了解Java垃圾收集的工作,_Java内存_管理非常重要。今天我们将研究Java中的内存管理,JVM内存的不同部分以及如何监视和执行垃圾… _JVM内存模型_详解-_Java_工具类资源-CSDN下载 2019年9月4日 - jvm内存模型,jvm脑图,jvm调优,jvm垃圾回收算法,jvm垃圾回收器,逃逸算法等总结。jvm 所需积分/C币:12 上传时间:2019-02-22 资源大小:14MB … java内存模型(JMM)与并发 - Java 技术驿站-Java 技术驿站 2019年12月10日 - JMM-java内存模型,就是通过定义一套抽象规则,去屏蔽底层操作系统、硬件对_内存_访问…(long\\doubel 64bit数据操作允许非原子性,但目前很少有非原子性实… 聊聊我对_Java内存模型_的理解 | 并发编程网 2015年3月26日 - 我试图了解了Java_、C#和Go语言的_内存模型,发现内容基本大同小异,只是这些语言在…这个问题也曾经困扰了我很长时间,因为我从来没有从_JVM_的实现中找到… Java内存模型(JMM)总结 - 知乎 2018年10月27日 - Java内存模型_中的线程的工作内存(working memory)是cpu的寄存器和高速缓存的抽象描述。而JVM的静态内存储模型(_JVM内存模型)只是一种对内存的物理划分… java_基础,_JVM(java内存模型)_哔哩哔哩 (゜-゜)つロ 干杯~-bili…深入理解_java内存模型_系列文章 | 并发编程网 – ifeve.com 的内存语义,重排序规则及在处理器中的实现;java内存模型_的设计目标,及其与处理…Java 10的类型推导 谈谈Netty的线程_模型 _JVM_之动态方法调用:invokedynamic Java… JVM—_java内存_区域与_java内存模型__码神岛 2019年2月22日 - _jvm_在执行_java_程序的过程中会把所管理的_内存_分为若干不同的区域,有的区域随着虚拟机进程的启动而存在,有些区域则是依赖用户线程的启动和结束而建立和销毁的。 以下… _java内存模型_详解以及Java堆的分代 - 程序员大本营 _jvm_是_java_的核心和基础,在_java_编译器和os平台之间的虚拟处理器,_JVM_有自己完善的硬件架构,如处理器、堆栈、寄存器等,使用_JVM_就是为了支持与操作系统无关,实现跨平台… _Java内存模型与_线程 - loda0128的个人空间 - OSCHINA 2015年6月6日 - jvmjava内存模型_JMM多线程并发单例模式先行发生Happens-Before原则底层优化 工作_内存_与主_内存 Java内存模型(jmm)的出现是为了各种操作系统和硬件的内… 硬件_内存模型和Java内存模型_中的主内存相当于电脑中的内存还是磁盘? 2019年8月14日 - 回答：是硬盘模拟_内存_。 _java 内存模型与JVM_的_内存模型_是一个意思吗_百度知道 2018年9月18日 - 回答：是的,是一个意思。 聊聊我对_Java内存模型_的理解 | 并发编程网 – ifeve.com 所有的编程语言中都有内存模型_这个概念,区别于微架构的_内存模型,高级语言的内存模型_包括了编译器和微架构两部分。我试图了解了_Java_、C#和Go语言的_内存模型,发现内容… Java内存模型(Memory Model)_线程 2018年11月14日 - Java内存模型,Java Memory Model,我个人更喜欢“Java存储_模型_”的译法。 介绍 如前所述,_JVM_被设计成一台抽象的虚拟计算机,_JVM_的并发问题及解决方案与物理计算机中… _Java内存模型_详解(一) - 云+社区 - 腾讯云 2019年8月23日 - 本文开始死磕JMM(Java内存模型)由于知识点较多,分来写该文为JMM第一篇技术往往…同时JMM也规范了_JVM_如何与计算机_内存_进行交互。简单的来说JMM就是Jav… _jvm内存模型和_内存分配 - 简书 2019年3月19日 - _jvm_包含一套字节码指令集,一组寄存器,一个栈,一个垃圾回收堆和一个存储方法域。 _JVM_屏蔽了与具体操作系统平台相关的信息,使_Java_程序只需生成在_Java_虚… 面试问题:你了解_Java内存模型_么(Java7、8、9_内存模型_的区别) - 简书 2018年10月9日 - _Java内存模型_是每个java程序员必须掌握理解的,这是Java的核心基础,对我们编写代码特别是并发编程时有很大帮助。由于Java程序是交由_JVM_执行的,所以我们… _JVM内存模型_总结 2019年6月27日 - 在_Java内存模型_中,为了效率是允许编译器和处理器对指令进行重排序,当然重排序它…在_JVM_底层volatile是采用“_内存_屏障”来实现的。 问题的提出 计算机… _Jvm内存模型与_垃圾回收_慕课手记 2018年12月5日 - 内存模型 _JVM内存_空间包含:方法区、_java_堆、_java_栈、本地方法栈。 352511-20170810232433792-373676900.png 方法区是各个线程共享的区域,存放类信息、… 一篇文章搞懂Java内存模型(详解) - 知乎 2019年11月27日 - Java 内存模型(JMM)是一种抽象的概念,并不真实存在,它描述了一组规则或规范,…注意JMM_与JVM内存_区域划分的区别: JMM描述的是一组规则,围绕原子性、有… 什么是Java内存模型(JMM) - Java 技术驿站-Java 技术驿站 2019年12月10日 - 什么是java内存模型 缓存一致性问题 在现代计算机中,因为CPU的运算速度远大于_内存_的读写速度,因此为了不让CPU在计算的时候因为实时读取_内存_数据而影响… _JAVA_的_内存模型及_结构 | 并发编程网 – ifeve.com Java内存模型_在_JVM specification, Java SE 7 Edition, and mainly in the chapters “2.5 Runtime Data Areas” and “2.6 Frames”中有详细的说明。对象和类… _Java内存模型_、GC工作原理-Java文档类资源-CSDN下载 2017年9月1日 - 一个优秀Java程序员,必须了解_Java内存模型_、GC工作原理,以及如何优化GC的性能、…本文将从_JVM内存模型_、GC工作原理,以及GC的几个关键问题进行探讨,从… _Java内存模型和_类加载过程 - JerryLin123的个人空间 - OSCHINA 2018年7月3日 - Java_栈描述的是_Java_方法执行的_内存模型:每个方法在执行的同时都会创建一个栈帧…如果类满足卸载条件,_JVM_就在GC的时候,对类进行卸载,即在方法区清除类的信息。… _java内存模型与_线程规范 PDF 下载_Java知识分享网-免费Java资源下载 2014年4月13日 - _java内存模型与_线程规范 PDF 下载失效链接处理 _java内存模型与_线程规范 PDF 下载 下载地址:_java内存模型与_线程规范 PDF 下载 相关截图:… 又踩到一个坑——JAVA_虚拟机最大_内存-CSDN论坛 32位操作系统最大也就只能支持4G_内存_啊。这是根据操作…堆是在_Java_虚拟机启动时创建的。 _JVM内存_最大能调…32位操作系统最大也就只能支持4G_内存_啊。这是根据操… java - _jvm内存模型_的工作_内存_和主_内存_到底是什么?是在哪个层面上… 2018年12月23日 - 看了周志明老师的&lt;深入理解_JVM_虚拟机&gt;12章,很自然地萌生了这个疑问.在书中周老师也并没有明确给出这两个概念是在哪个逻辑层次上做的划分,而只是说了”… 《深入理解_JAVA内存模型_》PDF-Java文档类资源-CSDN下载 2017年11月27日 - (java_语言规范称之为formal method parameters)和异常处理器参数(exception handler parameters)不会在线程之间共享,它们不会有内存可见性问题,也不受_… _Java内存模型和JVM内存_管理 - 鸿燕藏锋 - CSDN博客 2017年9月11日 - _Java内存模型_的主要目标是定义程序中各个变量的访问规则,即在_JVM_中将变量存储到_内存_和从_内存_中取出变量这样的底层细节。此处的变量与Java编程里面的变… _Java内存模型_JMM详解_java_脚本之家 2017年11月25日 - 这个保证简单来说就是一个线程的修改何时对其他线程可见,因此Java语言提出了JavaMemoryModel即Java内存模型,对于Java语言、_JVM_、编译器等实现者需要按… _Java内存模型_JMM 高并发原子性可见性有序性简介 多线程中篇(十… 2019年2月20日 - Java 内存模型_作为_JVM_的一种抽象_内存模型,屏蔽掉各种硬件和操作系统的内存差异,达到跨平台的内存访问效果。 Java语言规范定义了一个统一的内存管理模型JMM(Java Memory… 理解_Java内存模型__慕课手记 2018年12月7日 - _Java内存模型_抽象示意图 _JVM内存_操作的并发问题 结合前面介绍的物理机的处理器处理内存的问题,可以类比总结出_JVM内存_操作的问题,下面介绍的_Java内存模型_的执行处理将围… _JVM内存_结构、_Java内存模型_以及Java对象_模型_之间的区别_CSDN博客 2018年11月5日 - 这就是一个简单的Java对象的OOP-Klass模型,即Java对象模型。 总结 我们再来区分下JVM内存_结构、 _Java内存模型 以及 Java对象模型 三个概念。 _JVM内存_结构,和Java虚… Java内存模型与JVM (二) - 简书 2017年8月18日 - 第一步,了解_JVM_基本概念,基本结构。 第二步,了解_JVM_中线程私有区和公有区。 第三步,了解线程与_Java内存模型_。 第四步,了解并发编程 _JVM_的基础概念 _JVM_的中文… 快速带你分清java内存_结构,_java内存模型,java对象模型和jvm内存… 2019年6月22日 - 过程中的重点和难点,我习惯把这块的知识叫做javaSE高级基础,在学习jvm这块的知识,你一定会遇到几个概念,那就是java内存结构,java内存模型,java对象模… _jvm_面试系列一:_java内存模型_你掌握了多少? 2017年4月20日 - 今天我们就来聊一聊Java内存模型,面试中面试官会通过考察你对_jvm_的理解更深入得了解你的水平。如果你应聘的职位涉及系统调优,如堆大小的分配、垃圾回… _Java内存_管理-_JVM内存模型_以及JDK7和JDK8_内存模型_对比总结(三… 2019年3月22日 - 如果虚拟机栈可以动态扩展,当扩展到无法申请内存_到足够的_内存,就会抛出OutOfMemoryError异常! 4、_Java_堆 堆是_jvm内存_管理的最大的一块区域,此_内存_区域的唯一目的就… 【_Java_】JMM_内存模型和JVM内存_结构 - 热咖啡与白猫 - 博客园 2019年6月1日 - JMM_内存模型和JVM内存_结构 JAVA内存模型(Java Memory Model) Java内存模型,一般指的是JDK 5 开始使用的新的内存模型,主要由JSR-133: JavaTM Memory Mo… 终于有人把_Java内存模型_说清楚了! - 小推爱学习 - 博客园 2018年7月27日 - 网上有很多关于 _Java 内存模型_的文章,但是很多人读完之后还是搞不清楚,甚至有的…特别需要注意的是,主内存… _Java内存模型与JVM_运行时数据区的区别_a7151593的博客-CSDN博客 2019年10月12日 - _Java内存模型_是Java语言在多线程并发情况下对于共享变量读写(实际是共享变量对应的_内存_操作)的规范,主要是为了解决多线程可见性、原子性的问题,解决共… _Java 内存模型和 JVM 内存_结构真不是一回事_顿悟源码-CSDN博客 2019年9月15日 - 这两个概念估计有不少人会混淆,它们都可以说是 JVM 规范的一部分,但真不是一回事!它们描述和解决的是不同问题,简单来说, Java 内存模型,描述的是多线… 浅析java内存模型–JMM(Java Memory Model) - 路易小七 - 博客园 2016年1月22日 - 主内存和工作内存: _Java内存模型_的主要目标是定义程序中各个变量的访问规则,即在_JVM_中将变量存储到_内存_和从_内存_中取出变量这样的底层细节。此处的变量… 深入理解_Java内存模型_之系列篇 - CSniper - 博客园 2016年5月5日 - _Java内存模型_的抽象 在java中,所有实例域、静态域和数组元素存储在堆_内存_中,堆…为了实现最小安全性,_JVM_在… Java内存模型 - 残雪余香 - 博客园 2014年3月9日 - 在讨论_Java内存模型和_线程之前,先简单介绍一下硬件的效率与一致性。 2.硬件的…· _JVM内存_结构、_Java内存模型和_Java对象模型· 求你了,再问你Java_内存模型_的… Java内存模型 | 并发编程网 – ifeve.com _Java内存模型_规定了如何和何时可以看到由其他线程修改过后的共享变量的值,以及在必须时如何同步的访问共享变量。原始的_Java内存模型_存在一些不足,因此_Java内存模型_在… _java内存模型和_内存分配_kunpeng90的博客-CSDN博客 2018年5月12日 - _jvm内存模型和_内存分配 1.什么是jvm? (1)jvm是一种用于计算设备的规范,它是…(3)JVM屏蔽了与具体操作系统平台相关的信息,使_Java_程序只需生成在_Java_虚拟机上… JVM _Java内存模型与_线程 - 知乎 2020年1月18日 - 本文记录了阅读《深入理解Java虚拟机:_JVM_高级特性与最佳实践 —— 周志明》的《_Java内存模型与_线程》章节的笔记。硬件的效率与一致性计算机中的运算任… _JVM内存模型及_内存分配过程 - 神奇的旋风 - 博客园 2015年8月17日 - 一、JVM内存模型 JVM主要管理两种类型内存:堆(Heap)和非堆(Permanent区域)。 1…_Java 内存模型及_GC原理 _java内存模型及_GC原理 和 图解JVM在内存中申… _JVM内存模型与_调优__JVM内存模型与_调优_给我一个Object…_CSDN博客 2018年12月5日 - 首先需要注意的是在对JVM内存_调优的时候不能只看操作系统级别_Java_进程所占用的_内存,这个数值不能准确的反应堆_内存_的真实占用情况,因为GC过后这个值是… 细说JVM内存模型 - 追梦1819 - 博客园 2019年12月6日 - 在正式学习 JVM 内存模型_之前,先注意以下几个是问题:_JVM 内存模型与 _JAVA 内存模型_不是同一个概念。_JVM 内存模型_是从运行时数据区的结构的角度描述的概念;而 … 深入理解JAVA内存模型(PDF版)-Java文档类资源-CSDN下载 2017年10月3日 - java 内存模型JVM内存_讲解,堆栈讲解,本机内存。 立即下载 java 内存 上传时间: 2013-06-14 资源大小: 871KB 深入理解_java内存模型 本书从重排序、… _Java内存模型及_性能优化及Java垃圾回收 - mine_song的…_CSDN博客 2017年3月9日 - 一、JVM内存模型 首先介绍下Java_程序具体执行的过程: _Java_源代码文件(._java_后缀…_Java_栈:_Java_栈是_Java_方法执行的_内存模型,_Java_栈中存放的是一个个的…","link":"/2020/04/06/3-%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8CJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"title":"GraphQL 在微服务架构中的实践","text":"在过去的将近半年的时间里，作者一直在使用 GraphQL 这门相对新兴的技术开发 Web 服务，与更早出现的 SOAP 和 REST 相比，GraphQL 其实提供的是一套相对完善的查询语言，而不是类似 REST 的设计规范，所以需要语言的生态提供相应的框架支持，但是由于从它开源至今也只有两三年的时间，所以在使用的过程中，尤其是在微服务架构中实践时确实还会遇到很多问题。 GraphQL简单对象访问协议（SOAP）从今天来看已经是一门非常古老的 Web 服务技术了，虽然很多服务仍然在使用遵循 SOAP 的接口，但是到今天 REST 风格的面向资源的 API 接口已经非常深入人心，也非常的成熟；但是这篇文章要介绍的主角其实是另一门更加复杂、完备的查询语言 GraphQL。 作为 Facebook 在 2015 年推出的查询语言，GraphQL 能够对 API 中的数据提供一套易于理解的完整描述，使得客户端能够更加准确的获得它需要的数据，目前包括 Facebook、Twitter、GitHub 在内的很多公司都已经在生产环境使用 GraphQL 提供 API；其实无论我们是否决定生产环境中使用 GraphQL，它确实是一门值得学习的技术。 类型系统GraphQL 的强大表达能力主要还是来自于它完备的类型系统，与 REST 不同，它将整个 Web 服务中的全部资源看成一个有连接的图，而不是一个个资源孤岛，在访问任何资源时都可以通过资源之间的连接访问其它的资源。 如上图所示，当我们访问 User 资源时，就可以通过 GraphQL 中的连接访问当前 User 的 Repo 和 Issue 等资源，我们不再需要通过多个 REST 的接口分别获取这些资源，只需要通过如下所示的查询就能一次性拿到全部的结果： { user { id email username repos(first: 10) { id url name issues(first: 20) { id author title } } } } GraphQL 这种方式能够将原有 RESTful 风格时的多次请求聚合成一次请求，不仅能够减少多次请求带来的延迟，还能够降低服务器压力，加快前端的渲染速度。它的类型系统也非常丰富，除了标量、枚举、列表和对象等类型之外，还支持接口和联合类型等高级特性。 为了能够更好的表示非空和空字段，GraphQL 也引入了 Non-Null 等标识代表非空的类型，例如 String! 表示非空的字符串。 schema { query: Query mutation: Mutation } Schema 中绝大多数的类型都是普通的对象类型，但是每一个 Schema 中都有两个特殊类型：query 和 mutation，它们是 GraphQL 中所有查询的入口，在使用时所有查询接口都是 query 的子字段，所有改变服务器资源的请求都应该属于 mutation 类型。 集中式 vs 分散式GraphQL 以图的形式将整个 Web 服务中的资源展示出来，其实我们可以理解为它将整个 Web 服务以 “SQL” 的方式展示给前端和客户端，服务端的资源最终都被聚合到一张完整的图上，这样客户端可以按照其需求自行调用，类似添加字段的需求其实就不再需要后端多次修改了。 与 RESTful 不同，每一个的 GraphQL 服务其实对外只提供了一个用于调用内部接口的端点，所有的请求都访问这个暴露出来的唯一端点。 GraphQL 实际上将多个 HTTP 请求聚合成了一个请求，它只是将多个 RESTful 请求的资源变成了一个从根资源 Post 访问其他资源的 Comment 和 Author 的图，多个请求变成了一个请求的不同字段，从原有的分散式请求变成了集中式的请求，这种方式非常适合单体服务直接对外提供 GraphQL 服务，能够在数据源和展示层建立一个非常清晰的分离，同时也能够通过一些强大的工具，例如 GraphiQL 直接提供可视化的文档；但是在业务复杂性指数提升的今天，微服务架构成为了解决某些问题时必不可少的解决方案，所以如何在微服务架构中使用 GraphQL 提高前后端之间的沟通效率并降低开发成本成为了一个值得考虑的问题。 Relay 标准如果说 RESTful 其实是客户端与服务端在 HTTP 协议通信时定义的固定标准，那么 Relay 其实也是我们在使用 GraphQL 可以遵循的一套规范。 这种标准的出现能够让不同的工程师开发出较为相似的通信接口，在一些场景下，例如标识对象和分页这种常见的需求，引入设计良好的标准能够降低开发人员之间的沟通成本。 Relay 标准其实为三个与 API 有关的最常见的问题制定了一些规范： 提供能够重新获取对象的机制； 提供对如何对连接进行分页的描述； 标准化 mutation 请求，使它们变得更加可预测； 通过将上述的三个问题规范化，能够极大地增加前后端对于接口制定和对接时的工作效率。 对象标识符Node 是 Relay 标准中定义的一个接口，所有遵循 Node 接口的类型都应该包含一个 id 字段： interface Node { id: ID! } type Faction : Node { id: ID! name: String ships: ShipConnection } type Ship : Node { id: ID! name: String } Faction 和 Ship 两个类型都拥有唯一标识符 id 字段，我们可以通过该标识符重新从服务端取回对应的对象，Node 接口和字段在默认情况下会假定整个服务中的所有资源的 id 都是不同的，但是很多时候我们都会将类型和 id 绑定到一起，组合后才能一个类型特定的 ID；为了保证 id 的不透明性，返回的 id 往往都是 Base64 编码的字符串，GraphQL 服务器接收到对应 id 时进行解码就可以得到相关的信息。 连接与分页在一个常见的数据库中，一对多关系是非常常见的，一个 User 可以同时拥有多个 Post 以及多个 Comment，这些资源的数量在理论上不是有穷的，没有办法在同一个请求全部返回，所以要对这部分资源进行分页。 query { viewer { name email posts(first: 1) { edge { cursor node { title} } } } } Relay 通过抽象出的『连接模型』为一对多的关系提供了分片和分页的支持，在 Relay 看来，当我们获取某一个 User 对应的多个 Post 时，其实是得到了一个 PostConnection，也就是一个连接： { \"viewer\": { \"name\": \"Draveness\", \"email\": \"i@draveness.me\", \"posts\": { \"edges\": [ \"cursor\": \"YXJyYXljb25uZWN0aW9uOjI=\", \"node\": { \"title\": \"Post title\", } ] } } } 在一个 PostConnection 中会存在多个 PostEdge 对象，其中的 cursor 就是我们用来做分页的字段，所有的 cursor 其实都是 Base64 编码的字符串，这能够提醒调用方 cursor 是一个不透明的指针，拿到当前 cursor 后就可以将它作为 after 参数传到下一个查询中： query { viewer { name email posts(first: 1, after: “YXJyYXljb25uZWN0aW9uOjI=”) { edge { cursor node { title} } } } } 当我们想要知道当前页是否是最后一页时，其实只需要使用每一个连接中的 PageInfo 对象，其中包含了很多与分页相关的信息，一个连接对象中一般都有以下的结构和字段，例如：Edge、PageInfo 以及游标和节点等。 PostConnection ├── PostEdge │ ├── cursor │ └── Post └── PageInfo ├── hasNextPage├── hasPreviousPage├── startCursor└── endCursor Relay 使用了非常多的功能在连接周围构建抽象，让我们能够更加方便地管理客户端中的游标，整个连接相关的规范其实特别复杂，可以阅读 Relay Cursor Connections Specification 了解更多与连接和游标有关的设计。 可变请求每一个 Web 服务都可以看做一个大型的复杂状态机，这个状态机对外提供两种不同的接口，一种接口是查询接口，它能够查询状态机的当前状态，而另一种接口是可以改变服务器状态的可变操作，例如 POST、DELETE 等请求。 按照约定，所有的可变请求都应该以动词开头并且它们的输入都以 Input 结尾，与之相对应的，所有的输出都以 Payload 结尾： input IntroduceShipInput { factionId: ID! shipName: String! clientMutationId: String! } type IntroduceShipPayload { faction: Faction ship: Ship clientMutationId: String! } 除此之外，可变请求还可以通过传入 clientMutationId 保证请求的幂等性。 小结Facebook 的 Relay 标准其实是一个在 GraphQL 上对于常见领域问题的约定，通过这种约定我们能够减少工程师的沟通成本和项目的维护成本并在多人协作时保证服务对外提供接口的统一。 N + 1 问题在传统的后端服务中，N + 1 查询的问题就非常明显，由于数据库中一对多的关系非常常见，再加上目前大多服务都使用 ORM 取代了数据层，所以在很多时候相关问题都不会暴露出来，只有真正出现性能问题或者慢查询时才会发现。 SELECT * FROM users LIMIT 3; SELECT * FROM posts WHERE user_id = 1; SELECT * FROM posts WHERE user_id = 2; SELECT * FROM posts WHERE user_id = 3; SELECT * FROM users LIMIT 3; SELECT * FROM posts WHERE user_id IN (1, 2, 3); GraphQL 作为一种更灵活的 API 服务提供方式，相比于传统的 Web 服务更容易出现上述问题，类似的问题在出现时也可能更加严重，所以我们更需要避免 N + 1 问题的发生。 数据库层面的 N + 1 查询我们可以通过减少 SQL 查询的次数来解决，一般我们会将多个 = 查询转换成 IN 查询；但是 GraphQL 中的 N + 1 问题就有些复杂了，尤其是当资源需要通过 RPC 请求从其他微服务中获取时，更不能通过简单的改变 SQL 查询来解决。 在处理 N + 1 问题之前，我们要真正了解如何解决这一类问题的核心逻辑，也就是将多次查询变成一次查询，将多次操作变成一次操作，这样能够减少由于多次请求增加的额外开销 —— 网络延迟、请求解析等；GraphQL 使用了 DataLoader 从业务层面解决了 N + 1 问题，其核心逻辑就是整个多个请求，通过批量请求的方式解决问题。 微服务架构微服务架构在当下已经成为了遇到业务异常复杂、团队人数增加以及高并发等需求或者问题时会使用的常见解决方案，当微服务架构遇到 GraphQL 时就会出现很多理论上的碰撞，会出现非常多的使用方法和解决方案。 在这一节中，我们将介绍在微服务架构中使用 GraphQL 会遇到哪些常见的问题，对于这些问题有哪些解决方案需要权衡，同时也会分析 GraphQL 的设计理念在融入微服务架构中应该注意什么。 当我们在微服务架构中融入 GraphQL 的标准时，会遇到三个核心问题，这些问题其实主要是从单体服务迁移到微服务架构这种分布式系统时引入的一系列技术难点，这些技术难点以及选择之间的折衷是在微服务中实践 GraphQL 的关键。 Schema 设计GraphQL 独特的 Schema 设计其实为整个服务的架构带来了非常多的变数，如何设计以及暴露对外的接口决定了我们内部应该如何实现用户的认证与鉴权以及路由层的设计。 从总体来看，微服务架构暴露的 GraphQL 接口应该只有两种；一种接口是分散式的，每一个微服务对外暴露不同的端点，分别对外界提供服务。 在这种情况下，流量的路由是根据用户请求的不同服务进行分发的，也就是我们会有以下的一些 GraphQL API 服务： http://draveness.me/posts/api/graphql http://draveness.me/comments/api/graphql http://draveness.me/subscriptions/api/graphql 我们可以看到当前博客服务总共由内容、评论以及订阅三个不同的服务来提供，在这时其实并没有充分利用 GraphQL 服务的好处，当客户端或前端同时需要多个服务的资源时，需要分别请求不同服务上的资源，并不能通过一次 HTTP 请求满足全部的需求。 另一种方式其实提供了一种集中式的接口，所有的微服务对外共同暴露一个端点，在这时流量的路由就不是根据请求的 URL 了，而是根据请求中不同的字段进行路由。 这种路由的方式并不能够通过传统的 nginx 来做，因为在 nginx 看来整个请求其实只有一个 URL 以及一些参数，我们只有解析请求参数中的查询才能知道客户端到底访问了哪些资源。 http://draveness.me/api/graphql 请求的解析其实是对一颗树的解析，这部分解析其实是包含业务逻辑的，在这里我们需要知道的是，这种 Schema 设计下的请求是按照 field 进行路由的，GraphQL 其实帮助我们完成了解析查询树的过程，我们只需要对相应字段实现特定的 Resolver 处理返回的逻辑就可以了。 然而在多个微服务提供 Schema 时，我们需要通过一种机制将多个服务的 Schema 整合起来，这种整合 Schema 的思路最重要的就是需要解决服务之间的重复资源和冲突字段问题，如果多个服务需要同时提供同一个类型的基础资源，例如：User 可以从多种资源间接访问到。 { post(id: 1) { user { id email } id title content } 作为微服务的开发者或者提供方来讲，不同的微服务之间的关系是平等的，我们需要一个更高级别或者更面向业务的服务对提供整合 Schema 的功能，确保服务之间的字段与资源类型不会发生冲突。 前缀如何解决冲突资源从目前来看有两种不同的方式，一种是为多个服务提供的资源添加命名空间，一般来说就是前缀，在合并 Schema 时，通过添加前缀能够避免不同服务出现重复字段造成冲突的可能。 SourceGraph 在实践 GraphQL 时其实就使用了这种增加前缀的方式，这种方式的实现成本比较低，能够快速解决微服务中 Schema 冲突的问题，读者可以阅读 GraphQL at massive scale: GraphQL as the glue in a microservice architecture 一文了解这种做法的实现细节；这种增加前缀解决冲突的方式优点就是开发成本非常低，但是它将多个服务的资源看做孤岛，没有办法将多个不同服务中的资源关系串联起来，这对于中心化设计的 GraphQL 来说其实会造成一定体验上的丢失。 粘合除了增加前缀这种在工程上开发成本非常低的方法之外，GraphQL 官方提供了一种名为 Schema Stitching 的方案，能够将不同服务的 GraphQL Schema 粘合起来并对外暴露统一的接口，这种方式能够将多个服务中的不同资源粘合起来，能够充分利用 GraphQL 的优势。 为了打通不同服务之间资源的壁垒、建立合理并且完善的 GraphQL API，我们其实需要付出一些额外的工作，也就是在上层完成对公共资源的处理；当对整个 Schema 进行合并时，如果遇到公共资源，就会选用特定的 Resolver 进行解析，这些解析器的逻辑是在 Schema Stitching 时指定的。 const linkTypeDefs = ` extend type User { chirps: [Chirp] } `; 我们需要在服务层上的业务层对服务之间的公共资源进行定义，并为这些公共资源建立新的 Resolver，当 GraphQL 解析当公共资源时，就会调用我们在合并 Schema 时传入的 Resolver 进行解析和处理。 const mergedSchema = mergeSchemas({ schemas: [ chirpSchema, authorSchema, linkTypeDefs, ], resolvers: { User: { chirps: { fragment: ... on User { id }, resolve(user, args, context, info) { return info.mergeInfo.delegateToSchema({ schema: chirpSchema, operation: 'query', fieldName: 'chirpsByAuthorId', args: { authorId: user.id, }, context, info, }); }, }, }, }, }); 在整个 Schema Stitching 的过程中，最重要的方法其实就是 mergeSchemas，它总共接受三个参数，需要粘合的 Schema 数组、多个 Resolver 以及类型出现冲突时的回调： mergeSchemas({ schemas: Array; resolvers?: Array | IResolvers; onTypeConflict?: ( left: GraphQLNamedType, right: GraphQLNamedType, info?: { left: { schema?: GraphQLSchema; }; right: { schema?: GraphQLSchema; }; }, ) => GraphQLNamedType; }) Schema Stitching 其实是解决多服务共同对外暴露 Schema 时比较好的方法，这种粘合 Schema 的方法其实是 GraphQL 官方推荐的做法，同时它们也为使用者提供了 JavaScript 的工具，但是它需要我们在合并 Schema 的地方手动对不同 Schema 之间的公共资源以及冲突类型进行处理，还要定义一些用于解析公共类型的 Resolver；除此之外，目前 GraphQL 的 Schema Stitching 功能对于除 JavaScript 之外的语言并没有官方的支持，作为一个承载了服务发现以及流量路由等功能的重要组件，稳定是非常重要的，所以应该慎重考虑是否应该自研用于 Schema Stitching 组件。 组合除了上述的两种方式能够解决对外暴露单一 GraphQL 的问题之外，我们也可以使用非常传统的 RPC 方式组合多个微服务的功能，对外提供统一的 GraphQL 接口： 当我们使用 RPC 的方式解决微服务架构下 GraphQL Schema 的问题时，内部的所有服务组件其实与其他微服务架构中的服务没有太多区别，它们都会对外提供 RPC 接口，只是我们通过另一种方式 GraphQL 整合了多个微服务中的资源。 使用 RPC 解决微服务中的问题其实是一个比较通用同时也是比较稳定的解决方案，GraphQL 作为一种中心化的接口提供方式，通过 RPC 调用其他服务的接口并进行合并和整合其实也是一个比较合理的事情；在这种架构下，我们其实可以在提供 GraphQL 接口的情况下，也让各个微服务直接或者通过其他业务组件对外暴露 RESTful 接口，提供更多的接入方式。 虽然 RPC 的使用能为我们的服务提供更多的灵活性，同时也能够将 GraphQL 相关的功能拆分到单独的服务中，但是这样给我们带来了一些额外的工作量，它需要工程师手动拼接各个服务的接口并对外提供 GraphQL 服务，在遇到业务需求变更时也可能会导致多个服务的修改和更新。 小结从使用前缀、粘合到使用 RPC 组合各个微服务提供的接口，对外暴露的 Schema 其实是一个由点到面逐渐聚合的过程，同时实现的复杂度也会逐步上升。 在这三种方式中，作者并不推荐使用前缀的方式隔离多个微服务提供的接口，这种做法并没有充分利用 GraphQL 的好处，不如使用 RESTful 将多个服务的接口直接解耦，使用 GraphQL 反而是有一些滥用的感觉。 除了使用前缀的做法之外，无论是粘合还是组合都能够提供一个完整的 GraphQL 接口，它们两者都需要在直接对接用户的 GraphQL 服务中对各个微服务提供的接口进行整合，当我们使用 Schema Stitching 时，其实对后面的服务提出了更多的要求 —— 开发微服务的工程师需要掌握 GraphQL Schema 的设计与开发方法，与此同时，各个微服务之间的类型也可能出现冲突，需要在上层进行解决，不过这也减少了一些最前面的 GraphQL 服务的工作量。 在最后，使用组合方式就意味着整个架构中的 GraphQL 服务需要通过组合 RPC 的方式处理与 GraphQL 相关的全部逻辑，相当于把 GraphQL 相关的全部逻辑都抽离到了最前面。 经过几次架构的重构之后，在微服务架构中，作者更倾向于使用 RPC 组合各个微服务功能的方式提供 GraphQL 接口，虽然这样带来了更多的工作量，但是却能拥有更好的灵活性，也不需要其他微服务的开发者了解 GraphQL 相关的设计规范以及约定，让各个服务的职责更加清晰与可控。 认证与授权在一个常见的 Web 服务中，如何处理用户的认证以及鉴权是一个比较关键的问题，因为我们需要了解在使用 GraphQL 的服务中我们是如何进行用户的认证与授权的。 如果我们决定 Web 服务作为一个整体对外暴露的是 GraphQL 的接口，那么在很大程度上，Schema 设计的方式决定了认证与授权应该如何组织；作为一篇介绍 GraphQL 在微服务架构中实践的文章，我们也自然会介绍在不同 Schema 设计下，用户的认证与授权方式应该如何去做。 上一节中总共提到了三种不同的 Schema 设计方式，分别是：前缀、粘合和组合，这些设计方式在最后都会给出一个如下所示的架构图： 使用 GraphQL 的所有结构最终都会由一个中心化的服务对外接受来自客户端的 GraphQL 请求，哪怕它仅仅是一个代理，当我们有了这张 GraphQL 服务的架构图，如何对用户的认证与授权进行设计就变得非常清晰了。 认证首先，用户的认证在多个服务中分别实现是大不合理的，如果需要在多个服务中处理用户认证相关的逻辑，相当于将一个服务的职责同时分给了多个服务，这些服务需要共享用户认证相关的表，users、sessions 等等，所以在整个 Web 服务中，由一个服务来处理用户认证相关的逻辑是比较合适的。 这个服务既可以是作为网关代理的 GraphQL 服务本身，也可以是一个独立的用户认证服务，在每次用户请求时都会通过 RPC 或者其他方式调用该服务提供的接口对用户进行认证，用户的授权功能与认证就有一些不同了。 授权我们可以选择在 GraphQL 服务中增加授权的功能，也可以选择在各个微服务中判断当前用户是否对某一资源有权限进行操作，这其实是集中式跟分布式之间的权衡，两种方式都有各自的好处，前者将鉴权的权利留给了各个微服务，让它们进行自治，根据其业务需要判断请求者是否可以访问后者修改资源，而后者其实把整个鉴权的过程解耦了，内部的微服务无条件的信任来自 GraphQL 服务的请求并提供所有的服务。 上面的设计其实都是在我们只需要对外提供一个 GraphQL 端点时进行的，当业务需要同时提供 B 端、C 端或者管理后台的接口时，设计可能就完全不同了。 在这时，如果我们将鉴权的工作分给多个内部的微服务，每个服务都需要对不同的 GraphQL 服务（或者 Web 服务）提供不同的接口，然后分别进行鉴权；但是将鉴权的工作交给 GraphQL 服务就是一种比较好的方式了，内部的微服务不需要关心调用者是否有权限访问该资源，鉴权都由最外层的业务服务来处理，实现了比较好的解耦。 当然，完全的信任其他服务的调用其实是一个比较危险的事情，对于一些重要的业务或者请求调用可以通过外部的风控系统进行二次检查判断当前请求方调用的合法性。 如何实现一个完备并且有效的风控系统并不是这篇文章想要主要介绍的内容，读者可以寻找相关的资料了解风控系统的原理以及模型。 小结认证与授权的设计本来是系统中一件比较灵活的事情，无论我们是否在微服务架构中使用 GraphQL 作为对外的接口，将这部分逻辑交由直接对外暴露的服务是一种比较好的选择，因为直接对外暴露的服务中掌握了更多与当前请求有关的上下文，能够更容易地对来源用户以及其权限进行认证，而重要或者高危的业务操作可以通过额外增加风控服务管理风险，或者在路由层对 RPC 的调用方通过白名单进行限制，这样能够将不同的功能解耦，减少多个服务之间的重复工作。 路由设计作为微服务中非常重要的一部分，如何处理路由层的设计也是一个比较关键的问题；但是与认证与鉴权相似的是，Schema 的设计最终其实就决定了请求的路由如何去做。 GraphQL Schema Stitching 其实已经是一套包含路由系统的 GraphQL 在微服务架构的解决方案了，它能够在网关服务器 Resolve 请求时，通过 HTTP 协议将对应请求的片段交由其他微服务进行处理，整个过程不需要手动介入，只有在类型出现冲突时会执行相应的回调。 而组合的方式其实就相当于要手动实现 Schema Stitching 中转发请求的工作了，我们需要在对外暴露的 GraphQL 服务中实现相应字段的解析器调用其他服务提供的 HTTP 或者 RPC 接口取到相应的数据。 在 GraphQL 中的路由设计其实与传统微服务架构中的路由设计差不多，只是 GraphQL 提供了 Stitching 的相关工具用来粘合不同服务中的 Schema 并提供转发服务，我们可以选择使用这种粘合的方式，也可以选择在 Resolver 中通过 HTTP 或者 RPC 的方式来自获取用户请求的资源。 架构的演进从今年年初选择使用 GraphQL 作为服务对外暴露的 API 到现在大概有半年的事件，服务的架构也在不断演进和改变，在这个过程中确实经历了非常多的问题，也一次一次地对现有的服务架构进行调整，整个演进的过程其实可以分为三个阶段，从使用 RPC 组合的方式到 Schema Stitching 最后再回到使用 RPC。 虽然在整个架构演进的过程中，最开始和最终选择的技术方案虽然都是使用 RPC 进行通信，但是在实现的细节上却有着很多的不同以及差异，这也是我们在业务变得逐渐复杂的过程发现的。 中心化 Schema 与 RPC当整个项目刚刚开始启动时，其实就已经决定了使用微服务架构进行开发，但是由于当时选择使用的技术栈是 Elixir + Phoenx，所以很多基础设施并不完善，例如 gRPC 以及 Protobuf 就没有官方版本的 Elixir 实现，虽然有一些开源项目作者完成的项目，但是都并不稳定，所以最终决定了在 RabbitMQ 上简单实现了一个基于消息队列的 RPC 框架，并通过组合的方式对外提供 GraphQL 的接口。 RabbitMQ 在微服务架构中承担了消息总线的功能，所有的 RPC 请求其实都被转换成了消息队列中的消息，服务在调用 RPC 时会向 RabbitMQ 对应的队列投递一条消息并持续监听消息的回调，等待其他服务的响应。 这种做法的好处就是 RabbitMQ 中的队列承担了『服务发现』的职能，通过队列的方式将请求方与服务方解耦，对 RPC 请求进行路由，所以下游的消费者（服务方）可以水平扩展，但是这种方式其实也可以由负载均衡来实现，虽然负载均衡由于并不清楚服务方的负载，所以在转发请求时的效果可能没有服务方作为消费者主动拉的效率高。 最关键的问题是，手搓的 RPC 框架作为基础服务如果没有经过充分的测试以及生产环境的考验是不成熟的，而且作为语言无关的一种调用方式，我们可能需要为很多语言同时实现 RPC 框架，这其实就带来了非常高的人力、测试和维护成本，现在来看不是一个非常可取的方法。 如果我们抛开语言不谈，在一个比较成熟的语言中使用 RPC 的方式进行通信，确实能降低很多开发和维护的成本，但是也有另外一个比较大的代价，当业务并不稳定需要经常变更时，内部服务会经常为对外暴露的 RPC 接口添加额外的字段，而这也会要求最前面的 GraphQL 服务做额外的工作： 每一次服务的修改都会导致三个相关服务或仓库进行更新，这虽然是在微服务架构中是一件比较正常合理的事情，但是在项目的早期阶段这会导致非常多额外的工作量，这也是我们进行第一次架构迁移的主要原因。 去中心化管理的 Schema这里的去中心化其实并不是指 GraphQL 对外暴露多个端点，而是指 GraphQL 不同 field 的开发过程去中心化，为了解决中心化的 Schema 加上 RPC 带来的开发效率问题并且实践 GraphQL 官方提供的 Schema Stitching 解决方案，我们决定将 Schema 的管理去中心化，由各个微服务对外直接暴露 GraphQL 请求，同时将多个服务的 Schema 进行合并，以此来解决开发的效率问题。 使用 Schema Stitching 的方式能够将多个服务中不同的 GraphQL Schema 粘合成一个更大的 Schema，这种架构下最关键的组件就是用于 Schema 粘合的工具，在上面已经说到，除了 Javascript 之外的其他语言并没有官方的工具支持，也没有在生产环境中大规模使用，同时因为我们使用的也是一个比较小众的语言 Elixir，所以更不存在一个可以拆箱即用的工具了。 经过评估之后，我们决定在 GraphQL Elixir 实现 Absinthe 上进行一层包装，并对客户端的请求进行语法与语义的解析，将字段对应的树包装成子查询发送给下游的服务，最终再由最前面的 GraphQL 服务组合起来： GraphQL 前端服务总共包含两个核心组件，分别是 GraphQL Stitcher 和 Dispatcher，其中前者负责向各个 GraphQL 服务请求 IntrospectionQuery 并将获得的所有 Schema 粘合成一颗巨大的树；当客户端进行请求时，Graphql Dispatcher 会通过语法解析当前的请求，并将其中不同的字段以及子字段转换成树后转发给对应的服务。 在实现 GraphQL Stitcher 的过程中，需要格外注意不同服务之间类型冲突的情况，我们在实现的过程中并没有支持类型冲突以及跨服务资源的问题，而是采用了覆盖的方式，这其实有很大的问题，内部的 GraphQL 服务其实并不知道整个 Schema 中有哪些类型是已经被使用的，所以经常会造成服务之间的类型冲突，我们只有在发现时手动增加前缀来解决冲突。 增加前缀是一个比较容易的解决冲突的办法，但是却并不是特别的优雅，使用这种方式的主要原因是，我们发现了由于权限系统的设计缺陷 —— 在引入 B 端用户时无法优雅的实现鉴权，所以选择使用一种比较简单的办法临时解决类型冲突的问题。 在开发各种内部服务时，我们通过 scope 的方式对用户是否有权限读写资源做了限制，内部服务在执行操作前会先检查请求的用户是否能够读写该资源，然后开始处理真正的业务逻辑，也就是说用户鉴权是发生在所有的内部服务中的。 当我们对外暴露的 GraphQL 服务仅仅是面向 C 端用户的时候，使用 scope 并且让内部服务进行鉴权其实能够满足 C 端对于接口的需求，但是当我们需要同时为 B 端用户提供 GraphQL 或者 RESTful 接口时，这种鉴权方式其实就非常尴尬了。 在微服务架构中，由于各个服务之间的数据库是隔离的，对于一条数据库记录来说，很多内部服务都只能知道当前记录属于哪个用户或者那些用户，所以对于 scope 来说传递资源、读写请求加上来源用户就能够让处理请求的服务判断当前的来源用户是否有权限访问该条记录。 这种结论基于我们做的一条假设 —— 微服务收到的所有请求其实都要求读写来源用户拥有的资源，所以在引入 B 端用户时就遇到了比较大的困难，我们采用的临时解决方案就是在当前用户的 scope 中添加一些额外的信息并在内部服务中添加新的接口满足 B 端查询的需要，但是由于 B 端对于资源的查询要求可能非常多样，当我们需要为不同的查询接口进行不同的权限限制，并且在 B 端用户也不能访问全部用户的资源时，scope 的方式就很难表现这种复杂的鉴权需求。 在这种 Schema 管理去中心化的架构中，我们遇到了两个比较重要的问题： 用于 Schema Stitching 的组件对于 Elixir 语言并没有官方或者大型开源项目的支持，手搓的组件在承载较大的服务负载时会有很大的压力，同时功能也有非常多不完善的地方； 在内部服务对于整个请求没有太多上下文的情况下，一旦遇到复杂的鉴权需求时，将鉴权交给内部服务的的设计方式会导致服务之间的耦合增加 —— 微服务之间需要不断传递请求的上下文用于鉴权，同时也增加了开发的成本； 服务网格与 RPC使用去中心化管理的 Schema 虽然在一定程度上减少了开发的工作，但是在这种架构下我们也遇到了两个不能接受的问题，为了解决这些问题，我们准备对当前的技术架构做出以下的修改，让各个服务能够更加灵活的通信： 最新的架构设计中，我们使用 linkerd 来处理服务之间的通信，所有的内部服务不在独立对来源请求进行鉴权，它们只负责对外提供 RPC 接口，在这里使用 gRPC 和 Protobuf 对不同服务的接口进行管理，所有的鉴权都发生在最外层的 Web 服务中，面向 C 端用户的 GraphQL 服务以及面向 B 端用户的 Web 服务，分别会对来源的请求进行鉴权，通过鉴权后再向对应服务发起 RPC 请求，请求的路由和流量的转发都由 linkerd 完成。 linkerd 是服务网格（Service Mesh）技术的一个实现，它是一个开源的网络代理，能够在不改变现有服务的基础上为服务提供服务发现、管理、监控等功能，我们在这篇文章中并不会展开介绍服务网格这门技术，有兴趣的读者可以查找相关的资料。 由于面向 B 端用户可能涉及到较多的查询请求，并且这些请求非常复杂，我们可以选择使用从库的方式同步其他服务的数据，在服务内部实现相应的查询功能，当然也可以使用数据中心或者仓库的方式将数据处理后提供给面向 B 端用户的外部服务。 这种服务组织方式其实更像是对第一版架构的修改，通过引入 linkerd 解决服务发现、路由以及治理的问题，将一些微服务通用的基础设施交给相对成熟的开源项目负责，而鉴权逻辑被上移到了几个直接对外暴露的 Web 服务中，内部的服务不再承担鉴权的工作，虽然在这时依然会存在一次服务接口的改动，会导致多处进行修改的问题，但是从现在来看这是为了保持服务的灵活带来的代价。 总结从刚开始使用 GraphQL 到现在已经过去了将近半年的时间，在微服务中实践 GraphQL 的过程中，我们发现了微服务与 GraphQL 之间设计思路冲突的地方，也就是去中心化与中心化。 作为一门中心化的查询语言，GraphQL 在最佳实践中应该只对外暴露一个端点，这个端点会包含当前 Web 服务应该提供的全部资源，并把它们合理的连接成图，但是微服务架构恰恰是相反的思路，它的初衷就是将大服务拆分成独立部署的服务，所以在最后对架构进行设计时，我们分离了这两部分的逻辑，使用微服务架构对服务进行拆分，通过 GraphQL 对微服务接口进行组合并完成鉴权功能，同时满足了两种不同设计的需求。 在架构演进的过程中，我们遇到了很多设计不合理的地方，也因为没有预见到业务扩展带来需求改动，由此导致架构上无法优雅地实现新的需求；最后选择使用服务网格（Service Mesh）的方式对现有的架构进行重构，也是因为微服务治理相关的事情应该由统一的中间层来做，自己重新实现服务治理相关的逻辑成本也非常高，使用服务网格已经与 GraphQL 没有太多的联系了，GraphQL 服务也只是作为一个对外暴露的端点组合内部服务提供的接口，我们也可以将接口换成 RESTful 或者其他形式，这对于整体的架构设计没有太多的影响；回过头来看，当项目刚刚启动时不应该将 GraphQL 接口摆在一个特别重要的位置上，划分服务之间的边界并进行合理的解耦才是影响比较深远的事情。 到最后，我们会发现在微服务架构中，GraphQL 其实只是整个链路中的一环，或许官方提供的一些工具与微服务中的一些问题有关，但是从整个架构来看对外是否使用 GraphQL 其实不是特别的重要，将服务之间的职责进行解耦并对外提供合理的接口才是最关键的，只要架构上的设计合理，我们可以随时引入一个 GraphQL 服务来组合其他服务的功能，其优点在于： 将多个网络请求合并成一个，减少前后端之间的网络请求次数，加快前端页面的渲染； 提供了体验非常好的调试工具 GraphiQL，并可以通过代码生成文档，节约文档的维护成本和沟通成本； 不得不说 GraphQL 作为一门新兴的技术有着非常多的优点，很多公司都在尝试使用 GraphQL 对外提供 API，虽然目前来说这门技术不算特别成熟，但是却也有巨大的潜力。 Reference Web 服务编程，REST 与 SOAP GraphQL Relay GraphQL Server Specification Relay Cursor Connections Specification Solving the N+1 Problem for GraphQL through Batching – Shopify Engineering How Facebook organizes their GraphQL code How to structure GraphQL server code GraphQL as an API Gateway to Microservices GraphQL at massive scale: GraphQL as the glue in a microservice architecture GrAMPS Documentation Using GraphQL with Microservices in Go Linkerd 这篇文章中，首先会简单介绍 GraphQL 是什么，它能够解决的问题；在这之后，我们会重点分析 GraphQL 在微服务架构中的使用以及在实践过程中遇到的棘手问题，在最后作者将给出心中合理的 GraphQL 微服务架构的设计，希望能为同样在微服务架构中使用 GraphQL 的工程师提供一定的帮助，至于给出的建议是否能够满足读者在特定业务场景下的需求就需要读者自行判断了。","link":"/2020/06/14/GraphQL%20%E5%9C%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/"},{"title":"15.深入Java系列Java堆内存溢出解决方案","text":"Java_常见的几种_内存溢出_及_解决方案 - 平凡希 - 博客园 2017年9月4日 - Java_常见的几种_内存溢出_及_解决方案 1.JVM Heap(堆)溢出:java.lang.OutOfMemoryError: Java heap space JVM在启动的时候会自动设置JVM Heap的值, 可以… _Java内存溢出_详解及_解决方案___Java__易雪寒的博客-CSDN博客 2018年3月12日 - 本文以笔者开发和支持的多个项目为例,与大家分享在开发过程中遇到的_Java内存溢出_和数据库锁表的检测和_处理解决_过程。 2._内存溢出_的分析 _内存溢出_是指… 程序员:学习心得,_Java内存_区域,_内存溢出_异常 2019年12月10日 - 也就是以 8 字节为内存访问的基本单元,那么在地理处理上,就有 3 个位是空闲…Java内存溢出_异常_内存溢出堆_上无内存可完成实例分配且_堆_无法扩展时:_java.lang… Java堆内存溢出_的_解决方案 - qq_36318234的博客 - CSDN博客 2019年9月18日 - JAVA堆内存_管理是影响性能主要因素之一。 _堆内存溢出_是JAVA项目非常常见的故障,在解决该问题之前,必须先了解下_JAVA堆内存_是怎么工作的。 先看下_JAVA堆… _java内存溢出_问题(工作中常用、面试中常问的一个知识点) 2019年12月11日 - (3)java堆_和方法区:_java堆_区主要存放对象实例和数组等,方法区保存类信息、常量…用友内存溢出7 win10内存溢出 内存溢出异常 _内存溢出解决办法 作者最新文章 详解… Java内存溢出_的详细_解决方案 - 小六.223 - 博客园 2015年9月10日 - Java内存溢出_的详细_解决方案 一、内存溢出_类型 1、_java.lang.OutOfMemoryError: PermGen space JVM管理两种类型的内存,堆和非堆。堆是给开发人员用的… _Java内存溢出_的_解决方案__百度文库 评分:3.5/5 5页 2012年1月4日 - Java 内存溢出_的_解决方案 一、内存溢出_类型 1、_java.lang.OutOfMemoryError: PermGen space JVM 管理两种类型的内存,堆和非堆。堆是给开发人员用的上… 如何解决_物理_内存_不足引起的_JAVA 堆内存溢出-CSDN论坛 2007年6月26日 - 最近又加了一个_java_程序,启动配置-Xmx1024 但是当该程序使用内存到800M的时候,机器就成10M的内存了,然后就会出现_堆内存溢出_的问题了。 请各位达人指点… _Java 堆内存溢出_梗概分析 - OSCHINA 2018年3月19日 - 当内存溢出_时,获取到 _Java 进程中的堆转储。 明白应用程序正在遭遇的内存问题的类型。 使用一个堆分析器,可以使用 Eclipse MAT 这个优秀的开源项目来… java内存溢出解决方案-_Java_文档类资源-CSDN下载 2013年9月25日 - 该文档详细描述了,内存溢出_各种问题和_解决方案,适合学习!更多下载资源、学习资料请访问CSDN下载频道. JVM发生内存溢出_的8种原因、及_解决办法 2019年8月16日 - 造成原因_内存_不足,无法创建新线程。由于线程在本机_内存_中创建,报告这个错误表明本机_内存_空间不足_解决方案_为机器分配更多的_内存_减少 _Java 堆_空间修复应用… _Java 堆内存溢出_梗概分析 - 编程语言 - ITeye资讯 2018年3月30日 - 当内存溢出_时,获取到 _Java 进程中的堆转储。 明白应用程序正在遭遇的内存问题的类型。 使用一个堆分析器,可以使用 Eclipse MAT 这个优秀的开源项目… Java_中OutOfMemoryError(_内存溢出)的三种常见情况及解决办法 算法对几万条文本记录(每条记录的特征向量大约10来个)进行文本聚类时,由于程序细节上有问题,就导致了Java heap space的_内存溢出_问题,后来通过修改程序得到了解决。… 【java _内存溢出_】_Java内存溢出_的详细_解决方案_word…_爱问共享资料 2018年3月9日 - doc格式-5页-文件0.02M-_Java内存溢出_的详细_解决方案_JVM管理两种类型的内存,堆和非堆。堆是给开发人员用的上面说的就是,是在JVM启动时创建;非堆是… java内存溢出解决方案 - 豆丁网 2015年11月19日 - JAVA内存溢出 解决方案 内存溢出类型1.1. java.lang.OutOfMemoryError: PermGen space JVM 管理两种类型的内存,堆和非堆。堆是给开发人员用的上面说的… 1篇文章搞清楚8种JVM_内存溢出_(OOM)的原因和_解决_方法 - 知乎 2019年11月9日 - 撸Java_的同学,多多少少会碰到_内存溢出(OOM)的场景,但造成OOM的原因却是多种多样。 堆溢出 这种场景最为常见,报错信息: java.lang.OutOfMemoryError: Java heap… _Java_语言_内存溢出_和内存泄露的介绍及排查和_处理内存_泄露的方法讲解 2018年10月12日 - 本文主要向大家介绍了_Java_语言_内存溢出_和内存泄露的介绍及排查和_处理内存_泄露的方法讲解,通过具体的内容向大家展示,希望对大家学习_JAVA_语言有所帮助。 堆栈_溢出_就是_内存溢出_吗?|_Java_技术_方案解决_区 - 北风网 国内最… 2015年1月9日 - 1.堆栈溢出就是_内存溢出_吗? 2.数据存在堆栈里,就是存在内存里吗?… 1.堆栈溢出就是_内存溢出_吗? 2.数据存在堆栈里,就是存在内存里吗?…2、j***a中内… JVM发生内存溢出_的原因分析及_解决方案 | 《Linux就该这么学》 2019年9月20日 - JVM发生_内存溢出_的原因分析及_解决方案_Linux系统技术交流QQ群(193666696)验证问题答案…1. _Java 堆_空间 发生频率:5颗星 造成原因 无法在 _Java 堆_中分… Java内存溢出_场景及_解决办法 - code_kkk的博客 - CSDN博客 2018年10月4日 - Java内存溢出_即程序在申请内存时,没有足够的空间供其使用,出现outofmemory。常见于四种情况:栈溢出(StackOverflowError)、_堆溢出(OutOfMemoryError:ja… _java内存溢出_的_解决_思路 - kszsa - 博客园 2018年1月16日 - 5.启动参数内存值设定的过小; 内存溢出_的_解决方案: 第一步,修改JVM启动参数,…(java 虚拟机栈),Native MethodStack(本地方法栈),Heap(堆),Program Co… JAVA-常见_内存溢出情况及_解决方案___JAVA,JVM_小葫芦的博客-CSDN博客 2019年1月11日 - Java_常见的几种_内存溢出_及解决方法【情况一】:_java.lang.OutOfMemoryError… Java_常见的几种_内存溢出_及解决方法【情况一】:_java.lang.OutOfMemoryError:_Java_heapspac… _Java_服务_内存溢出_问题_解决_和总结_xiaolizh的博客-CSDN博客 2018年8月16日 - (connection reset by peer),紧接着看到服务_内存_100%,加_内存_也没用,不管加…在 _Java_引入 NewIO之前,对于每个网络连接,都有一个对应的线程来处理网络… _Java内存溢出问题总结_大_JAVA解决方案-CSDN博客 2018年7月19日 - 使用_Java_那么久,在此总结一下_Java_中常见的_内存溢出_问题以及对应的解决思路_堆溢出_报错信息j Java内存溢出_详解及_解决方案 - 小渣渣的博客 - CSDN博客 2015年10月19日 - 本文以笔者开发和支持的多个项目为例,与大家分享在开发过程中遇到的_Java内存溢出_和数据库锁表的检测和_处理解决_过程。 2._内存溢出_的分析 _内存溢出_是指应用系统中存在… [转]Java内存溢出_详解及_解决方案 - novalist - 博客园 _内存溢出_是指应用系统中存在无法回收的内存或使用的内存过多,最终使得程序运行要用到的内存大于虚拟机能提供的最大内存。为了_解决Java_中_内存溢出_问题,我们首先必须了解… _Java内存溢出_的详细_解决方案__dhfzhishi的专栏-CSDN博客 2018年5月11日 - 一、内存溢出_类型1、_java.lang.OutOfMemoryError: PermGen spac… 一、内存溢出_类型 1、_java.lang.OutOfMemoryError: PermGen space JVM管理两种类型… _Java内存溢出解决方案__godboy001的博客-CSDN博客 2017年10月9日 - _Java内存溢出_的详细_解决方案_本文介绍了_Java内存溢出_的详细_解决方案_。本文总结_内存溢出_主要有两种情 _Java内存溢出_的详细_解决方案__JEECG开源社区-CSDN博客 2014年1月5日 - 一、内存溢出_类型 1、_java.lang.OutOfMemoryError: PermGen sp… 一、内存溢出_类型 1、_java.lang.OutOfMemoryError: PermGen space JVM管理两种类型的内存,堆和非… _java_常见的几种_内存溢出_和_解决方案__elsery -CSDN博客 2015年11月4日 - 项目组最近在开发中经常会出现一些意想不到的内存溢出_问题。下面我就说说我们常见的几种_内存溢出_吧!1.JVM Heap(_堆)溢出:java.lang.OutOfMemoryError: … _java_常见的几种_内存溢出_和_解决方案___Java__xmt1139057136…_CSDN博客 2015年9月17日 - 项目组最近在开发中经常会出现一些意想不到的内存溢出_问题。下面我就说说我们常见的几种_内存溢出_吧!1.JVM Heap(_堆)溢出:java.lang.OutOfMemoryError: … _Java内存溢出_的详细_解决方案__涂作权的博客-CSDN博客 2014年5月12日 - 一、内存溢出_类型1、_java.lang.OutOfMemoryError: PermGen spac… 一、内存溢出_类型 1、_java.lang.OutOfMemoryError: PermGen space JVM管理两种类型的内存,堆和… Java_代码运行_内存溢出_详解及_解决方案 - jianghuchuanke…-CSDN博客 2018年4月17日 - 本文以笔者开发和支持的多个项目为例,与大家分享在开发过程中遇到的_Java内存溢出_和数据库锁表的检测和_处理解决_过程。 2._内存溢出_的分析 _内存溢出_是指应用系统中存在… java 大数据处理之内存溢出解决办法(一) - houbin0912…_CSDN博客 2017年3月24日 - 一、内存溢出_类型1、_java.lang.OutOfMemoryError: PermGen spaceJVM管理两种类型的内存,堆和非_堆_。_堆_是给开发人员用的上面说的就是,是在JVM启动时创建… _java内存溢出_的_解决_思路 - kszsa - 博客园 2018年1月16日 - 5.启动参数内存值设定的过小; 内存溢出_的_解决方案: 第一步,修改JVM启动参数,…(java 虚拟机栈),Native MethodStack(本地方法栈),Heap(堆),Program Co… 深入理解_java_虚拟机-_Java内存_区域与_内存溢出_异常_码神岛 2019年3月23日 - Java堆溢出 产生原因: java堆_用于存储对象实例,只要不断地创建对象,并且保证GC …_解决办法: 先通过_内存_映像分析工具(EMA)对Dump出来的堆快照进行分析… _Java内存溢出_的详细_解决方案__百度文库 评分:4/5 9页 2010年12月21日 - 详细介绍了java内存溢出_问题的原因及_解决办法,以及如何使自己免于内存溢出_的困扰详细介绍了_java内存溢出_问题的原因及_解决办法,以及如何使自己免于内存… Java_虚拟机_内存溢出 | 学步园 2013年6月8日 - (杀手锏级别的解决方案).可是这样不科学,科学的方式就要求我们知道为什么会发生…运行了好久好久,最终抛出堆内存溢出_。_Java heap space已经足够说明… JAVA_虚拟机的_内存溢出_详解与_解决方案-百度经验 2015年7月16日 - 在工作中我们经常会遇到Java heap space、PermGen space这两种错误。 Java heap space: 原因:Heap_内存溢出_,意味着Young和Old generation的内存不够。… java 取大量数据 _内存溢出_问题 有没有大侠出出好方法来…_CSDN论坛 没别的办法,只有分页处理。 0 2010-12-29 15:25:42 只看TA 引用 举报 #7 得分 0 记录一次大对象导致的_Java堆内存溢出_问题 前几天早上出现一后台项目无法… 中软国际:深度解析_Java堆内存溢出_的本质 2018年4月3日 - 有两种可能的_办法_去解决这个问题。 泄露:由于某些编程问题,内存使用随着时间的…_Java堆内存溢出_的本质这篇写的还是不够完全的,关注中软国际官网获取… 1篇文章搞清楚8种JVM_内存溢出_(OOM)的原因和_解决_方法-_Java_架构师… 2019年11月9日 - 撸Java_的同学,多多少少会碰到_内存溢出(OOM)的场景,但造成OOM的原因却是多种多样。 堆溢出 这种场景最为常见,报错信息: java.lang.OutOfMemoryError: Java heap… java 内存溢出 栈溢出的原因与排查方法 - oswebgod的个人空间… 2018年2月13日 - 定位问题后才能采取合适的解决方案,而不是一_内存溢出_就查找相关参数加大。 概念 …_Java堆内存_异常 Java栈内存异常 方法区内存异常 _Java堆内存_异常 /*… _java内存溢出_的2种情况 - 简书 2019年6月24日 - java_程序员在面试经常被问到内存om之后如何处理,但是实际在工作中遇到此类问题的情况却又非常少。 进过自己一番总结内存溢出主要分为2种: 一、_堆内存… _Java内存溢出_原因是什么? 爱问知识人 说白了就是程序运行要用到的内存大于虚拟机能提供的最大内存就发生内存溢出_了。…_java _内存堆_不足时,会不断调用 GC ,若连续回收都解决不了_内存堆_不足的问题… java 内存溢出,但是监控到_java_的_堆_并没有增长,只是window任务管理… 2009年4月21日 - java内存溢出_。经过监控发现,_java_的_堆_并没有增长,只是window任务管理器中_java_进程的内存一直在增长,直到_内存溢出 请问各位大虾遇到过这种情况没有,谢… java heap space_堆内存溢出_的原因及解决方案 - sannywang的个人… 2016年5月10日 - 解决方案:先解决程序中可能引起这个问题的BUG,再配置参数,-Xms 512m -Xmx 1024m 这样的运行_内存_大小的参数public class SubstringTest { private String str = … _JAVA内存溢出解决方案__百度文库 评分:5/5 6页 2015年12月8日 - JAVA内存溢出解决方案__计算机软件及应用IT/计算机_专业资料。内存溢出问题说明 _ 知识库编号:zjdr-problem-20140813-0000008 一、 OutOfMemoryErro… _Java_常见_内存溢出_异常分析与_解决___java__脚本之家 2016年10月18日 - 本篇文章主要分析了_JAVA_程序_内存溢出_问题原因,较为详细的说明了_java_导致程序_内存溢出_的原因与解决方法,感兴趣的小伙伴们可以参考一下。 hive 客户端查询报_堆内存溢出解决_方法 - duncan–学无止境 - IT… 2015年3月25日 - OKException in thread “main” java.lang.OutOfMemoryError: Java heap space问题原因: hive_堆内存_默认为256M这个问题的解决方法为:… 内存溢出_和内存泄露的区别以及在_解决办法-CSDN论坛 2019年6月24日 - Java常见的几种_内存溢出_及解决方法【情况一】: java.lang.OutOfMemoryError:Javaheapspace:这种是_java堆内存_不够,一个原因是真不够(如递归的层数太多… JVM发生_内存溢出_的原因分析及_解决方案__gen 2019年9月20日 - 解决方案 使用-Xmx 增加堆_大小 修复应用程序中的_内存_泄漏 2. GC 开销超过限制 发生频率:5颗星 造成原因 _Java 进程98%的时间在进行垃圾回收,恢复了不… 完美_解决java_读取大文件_内存溢出_的问题__java__脚本之家 2017年8月10日 - 下面小编就为大家带来一篇完美_解决java_读取大文件_内存溢出_的问题。小编觉得挺不错的,现在就分享给大家,也给大家做个参考。一起跟随小编过来看看吧 java内存溢出问题__java _内存溢出___java内存 内存溢出 - 云+社区… 通过jdk自带的工具jmap,jconsole来获得一个堆转储文件这里使用方式一来获得_java_中outofmemoryerror(_内存溢出_的三种情况及_解决办法_在_解决java内存溢出_问题之前,需要对jvm… _java_大批量_处理_图片导致_内存溢出_以及效率低-CSDN论坛 彻底解决Java_处理图片时,BufferedImage_内存溢出_的_解决方案 最近系统总数无原因出现_内存溢出_问题,我程序内会读取一张图片,先压缩图片大小,然后转成byte数组写入到数据库… _java内存溢出_示例(_堆溢出_、栈溢出) - THISISPAN - 博客园 2016年9月18日 - /** * @author LXA * 堆溢出 */ public class Heap { public static void…Java_中对_内存_对象的访问,使用的是引用的方式。在 _Java 代码中我们维护一个… Java_中OutOfMemoryError(_内存溢出)的三种情况及解决办法…_博客园 2016年10月25日 - 在_解决java内存溢出_问题之前,需要对jvm(_java_虚拟机)的内存管理有一定的认识。jvm管理的内存大致包括三种不同类型的内存区域:Permanent Generation spa… Java_中OutOfMemoryError(_内存溢出)的三种情况及解决办法 - 简书 2018年5月23日 - 在解决java内存溢出_问题之前,需要对jvm(_java_虚拟机)的内存管理有一定的认识。jvm…PermanentGeneration space(永久保存区域)、Heap space(堆区域)、_J… _java内存溢出_示例(_堆溢出_、栈溢出) - THISISPAN - 博客园 2016年9月18日 - 在 Java 程序中,这个引用变量本身既可以存放_堆内存_中,又可以放在代码栈的内存中…· _内存溢出解决方案_· _Java_内存溢出和内存泄露· 堆和栈» 更多推… _Java 堆内存溢出_原因分析_java_脚本之家 2019年6月13日 - 这篇文章主要介绍了_Java 堆内存溢出_原因分析,任何使用过基于 Java 的企业级后端应用的软件开发者都会遇到过这种报错,java.lang.OutOfMemoryError:Java… _内存溢出_常_解决方案_总结_百度文库 2019年1月4日 - 内存溢出_异常_解决方案_总结 一 调整 虚拟机参数 二 立即 释放无用的对象 三 利用序列化和反序列化技术 简单的说 _java 中的堆和栈 java 把内存分两种:一… jvm_内存溢出_的三种情况以及解决办法 - wujf - 博客园 2019年5月9日 - 在_解决java内存溢出_问题之前,需要对jvm(_java_虚拟机)的内存管理有一定的认识。jvm管理的内存大致包括三种不同类型的内存区域:Permanent Generation spa… Java_常见_内存溢出(OOM)解决方案 - samjustin的博客_CSDN博客 2016年8月21日 - 与程序计数器一样,_java_栈(虚拟机栈)也是线程私有的,其生命周期与线程相同。通常…避免垃圾回收机制清除这些对象,就会在对象数量达到最大堆容量限制后… 分析Java 堆(转)_西安尚学堂_新浪博客 2017年6月6日 - 标签: java 堆 一.常见的内存溢出:堆溢出,直接内存溢出,永久区溢出等 二.堆…三.直接内存溢出 1.原因一:使用 NIO 不当,导致直接内存溢出 2.解决方案:… _java_虚拟机_内存溢出_各种场景总结 - justin_xiaoshuai - 博客园 2015年1月12日 - _java堆_用于存储对象实例,只要不断地创建对象,并且保证gc roots到对象之间有可达路径…要解决这个区域的异常,首先要区分是出现了内存泄露(Memory Leak… 关于(java heap space)内存溢出_的_解决办法 - tlk20071 - CSDN博客 2011年11月29日 - java.lang.OutOfMemoryError: Java heap space 内存溢出_错误及_处理办法(转) 阅读数 747 以下是堆空间溢出的错误原因:java.lang.OutOfMemoryError:Jav… _Java_常见的几种_内存溢出_及_解决_方法 - lixld的专栏_CSDN博客 2018年4月27日 - ava常见的几种_内存溢出_及解决方法【情况一】:java.lang.OutOfMemoryError:Javaheapspace:这种是_java堆内存_不够,一个原因是真不够(如递归的层数太多等)… 面试题:JVM_内存溢出的_解决_方法__java 2018年12月21日 - 对于_java_程序员来说,在虚拟机自动内存管理机制的帮助下,不需要自己实现释放内存,不容易出现内存泄漏和_内存溢出_的问题,由虚拟机管理内存这一切看起来非… _Java内存溢出_问题总结 - 木易森林 - 博客园 2018年4月8日 - 使用Java_那么久,在此总结一下_Java_中常见的_内存溢出_问题以及对应的解决思路 堆…垃圾回收器超过98%的时间用来做垃圾回收,但回收了不到2%的_堆内存_。 _解… _Java内存溢出_的详细_解决方案__百度文库 评分:4.5/5 5页 2011年9月13日 - Java 内存溢出_的详细_解决方案 2009-06-16 11:01 佚名 网络 我要评论(1) 字号:T | T 本文介绍了 Java _内存溢出_的详细_解决方案_。本文总结_内存溢出_主要有… _Java内存溢出_和内存泄露的介绍及排查和_处理内存_泄露的方法讲解 2018年6月22日 - 因此,从根本上_解决Java内存溢出_的唯一方法就是修改程序,及时地释放没用的对象,…2)更轻量级的在线分析,使用“_Java内存_影像工具:jmap”生成堆转储快照… _java内存溢出_示例(_堆溢出_、栈溢出) - @you的博客_CSDN博客 2019年8月29日 - java内存溢出_示例(_堆溢出_、栈溢出)_堆溢出:/*** @author LXA* _堆溢出_*/public class Heap{ public static void main(String[] args) { ArrayList list=new … JAVA内存溢出(OutOfMemoryError)的_解决办法__CTO成长之…_CSDN博客 2013年5月30日 - 关于_JAVA_中_内存溢出_的_解决办法_J2ee应用系统是运行在J2EE应用服务器上的,而j2ee应用服务器 _java_项目_内存溢出_问题_解决_方法_jinpengqdlg的专栏-CSDN博客 2013年11月9日 - 原因:_内存_容易_溢出_可以说是因为在程序中有_内存_泄漏(memory leak)的问题,容易引起…JVM_堆_的设置是指_java_程序运行过程中JVM可以调配使用的_内存_空间的设… …Error:Java heap space_堆内存溢出_错误的分析方案…_CSDN博客 2015年6月15日 - 抛出_堆内存溢出_的错误一定要记得保留现场环境(导出堆内存信息到文件),否则如果无法进行分析,并从根本上解决问题,下次很有可能还会出现。… _java内存溢出_的问题如何排查?-CSDN论坛 2010年6月24日 - 1,_Java_内存溢出包括:_堆内存溢出_和栈内存溢出 首先说下:内存溢出和内存泄露 内存溢出:out of memory 是指程序申请内存时没有足够的空间了 内存泄露: me… 线上_堆内存溢出_和堆外内存溢出问题的_解决_和思考 - 简书 format=b,file=/home/ssd/log/Scheduler/java.dump pid)使用mat分析,发现内存_占用只用了50MB多,这个这个时候怀疑是_堆_外_内存_发生了_溢出,于是就对_堆_外_内存_进行监控… 关于JVM_内存溢出_的原因分析及_解决方案_探讨 - _Java_技术zhai - 博客园 2019年8月11日 - 解析:AC是持久带,B直接内存也就是堆外内存,D_堆内存_。 参考书籍: 《深入理解Java_虚拟机》 (第二版) 周志明 著; 标签: _Java, JVM, 内存溢出, 面试题 好… _内存溢出_异常_解决方案_总结_百度文库 内存溢出_异常_解决方案_总结一 调整 虚拟机参数 二 立即 释放无用的对象 三 利用序列化和反序列化技术 简单的说 _java 中的堆和栈 java 把内存分两种:一种是栈… java 内存溢出 栈溢出的原因与排查方法 - yanlove_jing…_CSDN博客 2016年6月11日 - 1、 内存溢出的原因是什么?内存溢出是由于没被引用…(垃圾)过多造成JVM没有及时回收,造成的内存溢出。…一个是堆内存溢出,另一个是持久代内存溢出. … …heap space(Java堆_空间_内存溢出)_解决_方法 - svennee - 博客园 2014年11月7日 - 解决方案[转] 一直都知道可以设置jvm heap大小,一直用eclipse写/调试java_程序。…两种选择:使用-Xmx参数增加堆的最大使用_内存(或者使用-XX:MaxPermSi… Java_中OutOfMemoryError(_内存溢出)的三种情况及_解决_办…_CSDN博客 2018年11月5日 - Java_中OutOfMemoryError(_内存溢出)的三种情况及解决办法 相信有一定_java_开发经验的人或多或少都会遇到OutOfMemoryError的问题,这个问题曾困扰了我很长… 内存溢出_的几种原因和_解决办法 - 冰～橙 - 博客园 2019年4月4日 - 内存溢出_的几种原因和_解决办法 对于JVM的内存写过的文章已经有点多了,而且有点…另外此参数只会在第一次输出OOM的时候才会进行堆的dump操作(java hea… JVM总结-内存_监视手段及各区域_内存溢出解决 - 小学生II - 博客园 2018年5月8日 - 以及JVM运行时数据区各个部分内存溢出_的发生和对应的_解决方案,总体来说属于概括…内存溢出:OutOfMemoryError:Java heap space 溢出原因:堆中没有足够… _Java内存溢出_与栈溢出分析 - binglong_world的专栏 - CSDN博客 2018年6月14日 - 二、堆溢出 堆(Heap)是Java_存放对象实例的地方。 _堆溢出_可以分为以下两种情况,这两种情况都会抛出OutOfMemoryError:_java heap space异常: 1、_内存_泄漏… 「_内存溢出_」_Java_服务_内存溢出_问题_解决_和总结 - seo实验室 2019年8月16日 - 内存溢出 最近,公司测试环境服务发现一个问题:一个…线程之后,继续使用jstack pid命令查看当前_java_进程的…采用javaScript语言直接调用后台业务商业…","link":"/2020/04/05/%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97Java%E5%A0%86%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"3.深入Java系列之基本数据类型","text":"Java 基本数据类型 | 菜鸟教程 Java 基本数据类型 变量就是申请内存来存储值。也就是说,当创建变量的时候,需要在内存中申请空间。 内存管理系统根据变量的类型为变量分配存储空间,分配的空间只能… Java_的_基本数据类型 - 1130136248 - 博客园 2016年1月6日 - Java_语言提供了八种_基本类型_。六种数字类型(四个整数型(默认是int 型),两个浮点型(默认是double 型)),一种字符类型,还有一种布尔型。 byte: byte_数据… Java基础(一) 八大基本数据类型 - 工匠初心 - 博客园 2019年6月18日 - 自从_Java_发布以来,_基本数据类型_就是_Java_语言的一部分,分别是byte, short, int, long, char, float, double, boolean. 其中: 整型:byte, short, int, l… Java 八大_基本数据类型___Java__T的专栏-CSDN博客 2018年9月11日 - 1.bit就是位,也叫比特位,是计算机表示数据_最小的单位2.byte就是字节3.1byte=8bit_Java… _Java基本类型_共有八种,_基本类型_可以分为三类,字符_类型_char,布… _Java基本数据类型_拓展详细讲解 2019年2月19日 - 基本数据类型 JAVA_中一共有八种_基本数据类型,他们分别是byte、short、int、long、float、double、char、boolean。 基本数据类型 在通常情况下,如果_JAVA_中出现了一个… Java_中几种_基本数据类型 - Sindyue的博客 - CSDN博客 2019年2月28日 - 内置_数据类型Java_语言提供了八种_基本类型_。六种数字类型(四个整数型,两个浮点型),一种字符类型,还有一种布尔型。1.bytebyte_数据类型_是8位、有符号的,… java_之ArrayList集合存储_基本数据类型 2019年6月5日 - 在ArrayList集合当中,如果要存储基本数据类型_需要用到_基本数据类型_相对应的包装类(包装类是引用数据类型,位于_java.long包下,不需要导包)。 小编先插入一个表格,来… _java_的_基本数据类型_有这几个! 2018年11月23日 - _Java_的_基本数据类型_也叫做内置类型是_java_语言本身提供的数据类型,是引用其他类型的基础。_Java_的_基本数据类型_分为:整数类型、浮点类型、字符类型、布尔类型这四个类型。… _Java基础_教程之八大_基本数据类型___java__脚本之家 2019年6月30日 - 这篇文章主要给大家介绍了关于_Java基础_教程之八大_基本数据类型_的相关资料,文中通过示例代码介绍的非常详细,对大家的学习或者工作具有一定的参考学习价… _Java_语言的八种_基本数据类型_介绍-职坐标 2018年12月4日 - 本文主要向大家介绍了_Java_语言的八种_基本数据类型_介绍,通过具体的内容向大家展示,希望对大家学习_JAVA_语言有所帮助。 _Java_中常用的_基本数据类型_有哪些? 2017年1月11日 - Java_语言中定义了8个_基本_的_数据类型:字节型(byte),短整型(short),整型(int),长整型(long),字符型(char),浮点型(float),双精度型(double),布尔型(boole… _Java_中_基本数据类型_和Object之间的关系?-CSDN论坛 _java_语言的数据类型包括两种,_基本数据类型_和引用数据类型。引用数据类型的类都是Object类的子类。_基本数据类型_对应了封装类,需要时jdk把他们自动装箱,包装成封装类。… _JAVA_中八种_基本数据类型_的默认值 - 空即是色 - ITeye博客 2011年4月25日 - JAVA_中八种_基本数据类型_的默认值 博客分类: Core _Java Java 引用 For type byte, the default value is zero, that is, the value of (byte)0. For ty… 以下哪几种是_java_的_基本数据类型_。_用友笔试题_牛客网 2019年10月9日 - Double在java.lang包,是double的一个包装类,不是基本数据类型 发表于 2019-07-25 22:02:18回复(0)举报 3 一只Simon java 8中基本数据类型:byte,short,… _Java_八种_基本数据类型__慕课手记 2018年4月16日 - _基本数据类型Java_八种_基本数据类型_1)四种整数类型(byte、short、int、long):(注意: 一个字节byte = 8位bit) ! byte: Java 基本数据类型 和引用数据类型 - 简书 2018年5月8日 - 很多时候由于 原理基础知识反而显得生疏。 动手敲了一遍。 发现确实是这样子, 想到了是基本数据类型 和引用数据类型的差异。java_中数据类型分为_基本数… java_的_基本数据类型_及属性 - _java 2019年8月5日 - java_的_基本数据类型_及属性,需要的朋友可以可以参考一下… _java_的_基本数据类型_及属性2019/8/5 15:03:26 0 人评论 72 次浏览 分类:_java 数据类型 大小 范围 默… java_的_基本数据类型_及属性 - _java 2019年8月5日 - java_的_基本数据类型_及属性,需要的朋友可以可以参考一下… _java_的_基本数据类型_及属性2019/8/5 15:03:26 0 人评论 72 次浏览 分类:_java 数据类型 大小 范围 默… _java_的_基本数据类型_有八种: - Sonnyb - 博客园 2016年8月24日 - _java_的_基本数据类型_有八种: 1)四种整数类型(byte、short、int、long): byte:8 位,用于表示最小数据单位,如文件中数据,-128~127 short:16 位,很少用,-3… Java_的8种_基本数据类型 - chancaoer - 博客园 2018年10月12日 - 关于Java_的8种_基本数据类型,其名称、位数、默认值、取值范围及示例如下表所示: 序号 数据类型 位数 默认值 取值范围 举例说明 1 byte(位) 8 0 -… _Java基本数据类型___Java__Spring , Hadoop, Spark , BI , ML-CSDN博客 2014年5月31日 - Java_语言是静态类型的… 因此,_Java数据类型(type)可以分为两大类:基本类型(primitive types)和引用类型(reference types)。primitive types 包括bool… Java_之_基本数据类型 - NYfor2018 - 博客园 2018年8月19日 - Java_有8种_基本数据类型,其中有4种整型、2种浮点类型、1种用于表示Unicode编码的字符单元的字符类型char和1种用于表示真值的boolean类型。 类型 boole… java-_基本数据类型_介绍 - 青竹逸风 - 博客园 2018年12月26日 - 在写java_代码的时候,所有的变量都需要声明一种数据类型,在_java_的代码中,数据类型分为_基本数据类型_和引用数据类型。下面先介绍_基本数据类型 _基本数据类型_由8个: 1、… java基础—&gt;_java_的八种_基本数据类型_及其包装类 - LXRM-J…_博客园 2017年2月22日 - Java_不仅支持上述8种_基本数据类型,还为这8种_基本数据类型_提供了对应的包装类,通过这些包装类,我们就可以将上述_基本数据类型_当做_Java_中的类对象来处理了。值得说明的… Java_的8种_基本数据类型 - WhoKnows1 - 博客园 2019年3月15日 - 待整理主题:_Java_的8种_基本数据类型_与对应封装类型、拆箱、装箱 ===…- 整数字面量默认都为int类型,所以在定义的long型数据后面加L或l。 - 小于32位数… 深入理解 Java 基本数据类型 - 静默虚空 - 博客园 2019年3月10日 - Java 中的数据类型有两类:值类型(又叫内置数据类型,基本数据类型) 引用类型(除值类型以外,都是引用类型,包括 String、数组)值类型… _java_中的_基本数据类型_的转换 - Black_Knight - 博客园 2016年10月27日 - _Java_中数据类型主要分为两大类:_基本数据类型_和引用数据类型。_基本数据类型_共有8种,分别是:布尔型boolean, 字符型char和数值型byte/short/int/long/flo… Java_中的_基本数据类型 - 风一样的码农 - 博客园 2016年10月10日 - 什么是基本数据类型 就是我们在编程的时候经常需要用到的数据类型,如整型,浮点型等,把这些数据类型专门拿出来特殊对待,并想象成所谓的“基本类型_”。 _… Java 基本数据类型 - 四类八种 - 清风Coder - CSDN博客 2018年6月13日 - 整理一下脑子里的知识,也算温故知新吧。一、_Java_四大_数据类型_分类1、整型byte、short、int、long2、浮点型float、double3、字符型char4、布尔型boolea… Java_的_基本数据类型 - 最喜欢夏天了 - 博客园 2019年11月10日 - Java_是一个近乎纯洁的面向对象编程语言,但是为了编程的方便还是引入了_基本数据类型,为了能够将这些基本数据类型_当成对象操作,_Java_为每一个_基本数据类… Java_的_基本数据类型 - 1130136248 - 博客园 2016年1月6日 - Java_语言提供了八种_基本类型_。六种数字类型(四个整数型(默认是int 型),两个浮点型(默认是double 型)),一种字符类型,还有一种布尔型。 byte: byte_数据… _Java基本数据类型_总结 - 时间朋友 - 博客园 2012年5月25日 - 基本类型,或者叫做内置类型,是JAVA_中不同于类的特殊类型。它们是我们编程中使用最频繁的类型。_java_是一种强类型语言,第一次申明变量必须说明_数据类型,… _Java_的_基本数据类型_有几种?分别是?_网易订阅 2018年7月19日 - 如果你想学习_Java_可以来这个群,首先是二二零,中间是一四二,最后是九零六,里面有大量的学习资料可以下载。 3、 _Java_的_基本数据类型_有几种?分别是? … JAVA 基本数据类型 取值范围 - qsfwy - ITeye博客 2009年9月14日 - JAVA_4:_基本数据类型 先看一段代码public class Hello{ public static void main(String[] args){ int i = 5 , j = 2; System.out.println(i+j); … Java基本数据类型_和长度 - _java coder - ITeye博客 2010年2月25日 - java数据类型 字节 表示范围 byte(字节型) 1 -128～127 short(短整型) 2 -32768～32767 int(整型) 4 -2147483648～2147483647 long(长整型) 8 -… _java基本数据类型_取值范围 - 夕弦 - ITeye博客 2011年7月6日 - 在JAVA_中一共有八种_基本数据类型,他们分别是 byte、short、int、long、float、double、char、boolean 整型 其中byte、short、int、long都是表示整数的… Java _基本数据类型_之间的转换 - - ITeye博客 2015年10月15日 - java_内存泄漏 _Java _基本数据类型_之间的转换 一、数据类型 1.布尔型(boolean) :true/false,不可以以0或非0的数字代替;不能进行数据之间的转换。 2.整数… _JAVA_的_基本数据类型_为什么不包括String?【_java_吧】_百度贴吧 2楼: …不是_基本数据类型_。或者你还可以这样想， _java_分为1… 15楼: 什么语言_基本数据类型_包括string？ _java基本数据类型_练习题 - 道客巴巴 2017年11月14日 - _java基本数据类型_练习题 浏览次数:291 内容提示: 1 . 用 8 位无符号二进制数能表示的最大十进制数为 ( C ) A. 127 B. 128 C. 255 D. 256 2 .以下… Java基础 (2) - _基本数据类型_及包装类-似水流年-51CTO博客 2019年9月6日 - JDK1.5,开始提供自动装箱和拆箱功能,基本类型_变量赋给对应的包装类变量称之为装箱。自动拆箱与之相反。_Java 7增强了包装类的功能,为所有的包装类提供了一个静态… _Java基本数据类型_与包装类 - 程序员大本营 Java基本数据类型_与包装类,程序员大本营,技术文章内容聚合第一站。… 2.4:这些类都在_java.lang包中 3.自动装箱和自动拆箱 3.1将_基本数据类型_变成包装类称为装箱 … java _基本数据类型_各种情况下在内存中存储位置? - SegmentFault… 2017年3月29日 - java 基本数据类型_各种情况下在内存中存储位置?_java 问题: 如何理解《_Java_编程思想-第四版》P23 中,这个变量直接存储“值”,并置于堆栈中,因此更加高… _Java基础_――_基本数据类型_及其包装类 | 易学教程 2019年12月2日 - 了解_基本数据类型_和包装数据类型的区别之前,先来说说_Java_中的内存分配 栈:函数中定义的一些_基本类型_的数据变量和对象的引用变量都在函数的ջ内存中分… _JAVA基本数据类型_所占字节 - 没救了呀疯子的个人空间 - OSCHINA 2018年11月11日 - Java基本数据类型 int 32bit short 16bit long 64bit byte 8bit char 16bit float 32bit double 64bit boolean 1bit,This data type represents one b… _java_的_基本数据类型_中,有几种可以表示数字?-布布扣-bubuko.com 2016年7月13日 - _java_的_基本类型_一共有8个,byte字节型,8位;short短整型,16位;int整型,32位;long长整型,64位;float单精度浮点型,32位;double双精度浮点型,64位;… _JAVA基本数据类型_的取值范围-AIDE技术网–技术综合类博客|AIDEZY… 2019年9月26日 - [caption id=’’ align=’alignnone’ width=’998’] _JAVA基本数据类型_的取值范围[/caption] 前言: 对于_java_的数据类型,既熟悉又陌生,于是整理了这篇文档… Java_编程_基础 八种基本数据类型-教育视频-搜狐视频jvm-_Java基本数据类型_字面量在JVM中如何申请内存——CSDN问答频道 2017年4月7日 - _Java基本数据类型_字面量在JVM中如何申请内存 有如下三段代码,A、B、C。 其中A段代码中,i1、i2打印出来的HashCode是一样的,这个我可以理解,因为127在常… _java_的_基本数据类型_有哪些-百度经验 2019年1月22日 - 有时候我们想知道java_的_基本数据类型_有哪些,下面来介绍一下 工具/原料 _java 基本数据类型 方法/步骤 1 第一步我们首先需要知道_java_的_基本数据类型_一… 在_Java_的_基本数据类型_中,char型采用Unicode编码方案…_考试资料网 2014年11月11日 - 在_Java_的_基本数据类型_中,char型采用Unicode编码方案,每个Unicode码占用___字节内存空间,这样,无论是中文字符还是英文字符,都是占用___字节内存空间。 … java基本_8种_数据类型 - 简书 以上占用字节数其实是针对c/c++语言而言的,对于_java_来说由于其JVM具有跨平台性因此_java_在32位和64位机下_基本数据类型_占字节数是一致的(这样才能达到跨平台通信)。… _Java_中八种_基本数据类型_和八种封装数据类型word免…_爱问共享资料 2019年4月19日 - doc格式-5页-文件0.02M-_Java_中八种_基本数据类型_和八种封装数据类型初使值的求解过程及比较 作者:Zealjiang1八种_基本数据类型_创建名为MemberTestBasic… Java_语言的_基本数据类型.ppt_图文_百度文库 2019年3月26日 - ? ? 基本数据类型_、数组和枚举类型 2.1 标识符和关键字 2.2 _Java_语言的_基本数据类型 2.3 从命令行输入、输出数据 2.4 _Java_的数组 2.5 枚举类型(jd … _java基本数据类型_各占多少字节 - 「dt猫」 2019年2月20日 - _类型_字节数取值范围byte1-128127(-2的7次方到2的7次方-1) short2-3276832767(-2的15次方到2的15次方-1)int4-2147483648~2147483647(-2的31… java,c,c 语言之间_基本数据类型_的比较 - wu928320442的专栏… 2011年3月11日 - java_语言_基本数据类型 在JAVA_中一共有八种_基本数据类型,他们分别是 byte、short、int、long、float、double、char、boolean 整型 其中byte、short、in… _Java_为什么_基本数据类型_不需要进行创建对象?__java__脚本之家 2019年4月11日 - 今天小编就为大家分享一篇关于_Java_为什么_基本数据类型_不需要进行创建对象?,小编觉得内容挺不错的,现在分享给大家,具有很好的参考价值,需要的朋友一起… Java基本数据类型-百度经验 2018年7月16日 - Java基本数据类型,今天小编就来给大家分享Java基本数据类型,希望可以帮助到大家… 今天小编就来给大家分享Java基本数据类型,希望可以帮助到大家; 工… 大数据_语言,_Java_的八大_基本数据类型 2018年10月25日 - Java_中的数据类型,分为引用类型和_基本数据类型_。_基本类型_又分为8种,今天为大家介绍这8种_基本数据类型: 整型:byte,short,int,long 浮点型:float,double 字符型:ch… Java 变量类型 | 菜鸟教程 Java 变量类型 在Java_语言中,所有的变量在使用前必须声明。声明变量的_基本_格式如下: [mycode3 type=’_java‘] type identifier [ = value][, identifier [= … _Java基本数据类型__图文_百度文库 2019年5月18日 - 第3章 Java基本数据类型 3.1 _Java_程序基本组成元素 3.2 数据类型 3.3 变量与常量 3.4 运算符与表达式 本章要点: ? 熟练掌握标识符的命名规则,关键字和… Java 的基本数据类型 - saulc的个人空间 - OSCHINA 2016年2月18日 - 了解_Java_的8种_基本数据类型_的字节空间,使用场景,取值范围,默认值… 前阵子,我们分享了《_Java_中的_基本数据类型_转换》这篇文章,对许多粉丝还是有带来帮… _Java_八种_基本数据类型__Simon Liu的博客-CSDN博客 2018年4月16日 - 基本数据类型Java_八种_基本数据类型_1)四种整数类型(byte、short、int、long):(注… _Java_八种_基本数据类型 1)四种整数类型(byte、short、int、long):(… _Java基本数据类型_的长度范围 - _JAVA_编程语言程序开发技…_红黑联盟 2014年3月9日 - 1、Java基本数据类型_的长度范围代码 ** * @Title:DataTypeLength _java * @Package:com you dao * @Description:_Java_数据类型长度 * @Author: 游海东 *… 怎样记忆JAVA_的_基本数据类型-百度经验 2014年12月7日 - 怎样记忆JAVA_的_基本数据类型,在_JAVA_中有8中_基本数据类型_来储存数值、字符和布尔值,那么都有哪8种呢,我们来看一看 [Android-Java]1.基本_概念-4八大_基本数据类型 - 简书 四、八大基本数据类型 在了解_基本数据类型_之前呢,我觉得大家有必要先来了解一下电脑的构成应该都玩过游戏,就比如魔兽世界来说,很大那么这个很大指的是什么呢?存储… _Java_中8中_基本数据类型__百度文库 Java 中 8 中基本数据类型:String 类型 byte short int long float double boolean char 字节数 1 2 4 8 4 8 1/8 2 null 默认值 数据范围计算公式(-2^… Java_有那些_基本数据类型,String是不是基本数据类型,他们有何区别 2010年3月21日 - Java_有那些_基本数据类型,String是不是基本数据类型,他们有何区别 2010-03-21 | 阅:3542 转:26 | 分享 基本:byte short int long float double boolean… JAVA基本数据类型 面试题-l123j的博客-51CTO博客 2018年4月4日 - b=b1+b2;编译失败: byte,short,char之间相互不转换,一旦进行运算的,默认提升为一个int类型 变量相加,是先看数据类型,最终相加后的结果是否在当前这个… 菜鸟java-基本数据类型 2018年8月14日 - 所以根据不同的数据类型的变量,可以在内存中储存整数、小数或者字符。 基本数据类型_引用数据类型 _基本数据类型 _java_有八种_基本数据类型_分别是六种数字类型(四种整数型… _Java_中8种_基本数据类型_及取值范围 - 简书 _类型_转换: boolean_类型_与其他_基本类型_不能进行_类型_的转换(既不能进行自动_类型_的提升,也不能强制_类型_转换), 否则,将编译出错。 image byte型不能自动_类型_提升到char… _java基本数据类型_转换规则详解——图文详解-百度经验 2016年6月20日 - 标签:JAVA 1 2 3 4 5 6 7分步阅读_java基本类型_分为8种,分别为byte,short,int,long,float,double,char,boolean,除boolean外,其他_类型_都可以进行相互转… java _基本数据类型_各种情况下在内存中存储位置? - OSCHINA 2016年12月29日 - 参考《_Java_编程思想-第四版》P23 和《深入理解_Java_虚拟机:JVM高级特性与最佳实践 第2版》P39-P43,对于该 demo 我的理解: 实例1:存储在堆内存中 变量… Java_的8中_基本数据类型 - weixin_33872660的博客 - CSDN博客 2019年2月15日 - JAVA_的四类八种_基本数据类型 阅读数 4756 先说明两个词汇的基本概念:bit(位):位是计算机中存储数据的最小单位,指二进制数中的一个位数,其值为“0”或… _java_八种_基本数据类型_详解_图文_百度文库 不是只有强制转换的时候会出现数据,例如下 面这种情况 2018/12/27 阳凡凡 3.1八种基本数据类型_包装_类基本_知识 _java_是一门面向对象的语言,但是8中_基本数据类型 不… _Java基本数据类型_转换详解-百度经验 2020年2月16日 - Java基本数据类型_转换详解,_Java_有八大_基本数据类型,那么八大类型之间如何实现转换?htt://www.iliili.com/htt://www.iliili.com/htt://www.iliili… Java 反射基本数据类型 - 简书 2018年5月8日 - class 是不同的,所以在获得 Method 指定参数时需要精确指定参数的类型,即基本类型_参数 int 是无法使用包装_类型 Integer 来获得的,在 Java 反射中一定… _java_的_基本数据类型_有八种: - Sonnyb - 博客园 2016年8月24日 - _java_的_基本数据类型_有八种: 1)四种整数类型(byte、short、int、long): byte:8 位,用于表示最小数据单位,如文件中数据,-128~127 short:16 位,很少用,-3… Java_的8种_基本数据类型 - chancaoer - 博客园 2018年10月12日 - 关于Java_的8种_基本数据类型,其名称、位数、默认值、取值范围及示例如下表所示: 序号 数据类型 位数 默认值 取值范围 举例说明 1 byte(位) 8 0 -… _Java基本数据类型_和长度 - svennee - 博客园 2014年11月8日 - 基本类型,或者叫做内置类型,是_JAVA_中不同于类的特殊类型。_Java基本数据类型_共有八种,它们分别都有相对应的包装类。关于它们的详细信息请看下表:表… Java 基本数据类型 - 四类八种 - 知乎 2017年3月14日 - 整理一下脑子里的知识,也算温故知新吧。 一、_Java_四大_数据类型_分类1、整型byte 、short 、int 、long 2、浮点型float 、 double3、字符型char4、布尔… _java基本数据类型_和引用数据类型的区别 2017年11月4日 - 一、基本数据类型: byte:_Java_中最小的数据类型,在内存中占8位(bit),即1个字节,取值范围-128~127,默认值0 short:短整型,在内存中占16位,即2个字节,取值… Java_四类八种_基本数据类型 - hu_service - 博客园 2018年7月21日 - _Java基本数据类型_就8种,记住就好了。除了这些都是引用型的了。 第一类:逻辑型boolean 第二类:文本型char 第三类:整数型(byte、short、int、long) cha… _java_中的_基本数据类型_存放位置 - THISISPAN - 博客园 2016年10月17日 - _java_中的_基本数据类型_存放位置 _基本数据类型_是放在栈中还是放在堆中,这取决于_基本类型_声明的位置。 一:在方法中声明的变量,即该变量是局部变量,每当程… Java_中_基本数据类型 - 简书 2018年9月3日 - _JAVA_中,char占2字节,16位。可在存放汉字 在_Java_中定义的八种_基本数据类型_中,除了其它七种类型都有明确的内存占用字节数外,就boolean类型没有给出具体… _JAVA_中分为_基本数据类型_和引用数据类型区别 - yinyanlei - 博客园 2017年9月3日 - 一、基本数据类型: byte:_Java_中最小的数据类型,在内存中占8位(bit),即1个字节,取值范围-128~127,默认值0 short:短整型,在内存中占16位,即2个字节,取值… java_四类八种_基本数据类型 - 仙人球很多刺 - 博客园 2016年8月31日 - 在栈中可以直接分配内存的数据是_基本数据类型_。 引用数据类型:是数据的引用在栈中,但是他的对象在堆中。 要想学好_Java_必须知道各种数据的在内存中存储… _java基本数据类型_习题(选择24)._百度文库 浮点型属于复合类型; D、变量属性分为:基本类型_和符合类型; 6、下列选项中,哪一项不属于 _JAVA 语言的简单数据类型: A、整数型; B、数组; C、字符型; D、… JAVA 中_基本数据类型_是什么,各自占用多少字节以及取值…-CSDN博客 2018年9月11日 - 前提:在学习基本数据类型_之前,我们先认识一下这两个单词:1、bit–位:位是计算机中存储数据的最小_Java _Java_中_基本数据类型_有哪些_百度知道 2017年6月6日 - _Java_中_基本数据类型_有哪些byte:8位,最大存储数据量是255,存放的数据范围是-128127之间。short:16位,最大数据存储量是65536,数据范围是-3276832767之… _java_的_基本数据类型_有八种_百度文库 java 的_基本数据类型_有八种 四类八种差不多数据类型 1. 整型 byte(1 字节) short (2 个字节) int(4 个字节) long (8 个字节) 2.浮点型 float(4 个… Java 3.基本数据类型 - HL() - 博客园 基本数据类型 java_有8大_基本数据类型,分别是4个整数型byte,short,int,long,2个浮点类型float,double,1个布尔型boolean和一个字符型char。 整形与浮点型 整形 … _Java_中8种_基本数据类型_是哪些? - 乱世以外 - 博客园 2019年8月22日 - 基本数据类型 是_JAVA_程序里已经定义好的规则,引用类型 是程序员在程序编写时定义的,一般只在程序员些的某个程序里有意义。_Java_中如何强制类型转换?… Java:八种基础数据类型-百度经验 2019年6月12日 - 认识Java_的八种_基础数据类型_。 工具/原料 Eclipse工具 方法/步骤 1 八种_基础数据类型: 四种整数类型:byte、short、int、long两种浮点数据类型:float… JAVA-八种_基本数据类型__CSII@王大仙的博客-CSDN博客 2018年8月13日 - 八种_基本数据类型_1)四种整数类型(byte、short、int、long):byte:8位,用于表示… _基本数据类型Java_八种_基本数据类型_1)四种整数类型(byte、short、int… 【JAVA_】5、_Java数据类型_的划分及8种_基本数据类型 - zh…-CSDN博客 2018年5月30日 - _Java_的数据类型可分为“_基本数据类型_”与“引用数据类型” ①_基本数据类型_也称为原始数据类型,它们包括了最基本的boolean、byte、char、shoot、int、l… _JAVA基本数据类型_和引用数据类型的区别 - cccuteboy - 博客园 2018年3月25日 - JAVA基本数据类型_和引用数据类型的区别 【_基本数据类型_】 _基本数据类型:声明时直接在栈内存中开辟空间,并直接在当前内存中存放数据,赋值时传递的是变… JAVA基本数据类型_所占字节数是多少? - _java-gubin - 博客园 2018年10月26日 - 在Java_中一共有8种_基本数据类型,其中有4种整型,2种浮点类型,1种用于表示Unicode编码的字符单元的字符类型和1种用于表示真值的boolean类型。(一个字节… _java_中八大_基本数据类型_详解 - Tanyboye - 博客园 2018年5月25日 - _基本数据类型_的分类 _java_中的类型分为_基本数据类型_和引用类型,今天我们讨论的是_java_中的八大_基本数据类型_。 _基本数据类型_可以分为三类:1.数值类型。2… _java基本数据类型_范围 - 菜菜鸟的博客 - CSDN博客 2019年7月5日 - boolean_类型_与其他_基本类型_不能进行_类型_的转换(既不能进行自动_类型_的提升,也不能强制_类型_转换), 否则,将编译出错。 byte型不能自动_类型_提升到char,cha… _JAVA基本数据类型_、引用数据类型-参数传递详解 - TMusket…_博客园 2018年11月27日 - JAVA基本数据类型_、引用数据类型-参数传递详解 1:_基本类型_的参数传值 对于_基本数据类型,修改这个值并不会影响作为参数传进来的那个变量,因为你修改的…","link":"/2020/04/01/%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"鉴权中心：Spring Boot 2.0.2 Oauth2 持久化","text":"Springboot2+Spring_Security+_Oauth2+Mysql数据库实现持久…_博客园 2019年8月23日 - Springboot2+Spring_Security+_Oauth2+Mysql数据库实现持久化_客户端数据 目录 介绍 建表,初始化数据 工程配置 Authorization Server - _Spring Security配置 Authorization … SpringBoot 整合 oauth2(四)实现 token 持久化 - 简书 SpringBoot 整合 oauth2(四)实现 token 持久化 为什么需要给token做持久化,试想如果存储token的服务器宕机后,用户信息也会伴随着失效,用户需要重新登陆来获取token, … springboot+_spring_security+_oauth2_整合(并用mysql数据…_CSDN博客 2018年8月13日 - 本文主要讲的是,实现_oauth2_的工作流程,对客户端数据用mysql数据库实现_持久化_。需要对oauth_2.0_概念有一定的基础知识了解。阅读前请学习oauth_2.0_的理论知识。文末有此… Spring Boot 配置OAuth2 使用Redis_持久化_保存token - w…_CSDN博客 2017年6月2日 - springboot+spring_security+_oauth2_整合(并用mysql实现_持久化)本文主要讲的是,实现_oauth2_的工作流程,需要对oauth_2.0_概念有一定的基础知识了解。阅读前… Spring Boot 配置OAuth2 使用Redis_持久化_保存token - yan5845hao… 2017年6月2日 - ()) // 持久_操作 .tokenStore(new RedisTokenStore(redisConnectionFactory)) …因为项目需要,调研并使用了_Spring cloud oauth2.0,网上关于oauth2.0… SpringBoot2.0 + Oauth2 实现RESTful API身份验证 - 简书 2019年5月22日 - OAuth2 网页翻译后截图 配置授权服务oauth @EnableAuthorizationServer: 用于激活OAuth _2.0_授权服务器。 主要配置: 客户端信息, 管理令牌, 授权类型。… Spring Boot 2.0 利用 Spring Security 实现简单的_OAuth2.0_认证… 2018年6月21日 - 经过前面一小节已经基本配置好了基于SpringBoot+Spring_Security+OAuth_2.0_的环境。这…_oauth2“) 32 .secret(finalSecret) 33 .and() 34 .withClient(“… Spring Boot2.0 Oauth2 服务器和客户端配置及原理 - 云+社区… 2019年4月3日 - spring_framework._boot spring…&gt;spring-security-oauth2 2… Spring Boot _Oauth2_多点登录,access_token刷新问题-CSDN论坛 2019年9月20日 - 基于Spring Boot2 + Spring Security OAuth2 实现单点登陆(一) 关于_OAuth2_的基本…8、Redis 的_持久化_机制是什么?各自的优缺点? 9、Redis 常见性… Spring boot 2.0 with Oauth2 + Jwt丶一个站在Java后端设计之路的… 2018年9月4日 - 2.24. Spring boot with Oauth2 jwt 2.24.1. Maven org.spring_framework._boot spring-boot-starter-sec… 在Spring _Boot_中使用_OAuth2_保护REST服务 - 个人文章 - Segment… 2019年9月9日 - 在授予卡的OAuth2_协议中,它称为身份验证服务器。_2…urerAdapter接口,所以Spring_将使用这个类来参数化服务…在我们的示例中,我们将使用_Spring _Boot_在… springboot2.0.X使用spring security oauth2 - 程序员大本营 最近收到一个任务使用spring security做一个oauth2_的授权服务器和资源服务器,…但是在_springboot2.X中redis的默认连接客户端不再是jedis而是lettuce,官方使用的… oauth2.0-spring boot oauth2 获取到access_token之后访问资源… 2019年2月19日 - .spring_framework._boot spring-boot-starter-data-redis org.spring… Spring Boot 2.0.0 + OAuth2 - Stack Overflow 2020年2月21日 - Does Spring Boot 2 + Sping Security OAuth2 still support the @AuthorizationServer annotation? From reading the release notes some things hav… _SpringBoot_整合_OAuth2_做认证授权 - 知乎 2019年9月25日 - oath_access_token 表 存储access_token _oauth__client_details 存储客户端… _SpringBoot_之_oauth2.0_学习之服务端配置快速上手 2018年12月20日 - 这里SpringBoot_的版本为_2.0.6.REALEASE1._2_、@Enable…public class _OAuth2_AuthorizationServerConfiguration extends… springboot2.0-oauth2-master springboot question,autho2验证… 2019年3月21日 - springboot2.0-oauth2-master\\authorization-server\\src\\main\\java\\cn\\merryyou\\security_SpringBoot2Oauth2_Application.java, 2065 , 2018-05-05 spr… oauth2-demo: _springboot_基于_oauth2_的授权验证,代码源于网络,感谢… springboot 2.0_使用_spring-security-oauth2_的迁移指南 有朋友使用了 _springboot2.0…序列化问题时,请注意下 spring-security-oauth2 的版本务必高于 2.3.2… 如何 设置springboot oauth2 验证不通过返回json_电脑培训 2017年5月22日 - spring-security-oauth2_在集群环境下可行定时任务的实现方式有多种,例如jdk自带的timer+timertask方式,_spring 3.0以后的调度任务(scheduled task),qua… Spring Security OAuth2 Boot Auto-config 2.0.4 &amp; 2.1.0.M2… 2018年8月29日 - Level up your Java code and explore what Spring can do for you…. Spring Security OAuth2 Boot Auto-config 2.0.4 &amp; 2.1.0.M2 Released … SpringBoot 整合 oauth2(四)实现 token _持久化__weixin…_CSDN博客 2018年5月15日 - springboot+spring_security+_oauth2_整合(并用mysql实现_持久化)本文主要讲的是,实现_oauth2_的工作流程,需要对oauth_2.0_概念有一定的基础知识了解。阅读前… _SpringBoot2.0_之Security-_Oauth2_配置踩坑+源码分析 - 简书 2019年1月9日 - 新版的SpringBoot_相关依赖的jar很多包结构做了变更,相关依赖也有很多不同,本人负责公司的基础服务,相关登录认证,资源认证采用了开源的 _Spring-Securit… _SpringBoot_之_oauth2.0_学习之服务端配置快速上手 - 聂晨 - 博客园 这里SpringBoot_的版本为_2.0.6.REALEASE 1.2_、@…_springboot_通过外部化配置的security._oauth2.client的…Store 主要定义了对token的增删改查操作,用于持久化… _springboot2_整合_oauth2__Java_qq_37170583的博客-CSDN博客 2018年6月15日 - 项目由springboot_1.5.X升级到_springboot2.0.0后,导致各组件API以及依赖包发生了变化。 完整项目demo:https://gitee.com/zkane/_springboot2_-_oauth2_.git… spring boot 2.0 整合 oauth2 authorization code授权码模式 - 简书 oauth2 authorization_code 授权模式 org.spring_framework._boot spring-boot-starter-parent&lt;/… Spring Boot OAuth2 整合(授权码和password的数据库配…_CSDN博客 2019年4月27日 - 无疑OAuth2_现在是最好的方式,如果_OAuth2_相关知识…//_Springboot_版本为_2.0.2.RELEASE &lt;group…(并用mysql数据库实现_持久化_客户端数据) … _springboot2_整合_OAuth2.0_认证实例 - haoxiaoyong1014的…_CSDN博客 2018年6月24日 - springboot-oauth2 包括: springboot-oauth2-authorization-server(认证服务)和springboot-oauth2-resource-server(资源服务) springBoot_版本:_2.0.1.RELEASE 授权码模… _springboot2_整合_OAuth2.0_认证实例 - Ethanxumf的博客 2018年8月17日 - 最详细的Spring Boot OAuth_2.0_密码模式服务器实现 阅读数 2万+ 前言由于项目要…springboot+spring_security+_oauth2_整合(并用mysql数据库实现_持久化… springboot+_spring_security+_oauth2_整合(并用mysql数据…_CSDN博客 2020年3月9日 - Springboot+Spring_security+_Oauth2_整合(并用mysql数据库实现_持久化客户端数据) 本文主要讲的是,实现_oauth2_的工作流程,对客户端数据用mysql数据库实现… Springboot2+Spring_Security+_Oauth2+Mysql数据库实现_持久化_客户端… 2019年8月23日 - 上述简单的介绍了_OAuth2_内部的四种授权方式,我们下面使用密码模式来进行测试;我们就来讲解下_SpringBoot_项目中是如何配置使用_OAuth2_服务器端,并且我们使用数据库中的用户… Spring boot 2.0 with Oauth2 + Jwt - 云+社区 - 腾讯云 2018年9月5日 - 2.24. Spring boot with Oauth2 jwt 2.24.1. Maven org.spring_framework._boot spring-boot-starter-sec… Spring Boot 2.0 整合 Spring Security Oauth2 - 谦和之中见卓越… 2018年4月29日 - Spring Security OAuth Boot 2 Auto-config 2.0.0 已发布,该项目用于提供 Spring Security OAuth 2 与 Spring Boot 2 的集成。 该项目旨在帮助用户在旧版 Sprin… spring boot 2 oauth2 access_token请求失败-CSDN论坛 .requestMatchers().antMatchers(“/oauth/**”,”/…2.AuthorizationServerConfig 中第21行 改为 .token…spring boot oauth2 获取到access_token之后访问资源… Springboot2.0 + _OAuth2.0_之密码模式之单项目集成 - lzj1…_博客园 2019年1月16日 - 其中OAuth2_为我们提供了四种授权方式: 1、授权码模式(authorization code) _2_、简化…» 下一篇: _Springboot2.0 + OAuth_2.0_之密码模式之认证资源分离 … springboot - Spirng_boot_ _Oauth2_中的@Enable_OAuth2_Sso @Enable… 2019年4月16日 - spring-boot-编程思想 springboot 我已经用了@EnableResourceServer EnableAuthorizationServer 问下@Enable_OAuth2_Sso @Enable_OAuth2_Client有啥用?… springboot_之_oauth2 - 小不点丶 - 博客园 2019年2月18日 - springboot_之_oauth2 一、OAuth_2.0_是OAuth协议的延续版本,但不向后兼容OAuth 1.0即完全废止了OAuth1.0。 OAuth _2.0_关注客户端开发者的简易性。要么通过… SpringBoot 整合 oauth2(五)实现 jwt 及 扩展 - 简书 SpringBoot 整合 oauth2(五)实现 jwt 及 扩展 FantJ关注赞赏支持SpringBoot …这样带来最大的问题,就是需要人工_持久化_处理token(像处理分布式下的sessionId一… Spring Boot 集成 Swagger2 与配置 OAuth2.0 授权 2018年9月3日 - Spring Boot 集成 Swagger2 很简单,由于接口采用了OAuth2.0 &amp; JWT 协议做了安全验证,使用过程中也遇到了很多小的问题,多次尝试下述配置可以正常使用。… spring springboot oauth2 实现一个token验证汗血宝马 2016年12月19日 - 今天老大让我给我们的项目api写一个token,防止第三方接口随意调用我们的接口,利用springboot 的_oauth2_去实现,grant_type是client_credentials,我是新… Spring Boot 整合 Spring Security OAuth2 OAuth2 协议解读 Spring Security 核心知识解读 Spring Security OAuth2 核心知识解读 Spring Boot 整合 Spring Security OAuth2 实现认证中心会员… Spring Boot 2.0_集成_Oauth2 - 陈嘟嘟的博客 2018年4月13日 - 最近在学习spring boot,发现在用spring boot 2.0_集成Oauth的资料比较少,所以记录下来,希望帮助到学习的童鞋。 _OAuth2 Spring Security OAuth project … _SpringBoot_中_oauth2.0_学习之服务端配置快速上手-云栖社区-阿里云 2018年12月17日 - 这里SpringBoot_的版本为_2.0.6.REALEASE 1.2_、@…_springboot_通过外部化配置的security._oauth2.client的…Store 主要定义了对token的增删改查操作,用… SpringBoot 整合(六)Security &amp; Oauth2.0(完整篇) - 简书 2. 企业级封装篇 我的Spring Security 文集 SpringBoot 整合 Security(一)实现…SpringBoot 整合 oauth2(四)实现 token 持久化 SpringBoot 整合 oauth2(五)实… SpringBoot 整合 oauth2(四)实现 token 持久化-云栖社区-阿里云 2018年5月15日 - 为什么需要给token做持久化,试想如果存储token的服务器宕机后,用户信息也会伴随着…Spring Boot Security OAuth2 实现支持JWT令牌的授权服务器 程序… _SpringBoot_之_oauth2.0_学习之服务端配置快速上手 - 聂晨 - 博客园 其实在这种示例当中,oauth_2.0_是使用比较多的一种…springboot_通过外部化配置的security._oauth2.client的…Store 主要定义了对token的增删改查操作,用于持久化… Spring Boot 集成 Swagger2 与配置 OAuth2.0 授权 - 花儿…_博客园 2018年9月3日 - Spring Boot 集成 Swagger2 很简单,由于接口采用了OAuth2.0 &amp; JWT 协议做了安全验证,使用过程中也遇到了很多小的问题,多次尝试下述配置可以正常使用。… Spring Boot_实现_OAuth 2.0(二)– 自定义权限验证_曱熊…_CSDN博客 2018年1月4日 - Spring boot+Security OAuth2 自定义登录和授权页面 阅读数 1555 在学习了_Spring_SecurityoAuth_2.0_框架的基础知识,以及动手搭建简单的认证服务器和资… Spring Security Oauth2_和_Spring _Boot_实现单点登录 - 知乎 2019年12月10日 - org.spring_framework.security.oauth._boot spring-security-oauth2-autoconfigure 2.0.1.RELE… springboot - spring boot _OAuth2_无法实现跨域CORS - Segment… spring boot 项目集成了_OAuth2_认证,http请求正常,访问未保护的接口正常,但当使用ajax跨域访问auth保护的接口,就报401,求大神帮忙看下。 SpringBoot 整合 Spring Security OAuth2 基于数据库实…_CSDN博客 2018年12月18日 - springboot+spring_security+_oauth2_整合(并用mysql实现_持久化)本文主要讲的是,实现_oauth2_的工作流程,需要对oauth_2.0_概念有一定的基础知识了解。阅读前… SpringBoot2.0 整合 Spring Security OAuth2,基于JDBC存储令牌… 2019年12月27日 - 概述SpringBoot_版本为 _2.0.6.RELEASE; 数据库使用的是MySQL; 配置Spring Security _OAuth2_大概可以分为4各部分: 实现Use… springboot2.0-oauth2-master111.7z-Java代码类资源-CSDN下载 2019年5月10日 - springboot2 oauth2 实现更多下载资源、学习资料请访问CSDN下载频道…. springboot2.0-oauth2-master111.7z 评分 springboot2 oauth2 实现 aaaa … springboot_和_spring_security整合_OAuth2 - if年少有为 - 博客园 2020年1月13日 - springboot_和_spring_security整合_OAuth2 1. OAuth_2.0_介绍 OAuth(开放授权)是一个…/** * 指定token的_持久化_策略 * 其下有 RedisTokenStore保存到redis… springboot oauth2.0 密码模式下怎么通过URL将参数发送…_CSDN论坛 springboot2_整合_oauth2 1.背景 项目由springboot_1.5.X升级到_springboot2.0.0后,导致各组件API以及依赖包发生了变化。 完整项目demo:https://gitee.com/zkane… Spring Boot 2.0 利用 Spring Security 实现简单的_OAuth2.0_认证… 2019年4月18日 - 经过前面一小节已经基本配置好了基于SpringBoot+Spring_Security+_OAuth2.0_的环境。这…server/ResourceServerConfiguration.java _OAuth 资源服务器配… spring _boot_做_OAuth2_认证服务端_zeusoul的博客-CSDN博客 2017年6月12日 - 由于公司业务需要,现将在_springboot_中部署_OAuth2_服务端的做法记录下来。 _OAuth2_的… 由于公司业务需要,现将在_springboot_中部署_OAuth2_服务端的做法记… spring boot 2.0 整合 security oauth2 password 模式和… 2018年7月9日 - oauth2 根据使用场景不同,分成了4种模式 授权码模式(authorization code 即先登录… org.spring_framework._boot… Spring Boot2.0 Oauth2 服务器和客户端配置及原理 - chinotan的… 2018年12月2日 - Spring Boot2.0 Oauth2 服务器和客户端配置及原理 …为了理解OAuth的适用场合,让我举一个假设的例子。 …设置序列化 Jackson_2_JsonRedisSerializer jackson_2_Json… 基于_Springboot_集成security、_oauth2_实现认证鉴权、资源…_博客园 2019年3月5日 - OAuth_2.0_是OAuth协议的延续版本,但不向后兼容OAuth …–JPA数据库持久化–&gt; 43 44 &lt;…man._springboot_securityauth2.config._OAuth2_Conf… Spring Boot_整合_Spring Security简记-OAuth2 重写Spring Boot 2.0… new無语 转载请注明原创出处,谢谢! Spring Security学习目录 用于OAuth客户端支持的Spring Boot _2.0_自动配置类是_OAuth2_ClientA… SpringBoot_系列–(1)–_SpringBoot2.x 之理解OAuth2.0…_CSDN博客 2019年1月30日 - _springboot2_整合_oauth2_实现密码授权模式 阅读数 1万+ _spring_cloud集成_oauth2_实现微服务认证,调用oauth服务获取token,通过这个access_token去访问其它… spring boot 2.0 整合 oauth2 authorization code授权码模式 - 简书 2018年7月9日 - Spring Boot_整合_Spring Security简记-OAuth2(十一) new無语 转载请注明原创出处,谢谢! Spring Security学习目录 OAuth 2.0 Provider OAuth 2.0 Provi… oauth 2.0 - Spring boot Oauth2 Access token doesn’t work… 2020年3月10日 - spring-boot oauth-2.0 spring-security-oauth2 shareimprove this question asked…5_Spring_ boot security consider case insensitive username c… 用户对问题“如何获取_SpringBoot_和_OAuth2_示例以使用密码授予凭据… 2018年4月11日 - 下面是DaveSyer的基本SpringBootOAuth2_示例:https://github.com/dsyer/sparklr-_boot/blob/master/src/main/java/demo/Application.java @Configuratio… SpringBoot 整合 oauth2(五)实现 jwt 及 扩展-云栖社区-阿里云 2018年5月22日 - 这样带来最大的问题,就是需要人工持久化_处理token(像处理分布式下的sessionId一…_SpringBoot 整合(六)Security &amp; Oauth2.0(完整篇) 微笑着生活 2018… Springboot2(53)整合_oauth2__cowbin2012的专栏-CSDN博客 2019年6月28日 - springboot2_教程系列 _OAuth 概念 ​ OAuth 是一个开放标准,允许用户让第三方应用访问该用户在某一网站上存储的私密的资源(如照片,视频,联系人列表),而… Spring Boot 集成 Swagger2 与配置 OAuth2.0 授权 - we…_CSDN博客 2018年9月3日 - Spring Boot 集成 Swagger2 很简单,由于接口采用了OAuth2.0 &amp; JWT 协议做了安全验证,使用过程中也遇到了很多小的问题,多次尝试下述配置可以正常使用。… SpringBoot2.0 _Oauth2_搭建认证服务器自定义认证数据库表 - 程序员… 1、spring security oauth2 通过注解@PreAuthorize进行authorities权限和scope权限拦截,该注解使用在方法上面。 _2_、通过自定义注解@ScopeDetail,注解使用在方法上面有效,… spring boot 2.0 整合 security oauth2 password 模式和… 2018年7月9日 - oauth2 根据使用场景不同,分成了4种模式 授权码模式(authorization code 即先登录… org.spring_framework._boot… Spring Boot_实现_OAuth 2.0(二)– 自定义权限验证 - 怯…_CSDN博客 2018年1月4日 - (response); return false; } OAuth2_Authentication …_spring-security 1篇 oauth-2-0 1篇 Java泛型…Spring Boot_实现OAuth _2.0(二)– 自定义权限… Spring boot 2.x+_oauth2_实现单点登录:基础准备之OAuth…_CSDN博客 2018年9月12日 - Spring boot 2.x+_oauth2_实现单点登录:基础准备之…这是OAuth _2.0_的官方介绍,大意是说OAuth _2.0_是工业…声明:本文不会下关于Mybatis和JPA两个_持久_层框架… _SpringBoot_实现_OAuth2_认证服务器 - 柚子苹果果 - 博客园 2018年11月8日 - org.spring_framework.security.oauth._boot spring-security-oauth2-autoconfigure 2.1.0.RELE… springboot_快速搭建_oauth2 内存版身份认证 - 简书 2019年6月19日 - _SpringBoot_升级到了_2.0_之后的版本,Security也由原来的版本4升级到了5 升到5版本之后的security必须加入密码加密 WebSecurityConfiguration.class pack… Spring Boot_实现_OAuth 2.0 - 曱熊的博客 2018年1月3日 - 当你有了自己的数据源配置后,spring boot_会自动采用…至此,_spring security的用户认证和_OAuth2_的客户端授权… springboot+_spring_security+_oauth2_整合(并用mysql数据…_CSDN博客 2020年3月9日 - Springboot+Spring_security+_Oauth2_整合(并用mysql数据库实现_持久化客户端数据) 本文主要讲的是,实现_oauth2_的工作流程,对客户端数据用mysql数据库实现… springboot _Oauth2_配置_OAuth2_AuthenticationProcessingFilter… 2017年5月23日 - 工作中遇到一个比较蛋疼的情况,_Oauth2_人家的jar包封装的好好的,当access_token超时的时候,返回的是_OAuth2_Exception,格式是{“error”:”invalid_request”… Springboot 2-_OAuth 2_修改登录加密方式 - 算法之名的个人空间… 2018年8月21日 - spring-oauth-server在2019-08-04更新发布了2.0.1版本,spring-oauth-server是Spring_与_Oauth2_整合示例。 此版本是使用_Spring _Boot_重构实现后的第2个发… springboot2.0.X使用spring security oauth2 - qq_3634…_CSDN博客 2019年1月30日 - 最近收到一个任务使用spring security做一个oauth2_的授权服务器和资源服务器,授权…但是在_springboot2.X中redis的默认连接客户端不再是jedis而是lett… 基于_Springboot_集成security、_oauth2_实现认证鉴权、资源…_博客园 2019年3月5日 - 2.3.3.RELEASE 40 41 42 &lt;!–JPA数据库持久化-…_Oauth2_Config代码如下: 1 package com.unionman._springboot_securityauth2.c… SpringOauth2.0_源码分析之Token_持久化(五) - 有信仰的蜗牛 2018年10月29日 - 默认的情况下,SpringOauth2.0 提供4种方式存储。第…这里我们主要分析的是mysql的持久化_和redis的_持久化… 【Spring Boot&amp;&amp; Spring Cloud系列】单点登录SSO之OAuth2…_博客园 2017年8月30日 - OAuth2_AuthenticationProcessingFilter用来给一个有授权access token的请求加载授权信息。 对于所有OAuth_2.0_提供者的特性,配置是使用特殊的_Spring OAu… springboot 2.0 使用 spring-security-oauth2 (对比 spring _boot_1… 2018年4月20日 - springboot2_整合_oauth2 阅读数 2万+ 1.背景项目由springboot_1.5.X升级到_springboot2.0.0后,导致各组件API以及依赖包发生了变化。完整项目demo:https:… Spring Boot 2.0 整合 Spring Security Oauth2 - 谦和之中见卓越… 2018年4月29日 - Spring Security OAuth Boot 2 Auto-config 2.0.0 已发布,该项目用于提供 Spring Security OAuth 2 与 Spring Boot 2 的集成。 该项目旨在帮助用户在旧版 Sprin… springboot+spring_security+_oauth2_整合(并用mysql数据库实现_持久… 2019年9月12日 - Springboot+_Spring_security+_Oauth2_整合(并用mysql数据库实现_持久化_客户端数据) 本文主要讲的是,实现_oauth2_的工作流程,对客户端数据用mysql数据库实现_持久化_。需要对oa… spring boot 2.1.3整合_oauth2_的依赖问题 - qwty146的博…_CSDN博客 2019年3月8日 - springboot2_整合_oauth2 阅读数 2万+ 1.背景项目由springboot_1.5.X升级到_springboot2.0.0后,导致各组件API以及依赖包发生了变化。完整项目demo:https:… SpringBoot2.0 + Oauth2 实现RESTful API身份验证 - wa…_CSDN博客 2019年5月22日 - * JwtTokenStore 不是真正的存储,不持久化_数据,身份和访问令牌可以相互转换。 …_SpringBoot2.x版本整合_Spring_Security、_Oauth2_进行password认证 阅读… Spring boot 入门教程-Oauth2.0 (授权码模式) - 程序猿的踩坑之路 2018年9月6日 - 中添加security.oauth2.resource.filter-order = 3,但是添加后没有作用,按住ctrl 点击提示找不到,故推断是版本的问题,查看资料说spring boot 2.0 版本… _springboot2_集成_oauth2__swordmanChen的博客-CSDN博客 2019年4月14日 - springboot2_整合_oauth2 阅读数 2万+ 1.背景项目由springboot_1.5.X升级到_springboot2.0.0后,导致各组件API以及依赖包发生了变化。完整项目demo:https:… spring _boot_整合_OAuth2_保证api接口安全_lizhengyu89123…_CSDN博客 2019年6月11日 - spring-security-oauth2 4.2、配置资源服务器 @EnableResourceServer注解来开启资源服务器 package com.vesu… Spring Boot 2.0 整合 Spring Security Oauth2 丨 merryyou… 2018年4月29日 - 在Spring Security源码分析十一:Spring Security OAuth2_整合JWT中,我们使用_Spring Boot 1.5.6.RELEASE版本整合Spring Security _Oauth2_实现了授权码模…","link":"/2020/04/03/%E9%89%B4%E6%9D%83%E4%B8%AD%E5%BF%83%EF%BC%9ASpring-Boot-2-0-2-Oauth2-%E6%8C%81%E4%B9%85%E5%8C%96/"},{"title":"JavaScript编码规范","text":"1 前言 2 代码风格 2.1 文件 2.2 结构 2.2.1 缩进 2.2.2 空格 2.2.3 换行 2.2.4 语句 2.3 命名 2.4 注释 2.4.1 单行注释 2.4.2 多行注释 2.4.3 文档化注释 2.4.4 类型定义 2.4.5 文件注释 2.4.6 命名空间注释 2.4.7 类注释 2.4.8 函数/方法注释 2.4.9 事件注释 2.4.10 常量注释 2.4.11 复杂类型注释 2.4.12 AMD 模块注释 2.4.13 细节注释 3 语言特性 3.1 变量 3.2 条件 3.3 循环 3.4 类型 3.4.1 类型检测 3.4.2 类型转换 3.5 字符串 3.6 对象 3.7 数组 3.8 函数 3.8.1 函数长度 3.8.2 参数设计 3.8.3 闭包 3.8.4 空函数 3.9 面向对象 3.10 动态特性 3.10.1 eval 3.10.2 动态执行代码 3.10.3 with 3.10.4 delete 3.10.5 对象属性 4 浏览器环境 4.1 模块化 4.1.1 AMD 4.1.2 define 4.1.3 require 4.2 DOM 4.2.1 元素获取 4.2.2 样式获取 4.2.3 样式设置 4.2.4 DOM 操作 4.2.5 DOM 事件 1 前言JavaScript在百度一直有着广泛的应用，特别是在浏览器端的行为管理。本文档的目标是使JavaScript代码风格保持一致，容易被理解和被维护。 虽然本文档是针对JavaScript设计的，但是在使用各种JavaScript的预编译语言时(如TypeScript等)时，适用的部分也应尽量遵循本文档的约定。 2 代码风格2.1 文件[建议] JavaScript 文件使用无 BOM 的 UTF-8 编码。解释： UTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。 [建议] 在文件结尾处，保留一个空行。2.2 结构2.2.1 缩进[强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符。[强制] switch 下的 case 和 default 必须增加一个缩进层级。示例： 12345678910111213141516171819202122232425262728293031// goodswitch (variable) { case '1': // do... break; case '2': // do... break; default: // do...}// badswitch (variable) {case '1': // do... break;case '2': // do... break;default: // do...} 2.2.2 空格[强制] 二元运算符两侧必须有一个空格，一元运算符与操作对象之间不允许有空格。示例： 123var a = !arr.length;a++;a = b + c; [强制] 用作代码块起始的左花括号 { 前必须有一个空格。示例： 12345678910111213141516171819// goodif (condition) {}while (condition) {}function funcName() {}// badif (condition){}while (condition){}function funcName(){} [强制] if / else / for / while / function / switch / do / try / catch / finally 关键字后，必须有一个空格。示例： 12345678910111213141516171819// goodif (condition) {}while (condition) {}(function () {})();// badif(condition) {}while(condition) {}(function() {})(); [强制] 在对象创建时，属性中的 : 之后必须有空格，: 之前不允许有空格。示例： 12345678910111213// goodvar obj = { a: 1, b: 2, c: 3};// badvar obj = { a : 1, b:2, c :3}; [强制] 函数声明、具名函数表达式、函数调用中，函数名和 ( 之间不允许有空格。示例： 1234567891011121314151617// goodfunction funcName() {}var funcName = function funcName() {};funcName();// badfunction funcName () {}var funcName = function funcName () {};funcName (); [强制] , 和 ; 前不允许有空格。示例： 12345// goodcallFunc(a, b);// badcallFunc(a , b) ; [强制] 在函数调用、函数声明、括号表达式、属性访问、if / for / while / switch / catch 等语句中，() 和 [] 内紧贴括号部分不允许有空格。示例： 12345678910111213141516171819202122232425262728// goodcallFunc(param1, param2, param3);save(this.list[this.indexes[i]]);needIncream &amp;&amp; (variable += increament);if (num &gt; list.length) {}while (len--) {}// badcallFunc( param1, param2, param3 );save( this.list[ this.indexes[ i ] ] );needIncreament &amp;&amp; ( variable += increament );if ( num &gt; list.length ) {}while ( len-- ) {} [强制] 单行声明的数组与对象，如果包含元素，{} 和 [] 内紧贴括号部分不允许包含空格。解释： 声明包含元素的数组与对象，只有当内部元素的形式较为简单时，才允许写在一行。元素复杂的情况，还是应该换行书写。 示例： 1234567891011121314151617// goodvar arr1 = [];var arr2 = [1, 2, 3];var obj1 = {};var obj2 = {name: 'obj'};var obj3 = { name: 'obj', age: 20, sex: 1};// badvar arr1 = [ ];var arr2 = [ 1, 2, 3 ];var obj1 = { };var obj2 = { name: 'obj' };var obj3 = {name: 'obj', age: 20, sex: 1}; [强制] 行尾不得有多余的空格。2.2.3 换行[强制] 每个独立语句结束后必须换行。[强制] 每行不得超过 120 个字符。解释： 超长的不可分割的代码允许例外，比如复杂的正则表达式。长字符串不在例外之列。 [强制] 运算符处换行时，运算符必须在新行的行首。示例： 1234567891011121314151617181920212223// goodif (user.isAuthenticated() &amp;&amp; user.isInRole('admin') &amp;&amp; user.hasAuthority('add-admin') || user.hasAuthority('delete-admin')) { // Code}var result = number1 + number2 + number3 + number4 + number5;// badif (user.isAuthenticated() &amp;&amp; user.isInRole('admin') &amp;&amp; user.hasAuthority('add-admin') || user.hasAuthority('delete-admin')) { // Code}var result = number1 + number2 + number3 + number4 + number5; [强制] 在函数声明、函数表达式、函数调用、对象创建、数组创建、for语句等场景中，不允许在 , 或 ; 前换行。示例： 1234567891011121314151617181920212223242526// goodvar obj = { a: 1, b: 2, c: 3};foo( aVeryVeryLongArgument, anotherVeryLongArgument, callback);// badvar obj = { a: 1 , b: 2 , c: 3};foo( aVeryVeryLongArgument , anotherVeryLongArgument , callback); [建议] 不同行为或逻辑的语句集，使用空行隔开，更易阅读。示例： 12345678// 仅为按逻辑换行的示例，不代表setStyle的最优实现function setStyle(element, property, value) { if (element == null) { return; } element.style[property] = value;} [建议] 在语句的行长度超过 120 时，根据逻辑条件合理缩进。示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 较复杂的逻辑条件组合，将每个条件独立一行，逻辑运算符放置在行首进行分隔，或将部分逻辑按逻辑组合进行分隔。// 建议最终将右括号 ) 与左大括号 { 放在独立一行，保证与 if 内语句块能容易视觉辨识。if (user.isAuthenticated() &amp;&amp; user.isInRole('admin') &amp;&amp; user.hasAuthority('add-admin') || user.hasAuthority('delete-admin')) { // Code}// 按一定长度截断字符串，并使用 + 运算符进行连接。// 分隔字符串尽量按语义进行，如不要在一个完整的名词中间断开。// 特别的，对于HTML片段的拼接，通过缩进，保持和HTML相同的结构。var html = '' // 此处用一个空字符串，以便整个HTML片段都在新行严格对齐 + '&lt;article&gt;' + '&lt;h1&gt;Title here&lt;/h1&gt;' + '&lt;p&gt;This is a paragraph&lt;/p&gt;' + '&lt;footer&gt;Complete&lt;/footer&gt;' + '&lt;/article&gt;';// 也可使用数组来进行拼接，相对 + 更容易调整缩进。var html = [ '&lt;article&gt;', '&lt;h1&gt;Title here&lt;/h1&gt;', '&lt;p&gt;This is a paragraph&lt;/p&gt;', '&lt;footer&gt;Complete&lt;/footer&gt;', '&lt;/article&gt;'];html = html.join('');// 当参数过多时，将每个参数独立写在一行上，并将结束的右括号 ) 独立一行。// 所有参数必须增加一个缩进。foo( aVeryVeryLongArgument, anotherVeryLongArgument, callback);// 也可以按逻辑对参数进行组合。// 最经典的是baidu.format函数，调用时将参数分为“模板”和“数据”两块baidu.format( dateFormatTemplate, year, month, date, hour, minute, second);// 当函数调用时，如果有一个或以上参数跨越多行，应当每一个参数独立一行。// 这通常出现在匿名函数或者对象初始化等作为参数时，如setTimeout函数等。setTimeout( function () { alert('hello'); }, 200);order.data.read( 'id=' + me.model.id, function (data) { me.attchToModel(data.result); callback(); }, 300);// 链式调用较长时采用缩进进行调整。$('#items') .find('.selected') .highlight() .end();// 三元运算符由3部分组成，因此其换行应当根据每个部分的长度不同，形成不同的情况。var result = thisIsAVeryVeryLongCondition ? resultA : resultB;var result = condition ? thisIsAVeryVeryLongResult : resultB;// 数组和对象初始化的混用，严格按照每个对象的 { 和结束 } 在独立一行的风格书写。var array = [ { // ... }, { // ... }]; [建议] 对于 if...else...、try...catch...finally 等语句，推荐使用在 } 号后添加一个换行 的风格，使代码层次结构更清晰，阅读性更好。示例： 12345678910111213if (condition) { // some statements;}else { // some statements;}try { // some statements;}catch (ex) { // some statements;} 2.2.4 语句[强制] 不得省略语句结束的分号。[强制] 在 if / else / for / do / while 语句中，即使只有一行，也不得省略块 {...}。示例： 123456789// goodif (condition) { callFunc();}// badif (condition) callFunc();if (condition) callFunc(); [强制] 函数定义结束不允许添加分号。示例： 1234567891011// goodfunction funcName() {}// badfunction funcName() {};// 如果是函数表达式，分号是不允许省略的。var funcName = function () {}; [强制] IIFE 必须在函数表达式外添加 (，非 IIFE 不得在函数表达式外添加 (。解释： IIFE = Immediately-Invoked Function Expression. 额外的 ( 能够让代码在阅读的一开始就能判断函数是否立即被调用，进而明白接下来代码的用途。而不是一直拖到底部才恍然大悟。 示例： 123456789101112131415161718// goodvar task = (function () { // Code return result;})();var func = function () {};// badvar task = function () { // Code return result;}();var func = (function () {}); 2.3 命名[强制] 变量 使用 Camel命名法。示例： 1var loadingModules = {}; [强制] 常量 使用 全部字母大写，单词间下划线分隔 的命名方式。示例： 1var HTML_ENTITY = {}; [强制] 函数 使用 Camel命名法。示例： 12function stringFormat(source) {} [强制] 函数的 参数 使用 Camel命名法。示例： 12function hear(theBells) {} [强制] 类 使用 Pascal命名法。示例： 12function TextNode(options) {} [强制] 类的 方法 / 属性 使用 Camel命名法。示例： 12345678function TextNode(value, engine) { this.value = value; this.engine = engine;}TextNode.prototype.clone = function () { return this;}; [强制] 枚举变量 使用 Pascal命名法，枚举的属性 使用 全部字母大写，单词间下划线分隔 的命名方式。示例： 123456var TargetState = { READING: 1, READED: 2, APPLIED: 3, READY: 4}; [强制] 命名空间 使用 Camel命名法。示例： 1equipments.heavyWeapons = {}; [强制] 由多个单词组成的缩写词，在命名中，根据当前命名法和出现的位置，所有字母的大小写与首字母的大小写保持一致。示例： 1234567function XMLParser() {}function insertHTML(element, html) {}var httpRequest = new HTTPRequest(); [强制] 类名 使用 名词。示例： 12function Engine(options) {} [建议] 函数名 使用 动宾短语。示例： 12function getStyle(element) {} [建议] boolean 类型的变量使用 is 或 has 开头。示例： 12var isReady = false;var hasMoreCommands = false; [建议] Promise对象 用 动宾短语的进行时 表达。示例： 12var loadingData = ajax.get('url');loadingData.then(callback); 2.4 注释2.4.1 单行注释[强制] 必须独占一行。// 后跟一个空格，缩进与下一行被注释说明的代码一致。2.4.2 多行注释[建议] 避免使用 /*...*/ 这样的多行注释。有多行注释内容时，使用多个单行注释。2.4.3 文档化注释[强制] 为了便于代码阅读和自文档化，以下内容必须包含以 /**...*/ 形式的块注释中。解释： 文件 namespace 类 函数或方法 类属性 事件 全局变量 常量 AMD 模块 [强制] 文档注释前必须空一行。[建议] 自文档化的文档说明 what，而不是 how。2.4.4 类型定义[强制] 类型定义都是以{开始, 以}结束。解释： 常用类型如：{string}, {number}, {boolean}, {Object}, {Function}, {RegExp}, {Array}, {Date}。 类型不仅局限于内置的类型，也可以是自定义的类型。比如定义了一个类 Developer，就可以使用它来定义一个参数和返回值的类型。 [强制] 对于基本类型 {string}, {number}, {boolean}，首字母必须小写。 类型定义 语法示例 解释 String {string} – Number {number} – Boolean {boolean} – Object {Object} – Function {Function} – RegExp {RegExp} – Array {Array} – Date {Date} – 单一类型集合 {Array.&lt;string&gt;} string 类型的数组 多类型 {(number｜boolean)} 可能是 number 类型, 也可能是 boolean 类型 允许为null {?number} 可能是 number, 也可能是 null 不允许为null {!Object} Object 类型, 但不是 null Function类型 {function(number, boolean)} 函数, 形参类型 Function带返回值 {function(number, boolean):string} 函数, 形参, 返回值类型 参数可选 @param {string=} name 可选参数, =为类型后缀 可变参数 @param {…number} args 变长参数, …为类型前缀 任意类型 {*} 任意类型 可选任意类型 @param {*=} name 可选参数，类型不限 可变任意类型 @param {…*} args 变长参数，类型不限 2.4.5 文件注释[强制] 文件顶部必须包含文件注释，用 @file 标识文件说明。示例： 123/** * @file Describe the file */ [建议] 文件注释中可以用 @author 标识开发者信息。解释： 开发者信息能够体现开发人员对文件的贡献，并且能够让遇到问题或希望了解相关信息的人找到维护人。通常情况文件在被创建时标识的是创建者。随着项目的进展，越来越多的人加入，参与这个文件的开发，新的作者应该被加入 @author 标识。 @author 标识具有多人时，原则是按照 责任 进行排序。通常的说就是如果有问题，就是找第一个人应该比找第二个人有效。比如文件的创建者由于各种原因，模块移交给了其他人或其他团队，后来因为新增需求，其他人在新增代码时，添加 @author 标识应该把自己的名字添加在创建人的前面。 @author 中的名字不允许被删除。任何劳动成果都应该被尊重。 业务项目中，一个文件可能被多人频繁修改，并且每个人的维护时间都可能不会很长，不建议为文件增加 @author 标识。通过版本控制系统追踪变更，按业务逻辑单元确定模块的维护责任人，通过文档与wiki跟踪和查询，是更好的责任管理方式。 对于业务逻辑无关的技术型基础项目，特别是开源的公共项目，应使用 @author 标识。 示例： 12345/** * @file Describe the file * @author author-name(mail-name@domain.com) * author-name2(mail-name2@domain.com) */ 2.4.6 命名空间注释[建议] 命名空间使用 @namespace 标识。示例： 1234/** * @namespace */var util = {}; 2.4.7 类注释[建议] 使用 @class 标记类或构造函数。解释： 对于使用对象 constructor 属性来定义的构造函数，可以使用 @constructor 来标记。 示例： 12345678/** * 描述 * * @class */function Developer() { // constructor body} [建议] 使用 @extends 标记类的继承信息。示例： 1234567891011/** * 描述 * * @class * @extends Developer */function Fronteer() { Developer.call(this); // constructor body}util.inherits(Fronteer, Developer); [强制] 使用包装方式扩展类成员时， 必须通过 @lends 进行重新指向。解释： 没有 @lends 标记将无法为该类生成包含扩展类成员的文档。 示例： 12345678910111213141516171819/** * 类描述 * * @class * @extends Developer */function Fronteer() { Developer.call(this); // constructor body}util.extend( Fronteer.prototype, /** @lends Fronteer.prototype */{ _getLevel: function () { // TODO } }); [强制] 类的属性或方法等成员信息使用 @public / @protected / @private 中的任意一个，指明可访问性。解释： 生成的文档中将有可访问性的标记，避免用户直接使用非 public 的属性或方法。 示例： 1234567891011121314151617181920212223242526272829/** * 类描述 * * @class * @extends Developer */var Fronteer = function () { Developer.call(this); /** * 属性描述 * * @type {string} * @private */ this._level = 'T12'; // constructor body};util.inherits(Fronteer, Developer);/** * 方法描述 * * @private * @return {string} 返回值描述 */Fronteer.prototype._getLevel = function () {}; 2.4.8 函数/方法注释[强制] 函数/方法注释必须包含函数说明，有参数和返回值时必须使用注释标识。[强制] 参数和返回值注释必须包含类型信息和说明。[建议] 当函数是内部函数，外部不可访问时，可以使用 @inner 标识。示例： 1234567891011121314151617/** * 函数描述 * * @param {string} p1 参数1的说明 * @param {string} p2 参数2的说明，比较长 * 那就换行了. * @param {number=} p3 参数3的说明（可选） * @return {Object} 返回值描述 */function foo(p1, p2, p3) { var p3 = p3 || 10; return { p1: p1, p2: p2, p3: p3 };} [强制] 对 Object 中各项的描述， 必须使用 @param 标识。示例： 12345678910/** * 函数描述 * * @param {Object} option 参数描述 * @param {string} option.url option项描述 * @param {string=} option.method option项描述，可选参数 */function foo(option) { // TODO} [建议] 重写父类方法时， 应当添加 @override 标识。如果重写的形参个数、类型、顺序和返回值类型均未发生变化，可省略 @param、@return，仅用 @override 标识，否则仍应作完整注释。解释： 简而言之，当子类重写的方法能直接套用父类的方法注释时可省略对参数与返回值的注释。 2.4.9 事件注释[强制] 必须使用 @event 标识事件，事件参数的标识与方法描述的参数标识相同。示例： 12345678910/** * 值变更时触发 * * @event * @param {Object} e e描述 * @param {string} e.before before描述 * @param {string} e.after after描述 */onchange: function (e) {} [强制] 在会广播事件的函数前使用 @fires 标识广播的事件，在广播事件代码前使用 @event 标识事件。[建议] 对于事件对象的注释，使用 @param 标识，生成文档时可读性更好。示例： 1234567891011121314151617181920212223/** * 点击处理 * * @fires Select#change * @private */Select.prototype.clickHandler = function () { /** * 值变更时触发 * * @event Select#change * @param {Object} e e描述 * @param {string} e.before before描述 * @param {string} e.after after描述 */ this.fire( 'change', { before: 'foo', after: 'bar' } );}; 2.4.10 常量注释[强制] 常量必须使用 @const 标记，并包含说明和类型信息。示例： 1234567/** * 常量说明 * * @const * @type {string} */var REQUEST_URL = 'myurl.do'; 2.4.11 复杂类型注释[建议] 对于类型未定义的复杂结构的注释，可以使用 @typedef 标识来定义。示例： 123456789101112131415161718192021222324// `namespaceA~` 可以换成其它 namepaths 前缀，目的是为了生成文档中能显示 `@typedef` 定义的类型和链接。/** * 服务器 * * @typedef {Object} namespaceA~Server * @property {string} host 主机 * @property {number} port 端口 *//** * 服务器列表 * * @type {Array.&lt;namespaceA~Server&gt;} */var servers = [ { host: '1.2.3.4', port: 8080 }, { host: '1.2.3.5', port: 8081 }]; 2.4.12 AMD 模块注释[强制] AMD 模块使用 @module 或 @exports 标识。解释： @exports 与 @module 都可以用来标识模块，区别在于 @module 可以省略模块名称。而只使用 @exports 时在 namepaths 中可以省略 module: 前缀。 示例： 12345678910111213141516171819202122232425define( function (require) { /** * foo description * * @exports Foo */ var foo = { // TODO }; /** * baz description * * @return {boolean} return description */ foo.baz = function () { // TODO }; return foo; }); 也可以在 exports 变量前使用 @module 标识： 12345678910111213141516171819202122define( function (require) { /** * module description. * * @module foo */ var exports = {}; /** * bar description * */ exports.bar = function () { // TODO }; return exports; }); 如果直接使用 factory 的 exports 参数，还可以： 123456789101112131415161718/** * module description. * * @module */define( function (require, exports) { /** * bar description * */ exports.bar = function () { // TODO }; return exports; }); [强制] 对于已使用 @module 标识为 AMD模块 的引用，在 namepaths 中必须增加 module: 作前缀。解释： namepaths 没有 module: 前缀时，生成的文档中将无法正确生成链接。 示例： 1234567891011121314151617181920212223/** * 点击处理 * * @fires module:Select#change * @private */Select.prototype.clickHandler = function () { /** * 值变更时触发 * * @event module:Select#change * @param {Object} e e描述 * @param {string} e.before before描述 * @param {string} e.after after描述 */ this.fire( 'change', { before: 'foo', after: 'bar' } );}; [建议] 对于类定义的模块，可以使用 @alias 标识构建函数。示例： 1234567891011121314151617/** * A module representing a jacket. * @module jacket */define( function () { /** * @class * @alias module:jacket */ var Jacket = function () { }; return Jacket; }); [建议] 多模块定义时，可以使用 @exports 标识各个模块。示例： 123456789101112131415161718192021222324// one moduledefine('html/utils', /** * Utility functions to ease working with DOM elements. * @exports html/utils */ function () { var exports = { }; return exports; });// another moduledefine('tag', /** @exports tag */ function () { var exports = { }; return exports; }); [建议] 对于 exports 为 Object 的模块，可以使用@namespace标识。解释： 使用 @namespace 而不是 @module 或 @exports 时，对模块的引用可以省略 module: 前缀。 [建议] 对于 exports 为类名的模块，使用 @class 和 @exports 标识。示例： 1234567891011121314151617181920212223// 只使用 @class Bar 时，类方法和属性都必须增加 @name Bar#methodName 来标识，与 @exports 配合可以免除这一麻烦，并且在引用时可以省去 module: 前缀。// 另外需要注意类名需要使用 var 定义的方式。/** * Bar description * * @see foo * @exports Bar * @class */var Bar = function () { // TODO};/** * baz description * * @return {(string|Array)} return description */Bar.prototype.baz = function () { // TODO}; 2.4.13 细节注释对于内部实现、不容易理解的逻辑说明、摘要信息等，我们可能需要编写细节注释。 [建议] 细节注释遵循单行注释的格式。说明必须换行时，每行是一个单行注释的起始。示例： 1234567function foo(p1, p2, opt_p3) { // 这里对具体内部逻辑进行说明 // 说明太长需要换行 for (...) { .... }} [强制] 有时我们会使用一些特殊标记进行说明。特殊标记必须使用单行注释的形式。下面列举了一些常用标记：解释： TODO: 有功能待实现。此时需要对将要实现的功能进行简单说明。 FIXME: 该处代码运行没问题，但可能由于时间赶或者其他原因，需要修正。此时需要对如何修正进行简单说明。 HACK: 为修正某些问题而写的不太好或者使用了某些诡异手段的代码。此时需要对思路或诡异手段进行描述。 XXX: 该处存在陷阱。此时需要对陷阱进行描述。 3 语言特性3.1 变量[强制] 变量在使用前必须通过 var 定义。解释： 不通过 var 定义变量将导致变量污染全局环境。 示例： 12345// goodvar name = 'MyName';// badname = 'MyName'; [强制] 每个 var 只能声明一个变量。解释： 一个 var 声明多个变量，容易导致较长的行长度，并且在修改时容易造成逗号和分号的混淆。 示例： 123456789// goodvar hangModules = [];var missModules = [];var visited = {};// badvar hangModules = [], missModules = [], visited = {}; [强制] 变量必须 即用即声明，不得在函数或其它形式的代码块起始位置统一声明所有变量。解释： 变量声明与使用的距离越远，出现的跨度越大，代码的阅读与维护成本越高。虽然JavaScript的变量是函数作用域，还是应该根据编程中的意图，缩小变量出现的距离空间。 示例： 1234567891011121314151617181920212223242526272829303132333435// goodfunction kv2List(source) { var list = []; for (var key in source) { if (source.hasOwnProperty(key)) { var item = { k: key, v: source[key] }; list.push(item); } } return list;}// badfunction kv2List(source) { var list = []; var key; var item; for (key in source) { if (source.hasOwnProperty(key)) { item = { k: key, v: source[key] }; list.push(item); } } return list;} 3.2 条件[强制] 在 Equality Expression 中使用类型严格的 ===。仅当判断 null 或 undefined 时，允许使用 == null。解释： 使用 === 可以避免等于判断中隐式的类型转换。 示例： 123456789// goodif (age === 30) { // ......}// badif (age == 30) { // ......} [建议] 尽可能使用简洁的表达式。示例： 1234567891011// 字符串为空// goodif (!name) { // ......}// badif (name === '') { // ......} 1234567891011// 字符串非空// goodif (name) { // ......}// badif (name !== '') { // ......} 1234567891011// 数组非空// goodif (collection.length) { // ......}// badif (collection.length &gt; 0) { // ......} 1234567891011// 布尔不成立// goodif (!notTrue) { // ......}// badif (notTrue === false) { // ......} 1234567891011// null 或 undefined// goodif (noValue == null) { // ......}// badif (noValue === null || typeof noValue === 'undefined') { // ......} [建议] 按执行频率排列分支的顺序。解释： 按执行频率排列分支的顺序好处是： 阅读的人容易找到最常见的情况，增加可读性。 提高执行效率。 [建议] 对于相同变量或表达式的多值条件，用 switch 代替 if。示例： 1234567891011121314151617181920// goodswitch (typeof variable) { case 'object': // ...... break; case 'number': case 'boolean': case 'string': // ...... break;}// badvar type = typeof variable;if (type === 'object') { // ......} else if (type === 'number' || type === 'boolean' || type === 'string') { // ......} [建议] 如果函数或全局中的 else 块后没有任何语句，可以删除 else。示例： 123456789101112131415161718// goodfunction getName() { if (name) { return name; } return 'unnamed';}// badfunction getName() { if (name) { return name; } else { return 'unnamed'; }} 3.3 循环[建议] 不要在循环体中包含函数表达式，事先将函数提取到循环体外。解释： 循环体中的函数表达式，运行过程中会生成循环次数个函数对象。 示例： 12345678910111213141516// goodfunction clicker() { // ......}for (var i = 0, len = elements.length; i &lt; len; i++) { var element = elements[i]; addListener(element, 'click', clicker);}// badfor (var i = 0, len = elements.length; i &lt; len; i++) { var element = elements[i]; addListener(element, 'click', function () {});} [建议] 对循环内多次使用的不变值，在循环外用变量缓存。示例： 123456789101112131415// goodvar width = wrap.offsetWidth + 'px';for (var i = 0, len = elements.length; i &lt; len; i++) { var element = elements[i]; element.style.width = width; // ......}// badfor (var i = 0, len = elements.length; i &lt; len; i++) { var element = elements[i]; element.style.width = wrap.offsetWidth + 'px'; // ......} [建议] 对有序集合进行遍历时，缓存 length。解释： 虽然现代浏览器都对数组长度进行了缓存，但对于一些宿主对象和老旧浏览器的数组对象，在每次 length 访问时会动态计算元素个数，此时缓存 length 能有效提高程序性能。 示例： 1234for (var i = 0, len = elements.length; i &lt; len; i++) { var element = elements[i]; // ......} [建议] 对有序集合进行顺序无关的遍历时，使用逆序遍历。解释： 逆序遍历可以节省变量，代码比较优化。 示例： 12345var len = elements.length;while (len--) { var element = elements[len]; // ......} 3.4 类型3.4.1 类型检测[建议] 类型检测优先使用 typeof。对象类型检测使用 instanceof。null 或 undefined 的检测使用 == null。示例： 1234567891011121314151617181920212223242526272829// stringtypeof variable === 'string'// numbertypeof variable === 'number'// booleantypeof variable === 'boolean'// Functiontypeof variable === 'function'// Objecttypeof variable === 'object'// RegExpvariable instanceof RegExp// Arrayvariable instanceof Array// nullvariable === null// null or undefinedvariable == null// undefinedtypeof variable === 'undefined' 3.4.2 类型转换[建议] 转换成 string 时，使用 + ''。示例： 1234567// goodnum + '';// badnew String(num);num.toString();String(num); [建议] 转换成 number 时，通常使用 +。示例： 12345// good+str;// badNumber(str); [建议] string 转换成 number，要转换的字符串结尾包含非数字并期望忽略时，使用 parseInt。示例： 12var width = '200px';parseInt(width, 10); [强制] 使用 parseInt 时，必须指定进制。示例： 12345// goodparseInt(str, 10);// badparseInt(str); [建议] 转换成 boolean 时，使用 !!。示例： 12var num = 3.14;!!num; [建议] number 去除小数点，使用 Math.floor / Math.round / Math.ceil，不使用 parseInt。示例： 1234567// goodvar num = 3.14;Math.ceil(num);// badvar num = 3.14;parseInt(num, 10); 3.5 字符串[强制] 字符串开头和结束使用单引号 '。解释： 输入单引号不需要按住 shift，方便输入。 实际使用中，字符串经常用来拼接 HTML。为方便 HTML 中包含双引号而不需要转义写法。 示例： 12var str = '我是一个字符串';var html = '&lt;div class=&quot;cls&quot;&gt;拼接HTML可以省去双引号转义&lt;/div&gt;'; [建议] 使用 数组 或 + 拼接字符串。解释： 使用 + 拼接字符串，如果拼接的全部是 StringLiteral，压缩工具可以对其进行自动合并的优化。所以，静态字符串建议使用 + 拼接。 在现代浏览器下，使用 + 拼接字符串，性能较数组的方式要高。 如需要兼顾老旧浏览器，应尽量使用数组拼接字符串。 示例： 123456789101112131415// 使用数组拼接字符串var str = [ // 推荐换行开始并缩进开始第一个字符串, 对齐代码, 方便阅读. '&lt;ul&gt;', '&lt;li&gt;第一项&lt;/li&gt;', '&lt;li&gt;第二项&lt;/li&gt;', '&lt;/ul&gt;'].join('');// 使用 + 拼接字符串var str2 = '' // 建议第一个为空字符串, 第二个换行开始并缩进开始, 对齐代码, 方便阅读 + '&lt;ul&gt;', + '&lt;li&gt;第一项&lt;/li&gt;', + '&lt;li&gt;第二项&lt;/li&gt;', + '&lt;/ul&gt;'; [建议] 复杂的数据到视图字符串的转换过程，选用一种模板引擎。解释： 使用模板引擎有如下好处： 在开发过程中专注于数据，将视图生成的过程由另外一个层级维护，使程序逻辑结构更清晰。 优秀的模板引擎，通过模板编译技术和高质量的编译产物，能获得比手工拼接字符串更高的性能。 artTemplate: 体积较小，在所有环境下性能高，语法灵活。 dot.js: 体积小，在现代浏览器下性能高，语法灵活。 etpl: 体积较小，在所有环境下性能高，模板复用性高，语法灵活。 handlebars: 体积大，在所有环境下性能高，扩展性高。 hogon: 体积小，在现代浏览器下性能高。 nunjucks: 体积较大，性能一般，模板复用性高。 3.6 对象[强制] 使用对象字面量 {} 创建新 Object。示例： 12345// goodvar obj = {};// badvar obj = new Object(); [强制] 对象创建时，如果一个对象的所有 属性 均可以不添加引号，则所有 属性 不得添加引号。示例： 1234var info = { name: 'someone', age: 28}; [强制] 对象创建时，如果任何一个 属性 需要添加引号，则所有 属性 必须添加 '。解释： 如果属性不符合 Identifier 和 NumberLiteral 的形式，就需要以 StringLiteral 的形式提供。 示例： 12345678910111213// goodvar info = { 'name': 'someone', 'age': 28, 'more-info': '...'};// badvar info = { name: 'someone', age: 28, 'more-info': '...'}; [强制] 不允许修改和扩展任何原生对象和宿主对象的原型。示例： 123// 以下行为绝对禁止String.prototype.trim = function () {}; [建议] 属性访问时，尽量使用 .。解释： 属性名符合 Identifier 的要求，就可以通过 . 来访问，否则就只能通过 [expr] 方式访问。 通常在 JavaScript 中声明的对象，属性命名是使用 Camel 命名法，用 . 来访问更清晰简洁。部分特殊的属性(比如来自后端的JSON)，可能采用不寻常的命名方式，可以通过 [expr] 方式访问。 示例： 12info.age;info['more-info']; [建议] for in 遍历对象时, 使用 hasOwnProperty 过滤掉原型中的属性。示例： 123456var newInfo = {};for (var key in info) { if (info.hasOwnProperty(key)) { newInfo[key] = info[key]; }} 3.7 数组[强制] 使用数组字面量 [] 创建新数组，除非想要创建的是指定长度的数组。示例： 12345// goodvar arr = [];// badvar arr = new Array(); [强制] 遍历数组不使用 for in。解释： 数组对象可能存在数字以外的属性, 这种情况下 for in 不会得到正确结果. 示例： 123456789101112var arr = ['a', 'b', 'c'];arr.other = 'other things'; // 这里仅作演示, 实际中应使用Object类型// 正确的遍历方式for (var i = 0, len = arr.length; i &lt; len; i++) { console.log(i);}// 错误的遍历方式for (i in arr) { console.log(i);} [建议] 不因为性能的原因自己实现数组排序功能，尽量使用数组的 sort 方法。解释： 自己实现的常规排序算法，在性能上并不优于数组默认的 sort 方法。以下两种场景可以自己实现排序： 需要稳定的排序算法，达到严格一致的排序结果。 数据特点鲜明，适合使用桶排。 [建议] 清空数组使用 .length = 0。3.8 函数3.8.1 函数长度[建议] 一个函数的长度控制在 50 行以内。解释： 将过多的逻辑单元混在一个大函数中，易导致难以维护。一个清晰易懂的函数应该完成单一的逻辑单元。复杂的操作应进一步抽取，通过函数的调用来体现流程。 特定算法等不可分割的逻辑允许例外。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344function syncViewStateOnUserAction() { if (x.checked) { y.checked = true; z.value = ''; } else { y.checked = false; } if (!a.value) { warning.innerText = 'Please enter it'; submitButton.disabled = true; } else { warning.innerText = ''; submitButton.disabled = false; }}// 直接阅读该函数会难以明确其主线逻辑，因此下方是一种更合理的表达方式：function syncViewStateOnUserAction() { syncXStateToView(); checkAAvailability();}function syncXStateToView() { if (x.checked) { y.checked = true; z.value = ''; } else { y.checked = false; }}function checkAAvailability() { if (!a.value) { displayWarningForAMissing(); } else { clearWarnignForA(); }} 3.8.2 参数设计[建议] 一个函数的参数控制在 6 个以内。解释： 除去不定长参数以外，函数具备不同逻辑意义的参数建议控制在 6 个以内，过多参数会导致维护难度增大。 某些情况下，如使用 AMD Loader 的 require 加载多个模块时，其 callback 可能会存在较多参数，因此对函数参数的个数不做强制限制。 [建议] 通过 options 参数传递非数据输入型参数。解释： 有些函数的参数并不是作为算法的输入，而是对算法的某些分支条件判断之用，此类参数建议通过一个 options 参数传递。 如下函数： 123456789101112/** * 移除某个元素 * * @param {Node} element 需要移除的元素 * @param {boolean} removeEventListeners 是否同时将所有注册在元素上的事件移除 */function removeElement(element, removeEventListeners) { element.parent.removeChild(element); if (removeEventListeners) { element.clearEventListeners(); }} 可以转换为下面的签名： 12345678910111213/** * 移除某个元素 * * @param {Node} element 需要移除的元素 * @param {Object} options 相关的逻辑配置 * @param {boolean} options.removeEventListeners 是否同时将所有注册在元素上的事件移除 */function removeElement(element, options) { element.parent.removeChild(element); if (options.removeEventListeners) { element.clearEventListeners(); }} 这种模式有几个显著的优势： boolean 型的配置项具备名称，从调用的代码上更易理解其表达的逻辑意义。 当配置项有增长时，无需无休止地增加参数个数，不会出现 removeElement(element, true, false, false, 3) 这样难以理解的调用代码。 当部分配置参数可选时，多个参数的形式非常难处理重载逻辑，而使用一个 options 对象只需判断属性是否存在，实现得以简化。 3.8.3 闭包[建议] 在适当的时候将闭包内大对象置为 null。解释： 在 JavaScript 中，无需特别的关键词就可以使用闭包，一个函数可以任意访问在其定义的作用域外的变量。需要注意的是，函数的作用域是静态的，即在定义时决定，与调用的时机和方式没有任何关系。 闭包会阻止一些变量的垃圾回收，对于较老旧的JavaScript引擎，可能导致外部所有变量均无法回收。 首先一个较为明确的结论是，以下内容会影响到闭包内变量的回收： 嵌套的函数中是否有使用该变量。 嵌套的函数中是否有 直接调用eval。 是否使用了 with 表达式。 Chakra、V8 和 SpiderMonkey 将受以上因素的影响，表现出不尽相同又较为相似的回收策略，而JScript.dll和Carakan则完全没有这方面的优化，会完整保留整个 LexicalEnvironment 中的所有变量绑定，造成一定的内存消耗。 由于对闭包内变量有回收优化策略的 Chakra、V8 和 SpiderMonkey 引擎的行为较为相似，因此可以总结如下，当返回一个函数 fn 时： 如果 fn 的 [[Scope]] 是ObjectEnvironment（with 表达式生成 ObjectEnvironment，函数和 catch 表达式生成 DeclarativeEnvironment），则： 如果是 V8 引擎，则退出全过程。 如果是 SpiderMonkey，则处理该 ObjectEnvironment 的外层 LexicalEnvironment。 获取当前 LexicalEnvironment 下的所有类型为 Function 的对象，对于每一个 Function 对象，分析其 FunctionBody： 如果 FunctionBody 中含有 直接调用eval，则退出全过程。 否则得到所有的 Identifier。 对于每一个 Identifier，设其为 name，根据查找变量引用的规则，从 LexicalEnvironment 中找出名称为 name 的绑定 binding。 对 binding 添加 notSwap 属性，其值为 true。 检查当前 LexicalEnvironment 中的每一个变量绑定，如果该绑定有 notSwap 属性且值为 true，则： 如果是V8引擎，删除该绑定。 如果是SpiderMonkey，将该绑定的值设为 undefined，将删除 notSwap 属性。 对于Chakra引擎，暂无法得知是按 V8 的模式还是按 SpiderMonkey 的模式进行。 如果有 非常庞大 的对象，且预计会在 老旧的引擎 中执行，则使用闭包时，注意将闭包不需要的对象置为空引用。 [建议] 使用 IIFE 避免 Lift 效应。解释： 在引用函数外部变量时，函数执行时外部变量的值由运行时决定而非定义时，最典型的场景如下： 1234567891011var tasks = [];for (var i = 0; i &lt; 5; i++) { tasks[tasks.length] = function () { console.log('Current cursor is at ' + i); };}var len = tasks.length;while (len--) { tasks[len]();} 以上代码对 tasks 中的函数的执行均会输出 Current cursor is at 5，往往不符合预期。 此现象称为 Lift 效应 。解决的方式是通过额外加上一层闭包函数，将需要的外部变量作为参数传递来解除变量的绑定关系： 1234567891011121314var tasks = [];for (var i = 0; i &lt; 5; i++) { // 注意有一层额外的闭包 tasks[tasks.length] = (function (i) { return function () { console.log('Current cursor is at ' + i); }; })(i);}var len = tasks.length;while (len--) { tasks[len]();} 3.8.4 空函数[建议] 空函数不使用 new Function() 的形式。示例： 1var emptyFunction = function () {}; [建议] 对于性能有高要求的场合，建议存在一个空函数的常量，供多处使用共享。示例： 12345678var EMPTY_FUNCTION = function () {};function MyClass() {}MyClass.prototype.abstractMethod = EMPTY_FUNCTION;MyClass.prototype.hooks.before = EMPTY_FUNCTION;MyClass.prototype.hooks.after = EMPTY_FUNCTION; 3.9 面向对象[强制] 类的继承方案，实现时需要修正 constructor。解释： 通常使用其他 library 的类继承方案都会进行 constructor 修正。如果是自己实现的类继承方案，需要进行 constructor 修正。 示例： 123456789101112/** * 构建类之间的继承关系 * * @param {Function} subClass 子类函数 * @param {Function} superClass 父类函数 */function inherits(subClass, superClass) { var F = new Function(); F.prototype = superClass.prototype; subClass.prototype = new F(); subClass.prototype.constructor = subClass;} [建议] 声明类时，保证 constructor 的正确性。示例： 1234567891011121314151617function Animal(name) { this.name = name;}// 直接prototype等于对象时，需要修正constructorAnimal.prototype = { constructor: Animal, jump: function () { alert('animal ' + this.name + ' jump'); }};// 这种方式扩展prototype则无需理会constructorAnimal.prototype.jump = function () { alert('animal ' + this.name + ' jump');}; [建议] 属性在构造函数中声明，方法在原型中声明。解释： 原型对象的成员被所有实例共享，能节约内存占用。所以编码时我们应该遵守这样的原则：原型对象包含程序不会修改的成员，如方法函数或配置项。 12345678function TextNode(value, engine) { this.value = value; this.engine = engine;}TextNode.prototype.clone = function () { return this;}; [强制] 自定义事件的 事件名 必须全小写。解释： 在 JavaScript 广泛应用的浏览器环境，绝大多数 DOM 事件名称都是全小写的。为了遵循大多数 JavaScript 开发者的习惯，在设计自定义事件时，事件名也应该全小写。 [强制] 自定义事件只能有一个 event 参数。如果事件需要传递较多信息，应仔细设计事件对象。解释： 一个事件对象的好处有： 顺序无关，避免事件监听者需要记忆参数顺序。 每个事件信息都可以根据需要提供或者不提供，更自由。 扩展方便，未来添加事件信息时，无需考虑会破坏监听器参数形式而无法向后兼容。 [建议] 设计自定义事件时，应考虑禁止默认行为。解释： 常见禁止默认行为的方式有两种： 事件监听函数中 return false。 事件对象中包含禁止默认行为的方法，如 preventDefault。 3.10 动态特性3.10.1 eval[强制] 避免使用直接 eval 函数。解释： 直接 eval，指的是以函数方式调用 eval 的调用方法。直接 eval 调用执行代码的作用域为本地作用域，应当避免。 如果有特殊情况需要使用直接 eval，需在代码中用详细的注释说明为何必须使用直接 eval，不能使用其它动态执行代码的方式，同时需要其他资深工程师进行 Code Review。 [建议] 尽量避免使用 eval 函数。3.10.2 动态执行代码[建议] 使用 new Function 执行动态代码。解释： 通过 new Function 生成的函数作用域是全局使用域，不会影响当当前的本地作用域。如果有动态代码执行的需求，建议使用 new Function。 示例： 12var handler = new Function('x', 'y', 'return x + y;');var result = handler($('#x').val(), $('#y').val()); 3.10.3 with[建议] 尽量不要使用 with。解释： 使用 with 可能会增加代码的复杂度，不利于阅读和管理；也会对性能有影响。大多数使用 with 的场景都能使用其他方式较好的替代。所以，尽量不要使用 with。 3.10.4 delete[建议] 减少 delete 的使用。解释： 如果没有特别的需求，减少或避免使用delete。delete的使用会破坏部分 JavaScript 引擎的性能优化。 [建议] 处理 delete 可能产生的异常。解释： 对于有被遍历需求，且值 null 被认为具有业务逻辑意义的值的对象，移除某个属性必须使用 delete 操作。 在严格模式或IE下使用 delete 时，不能被删除的属性会抛出异常，因此在不确定属性是否可以删除的情况下，建议添加 try-catch 块。 示例： 123456try { delete o.x;}catch (deleteError) { o.x = null;} 3.10.5 对象属性[建议] 避免修改外部传入的对象。解释： JavaScript 因其脚本语言的动态特性，当一个对象未被 seal 或 freeze 时，可以任意添加、删除、修改属性值。 但是随意地对 非自身控制的对象 进行修改，很容易造成代码在不可预知的情况下出现问题。因此，设计良好的组件、函数应该避免对外部传入的对象的修改。 下面代码的 selectNode 方法修改了由外部传入的 datasource 对象。如果 datasource 用在其它场合（如另一个 Tree 实例）下，会造成状态的混乱。 123456789101112function Tree(datasource) { this.datasource = datasource;}Tree.prototype.selectNode = function (id) { // 从datasource中找出节点对象 var node = this.findNode(id); if (node) { node.selected = true; this.flushView(); }}; 对于此类场景，需要使用额外的对象来维护，使用由自身控制，不与外部产生任何交互的 selectedNodeIndex 对象来维护节点的选中状态，不对 datasource 作任何修改。 12345678910111213function Tree(datasource) { this.datasource = datasource; this.selectedNodeIndex = {};}Tree.prototype.selectNode = function (id) { // 从datasource中找出节点对象 var node = this.findNode(id); if (node) { this.selectedNodeIndex[id] = true; this.flushView(); }}; 除此之外，也可以通过 deepClone 等手段将自身维护的对象与外部传入的分离，保证不会相互影响。 [建议] 具备强类型的设计。解释： 如果一个属性被设计为 boolean 类型，则不要使用 1 / 0 作为其值。对于标识性的属性，如对代码体积有严格要求，可以从一开始就设计为 number 类型且将 0 作为否定值。 从 DOM 中取出的值通常为 string 类型，如果有对象或函数的接收类型为 number 类型，提前作好转换，而不是期望对象、函数可以处理多类型的值。 4 浏览器环境4.1 模块化4.1.1 AMD[强制] 使用 AMD 作为模块定义。解释： AMD 作为由社区认可的模块定义形式，提供多种重载提供灵活的使用方式，并且绝大多数优秀的 Library 都支持 AMD，适合作为规范。 目前，比较成熟的 AMD Loader 有： 官方实现的 requirejs 百度自己实现的 esl [强制] 模块 id 必须符合标准。解释： 模块 id 必须符合以下约束条件： 类型为 string，并且是由 / 分割的一系列 terms 来组成。例如：this/is/a/module。 term 应该符合 [a-zA-Z0-9_-]+ 规则。 不应该有 .js 后缀。 跟文件的路径保持一致。 4.1.2 define[建议] 定义模块时不要指明 id 和 dependencies。解释： 在 AMD 的设计思想里，模块名称是和所在路径相关的，匿名的模块更利于封包和迁移。模块依赖应在模块定义内部通过 local require 引用。 所以，推荐使用 define(factory) 的形式进行模块定义。 示例： 1234define( function (require) { }); [建议] 使用 return 来返回模块定义。解释： 使用 return 可以减少 factory 接收的参数（不需要接收 exports 和 module），在没有 AMD Loader 的场景下也更容易进行简单的处理来伪造一个 Loader。 示例： 123456789define( function (require) { var exports = {}; // ... return exports; }); 4.1.3 require[强制] 全局运行环境中，require 必须以 async require 形式调用。解释： 模块的加载过程是异步的，同步调用并无法保证得到正确的结果。 示例： 123456// goodrequire(['foo'], function (foo) {});// badvar foo = require('foo'); [强制] 模块定义中只允许使用 local require，不允许使用 global require。解释： 在模块定义中使用 global require，对封装性是一种破坏。 在 AMD 里，global require 是可以被重命名的。并且 Loader 甚至没有全局的 require 变量，而是用 Loader 名称做为 global require。模块定义不应该依赖使用的 Loader。 [强制] Package在实现时，内部模块的 require 必须使用 relative id。解释： 对于任何可能通过 发布-引入 的形式复用的第三方库、框架、包，开发者所定义的名称不代表使用者使用的名称。因此不要基于任何名称的假设。在实现源码中，require 自身的其它模块时使用 relative id。 示例： 12345define( function (require) { var util = require('./util'); }); [建议] 不会被调用的依赖模块，在 factory 开始处统一 require。解释： 有些模块是依赖的模块，但不会在模块实现中被直接调用，最为典型的是 css / js / tpl 等 Plugin 所引入的外部内容。此类内容建议放在模块定义最开始处统一引用。 示例： 12345678define( function (require) { require('css!foo.css'); require('tpl!bar.tpl.html'); // ... }); 4.2 DOM4.2.1 元素获取[建议] 对于单个元素，尽可能使用 document.getElementById 获取，避免使用document.all。[建议] 对于多个元素的集合，尽可能使用 context.getElementsByTagName 获取。其中 context 可以为 document 或其他元素。指定 tagName 参数为 * 可以获得所有子元素。[建议] 遍历元素集合时，尽量缓存集合长度。如需多次操作同一集合，则应将集合转为数组。解释： 原生获取元素集合的结果并不直接引用 DOM 元素，而是对索引进行读取，所以 DOM 结构的改变会实时反映到结果中。 示例： 12345678910111213141516&lt;div&gt;&lt;/div&gt;&lt;span&gt;&lt;/span&gt;&lt;script&gt;var elements = document.getElementsByTagName('*');// 显示为 DIValert(elements[0].tagName);var div = elements[0];var p = document.createElement('p');document.body.insertBefore(p, div);// 显示为 Palert(elements[0].tagName);&lt;/script&gt; [建议] 获取元素的直接子元素时使用 children。避免使用childNodes，除非预期是需要包含文本、注释和属性类型的节点。4.2.2 样式获取[建议] 获取元素实际样式信息时，应使用 getComputedStyle 或 currentStyle。解释： 通过 style 只能获得内联定义或通过 JavaScript 直接设置的样式。通过 CSS class 设置的元素样式无法直接通过 style 获取。 4.2.3 样式设置[建议] 尽可能通过为元素添加预定义的 className 来改变元素样式，避免直接操作 style 设置。[强制] 通过 style 对象设置元素样式时，对于带单位非 0 值的属性，不允许省略单位。解释： 除了 IE，标准浏览器会忽略不规范的属性值，导致兼容性问题。 4.2.4 DOM 操作[建议] 操作 DOM 时，尽量减少页面 reflow。解释： 页面 reflow 是非常耗时的行为，非常容易导致性能瓶颈。下面一些场景会触发浏览器的reflow： DOM元素的添加、修改（内容）、删除。 应用新的样式或者修改任何影响元素布局的属性。 Resize浏览器窗口、滚动页面。 读取元素的某些属性（offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE)) 。 [建议] 尽量减少 DOM 操作。解释： DOM 操作也是非常耗时的一种操作，减少 DOM 操作有助于提高性能。举一个简单的例子，构建一个列表。我们可以用两种方式： 在循环体中 createElement 并 append 到父元素中。 在循环体中拼接 HTML 字符串，循环结束后写父元素的 innerHTML。 第一种方法看起来比较标准，但是每次循环都会对 DOM 进行操作，性能极低。在这里推荐使用第二种方法。 4.2.5 DOM 事件[建议] 优先使用 addEventListener / attachEvent 绑定事件，避免直接在 HTML 属性中或 DOM 的 expando 属性绑定事件处理。解释： expando 属性绑定事件容易导致互相覆盖。 [建议] 使用 addEventListener 时第三个参数使用 false。解释： 标准浏览器中的 addEventListener 可以通过第三个参数指定两种时间触发模型：冒泡和捕获。而 IE 的 attachEvent 仅支持冒泡的事件触发。所以为了保持一致性，通常 addEventListener 的第三个参数都为 false。 [建议] 在没有事件自动管理的框架支持下，应持有监听器函数的引用，在适当时候（元素释放、页面卸载等）移除添加的监听器。","link":"/2019/11/22/JavaScript%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"title":"Next.js手册","text":"如果您对Next.js的知识从零到零，或者您过去曾经使用过React，并且希望进一步深入到React生态系统，尤其是服务器端渲染，这对您来说是理想的。 我发现Next.js是创建Web应用程序的绝佳工具，并且在本文结尾，我希望您能像我一样对它感到兴奋。我希望它能帮助您学习Next.js！ 注意：您可以下载本教程的PDF / ePub / Mobi版本，以便离线阅读！ 介绍直到您意识到与在客户端呈现所有内容有关的几个问题之前，在由React驱动的现代JavaScript应用程序上进行工作非常出色。 首先，页面需要更长的时间才能被用户看到，因为在加载内容之前，必须加载所有JavaScript，并且您的应用程序需要运行才能确定在页面上显示的内容。 其次，如果您要建立一个公开可用的网站，则存在内容SEO问题。搜索引擎在运行和索引JavaScript应用方面越来越好，但是如果我们可以向他们发送内容而不是让他们弄清楚它，那就更好了。 解决这两个问题的方法是服务器渲染，也称为静态预渲染。 Next.js是一个React框架，可以通过一种非常简单的方式完成所有这些工作，但不仅限于此。它的创建者宣传它是React应用程序的零配置单命令工具链。 它提供了一种通用的结构，使您可以轻松构建前端React应用程序，并为您透明地处理服务器端渲染。 Next.js提供的主要功能这是Next.js主要功能的详尽列表： 热门代码重装当Next.js检测到任何保存到磁盘的更改时，它将重新加载页面。 自动路由任何URL都映射到文件系统，文件pages夹中的文件，并且您不需要任何配置（当然，您有自定义选项）。 单个文件组件使用styled-jsx与同一团队完全集成的，可以轻松地将范围限定的样式添加到组件中。 服务器渲染您可以在将HTML发送给客户端之前，在服务器端渲染React组件。 生态系统兼容性Next.js在其余的JavaScript，Node和React生态系统中表现良好。 自动代码分割页面仅使用它们所需的库和JavaScript呈现。Next.js会在几种不同的资源中自动将应用程序分解，而不是生成包含所有应用程序代码的单个JavaScript文件。 加载页面仅加载该特定页面所需的JavaScript。 Next.js通过分析导入的资源来做到这一点。 例如，如果只有一个页面导入Axios库，则该特定页面将在其捆绑包中包含该库。 这样可以确保您的第一个页面加载尽可能快，并且只有将来的页面加载（如果会被触发）才会将所需的JavaScript发送给客户端。 有一个值得注意的例外。如果至少在网站页面的一半中使用了常用导入，则这些导入将移入主要的JavaScript捆绑包中。 预取该Link组件用于将不同的页面链接在一起，支持prefetch在后台自动预取页面资源（包括由于代码拆分而丢失的代码）的道具。 动态组件您可以动态导入JavaScript模块和React组件。 静态出口使用该next export命令，Next.js允许您从应用程序导出完全静态的网站。 TypeScript支持Next.js用TypeScript编写，因此具有出色的TypeScript支持。 Next.js vs盖茨比vs create-react-appNext.js，Gatsby和create-react-app它们是令人惊奇的工具，可用于增强应用程序的功能。 让我们先说说它们的共同点。他们全都拥有React在幕后，为整个开发经验提供动力。他们还抽象化了webpack以及我们过去在过去曾经手动配置的所有低级内容。 create-react-app不能帮助您轻松生成服务器端渲染的应用。它附带的所有内容（SEO，速度…）仅由Next.js和Gatsby之类的工具提供。 什么时候Next.js比Gatsby更好？ 它们都可以帮助服务器端呈现，但是有2种不同的方式。 使用Gatsby的最终结果是没有服务器的静态站点生成器。您生成站点，然后在Netlify或另一个静态托管站点上静态部署生成过程的结果。 Next.js提供了一个后端，服务器端可以呈现对请求的响应，从而允许您创建动态网站，这意味着您将其部署在可以运行Node.js的平台上。 Next.js _也可以_生成一个静态站点，但是我不会说这是其主要用例。 如果我的目标是建立一个静态站点，那么我将很难选择，也许盖茨比拥有一个更好的插件生态系统，其中包括许多特别用于博客的插件。 Gatsby很大程度上也基于GraphQL，根据您的意见和需求，您可能会真正喜欢或不喜欢它。 如何安装Next.js？要安装Next.js，您需要安装Node.js。 确保您具有最新版本的Node。检查node -v终端中的运行情况，并将其与https://nodejs.org/上列出的最新LTS版本进行比较。 安装Node.js之后，您将在npm命令行中使用该命令。 如果您在此阶段遇到任何麻烦，建议您为我编写以下教程： 如何安装Node.js 如何更新Node.js npm软件包管理器简介 Unix Shell教程 如何使用macOS终端 重击壳 现在，您已经拥有Node，已更新为最新版本，并且npm已经设置好了！ 我们现在可以选择2条路线：使用create-next-app或经典方法，其中涉及手动安装和设置Next应用。 使用create-next-app如果您熟悉create-react-app，create-next-app则是一样的-顾名思义，它创建的是Next应用而不是React应用。 我假设您已经安装了Node.js，该版本从5.2版（撰写本文时已经2年多）开始捆绑了npx命令。这个方便的工具使我们能够下载并执行JavaScript命令，并且我们将像这样使用它： 1npx create-next-app 该命令要求应用程序名称（以及你使用该名称创建一个新的文件夹），然后下载它需要的所有包（react，react-dom，next），设置package.json到： 您可以通过运行npm run dev以下命令立即运行示例应用程序： 这是http：// localhost：3000上的结果： 这是启动Next.js应用程序的推荐方法，因为它为您提供了结构和示例代码。除了默认的示例应用程序之外，还有更多其他功能。您可以使用选项使用存储在https://github.com/zeit/next.js/tree/canary/examples中的任何示例--example。例如，尝试： 1npx create-next-app --example blog-starter 这也为您提供了一个立即可用的博客实例，并且语法突出显示了： 手动创建Next.js应用create-next-app如果您想从头开始创建Next应用程序，则可以避免。方法如下：在您喜欢的任何位置（例如在主文件夹中）创建一个空文件夹，然后进入该文件夹： 12mkdir nextjscd nextjs 并创建您的第一个Next项目目录： 12mkdir firstprojectcd firstproject 现在使用npm命令将其初始化为Node项目： 1npm init -y 该-y选项告诉npm您使用项目的默认设置，并填充示例package.json文件。 现在安装Next和React： 1npm install next react react-dom 您的项目文件夹现在应具有2个文件： package.json（参见我的教程） package-lock.json（请参阅我关于package-lock的教程） 和node_modules文件夹。 使用您喜欢的编辑器打开项目文件夹。我最喜欢的编辑器是VS Code。如果您有安装，可以运行code .在终端打开编辑器中的当前文件夹（如果该命令不为你工作，看到这个） Open package.json，现在具有以下内容： 1234567891011121314151617{ &quot;name&quot;: &quot;firstproject&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: { &quot;next&quot;: &quot;^9.1.2&quot;, &quot;react&quot;: &quot;^16.11.0&quot;, &quot;react-dom&quot;: &quot;^16.11.0&quot; }} 并将该scripts部分替换为： 12345&quot;scripts&quot;: { &quot;dev&quot;: &quot;next&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;start&quot;: &quot;next start&quot;} 添加Next.js构建命令，我们将很快使用它。 提示：用于&quot;dev&quot;: &quot;next -p 3001&quot;,更改端口并在此示例中在端口3001上运行。 现在创建一个pages文件夹，并添加一个index.js文件。 在这个文件中，让我们创建第一个React组件。 我们将使用它作为默认导出： 1234567const Index = () =&gt; ( &lt;div&gt; &lt;h1&gt;Home page&lt;/h1&gt; &lt;/div&gt;)export default Index 现在使用终端，运行npm run dev以启动Next开发服务器。 这将使该应用程序在本地主机上的端口3000上可用。 在浏览器中打开http：// localhost：3000进行查看。 查看源代码以确认SSR是否正常运行现在，让我们检查应用程序是否正常运行。这是一个Next.js应用程序，因此应该在服务器端呈现。 这是Next.js的主要卖点之一：如果我们使用Next.js创建一个网站，则该网站页面将呈现在服务器上，该服务器会将HTML传递给浏览器。 这具有3个主要优点： 客户端不需要实例化React来渲染，这使网站对您的用户更快。 搜索引擎将为页面编制索引，而无需运行客户端JavaScript。Google开始做的事情，但公开承认这是一个较慢的过程（如果您想获得良好的排名，则应该尽可能地帮助Google）。 您可以拥有社交媒体元标记，可用于添加预览图像，自定义在Facebook，Twitter等上共享的任何页面的标题和描述。 让我们查看应用程序的源代码。使用Chrome浏览器，您可以右键单击页面中的任意位置，然后按查看页面源。 如果您查看页面的源代码，您将&lt;div&gt;&lt;h1&gt;Home page&lt;/h1&gt;&lt;/div&gt;在HTML中看到该代码段body以及一堆JavaScript文件-该应用程序捆绑包。 我们不需要进行任何设置，SSR（服务器端渲染）已经在为我们工作。 React应用程序将在客户端上启动，并且将成为使用客户端渲染推动交互（例如单击链接）的一种方式。但是重新加载页面会从服务器重新加载页面。使用Next.js，浏览器内部的结果应该没有差异-服务器呈现的页面应该看起来完全像客户端呈现的页面。 该应用程序捆绑当查看页面源代码时，我们看到一堆JavaScript文件正在加载： 让我们开始将代码放入HTML格式化程序中，以使其格式更好，以便我们人类可以更好地了解它： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charSet=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,m_inimum-scale=1,initial-scale=1&quot; /&gt; &lt;meta name=&quot;next-head-count&quot; content=&quot;2&quot; /&gt; &lt;link rel=&quot;preload&quot; href=&quot;/_next/static/development/pages/index.js?ts=1572863116051&quot; as=&quot;script&quot; /&gt; &lt;link rel=&quot;preload&quot; href=&quot;/_next/static/development/pages/_app.js?ts=1572863116051&quot; as=&quot;script&quot; /&gt; &lt;link rel=&quot;preload&quot; href=&quot;/_next/static/runtime/webpack.js?ts=1572863116051&quot; as=&quot;script&quot; /&gt; &lt;link rel=&quot;preload&quot; href=&quot;/_next/static/runtime/main.js?ts=1572863116051&quot; as=&quot;script&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;__next&quot;&gt; &lt;div&gt; &lt;h1&gt;Home page&lt;/h1&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;/_next/static/development/dll/dll_01ec57fc9b90d43b98a8.js?ts=1572863116051&quot;&gt;&lt;/script&gt; &lt;script id=&quot;__NEXT_DATA__&quot; type=&quot;application/json&quot;&gt;{&quot;dataManager&quot;:&quot;[]&quot;,&quot;props&quot;:{&quot;pageProps&quot;:{}},&quot;page&quot;:&quot;/&quot;,&quot;query&quot;:{},&quot;buildId&quot;:&quot;development&quot;,&quot;nextExport&quot;:true,&quot;autoExport&quot;:true}&lt;/script&gt; &lt;script async=&quot;&quot; data-next-page=&quot;/&quot; src=&quot;/_next/static/development/pages/index.js?ts=1572863116051&quot;&gt;&lt;/script&gt; &lt;script async=&quot;&quot; data-next-page=&quot;/_app&quot; src=&quot;/_next/static/development/pages/_app.js?ts=1572863116051&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/_next/static/runtime/webpack.js?ts=1572863116051&quot; async=&quot;&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/_next/static/runtime/main.js?ts=1572863116051&quot; async=&quot;&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我们有4个JavaScript文件被声明为预加载到中head，使用rel=&quot;preload&quot; as=&quot;script&quot;： /_next/static/development/pages/index.js （96个本地代码） /_next/static/development/pages/_app.js （5900 LOC） /_next/static/runtime/webpack.js （LOC 939） /_next/static/runtime/main.js （LOC为12k） 这告诉浏览器在正常渲染流程开始之前尽快开始加载这些文件。没有这些脚本，脚本将被额外加载，这将提高页面加载性能。 然后，将这4个文件body与/_next/static/development/dll/dll_01ec57fc9b90d43b98a8.js（31k LOC）和一个JSON代码段一起加载到的末尾，该JSON代码段为页面数据设置了一些默认值： 12345678910111213&lt;script id=&quot;__NEXT_DATA__&quot; type=&quot;application/json&quot;&gt;{ &quot;dataManager&quot;: &quot;[]&quot;, &quot;props&quot;: { &quot;pageProps&quot;: {} }, &quot;page&quot;: &quot;/&quot;, &quot;query&quot;: {}, &quot;buildId&quot;: &quot;development&quot;, &quot;nextExport&quot;: true, &quot;autoExport&quot;: true}&lt;/script&gt; 加载的4个捆绑包文件已经实现了一项称为代码拆分的功能。该index.js文件提供了为路线index提供服务的组件所需的代码/，如果我们有更多的页面，我们将为每个页面提供更多的包，然后仅在需要时才进行加载-为页面提供更高性能的加载时间。 右下角的图标是什么？您是否在页面右下方看到了一个小图标，看起来像闪电？ 如果将其悬停，它将显示“ Prerendered Page”： 该图标（_仅在开发模式下才可见）_告诉您该页面符合自动静态优化的条件，这基本上意味着该页面不依赖于在调用时需要获取的数据，并且可以按以下方式进行预渲染和构建：在构建时（当我们运行时npm run build）的静态HTML文件。 接下来可以通过缺少getInitialProps()附加到页面组件的方法来确定这一点。 在这种情况下，我们的页面甚至可以更快，因为它将作为HTML文件静态提供，而不是通过生成HTML输出的Node.js服务器提供。 可能会出现在它旁边的另一个有用图标，或者代替它在未呈现页面上显示的是一个动画三角形： 这是一个编译指示符，当您保存页面并且Next.js正在编译应用程序之前，此提示会在热代码重新加载开始之前自动显示在应用程序中。 这是一种非常好的方法，可以立即确定应用程序是否已经编译，您可以测试正在处理的应用程序的一部分。 安装React Developer ToolsNext.js基于React，所以我们绝对需要安装（如果您尚未安装）一个非常有用的工具是React Developer Tools。 React Developer Tools是可用于Chrome和Firefox的基本工具，可用于检查React应用程序。 现在，React开发人员工具并不特定于Next.js，但是我想介绍它们，因为您可能不是100％熟悉React提供的所有工具。最好花一点时间来调试工具，而不要假设您已经了解它们。 他们提供了一个检查器，该检查器揭示了构建页面的React组件树，对于每个组件，您都可以检查道具，状态，钩子等等。 一旦安装了React Developer Tools，就可以打开常规的浏览器devtools（在Chrome中，右键单击页面，然后单击Inspect），您会发现2个新面板：Components和Profiler。 如果将鼠标移到组件上，则会在页面中看到，浏览器将选择该组件渲染的部分。 如果您在树中选择任何组件，则右侧面板将显示对父组件的引用以及传递给它的道具： 您可以通过单击组件名称来轻松导航。 您可以单击“开发人员工具”工具栏中的眼睛图标来检查DOM元素，如果您使用的是第一个图标（带有鼠标图标（通常位于类似的常规DevTools图标下）），则可以将元素悬停在浏览器用户界面以直接选择呈现它的React组件。 您可以使用该bug图标将组件数据记录到控制台。 这非常棒，因为一旦在其中打印了数据，就可以右键单击任何元素，然后按“存储为全局变量”。例如，在这里，我使用urlprop进行操作，并且可以使用分配给它的临时变量在控制台中对其进行检查temp1： 使用由Next.js在开发模式下自动加载的Source Maps，从Components面板中单击&lt;&gt;代码，然后DevTools将切换到Source面板，向我们显示组件源代码： 如果可能的话，“ 探查器”选项卡更加出色。它使我们能够在应用程序中记录交互，并观察发生了什么。我无法显示一个示例，因为它至少需要2个组件才能创建交互，而现在只有一个。稍后再说。 我使用Chrome显示了所有屏幕截图，但是React Developer Tools在Firefox中的工作方式相同： 您可以使用的其他调试技术除了对构建Next.js应用程序必不可少的React Developer Tools之外，我还要强调两种调试Next.js应用程序的方法。 首先显然是console.log()所有其他控制台API工具。Next应用程序的工作方式将使日志语句在浏览器控制台中或在您使用Next启动Next的终端中运行npm run dev。 特别是，如果页面是从服务器加载的，则将URL指向服务器时，或者单击刷新按钮/ cmd / ctrl-R，则任何控制台日志记录都会在终端中发生。 通过单击鼠标进行的后续页面转换将使所有控制台记录都发生在浏览器内部。 请记住，如果您对丢失日志感到惊讶。 另一个必不可少的工具就是debugger声明。将此语句添加到组件将使浏览器暂停呈现页面： 真棒，因为现在您可以使用浏览器调试器检查值并一次一行运行您的应用程序。 您还可以使用VS Code调试器来调试服务器端代码。我提到了这项技术和本教程来进行设置。 在网站上添加第二页现在我们已经掌握了可用于帮助开发Next.js应用程序的工具，让我们从剩下的第一个应用程序继续： 我想在此网站上添加第二页，即博客。它会送入/blog，并且暂时将只包含一个简单的静态页面，就像我们的第一个index.js组件一样： 保存新文件后，npm run dev已经运行的进程已经能够呈现页面，而无需重新启动它。 当我们点击URL http：// localhost：3000 / blog时，我们将打开新页面： 这是终端告诉我们的内容： 现在，URL仅/blog取决于文件名及其在pages文件夹下的位置。 您可以创建一个pages/hey/ho页面，该页面将显示在URL http：// localhost：3000 / hey / ho上。 对于URL而言，无所谓的是文件内的组件名称。 尝试浏览页面的源代码，当从服务器加载页面时，它将/_next/static/development/pages/blog.js作为加载的包之一列出，而/_next/static/development/pages/index.js不像主页中那样。这是因为通过自动代码拆分，我们不需要提供主页的捆绑包。只是用于博客页面的捆绑软件。 我们也可以只从导出一个匿名函数blog.js： 12345export default () =&gt; ( &lt;div&gt; &lt;h1&gt;Blog&lt;/h1&gt; &lt;/div&gt;) 或者，如果您更喜欢非箭头函数语法： 1234567export default function() { return ( &lt;div&gt; &lt;h1&gt;Blog&lt;/h1&gt; &lt;/div&gt; )} 链接两个页面现在我们有2个页面，分别由index.js和定义blog.js，我们可以介绍链接。 页面内的普通HTML链接是使用a标记完成的： 1&lt;a href=&quot;/blog&quot;&gt;Blog&lt;/a&gt; 我们无法在Next.js中做到这一点。 为什么？我们在技术上_可以_，当然，因为这是Web和_在网络上的事情从来没有突破_（这就是为什么我们仍然可以使用&lt;marquee&gt;标签，但使用接下来的主要好处之一是，一旦页面加载，转换到其他页面借助客户端渲染，速度非常快。 如果使用普通a链接： 12345678const Index = () =&gt; ( &lt;div&gt; &lt;h1&gt;Home page&lt;/h1&gt; &lt;a href='/blog'&gt;Blog&lt;/a&gt; &lt;/div&gt;)export default Index 现在打开DevTools，尤其是“ 网络”面板。第一次加载时，http://localhost:3000/我们会加载所有页面包： 现在，如果您单击“保留日志”按钮（以避免清除“网络”面板），然后单击“博客”链接，将发生以下情况： 我们再次从服务器获得了所有JavaScript！但是..如果我们已经有了JavaScript，就不需要所有的JavaScript。我们只需要blog.js页面捆绑包，这是页面上唯一的新捆绑包。 要解决此问题，我们使用Next提供的名为Link的组件。 我们导入它： 1import Link from 'next/link' 然后我们用它来包装我们的链接，像这样： 123456789101112import Link from 'next/link'const Index = () =&gt; ( &lt;div&gt; &lt;h1&gt;Home page&lt;/h1&gt; &lt;Link href='/blog'&gt; &lt;a&gt;Blog&lt;/a&gt; &lt;/Link&gt; &lt;/div&gt;)export default Index 现在，如果您重试我们以前做过的事情，blog.js当我们移至博客页面时，您将能够看到仅加载了捆绑软件： 而且页面加载的速度比以前快，该标签上的浏览器常规微调框甚至都没有出现。如您所见，URL发生了变化。这与浏览器的History API无缝配合。 这是实际的客户端渲染。 如果现在按下返回按钮怎么办？什么都没有加载，因为浏览器仍然具有旧的index.js捆绑软件，可以加载/index路由。都是自动的！ 路由器的动态内容在上一章中，我们看到了如何将主页链接到博客页面。 博客是Next.js的一个很好的用例，我们将在本章中通过添加博客文章继续进行探讨。 博客文章具有动态URL。例如，标题为“ Hello World”的帖子可能具有URL /blog/hello-world。标题为“我的第二条帖子”的帖子可能具有URL /blog/my-second-post。 此内容是动态的，可以从数据库，降价文件或更多内容中获取。 Next.js可以基于动态URL提供动态内容。 我们通过使用[]语法创建动态页面来创建动态URL 。 怎么样？我们添加一个pages/blog/[id].js文件。该文件将处理下的所有动态URL /blog/路径，就像那些我们上面提到的：/blog/hello-world，/blog/my-second-post等等。 在文件名中，[id]内部的任何的动态将在内部把方括号方式id的参数查询属性的的路由器。 好的，一次太多了。 什么是路由器？ 路由器是Next.js提供的库。 我们从导入next/router： 1import { useRouter } from 'next/router' 一旦有了useRouter，我们将使用以下方法实例化路由器对象： 1const router = useRouter() 一旦有了该路由器对象，就可以从中提取信息。 具体来说，我们可以[id].js通过访问来获取文件中URL的动态部分router.query.id。 动态部分也可以只是URL的一部分，例如post-[id].js。 因此，让我们继续将所有这些内容应用到实践中。 创建文件pages/blog/[id].js： 123456789101112import { useRouter } from 'next/router'export default () =&gt; { const router = useRouter() return ( &lt;&gt; &lt;h1&gt;Blog post&lt;/h1&gt; &lt;p&gt;Post id: {router.query.id}&lt;/p&gt; &lt;/&gt; )} 现在，如果您转到http://localhost:3000/blog/test路由器，应该会看到以下内容： 我们可以使用此id参数从帖子列表中收集帖子。例如，来自数据库。为了简单起见，我们将posts.json在项目根文件夹中添加一个文件： 12345678910{ &quot;test&quot;: { &quot;title&quot;: &quot;test post&quot;, &quot;content&quot;: &quot;Hey some post content&quot; }, &quot;second&quot;: { &quot;title&quot;: &quot;second post&quot;, &quot;content&quot;: &quot;Hey this is the second post content&quot; }} 现在我们可以导入它并从id键中查找帖子： 123456789101112131415import { useRouter } from 'next/router'import posts from '../../posts.json'export default () =&gt; { const router = useRouter() const post = posts[router.query.id] return ( &lt;&gt; &lt;h1&gt;{post.title}&lt;/h1&gt; &lt;p&gt;{post.content}&lt;/p&gt; &lt;/&gt; )} 重新加载页面应向我们显示以下结果： 但这不是！相反，我们在控制台中出现错误，在浏览器中也出现错误： 为什么？因为在渲染过程中初始化组件时，数据还不存在。在下一课中，我们将了解如何使用getInitialProps将数据提供给组件。 现在，if (!post) return &lt;p&gt;&lt;/p&gt;在返回JSX之前添加一点检查： 12345678910111213141516import { useRouter } from 'next/router'import posts from '../../posts.json'export default () =&gt; { const router = useRouter() const post = posts[router.query.id] if (!post) return &lt;p&gt;&lt;/p&gt; return ( &lt;&gt; &lt;h1&gt;{post.title}&lt;/h1&gt; &lt;p&gt;{post.content}&lt;/p&gt; &lt;/&gt; )} 现在一切正常。最初，在没有动态router.query.id信息的情况下渲染组件。呈现后，Next.js会使用查询值触发更新，并且页面显示正确的信息。 而且，如果您查看源&lt;p&gt;代码，则HTML中有一个空标记： 我们将尽快解决无法实施SSR的问题，这将损害我们的用户，SEO和社交共享的加载时间，正如我们已经讨论的那样。 我们可以通过列出以下帖子中的内容来完善博客示例pages/blog.js： 123456789101112131415import posts from '../posts.json'const Blog = () =&gt; ( &lt;div&gt; &lt;h1&gt;Blog&lt;/h1&gt; &lt;ul&gt; {Object.entries(posts).map((value, index) =&gt; { return &lt;li key={index}&gt;{value[1].title}&lt;/li&gt; })} &lt;/ul&gt; &lt;/div&gt;)export default Blog 我们可以将它们链接到个人页面后，通过导入Link从next/link使用它的职位循环内： 12345678910111213141516171819202122import Link from 'next/link'import posts from '../posts.json'const Blog = () =&gt; ( &lt;div&gt; &lt;h1&gt;Blog&lt;/h1&gt; &lt;ul&gt; {Object.entries(posts).map((value, index) =&gt; { return ( &lt;li key={index}&gt; &lt;Link href='/blog/[id]' as={'/blog/' + value[0]}&gt; &lt;a&gt;{value[1].title}&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt; ) })} &lt;/ul&gt; &lt;/div&gt;)export default Blog 预取前面我曾提到过如何使用LinkNext.js组件在两个页面之间创建链接，当您使用它时，Next.js 透明地为我们处理前端路由，因此当用户单击链接时，前端会负责显示新页面。网页，而不会触发新的客户端/服务器请求和响应周期，这通常在网页中会发生。 使用时，Next.js还会为您做另一件事Link。 只要包含在&lt;Link&gt;其中的元素出现在视口中（这意味着它对网站用户可见），只要它是本地链接（在您的网站上），Next.js就会预取它指向的URL，从而使应用程序变得超快给观看者。 此行为仅在生产模式下触发（我们将在稍后进行深入讨论），这意味着如果使用来运行该应用程序，则必须停止该应用程序npm run dev，使用来编译生产捆绑包，npm run build然后使用npm run start来运行它 。 使用DevTools中的网络检查器，您会注意到页面加载时折叠上方的所有链接在页面load上触发事件后立即开始预提取（在页面完全加载时触发，并在DOMContentLoaded事件发生后触发））。 Link用户滚动并滚动时，将预取视口中没有的其他任何标签 高速连接（Wifi和3g +连接）上的自动预取是自动的，除非浏览器发送Save-DataHTTP Header。 您可以Link通过将prefetchprop 设置为来退出预取单个实例false： 123&lt;Link href=&quot;/a-link&quot; prefetch={false}&gt; &lt;a&gt;A link&lt;/a&gt;&lt;/Link&gt; 使用路由器检测活动链接使用链接时，一个非常重要的功能是确定当前URL，尤其是为活动链接分配一个类，因此我们可以将其样式设置为与其他URL不同。 例如，这在您的网站标题中特别有用。 提供的Next.js默认Link组件next/link不会自动为我们执行此操作。 我们可以自己创建一个Link组件，然后将其存储Link.js在Components文件夹中的文件中，然后导入它而不是default next/link。 在此组件中，我们将首先导入React from react，Link from next/link和useRouter钩子from next/router。 在组件内部，我们确定当前路径名是否与href组件的prop 相匹配，如果是，则将selected类附加到子级。 我们最终使用以下方法通过更新后的类返回此子级React.cloneElement()： 1234567891011121314import React from 'react'import Link from 'next/link'import { useRouter } from 'next/router'export default ({ href, children }) =&gt; { const router = useRouter() let className = children.props.className || '' if (router.pathname === href) { className = `${className} selected` } return &lt;Link href={href}&gt;{React.cloneElement(children, { className })}&lt;/Link&gt;} 使用 next/router我们已经了解了如何使用Link组件在Next.js应用程序中声明性地处理路由。 在JSX中管理路由确实非常方便，但是有时您需要以编程方式触发路由更改。 在这种情况下，您可以直接访问next/router软件包中提供的Next.js路由器，并调用其push()方法。 这是访问路由器的示例： 123456import { useRouter } from 'next/router'export default () =&gt; { const router = useRouter() //...} 一旦通过调用获得了路由器对象useRouter()，就可以使用其方法。 这是客户端路由器，因此方法仅应在面向前端的代码中使用。确保这一点的最简单方法是将调用包装在useEffect()React钩子中，或包装componentDidMount()在React有状态组件中。 您可能最常使用的是push()和prefetch()。 push() 允许我们在前端以编程方式触发URL更改： 1router.push('/login') prefetch()允许我们以编程方式预取URL，当我们没有Link自动为我们处理预取代码的标记时，此功能非常有用： 1router.prefetch('/login') 完整示例： 123456789import { useRouter } from 'next/router'export default () =&gt; { const router = useRouter() useEffect(() =&gt; { router.prefetch('/login') })} 您也可以使用路由器侦听路由更改事件。 使用getInitialProps将数据馈送到组件在上一章中，动态生成帖子页面存在一个问题，因为该组件需要预先提供一些数据，并且当我们尝试从JSON文件获取数据时： 123456789101112131415import { useRouter } from 'next/router'import posts from '../../posts.json'export default () =&gt; { const router = useRouter() const post = posts[router.query.id] return ( &lt;&gt; &lt;h1&gt;{post.title}&lt;/h1&gt; &lt;p&gt;{post.content}&lt;/p&gt; &lt;/&gt; )} 我们收到此错误： 我们该如何解决？以及如何使SSR用于动态路由？ 我们必须使用一个getInitialProps()附加到组件的特殊功能为组件提供道具。 为此，首先我们将组件命名为： 12345const Post = () =&gt; { //...}export default Post 然后我们添加功能： 123456789const Post = () =&gt; { //...}Post.getInitialProps = () =&gt; { //...}export default Post 此函数将一个对象作为其参数，其中包含多个属性。特别是，我们现在感兴趣的是获取query对象，这是我们之前用于获取帖子ID的对象。 因此，我们可以使用_对象分解_语法来获取它： 123Post.getInitialProps = ({ query }) =&gt; { //...} 现在我们可以从该函数返回帖子： 12345Post.getInitialProps = ({ query }) =&gt; { return { post: posts[query.id] }} 我们还可以删除的导入useRouter，然后从props传递给Post组件的属性中获取发布： 123456789101112131415161718import posts from '../../posts.json'const Post = props =&gt; { return ( &lt;div&gt; &lt;h1&gt;{props.post.title}&lt;/h1&gt; &lt;p&gt;{props.post.content}&lt;/p&gt; &lt;/div&gt; )}Post.getInitialProps = ({ query }) =&gt; { return { post: posts[query.id] }}export default Post 现在将没有错误，并且SSR将按预期工作，如您所见，查看视图源： getInitialProps当我们Link像以前一样使用组件导航到新页面时，该功能将在服务器端和客户端执行。 重要的是要注意，getInitialProps除了query对象之外，它还接收其他上下文属性： pathname：pathURL部分 asPath -实际路径（包括查询）的字符串显示在浏览器中 在调用的情况下http://localhost:3000/blog/test将分别导致： /blog/[id] /blog/test 对于服务器端渲染，它还将收到： req：HTTP请求对象 res：HTTP响应对象 err：错误对象 req``res如果您已完成任何Node.js编码，将会很熟悉。 的CSS我们如何在Next.js中设置React组件的样式？ 我们有很多自由，因为我们可以使用我们喜欢的任何库。 但是Next.js是styled-jsx内置的，因为那是由从事Next.js的同一个人构建的库。 这是一个非常酷的库，为我们提供了范围内的CSS，这对于可维护性非常有用，因为CSS仅会影响所应用的组件。 我认为这是编写CSS的好方法，无需应用其他会增加复杂性的库或预处理器。 要将CSS添加到Next.js中的React组件中，我们将其插入JSX的一个片段中，该片段以 1&lt;style jsx&gt;{` 并以 1`}&lt;/style&gt; 在这个怪异的块中，我们编写普通的CSS，就像在.css文件中一样： 12345&lt;style jsx&gt;{` h1 { font-size: 3rem; }`}&lt;/style&gt; 您可以在JSX内编写它，如下所示： 12345678910111213const Index = () =&gt; ( &lt;div&gt; &lt;h1&gt;Home page&lt;/h1&gt; &lt;style jsx&gt;{` h1 { font-size: 3rem; } `}&lt;/style&gt; &lt;/div&gt;)export default Index 在块内部，我们可以使用插值来动态更改值。例如，在这里我们假设一个sizeprop被父组件传递，并在styled-jsx块中使用它： 1234567891011const Index = props =&gt; ( &lt;div&gt; &lt;h1&gt;Home page&lt;/h1&gt; &lt;style jsx&gt;{` h1 { font-size: ${props.size}rem; } `}&lt;/style&gt; &lt;/div&gt;) 如果要全局应用某些CSS，而不是将其范围限制在组件上，则将global关键字添加到style标签中： 12345&lt;style jsx global&gt;{`body { margin: 0;}`}&lt;/style&gt; 如果要在Next.js组件中导入外部CSS文件，则必须先安装@zeit/next-css： 1npm install @zeit/next-css 然后在项目的根目录中创建一个名为的配置文件，next.config.js内容如下： 12const withCSS = require('@zeit/next-css')module.exports = withCSS() 重新启动Next应用程序后，您现在可以像通常使用JavaScript库或组件一样导入CSS： 1import '../style.css' 您也可以直接使用@zeit/next-sass库导入SASS文件。 用自定义标签填充head标签您可以从任何Next.js页面组件向页面标题添加信息。 在以下情况下方便使用： 您要自定义页面标题 您想更改一个元标记 你该怎么做？ 您可以在每个组件内部导入Head组件，next/head并将其包含在组件JSX输出中： 123456789101112import Head from 'next/head'const House = props =&gt; ( &lt;div&gt; &lt;Head&gt; &lt;title&gt;The page title&lt;/title&gt; &lt;/Head&gt; {/* the rest of the JSX */} &lt;/div&gt;)export default House 您可以添加任何想要显示在&lt;head&gt;页面部分的HTML标记。 安装组件时，Next.js将确保将内部标签Head添加到页面标题。与卸载组件相同，Next.js将负责删除这些标记。 添加包装器组件您网站上的所有页面看起来大致相同。有一个chrome窗口，一个公共基础层，您只想更改其中的内容。 有一个导航栏，一个边栏，然后是实际内容。 您如何在Next.js中构建这样的系统？ 有两种方法。一种是通过创建组件来使用高阶组件components/Layout.js： 123456789101112export default Page =&gt; { return () =&gt; ( &lt;div&gt; &lt;nav&gt; &lt;ul&gt;....&lt;/ul&gt; &lt;/hav&gt; &lt;main&gt; &lt;Page /&gt; &lt;/main&gt; &lt;/div&gt; )} 在这里，我们可以为标题和/或边栏导入单独的组件，还可以添加所需的所有CSS。 您可以在每个页面中使用它，如下所示： 12345import withLayout from '../components/Layout.js'const Page = () =&gt; &lt;p&gt;Here's a page!&lt;/p&gt;export default withLayout(Page) 但是我发现这仅适用于不需要调用getInitialProps()页面的简单情况。 为什么？ 因为getInitialProps()仅在页面组件上被调用。但是，如果我们从页面导出withLayout（）的高阶组件，Page.getInitialProps()则不会被调用。withLayout.getInitialProps()将。 为了避免不必要地使我们的代码库复杂化，替代方法是使用props： 12345678910export default props =&gt; ( &lt;div&gt; &lt;nav&gt; &lt;ul&gt;....&lt;/ul&gt; &lt;/hav&gt; &lt;main&gt; {props.content} &lt;/main&gt; &lt;/div&gt;) 现在在我们的页面中，我们可以这样使用它： 1234567import Layout from '../components/Layout.js'const Page = () =&gt; ( &lt;Layout content={( &lt;p&gt;Here's a page!&lt;/p&gt; )} /&gt;) 这种方法使我们可以getInitialProps()在页面组件内使用，而唯一的缺点是必须在contentprop 内部编写组件JSX ： 1234567891011import Layout from '../components/Layout.js'const Page = () =&gt; ( &lt;Layout content={( &lt;p&gt;Here's a page!&lt;/p&gt; )} /&gt;)Page.getInitialProps = ({ query }) =&gt; { //...} API路由除了创建页面路由（这意味着将页面作为网页提供给浏览器）之外，Next.js还可创建API路由。 这是一个非常有趣的功能，因为这意味着Next.js可用于为Next.js本身存储和检索的数据创建前端，并通过提取请求传输JSON。 API路由位于该/pages/api/文件夹下，并映射到/api端点。 创建应用程序时，此功能_非常_有用。 在这些路由中，我们编写了Node.js代码（而不是React代码）。这是一个范式转换，您可以从前端移动到后端，但是非常无缝。 假设您有一个/pages/api/comments.js文件，其目标是以JSON格式返回博客文章的评论。 假设您有一个存储在comments.json文件中的注释列表： 12345678[ { &quot;comment&quot;: &quot;First&quot; }, { &quot;comment&quot;: &quot;Nice post&quot; }] 这是一个示例代码，它将注释列表返回给客户端： 12345import comments from './comments.json'export default (req, res) =&gt; { res.status(200).json(comments)} 它将在/api/commentsURL 上侦听GET请求，您可以尝试使用浏览器调用它： API路由也可以像页面一样使用动态路由，使用[]语法来创建动态API路由，例如/pages/api/comments/[id].js它将检索特定于帖子ID的注释。 在内部，[id].js您可以id通过在req.query对象内部查找来获取值： 12345import comments from '../comments.json'export default (req, res) =&gt; { res.status(200).json({ post: req.query.id, comments })} 在这里您可以看到上面的代码正在运行： 在动态网页，你需要导入useRouter从next/router，然后利用获取路由器对象const router = useRouter()，然后我们就可以得到id利用价值router.query.id。 在服务器端，这很容易，因为查询已附加到请求对象上。 如果您执行POST请求，则所有请求均以相同的方式工作-所有操作均通过该默认导出进行。 要将POST与GET和其他HTTP方法（PUT，DELETE）分开，请查找req.method值： 12345678910111213export default (req, res) =&gt; { switch (req.method) { case 'GET': //... break case 'POST': //... break default: res.status(405).end() //Method Not Allowed break }} 除了req.query和req.method我们已经看到，我们已经通过引用访问饼干req.cookies，在请求主体req.body。 在幕后，这些全部由Micro提供支持，Micro是一个支持异步HTTP微服务的库，该库由构建Next.js的同一团队制作。 您可以在我们的API路由中使用任何Micro中间件来添加更多功能。 仅在服务器端或客户端运行代码在页面组件中，通过检查window属性，您只能在服务器端或客户端执行代码。 此属性仅存在于浏览器内部，因此您可以检查 123if (typeof window === 'undefined') {} 并在该块中添加服务器端代码。 同样，您只能通过检查执行客户端代码 123if (typeof window !== 'undefined') {} JS技巧：我们在typeof这里使用运算符是因为我们无法通过其他方式检测到未定义的值。我们不能这样做，if (window === undefined)因为会出现“未定义窗口”运行时错误 Next.js作为构建时的优化，也从捆绑软件中删除了使用这些检查的代码。客户端捆绑包将不包含包装在if (typeof window === 'undefined') {}块中的内容。 部署生产版本部署应用程序始终是教程中的最后内容。 在这里，我想尽早介绍它，因为部署Next.js应用程序非常容易，我们现在就可以深入研究它，然后再转到其他更复杂的主题。 请记住，在“如何安装Next.js”一章中，我告诉您将这3行添加到该package.json script部分： 12345&quot;scripts&quot;: { &quot;dev&quot;: &quot;next&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;start&quot;: &quot;next start&quot;} npm run dev到目前为止，我们一直使用来调用next本地安装的命令node_modules/next/dist/bin/next。这启动了开发服务器，该服务器向我们提供了源映射和热代码重载，这是调试时的两个非常有用的功能。 build通过运行，可以调用相同的命令来构建传递标记的网站npm run build。然后，start通过运行，可以使用相同的命令通过该标志来启动生产应用npm run start。 这两个命令是我们必须调用以成功在本地部署站点的生产版本的命令。生产版本经过高度优化，并且不附带源地图和诸如热代码重载之类的其他东西，这些东西对我们的最终用户无益。 因此，让我们创建应用程序的生产部署。使用以下命令进行构建： 1npm run build 该命令的输出告诉我们某些路由（/并且/blog现在已预先/blog/[id]呈现为静态HTML，而Node.js后端将提供这些路由）。 然后，您可以运行npm run start以在本地启动生产服务器： 1npm run start 访问http：// localhost：3000将向我们展示该应用程序的生产版本。 立即部署在上一章中，我们在本地部署了Next.js应用程序。 我们如何将其部署到真实的Web服务器上，以便其他人可以访问它？ 部署Next应用程序最简单的方法之一就是通过Zeit创建的Now平台，该平台创建了开源项目Next.js。您可以使用Now来部署Node.js应用程序，静态网站等。 现在，使应用程序的部署和分发步骤变得非常，非常简单和快速，并且除了Node.js应用程序外，它们还支持部署Go，PHP，Python和其他语言。 您可以将其视为“云”，因为您并不真正知道应用程序的部署位置，但是您知道将拥有一个可以访问它的URL。 现在可以免费开始使用了免费的免费计划，该计划目前包括100GB托管，每天1000次无服务器功能调用，每月1000次构建，每月100GB带宽以及一个CDN位置。该定价页面帮助，如果你需要更多的获得成本的想法。 开始使用Now的最佳方法是使用官方的Now CLI： 1npm install -g now 命令可用后，运行 1now login 然后该应用会询问您的电子邮件。 如果尚未注册，请在继续之前在https://zeit.co/signup上创建一个帐户，然后将电子邮件添加到CLI客户端。 完成此操作后，从Next.js项目根文件夹运行 1now 并且该应用将立即部署到Now云中，并且会为您提供唯一的应用URL： 运行该now程序后，该应用程序将部署到now.sh域下的随机URL 。 我们在图像中给出的输出中可以看到3个不同的URL： https://firstproject-2pv7khwwr.now.sh https://firstproject-sepia-ten.now.sh https://firstproject.flaviocopes.now.sh 为什么那么多？ 第一个是标识部署的URL。每次我们部署应用程序时，此URL都会更改。 您可以通过更改项目代码中的某些内容并now再次运行来立即进行测试： 其他2个URL不会更改。第一个是随机的，第二个是您的项目名称（默认为当前项目文件夹，然后是您的帐户名now.sh。 如果您访问该URL，您将看到该应用程序已部署到生产环境。 您可以配置“现在”以将网站提供给您自己的自定义域或子域，但是我现在不会对此进行介绍。 该now.sh子域是足以让我们的测试目的。 分析应用捆绑Next为我们提供了一种分析生成的代码束的方法。 打开应用程序的package.json文件，然后在脚本部分中添加这3个新命令： 123&quot;analyze&quot;: &quot;cross-env ANALYZE=true next build&quot;,&quot;analyze:server&quot;: &quot;cross-env BUNDLE_ANALYZE=server next build&quot;,&quot;analyze:browser&quot;: &quot;cross-env BUNDLE_ANALYZE=browser next build&quot; 像这样： 12345678910111213141516171819202122{ &quot;name&quot;: &quot;firstproject&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;dev&quot;: &quot;next&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;start&quot;: &quot;next start&quot;, &quot;analyze&quot;: &quot;cross-env ANALYZE=true next build&quot;, &quot;analyze:server&quot;: &quot;cross-env BUNDLE_ANALYZE=server next build&quot;, &quot;analyze:browser&quot;: &quot;cross-env BUNDLE_ANALYZE=browser next build&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: { &quot;next&quot;: &quot;^9.1.2&quot;, &quot;react&quot;: &quot;^16.11.0&quot;, &quot;react-dom&quot;: &quot;^16.11.0&quot; }} 然后安装这两个软件包： 1npm install --dev cross-env @next/bundle-analyzer next.config.js在项目根目录中创建一个文件，内容如下： 12345const withBundleAnalyzer = require('@next/bundle-analyzer')({ enabled: process.env.ANALYZE === 'true'})module.exports = withBundleAnalyzer({}) 现在运行命令 1npm run analyze 这应该在浏览器中打开2个页面。一种用于客户端捆绑，另一种用于服务器捆绑： 这是非常有用的。您可以检查束中占用最多空间的空间，还可以使用边栏排除束，以更轻松地可视化较小的束： 延迟加载模块能够以可视方式分析捆绑软件非常有用，因为我们可以非常轻松地优化应用程序。 假设我们需要在博客文章中加载Moment库。跑： 1npm install moment 将其包括在项目中。 现在，让我们模拟一个事实，即我们在两条不同的路线上都需要它：/blog和/blog/[id]。 我们将其导入pages/blog/[id].js： 12345678910111213import moment from 'moment'...const Post = props =&gt; { return ( &lt;div&gt; &lt;h1&gt;{props.post.title}&lt;/h1&gt; &lt;p&gt;Published on {moment().format('dddd D MMMM YYYY')}&lt;/p&gt; &lt;p&gt;{props.post.content}&lt;/p&gt; &lt;/div&gt; )} 我仅以今天的日期为例。 您可以通过运行npm run analyze以下命令在博客文章页面捆绑包中包含Moment.js ： 看到我们现在在中有一个红色条目/blog/[id]，这是我们添加Moment.js的路线！ 它从〜1kB变为350kB，相当大的一笔。这是因为Moment.js库本身为349kB。 现在，客户端捆绑包可视化向我们显示，更大的捆绑包是第一页，以前很少。其代码的99％是Moment.js。 每次加载博客文章时，我们都会将所有这些代码转移到客户端。这不理想。 一种解决方法是寻找一个较小的库，因为Moment.js并不以其轻量级而著称（尤其是开箱即用，包括所有语言环境），但为示例起见，我们必须使用它。 相反，我们可以做的是将所有Moment代码分成一个单独的捆绑包。 怎么样？而不是在组件级别导入Moment，而是在内部执行异步导入getInitialProps，然后计算要发送到组件的值。请记住，我们不能在返回的对象内返回复杂的getInitialProps()对象，因此我们要计算其中的日期： 123456789101112131415161718192021import posts from '../../posts.json'const Post = props =&gt; { return ( &lt;div&gt; &lt;h1&gt;{props.post.title}&lt;/h1&gt; &lt;p&gt;Published on {props.date}&lt;/p&gt; &lt;p&gt;{props.post.content}&lt;/p&gt; &lt;/div&gt; )}Post.getInitialProps = async ({ query }) =&gt; { const moment = (await import('moment')).default() return { date: moment.format('dddd D MMMM YYYY'), post: posts[query.id] }}export default Post 看到.default()之后的特别电话await import吗？需要在动态导入中引用默认导出（请参阅https://v8.dev/features/dynamic-import） 现在，如果npm run analyze再次运行，我们可以看到： 我们的/blog/[id]包又很小，因为Moment已移至其自己的包文件，并由浏览器单独加载。 从这往哪儿走关于Next.js，还有更多的知识。我没有谈论使用登录，无服务器，管理数据库等等来管理用户会话。 本手册的目的不是要教您所有内容，而是要逐步向您介绍Next.js的所有功能。 我建议的下一步是仔细阅读Next.js官方文档，以查找有关我没有谈论的所有功能的更多信息，并查看Next.js插件引入的所有其他功能。，其中一些非常了不起。","link":"/2019/11/29/Next-js%E6%89%8B%E5%86%8C/"},{"title":"全栈工程师面试题刷这些就够了","text":"面试准备——自我介绍 一面 / 二面 面试技巧 页面布局 题目 五种解决方式代码 展示效果 知识拓展 1、各自的优缺点 2、去掉高度，有哪几种布局可以使用？ 页面布局模块——总结 页面布局的变通 CSS盒模型 题目 基本概念 JS如何获取盒模型对应的宽和高 实例题（根据盒模型解释边距重叠） BFC（边距重叠解决方案） 垂直方向边距重叠问题 DOM 事件类 题目 基本概念：DOM事件的级别 DOM事件模型 DOM事件流 描述DOM事件捕获的具体流程 Event对象的常见应用 自定义事件 实例分析 HTTP 协议类 题目 HTTP协议的主要特点 HTTP报文的组成部分 HTTP方法 POST和GET的区别（重点前5条） HTTP状态码 什么是持久连接 什么是管线化（加分点） 原型链 题目 创建对象有几种方法 原型、构造函数、实例、原型链 instanceof的原理 new运算符 面向对象 题目 类与实例 类与继承 通信类 题目 什么是同源策略及限制 前后端如何通信 如何创建Ajax 跨域通信的几种方式（重点） 安全类 题目 CSRF XSS CSRF与XSS区别 算法类 题目 排序 堆栈、队列、链表 递归 波兰式和逆波兰式 关于算法的心得 二面 / 三面 面试技巧 渲染机制 题目 什么是DOCTYPE及作用 浏览器渲染过程 重排Reflow 重绘Repaint js运行机制 题目 如何理解JS的单线程 什么是任务队列 什么是Event Loop 总结 页面性能 题目 异步加载 浏览器缓存 错误监控 题目 前端错误的分类 错误的捕获方式 上报错误的基本原理 三面 / 四面 面试技巧 结尾 面试准备——自我介绍一面 / 二面面试技巧 准备要充分 知识要系统 沟通要简洁 内心要诚实 态度要谦虚 回答要灵活 页面布局题目假设高度已知，请写出三栏布局，其中左、右栏宽度各为300px，中间自适应 五种解决方式代码 浮动解决方式 绝对定位解决方式 flexbox解决方式 表格布局 网格布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Layout&lt;/title&gt; &lt;style&gt; html *{ padding: 0; margin: 0; } .layout{ margin-top: 20px; } .layout article div{ min-height: 100px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 浮动解决方式 --&gt; &lt;section class=&quot;layout float&quot;&gt; &lt;style&gt; .layout.float .left{ float: left; width: 300px; background: red; } .layout.float .right{ float: right; width: 300px; background: blue; } .layout.float .center{ background: yellow; } &lt;/style&gt; &lt;article class=&quot;left-right-center&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;浮动解决方式&lt;/h1&gt; 1.这是三栏布局的正中间部分 2.这是三栏布局的正中间部分 &lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- 绝对定位解决方式 --&gt; &lt;section class=&quot;layout absolute&quot;&gt; &lt;style&gt; .layout.absolute .left-center-right&gt;div{ position: absolute; } .layout.absolute .left{ left: 0; width: 300px; background: red; } .layout.absolute .center{ left: 300px; right: 300px; background: yellow; } .layout.absolute .right{ right: 0; width: 300px; background: blue; } &lt;/style&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;绝对定位解决方式&lt;/h1&gt; 1.这是三栏布局的正中间部分 2.这是三栏布局的正中间部分 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- flexbox解决方式 --&gt; &lt;section class=&quot;layout flexbox&quot;&gt; &lt;style&gt; .layout.flexbox{ margin-top: 140px; } .layout.flexbox .left-center-right{ display: flex; } .layout.flexbox .left{ width: 300px; background: red; } .layout.flexbox .center{ flex: 1; background: yellow; } .layout.flexbox .right{ width: 300px; background: blue; } &lt;/style&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;flexbox解决方式&lt;/h1&gt; 1.这是三栏布局的正中间部分 2.这是三栏布局的正中间部分 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- 表格布局 --&gt; &lt;section class=&quot;layout table&quot;&gt; &lt;style&gt; .layout.table .left-center-right{ width: 100%; display: table; height: 100px; } .layout.table .left-center-right&gt;div{ display: table-cell; } .layout.table .left{ width: 300px; background: red; } .layout.table .center{ background: yellow; } .layout.table .right{ width: 300px; background: blue; } &lt;/style&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;表格解决方式&lt;/h1&gt; 1.这是三栏布局的正中间部分 2.这是三栏布局的正中间部分 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- 网格布局 --&gt; &lt;section class=&quot;layout grid&quot;&gt; &lt;style&gt; .layout.grid .left-center-right{ display: grid; width: 100%; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; } .layout.grid .left{ background: red; } .layout.grid .center{ background: yellow; } .layout.grid .right{ background: blue; } &lt;/style&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;网格解决方式&lt;/h1&gt; 1.这是三栏布局的正中间部分 2.这是三栏布局的正中间部分 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 展示效果 知识拓展上述5中解决方式是比较常见的，但是我们不能只局限于为了问答而问答，我们应该从此基础上升华一下问题。 答完了这5种常见方式，并不代表我们页面布局这一话题就结束了，面试官可能还会延伸我们的问题，比如： 这5种布局方式各自有什么优点和缺点？ 如果高度已知条件去掉，考虑纵向，那么对于中间内容过多，导致中间格子撑开，此时需要左右跟着撑开，以上5种方式哪几种还能使用？ 这5中方式的兼容性如何？如果让你选择一种最优的去应用于业务，你会选择哪种方式？ 那么，接下来就来围绕这三个问题来讲解： 1、各自的优缺点① 对于浮动： 优点 兼容性比较好，把清除浮动和其它浮动周边元素的关系处理好的话，那么它的兼容性是挺不错的。 缺点 设置浮动之后，脱离了文档流，处理不好的话，会带来很多问题，这是它本身的局限性。 ② 对于绝对定位： 优点 快捷，不容易出问题 缺点 本身脱离了文档流，就会导致子元素跟着脱离文档流。因此，导致绝对定位的有效性、可使用性比较差。 ③ 对于flexbox css3中推出的flex布局，就是为了解决上述两种方式不足而出现的，算是比较完美的一种方式，尤其是对于移动端 ④ 对于表格布局 优点 尽管多数人吐槽表格布局，但其实，表格布局在很多场景都适用的。比如上文写的三栏布局设计当中，表格布局是不是很轻松就实现了呢？ 同时，表格布局的兼容性是非常好的，当用flex解决不了问题的时候，对于PC端 IE8是不支持flex的，此时就可以尝试表格布局 缺点 除开历史上一些诟病外，还有一个： 比如我们把三栏理解成为三个小单元格，那么当其中某一个单元格高度超出的时候，其余两侧也会跟着调整，于是对于有些场景是不合适的。因此，对于不同场景，我们可以在flex和表格布局进行选优操作 ⑤ 对于网格布局 这一块的话，算是新热点，也是经历了一段时间的演变，从上文代码来看的话，通过网格布局我们能让代码更加简单、方便实现逻辑。在面试的时候提到也可以说明你比较关注新的事物，主动学习能力不错。 当然，以上表述有部分个人思考，也有现常说的优缺点，读者可以根据研究布局方式进行深入思考，学习更多的使用场景以及优缺点，其次，欢迎提出新的解决方案及相关知识点，后续进行补充。 2、去掉高度，有哪几种布局可以使用？这里，我们就采用增加高度方式来看看，还有哪些布局能使用。（中间区域增加几个p标签） 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Layout&lt;/title&gt; &lt;style&gt; html *{ padding: 0; margin: 0; } .layout{ margin-top: 20px; } .layout article div{ min-height: 100px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 浮动解决方式 --&gt; &lt;section class=&quot;layout float&quot;&gt; &lt;style&gt; .layout.float .left{ float: left; width: 300px; background: red; } .layout.float .right{ float: right; width: 300px; background: blue; } .layout.float .center{ background: yellow; } &lt;/style&gt; &lt;article class=&quot;left-right-center&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;浮动解决方式&lt;/h1&gt; 1.这是三栏布局的正中间部分 2.这是三栏布局的正中间部分 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- 绝对定位解决方式 --&gt; &lt;section class=&quot;layout absolute&quot;&gt; &lt;style&gt; .layout.absolute .left-center-right&gt;div{ position: absolute; } .layout.absolute .left{ left: 0; width: 300px; background: red; } .layout.absolute .center{ left: 300px; right: 300px; background: yellow; } .layout.absolute .right{ right: 0; width: 300px; background: blue; } &lt;/style&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;绝对定位解决方式&lt;/h1&gt; 1.这是三栏布局的正中间部分 2.这是三栏布局的正中间部分 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- flexbox解决方式 --&gt; &lt;section class=&quot;layout flexbox&quot;&gt; &lt;style&gt; .layout.flexbox{ margin-top: 140px; } .layout.flexbox .left-center-right{ display: flex; } .layout.flexbox .left{ width: 300px; background: red; } .layout.flexbox .center{ flex: 1; background: yellow; } .layout.flexbox .right{ width: 300px; background: blue; } &lt;/style&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;flexbox解决方式&lt;/h1&gt; 1.这是三栏布局的正中间部分 2.这是三栏布局的正中间部分 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- 表格布局 --&gt; &lt;section class=&quot;layout table&quot;&gt; &lt;style&gt; .layout.table .left-center-right{ width: 100%; display: table; height: 100px; } .layout.table .left-center-right&gt;div{ display: table-cell; } .layout.table .left{ width: 300px; background: red; } .layout.table .center{ background: yellow; } .layout.table .right{ width: 300px; background: blue; } &lt;/style&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;表格解决方式&lt;/h1&gt; 1.这是三栏布局的正中间部分 2.这是三栏布局的正中间部分 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- 网格布局 --&gt; &lt;section class=&quot;layout grid&quot;&gt; &lt;style&gt; .layout.grid .left-center-right{ display: grid; width: 100%; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; } .layout.grid .left{ background: red; } .layout.grid .center{ background: yellow; } .layout.grid .right{ background: blue; } &lt;/style&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;网格解决方式&lt;/h1&gt; 1.这是三栏布局的正中间部分 2.这是三栏布局的正中间部分 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 展示效果 这里，图片可能不是特别清楚，读者可以跑一遍上述代码，在浏览器打开使用会更好一点嗷~ 总结 从上述显示效果来看的话，改变了高度，用flex和表格布局还能继续使用。 对于第一块，也就是浮动布局那一块，我们还可以进行知识拓展： 为什么会有两段文字跑到最左边去了呢？ 答：因为向左浮动的原因，上面文字被左边红色部分挡住了，当内容超过高度后，就会往左边移动了。 那你怎么将多余的两段文字接着上述文字显示，而不是向左移动？ 答：这就扯到了BFC的问题，清楚浮动等等，这里就不再进行拓展了，不然这篇文章没法完结啦。。。 页面布局模块——总结 语义化掌握到位 页面布局深刻理解 CSS基础扎实 思维灵活且积极上进 代码书写规范 页面布局的变通三栏布局 左右宽度固定，中间自适应 上下高度固定，中间自适应 两栏布局 左宽度固定，右自适应 右宽度固定，左自适应 上宽度固定，下自适应 下宽度固定，上自适应 CSS盒模型题目谈谈你对CSS盒模型的认识 基本概念：标准模型+IE模型 标准模型和IE模型的区别 CSS如何设置这两种盒模型 JS如何设置获取盒模型对应的宽和高 实例题（根据盒模型解释边距重叠） BFC（边距重叠解决方案） 以上内容知识点由浅入深，知识点理论从CSS-&gt;JS-&gt;CSS 基本概念标准盒模型、怪异盒模型（IE盒模型）和flex弹性伸缩盒模型以及多列布局 标准盒模型（box-sizing content-box） IE盒模型（box-sizing border-box） content = width+padding+border 附完美回答方式： 标准盒子模型，即box-sizing content-box，浏览器默认模型，我们所写的width和height并不是最终盒子的宽高，而是content的，盒子的宽高由我们的content+padding+border来组成的，但是这样在做项目时可能会遇到小问题，假如我想构建一个100x100的盒子大小，但是我发现我写的是width和height是100，于是我需要加上padding及border，但是加上去之后，盒子也会相应变大，这就造成改动麻烦。 后面css3中提供了IE盒子模型，能够直接控制盒子的大小。于是项目中大多数用上了IE盒子模型，以及我看过bootstrap以及element-ui源码中大部分也是用的IE盒子模型 以上回答方式，请读者可以好好体会一下，挖掘其中的亮点！ FLEX盒模型 关于这里可以参考阮一峰老师的文章 参考：Flex 布局教程：语法篇 多列布局（基本上不用） 读者可以适当了解一下，这里就不加以说明了 JS如何获取盒模型对应的宽和高① dom.style.width / height 这种方法，有一定局限性，只能取内联样式的宽高。 ② dom.currentStyle.width / height 这种方法，也是有一定局限性，不过我们三种常用css样式都能获取。但是只支持IE，其它浏览器不支持 ③ window.getComputedStyle(dom).width / height 支持所有浏览器，兼容性好 ④ dom.getBoundingClientRect().width / height 这种方法，一般用于计算元素的绝对位置，根据视窗左上角的点来算的。可以拿到四个元素值：left、top、width、height 实例题（根据盒模型解释边距重叠）如下图，有两个盒子，深色的定为父元素，浅色的定位子元素，子元素的高度为100px，与父元素的上边距为10px，请问父元素实际高度是多少？ 结合这个标题的情况，你可能会说是100px，但你也可能就是直接相加，觉得是110px，但都不是面试官觉得满意的回答，因为要看父元素的盒模型是如何设置的，下面来探讨这个问题： 我们在界面里来写一个父子元素的盒子 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSS盒模型&lt;/title&gt; &lt;style&gt; html *{ padding: 0%; margin: 0; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section id=&quot;sec&quot;&gt; &lt;style&gt; #sec{ background: #f00; } .children{ height: 100px; margin-top: 10px; background: yellow; } &lt;/style&gt; &lt;article class=&quot;children&quot;&gt; &lt;/article&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 打开浏览器，出现如下界面： 我们父级元素貌似没看到，打开开发者工具（按下F12） 此时，我们看一下计算属性 Computed 发现，此时高度是100px。 同时，我们也看一下子元素的高度，如下，也是100px。 那是不是就是100px呢？在回答之前，接着来如下操作，我们修改一个地方： 在父元素样式里设置 overflow: hidden; 此时，我们再次查看content，变成了110px。 此时，就有疑问了，为什么之前是100px，而当我们加了overflow: hidden;之后变成了110px了呢？ 补充知识点： 我们常见的边距重叠，有两种情况： 父子元素重叠（如上文所述） 兄弟之间重叠：比如两个格子，第一个格子下边距30px，第二个上边距5px，会取一个最大值30px作为边距。另外，特殊一点的就是空元素了，会取margin-top和margin-bottom的最大值 补充完后，接着回答上一个问题，为什么加了overflow: hidden;之后变成了110px了呢？ 其实，是给父级元素创建了一个BFC，这里我们在下文继续讨论。 BFC（边距重叠解决方案）BFC基本概念：块级格式化上下文 与之并列的一个是IFC（内联格式化上下文）这个不常考，就提一下。 BFC的原理（渲染规则） ① 在BFC这个元素的垂直方向边距会发生重叠 ② BFC的区域不会与浮动元素的box重叠，可用来清除浮动布局 ③ BFC是一个独立的容器，外面的元素不会影响里面的元素，同时，里面的元素不会影响外面的元素。 ④ 计算BFC元素高度的时候，浮动元素也会参与计算 怎么创建BFC？ ① float值不为none，因为CSS默认为none，只要设置了浮动，当前元素就设置了BFC ② static：静态定位。它是position的默认值，一般不设置position属性时，元素会按照正常的文档流进行排列。那么，只要position不为默认值static也是设置了BFC ③ display属性，table、table-cell等table相关的，都是设置了BFC ④ overflow: auto / hidden BFC使用场景 垂直方向边距重叠问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSS盒模型&lt;/title&gt; &lt;style&gt; html *{ padding: 0%; margin: 0; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section id=&quot;sec&quot;&gt; &lt;style&gt; #sec{ background: #f00; } .children{ height: 100px; margin-top: 10px; background: yellow; } &lt;/style&gt; &lt;article class=&quot;children&quot;&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- BFC垂直方向边距重叠 --&gt; &lt;section id=&quot;margin&quot;&gt; &lt;style&gt; #margin{ background: pink; overflow: hidden; } #margin&gt;p{ margin: 5px auto 25px; background: red; } &lt;/style&gt; &lt;p&gt;a&lt;/p&gt; &lt;p&gt;b&lt;/p&gt; &lt;p&gt;c&lt;/p&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 如下图所示，a的顶部只有5px，而b的顶部用到了a的底部25px，因此就造成了边距重叠问题 如何消除上述情况？ 给子元素创建父元素，让父元素设置BFC 如下图所示，仅需加一个div，然后设置overflow: hidden即可 效果 接下来，来一个左边固定，右边自适应的例子。 123456789101112131415161718192021&lt;!-- BFC不予float重叠 --&gt;&lt;section id=&quot;layout&quot;&gt; &lt;style&gt; #layout{ margin-top: 10px; background: red; } #layout .left{ float: left; width: 100px; height: 100px; background: pink; } #layout .right{ height: 110px; background: #ccc; } &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/section&gt; 效果 从上图可以看到，右边因为宽度设置的高一点，经过浮动重叠到了左边一部分，此时，我们仅需一行代码即可overflow: auto; 12345#layout .right{ height: 110px; background: #ccc; overflow: auto;} 效果 计算BFC元素高度的时候，浮动元素也会参与计算 怎么理解这个概念呢？比如下面代码： 12345678910111213&lt;!-- BFC子元素即使是float也会参与高度计算 --&gt;&lt;section id=&quot;float&quot;&gt; &lt;style&gt; #float{ background: green; } #float .float{ float: left; font-size: 30px; } &lt;/style&gt; &lt;div class=&quot;float&quot;&gt;I am 浮动元素&lt;/div&gt;&lt;/section&gt; 效果 我们从上面图片发现，没有父级元素，于是检查一下，发现父级高度为0，因为子元素设置了浮动，高度没有算进去 解决办法，父级元素设置清除浮动，于是形成了一个BFC，然后就会加上子级元素的高度 1234#float{ background: green; overflow: hidden;} 从门再次打开开发者工具（F12），可以看到，父级元素已经有了高度 DOM 事件类题目 基本概念：DOM事件的级别 DOM事件模型 DOM事件流 描述DOM事件捕获的具体流程 Event对象的常见应用 自定义事件 基本概念：DOM事件的级别 DMO事件类 事件级别 DOM0 element.onclick=function(){} DOM2 element.addEventListener(‘click’, function(){} , false) DOM3 element.addEventListener(‘keyup’, function(){} , false) 为啥没有DOM1呢？ 答：因为DOM1制定的时候，没有设计与事件相关的东西，但不代表DOM1标准不存在 DOM3也是一种事件定义方式，相对来说事件类型增加了，比如鼠标键盘事件等 最后一个boolean值表示事件模型是捕获还是冒泡，默认为false冒泡，为true表示捕获。 DOM事件模型分为捕获（从上到下）和冒泡（从目标元素往上） DOM事件流如上图所示，这就是一个事件流，一个完整的事件流分为三个阶段： 第一阶段是捕获 第二阶段是目标阶段，比如说点按钮就是目标阶段，或者说是事件通过捕获到达目标元素 第三阶段是从目标元素上传到window对象，也就是冒泡的过程 描述DOM事件捕获的具体流程（冒泡方向与之相反） Event对象的常见应用 event.preventDefault() （阻止默认，例如链接等） event.stopPropagation() （阻止冒泡） event.stopImmediateProgation() （事件响应优先级，例如给一个按钮添加两个事件A和B，你想要只执行A，不执行B，就在A的响应函数里添加这个方法，就会阻止B事件的执行） event.currentTarget （表示当前所绑定的事件，如下面所述，指向的就是父级元素） event.target （与事件委托相关，把子元素的事件全都转到父级元素上，进行优化，只需绑定一次事件，然而作响应的时候，需要区别是哪个子元素被点击，该方法就可以绑定当前被点击的元素） 自定义事件12345var eve = new Event('custome');ev.addEventListener('custome',function(){ console.log('custome');});ev.dispatchEvent(eve); CustomEvent是为了解决Event事件不能传数据的问题 实例分析上文讲述了相关知识点，下面我们通过代码来简单实现，让抽象的知识更加具体化 DOM事件捕获的具体流程实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;ev&quot;&gt; &lt;style&gt; #ev{ width: 300px; height: 100px; color: #fff; text-align: center; line-height: 100px; background: red; } &lt;/style&gt; 目标元素 &lt;script type=&quot;text/javascript&quot;&gt; var ev=document.getElementById('ev'); //DOM2中定义事件 window window.addEventListener('click',function(){ console.log('window capture') },true) //document document.addEventListener('click',function(){ console.log('document capture') },true) //html document.documentElement.addEventListener('click',function(){ console.log('html capture') },true) //body document.body.addEventListener('click',function(){ console.log('body capture') },true) //目标元素 ev.addEventListener('click',function(){ console.log('ev capture') },true) /* 自定义事件 */ var eve = new Event('test'); ev.addEventListener('test',function(){ console.log('test dispatch') },true) setTimeout(function(){ ev.dispatchEvent(eve); },2000) &lt;/script&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果 HTTP 协议类题目 HTTP协议的主要特点 HTTP报文的组成部分 HTTP方法 POST和GET的区别 HTTP状态码 什么是持久连接 什么是管线化 HTTP协议的主要特点 简单快速 （每个资源URL是固定的，一个图片或页面地址，统一资源符，只需输入URL即可访问） 灵活 （在HTTP协议头部head部分有一个数据类型，通过http协议可以完成不同数据类型的传输） 无连接 （连接一次会断掉，不会保持连接） 无状态 （客户端和服务端连接两次，不能区分两次连接者身份） HTTP报文的组成部分 请求行：包含方法、页面地址、HTTP协议版本 请求头：key-value值，告诉服务端需要什么内容，要注意什么类型 空行：告诉服务端请求头结束，接下来是请求体部分了 请求体：数据部分 同理，响应报文 请求示例 以上第一行就是请求行，包含GET方法 / 表示首页 HTTP/1.1 表示HTTP协议版本 后面内容都是请求头，都是key-value键值对 空行在这里没有显示出来，然后对于请求体就是一些数据部分了。 响应示例 第一行是状态行，包含HTTP协议版本，协议状态码200 下面就是响应头了，也是键值对的形式 下面会有一个空行，类似下面这种效果（下面这条分割横线） HTTP方法 方法 作用 GET 获取资源 POST 传输资源 PUT 更新资源 DELETE 删除资源 HEAD 获取报文首部 POST和GET的区别（重点前5条） get在浏览器回退时是无害的，而post会再次提交请求 get请求会被浏览器主动缓存，而post不会，除非手动设置 get请求参数会被完整保留在浏览器历史记录里，而post中的参数不会被保留 get请求在URL中传送的参数是有长度限制的，而POST没有限制 get参数通过URL传递，post放在Request body中 get请求只能进行url编码，而post支持多种编码方式 对参数的数据类型，get只接受ASCALL字符，而post没有限制 get比post更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息 get产生的URL地址可以被收藏，而post不可以 HTTP状态码 1xx：指示信息——表示请求已接收，继续处理 2xx：成功——表示请求已经被成功接收 3xx：重定向——要完成请求必须进行更进一步的操作 4xx：客户端错误——请求有语法错误或请求无法实现 5xx：服务器错误——服务器未能实现合法的请求 一般答完上述基本ok了，如果问的详细一点的话，就多加一点知识上去： 200 OK：客户端请求成功 206 Partial Content：客户发送了一个带有Range（范围）头的GET请求，服务器完成了它（比如客户端请求0-1w字节，服务器就会返回206,常见播放视频和音频地址，文件过大时一般返回206） 301 Moved Permanently：所请求的页面已经转移至新的URL 302 Found：所请求的页面已经临时转移至新的URL 304 Not Modified：客户端有缓冲的文档并发出一个条件性的请求，服务器告诉客户，原来缓冲的文档还可以继续使用 400 Bad Request：客户端请求有语法错误，不能被服务器所理解 401 Unauthorized：请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用 403 Forbidden：请求访问的页面被禁止（比如页面只能通过服务端去访问） 404 Not Found：请求资源不存在 500 Internal Server Error：服务器发生不可预料的错误但原来缓冲的文档还可以继续使用 503 Server Unavailable：请求未完成，服务器临时过载或当机，一段时候后可能恢复正常 什么是持久连接HTTP协议采用“请求-应答”模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求 / 应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议） 当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务端的连接持续有效，当出现对服务器的后续请求时，Keep-Alive 功能避免了建立或者重新建立连接 PS：只有HTTP 1.1 版本才支持持久连接，1.0不支持。 什么是管线化（加分点）在使用持久连接的情况下，某个连接上消息的传递类似于 请求1-&gt;响应1-&gt;请求2-&gt;响应2-&gt;请求3-&gt;响应3 某个连接上的消息类似变成了这样： 请求1-&gt;请求2-&gt;请求3-&gt;响应1-&gt;响应2-&gt;响应3 （将请求打包一起发送，然后服务器一起打包回来响应） 拓展知识： 管线化机制通过持久连接完成，仅 HTTP / 1.1 支持此技术（重点） 只有get和head请求可以进行管线化，而 post 有所限制（重点） 初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持 HTTP /1.1 版本的协议（重点） 管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变 HTTP / 1.1要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可 由于上面提到的服务器端的问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如 Chrome 和 Firefox 默认并未开启管线化支持 原型链题目 创建对象有几种方法 原型、构造函数、实例、原型链 instanceof的原理 new运算符 创建对象有几种方法12var o1 = {name:'o1'};var o11 = new Object({name:'o11'}); 12var M = function(){this.name='o2'};var o2 = new M(); 12var P = {name:'o3'};var o3 = Object.create(P); 原型、构造函数、实例、原型链 12var M = function(name){this.name=name}; //构造函数var o2 = new M('o2'); //实例 构造函数和原型对象的关系 实例和构造函数的关系 原型链：通过原型链的方式，找到原型对象，原型对象的方法是被不同实例所共有的。例如Object上有toString()方法，因此其它所有的实例都共有这个方法。 instanceof的原理instanceof原理就是判断当前实例是不是当前构造函数的实例对象，判断依据就是实例对象的__proto__和构造函数的prototype是否指向相同的引用，只要在一条原型链上，instanceof就会返回true。 很抽象是吧，下面我们还是举上文的例子： 12var M = function(name){this.name=name};var o2 = new M('o2'); 因此，instanceof判断不严谨，比如m继承了a、b、c，我怎么判断是继承了哪一个呢？用instanceof判断都返回true。 下面就来，介绍constructor判断方式 new运算符 一个新对象被创建。它继承自foo.prototype 构造函数foo被执行。执行的时候，相应的参数会被传入，同时上下文（this）会被指定为这个新实例。new foo 等同于 new foo()，只能用在不传递任何参数的情况 如果构造函数返回一个“对象”，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象 面向对象题目类与实例 类的声明 生成实例 类与继承 如何实现继承 继承的几种方式 类与实例12345678910111213141516&lt;body&gt; &lt;script&gt; /* 类的声明 */ function Animal(){ this.name='aaa'; } /* ES6中的class的声明 */ class Animal2{ constructor(){ this.name = 'bbb'; } } /* 实例化一个类 */ console.log(new Animal(),new Animal2()); &lt;/script&gt;&lt;/body&gt; 效果 类与继承方法一：借助构造函数来实现继承 123456789/* 借助构造函数来实现继承 */ function fruit(){ this.name = 'fruit'; } function apple(){ fruit.call(this); this.type='apple'; } console.log(new apple); 上述这种方式，是通过改变fruit构造函数运行时this指向，指向了apple上，但是fruit原型链上的东西并没有被继承。 123456789101112/* 借助构造函数来实现继承 */ function fruit(){ this.name = 'fruit'; } fruit.prototype.eat = function(){ console.log('吃水果啦！'); } function apple(){ fruit.call(this); this.type='apple'; } console.log(new apple().eat()); 因此，通过构造函数来实现的继承，只能继承父类构造函数的属性，如果原型prototype上面还有方法甚至原型链上的方法，不会继承。 方法二：借助原型链实现继承 123456789/* 借助原型链实现继承 */function fruit(){ this.name = 'fruit';}function apple(){ this.type='apple';}apple.prototype = new fruit();console.log(new apple()); 掌握之前原型链相关的知识，下面的等式应该就比较容易理解了 但这种继承方式也是有缺点的，下文来探讨这个问题： 12345678910111213/* 借助原型链实现继承 */function fruit(){ this.name = 'fruit'; this.arr = [1,2,3];}function apple(){ this.type='apple';}apple.prototype = new fruit();var app1 = new apple();var app2 = new apple();app1.arr.push(4);console.log(app1,app2); 从上述结果来看，当我们修改某一个对象时，该函数的所有新出的实例对象都会跟着改变，这就造成了污染问题，肯定不是我们面向对象思想所想要的。（因为它们引用的是同一个父类实例对象） 方式三：组合方式实现继承 这种方式就是结合前两种的优点，弥补它们的缺点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;面向对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; /* 关于继承的几种方式 **使用方法： **读者按需将对应模块注释取消掉即可 */ /* 借助原型链实现继承 */ /*function fruit(){ this.name = 'fruit'; this.arr = [1,2,3]; } function apple(){ this.type='apple'; } apple.prototype = new fruit(); var app1 = new apple(); var app2 = new apple(); app1.arr.push(4); console.log(app1,app2);*/ /* 组合方式实现继承 */ /** *此方法的缺点：new fruit() 父类构造函数执行了两次，可以但没必要 */ function fruit(){ this.name = 'fruit'; this.arr = [1,2,3]; } function apple(){ fruit.call(this); this.type='apple'; } apple.prototype = new fruit(); //这里拿的是父类的实例，没有自己的constructor var app1 = new apple(); var app2 = new apple(); app1.arr.push(4); //console.log(app1,app2); //console.log(app1.constructor,app2.constructor) /* 组合方式实现继承优化1 */ function fruit1(){ this.name = 'fruit'; this.arr = [1,2,3]; } function apple1(){ fruit.call(this); this.type='apple'; } apple1.prototype = fruit1.prototype; //这里拿的是父类的原型对象，但依旧没有自己的constructor var app3 = new apple1(); var app4 = new apple1(); app3.arr.push(4); //console.log(app3,app4); //判断实例 //console.log(app3 instanceof apple1); //console.log(app3 instanceof fruit1); //这里无法判断当前对象是由父类产生的实例对象还是由子类产生的实例对象 //判断构造函数 //console.log(app3.constructor); //console.log(app4.constructor); //因为和父类的原型对象是一个对象，导致constructor也是指向的父类的constructor，无法判断自己 /* 组合方式实现继承优化2 */ function fruit2(){ this.name = 'fruit'; this.arr = [1,2,3]; } function apple2(){ fruit.call(this); this.type='apple'; } apple2.prototype = Object.create(fruit2.prototype); //这里使用Object.create()方法，和之前直接用fruit2.prototype来说，它创建了一个中间对象，和父类不是指向同一个区域了 //这样就能区分父类和子类的原型对象了，达到父类和子类原型对象的隔离效果 apple2.prototype.constructor = apple2; //由于隔离了父类子类的原型对象，我们就可以指定子类自己的constructor var app5 = new apple2(); var app6 = new apple2(); app5.arr.push(4); console.log(app5,app6); //判断实例 console.log(app5 instanceof apple2); console.log(app5 instanceof fruit2); //因此，这里可以判断当前对象是由父类产生的实例对象还是由子类产生的实例对象 //判断构造函数 console.log(app5.constructor); //指向的是自己的constructor &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 通信类题目 什么是同源策略及限制 前后端如何通信 如何创建Ajax 跨域通信的几种方式（重点） 什么是同源策略及限制同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。 源包括协议、域名、端口 Cookie、LocalStorage和IndexDB无法读取 DOM无法获得 AJAX请求不能发送 前后端如何通信 Ajax（同源下的通信） WebSocket（不限制，不受同源策略的限制） CORS（支持同源通信，也支持跨域通信，新型） 如何创建Ajax XMLHttpRequest（高级浏览器才支持）对象的工作流程 兼容性处理 事件的触发条件 事件的触发顺序 跨域通信的几种方式（重点） JSONP Hash（改变页面不刷新，search改变会刷新，因此search不可以） postMessage（H5中出现的标准，实现跨域通信） WebSocket CORS（可以理解为支持跨域通信的Ajax，在请求头上加了Origin） JSONP实现原理： 根据script标签异步加载而来 将html加入script标签，即把请求发送出去 很关键一点是会向服务端发送一个callbackName，然后服务器就会响应如下内容（下面那个script里的内容）利用callbackName作为函数名来返回，而且本地必须有这个函数名的函数。 Hash与postMessage实现原理 WebSocket实现原理 CORS实现原理 PS：CORS为什么支持跨域通信？ 浏览器回拦截Ajax请求，如果觉得是跨域的，就会在请求头上加上origin。 安全类题目 CSRF 基本概念和缩写 攻击原理 防御措施 XSS CSRF基本概念和缩写 CSRF，通常称为跨站请求伪造，英文名（Cross-site request forgery）缩写CSRF CSRF攻击原理 用户必须在网站登录过 网站中某个接口存在漏洞 CSRF防御措施 Token验证 Referer验证（页面来源验证） 隐藏令牌（类似Token，隐藏在http的head头中，不放在链接上） XSS基本概念和缩写 跨域脚本攻击（cross-site scripting） 攻击原理 比如可以在你的提交区里面写上script标签，即用一些渠道向你的页面注入js脚本 防御措施 让插入的js不可执行 CSRF与XSS区别CSRF是利用本身的漏洞自动执行接口，依赖于用户登录网站 XSS是向页面注入js，js函数体里面做想做的事 算法类题目 排序 堆栈、队列、链表 递归 波兰式和逆波兰式 … PS：由于文章篇幅所限，并且算法这一块需要的是自己平时的积累，这里就不作长文加载了，关于算法这一块我会在github里有相应专栏，记录题库。因此，在这里就给大家分享一些比较好的文章提供学习。 排序 快速排序：传送门 选择排序：传送门 希尔排序：传送门 推荐：【再也不怕面试官要你手写排序算法】一文详细解读前后端之各种排序算法及知识拓展（附图示） JS / C / C++ 堆栈、队列、链表参考：JS中的数据结构与算法 递归参考：JS中的递归 波兰式和逆波兰式参考：波兰式、逆波兰式与表达式求值 参考：源码 关于算法的心得首先，对于前端来说，算法要求没有后端那么严格，考察的一般不会很刁专，一般就是看下你的思考能力。如果一开始就考察算法题，如果你回答不了的话，也很正常，或许这不是一个关于前端的部门…可能招的是算法工程师，算法这一块问的话，多半是中间时间段。算法这一块的话，在于平时积累，如果时间充裕的话，可以深入了解一点，这也是面试加分点，如果时间紧迫的话，把上文提到的部分专题弄懂已经不错了。 二面 / 三面面试技巧 知识面要广 理解要深刻 内心要诚实 态度要谦虚 回答要灵活 要学会赞美 渲染机制题目 什么是DOCTYPE及作用 浏览器渲染过程 重排Reflow 重绘Repaint 布局Layout 什么是DOCTYPE及作用 DTD（document type ，文档类型定义）是一系列的语法规则，用来定义XML或（X）HTML的文件类型。浏览器会使用它来判断文件类型，决定使用何种协议来解析，以及切换浏览器模式 DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器就会出现一些解析错误。（简单来说，就是告诉浏览器我用了哪一个DTD） PS：这里要记住html5该如何声明，以及4.0版本有严格模式和传统模式，具体区别如上图下划线所示 浏览器渲染过程 简单快速回答： 第一步，HTML经过HTML解析器解析成为DOM Tree 第二步，CSS通过CSS解析器形成样式规则 第三步，将两个DOM结合形成Render Tree，这里就类似于告诉浏览器渲染树结构基本出来了，此时有一个平行操作，Layout，经过这个，就能知道元素具体应该显示在屏幕在哪个位置（宽、高、颜色等） 最后一步，浏览器通过GUI画图，呈现页面内容，最后Display显示页面 下面通过几个比较好理解的图形来将抽象具体化： DOM Tree CSSOM Tree Render Tree Layout 重排Reflow定义 DOM结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为reflow 触发Reflow 当你增加、删除、修改DOM结点时，会导致 Reflow 或 Repaint 当你移动DOM的位置，或是搞个动画的时候 当你修改CSS样式的时候 当你 Resize 窗口的时候（移动端没有这个问题），或是滚动的时候 当你修改网页的默认字体时候（影响比较大，性能问题） 重绘Repaint定义 当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为repaint。即页面需要呈现的内容，一起画到屏幕上。 触发Repaint DOM改动 CSS改动 （重点）如何尽量减小Repaint？ 比如页面有一个计算器，用户在输入框输入一些计算表达式，最后显示计算结果，然后把输入给隐藏掉。这里就有两个交互，先是用户输入，将输入隐藏掉，然后将结果显示出来。这两个交互呈现内容不一样，当然就需要Repaint，那怎么做少画点东西？ 好像是有一个documentFrame这个东西，把n个节点创建成一个片段，向浏览器一次添加这个片段。 （这里我的朋友考察过，遗留一下这个问题，可以帮助我完善这个问题，谢谢！） 下面就例举几个经典题，读者可以好好体会一下： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;js运行机制&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; console.log(1); setTimeout(function(){ console.log(3); },0); console.log(2); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345for(var i=0;i&lt;4;i++){ setTimeout(function(){ console.log(i); },1000)} 题目 如何理解JS的单线程 什么是任务队列 什么是Event Loop 以上三个问题的详细表述： 如何理解JS的单线程学过JS，不对，听过JS的同学应该都知道，JS是单线程的，而浏览器是多线程的，分配的时间内js只能干一件事情 什么是任务队列分同步任务和异步任务 什么是Event Loop为了解决同步和异步问题，浏览器提供了一个事件队列 Event Queue，根据特征不同，分为微任务和宏任务队列 执行顺序是：主线程代码 &gt; 微任务 &gt; 宏任务 宏任务： 定时器例如setTimeout（异步）、事件绑定 微任务： await（异步，执行x函数并等待返回结果，有结果再执行下面代码） resolve() / reject() 执行的时候把 then / catch 中的代码执行 promise、async 特殊情况： new Promise（同步）会立即执行 总结 理解Js的单线程的概念 理解任务队列 理解 Event Loop 理解哪些语句会放入异步任务队列 理解语句放入异步任务队列的时机 页面性能题目提升页面性能的方法有哪些？ 1、资源压缩合并，减少HTTP请求 2、非核心代码异步加载——异步加载的方式——异步加载的区别 3、利用浏览器缓存——缓存的分类——缓存的原理 4、使用CDN 5、预解析DNS 123&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt; //打开a标签dns预解析//有些https默认关了dns预解析，使用上述可以打开（加分点）&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//host_name_to_prefetch.com&quot;&gt; 异步加载1、异步加载的方式 动态脚本加载（用过js添加到document中，比如加入到body或head中） defer async 2、异步加载的区别 （1）defer是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行（2）async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关 浏览器缓存1、缓存的分类 ① 强缓存（不用任何请求，拿过来就用，如果两个都下发，以第二个Cache为准） Expires（过期时间-服务器绝对时间） Expires:Thu,21 Jan 2017 23:39:02 GMT （会导致客户端时间和服务器时间之间时间差问题） Cache-Control（客户端相对时间，单位秒） Cache-Control:max-age=3600 ② 协商缓存（浏览器发现本地有这个副本，但是不确定用不用它，于是得向服务器问一下，这个副本要不要用） Last-Modified（拿到某个资源文件时，通过这个字段服务器下发一个时间） If-Modified-Since （当下次请求这个资源是否发生变化时，是用这个key值，对比两个时间） Last-Modified: Web,26 Jan 2017 00:35:11 GMT （上述方式会存在问题，例如我可能时间上修改了，但是内容并没有修改） Etage（解决上述问题，服务器给Etage值，当过了强缓存时间，浏览器请求是否可用副本时，会在http请求头中用 If-None-Match 当做key值，加上value，此value就是Etage的值） PS：（面试真题-鹅厂）你知道浏览器与缓存相关的http头有哪些？ 答案就是上述加粗字体 错误监控问法：如何检测JS错误，如何保证你的产品质量？ 题目 前端错误的分类 错误的捕获方式 上报错误的基本原理 前端错误的分类即时运行错误：代码错误资源加载错误 错误的捕获方式即时运行错误的捕获方式 （1） try…catch（2）window.onerror（无法捕获资源加载错误，理由如下） 资源加载错误（上述原因：因为资源加载错误不会冒泡） （1）object.onerror（节点上绑定onerror事件） （2）performance.getEntries() （获得目前已加载的资源，例如图片，然后用document.getElementsByTagName(‘img’)来获取需要加载的图片，然后用总的去减已加载的，就能知道未加载的有多少了） （3）Error事件捕获（之前说不能冒泡，但可以捕获） 延伸：跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？ 处理 在script标签增加 crossorigin 属性 设置js资源响应头 `Access-Control-Allow-Origin:*（可以指定域名） 上报错误的基本原理1、采用Ajax通信的方式上报2、利用Image对象上报（重点，加分点） 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;利用Image对象上报&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; (new Image()).src='http://baidu.com/test?name=123'; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 此时，我们查看Nerwork，可以发现，我们的请求已经发出去了（比Ajax简单，不用借用任何第三方库） 三面 / 四面面试技巧 准备要充分 描述要熟练 引导找时机 优势要发挥 回答要灵活","link":"/2020/04/11/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%88%B7%E8%BF%99%E4%BA%9B%E5%B0%B1%E5%A4%9F%E4%BA%86/"},{"title":"5.深入Java系列深入理解JAVA I&#x2F;O","text":"深入理解 java I/O - 旧巷里的旧少年 - 博客园 2018年1月9日 - 深入理解 java I/O Java 的 I/O 类库的基本架构 I/O 问题是任何编程语言都无法回避的问题,可以说 I/O 问题是整个人机交互的核心问题,因为 I/O 是机器获取… 深入理解Java_中的_IO - 沉淀所有的痛 - 博客园 2018年12月6日 - 深入理解Java_中的_IO 引言: 对程序语言的设计者来说,创建一个好的输入/输出(I/O)系统是一项艰难的任务 &lt; Thinking in Java &gt; 本文的目录视图如下: Java… 【Java_基础】:_深入理解 java _I/O__hxcaifly的博客-CSDN博客 2019年1月31日 - 参考:https://www.cnblogs.com/jxldjsn/p/8251398.html… _Java_中_I/O_操作主要是指使用_Java_进行输入,输出操作。 _Java_所有的_I/O_机制都是基于数据流进行… 深入理解Java _IO_的知识体系 - 简书 2019年5月14日 - 1、IO_难题 对程序语言设计者来说,设计一个令人满意的_I/O(输入/输出)系统,是件极艰巨的任务 2、Stream 流 Stream 流是构成_Java_核心底层的体系 流有3分… _深入理解JavaI/O_流_blueZhang的博客-CSDN博客 2015年7月27日 - 其实我个人觉得,_javaI/O_流是一种比较乏味的事情。因为看不到明显的运行效果,但是输入输出程序都需 Java _I/O_体系从原理到应用,这一篇全说清楚了__Java__后端技术精选… 2019年11月24日 - 本文介绍操作系统I/O_工作原理,_Java I/O_设计,基本使用,开源项目中实现高性能_I/O_常见方法和_Java _深入理解JAVA_中的NIO - 知乎 2018年7月9日 - 深入理解JAVA_中的NIO 烂猪皮 在此我向大家推荐一个架构学习交流群。交流学习群号:478030634 6人赞同了该文章 前言: 传统的 _IO 流还是有很多缺陷的,尤… 深入理解Java _IO_的flush_java_脚本之家 2018年6月14日 - 本篇文章是小编总结的关于Java _IO_的flush的相关知识点内容,有需要的朋友可以跟着学习下。_Java_的_IO_是一个大知识点, 如果把它的知识点拆开来说的话估计… 猿学-Java _I/O_全解析完整版!_shitouer 2018年8月16日 - 前言:在之前的面试中,每每问到关于_JavaI/O_方面的东西都感觉自己吃了大亏..所以这里抢救一下..来_深入_的_了解_一下在_Java_之中的_I/O_到底是怎么回事..文章可能说明… java i o___java_ _i/o_库__java _i/o_技术 - 云+社区 - 腾讯云 当我第一次读到streamapi时,我对它的名称感到困惑,因为它听起来类似于java _i o_的inputstream和outputstream。 但是java 8 stream是… _深入了解Java_对象序列化 … Java I/O : _Java_中的进制详解 | 并发编程网 – ifeve.com 泥瓦匠就写了个工具类 IntegerConvert.java:…1、(inta &gt;&gt; i * 8) &amp; 0xff 移位 清零从左… _Java_文件_I/O_的三种方法 - 51CTO.COM 2016年10月12日 - 通道和缓冲器是一个成对的概念,Thinking in Java_中的一个例子特别好_理解:我们…为什么想到要用通道来做_I/O_呢?主要考虑的是性能问题,通道加缓冲器能够… Java I/O 总结详细教程 - _Java_开发 - 开发语言与工具 - 深度开源 2012年5月3日 - www.moandroid.com Java _I/O_总结  从new BufferedReader(new InputStream…再次看到这个地方,一方面时间已经过去了很多,另外 一方面对问题的_理解_也… 《深入_分析_Java Web技术内幕》PDF 下载__Java_知识分享网-免费Java… 2014年10月1日 - 首先介绍前端知识,主要介绍_Java_Web开发中涉及的一些基本知识,包括Web请求过程、HTTP协议、DNS技术和CDN技术。其次_深入_介绍_Java_技术,包括_I/O_技术、中文… _Java_学到什么程度才能叫精通? - 知乎 2015年3月20日 - 磁盘的_I/O_操作也少一些,而且B类树是平衡树,每个结点到叶子结点的高度都是相同…《写给大忙人看的JavaSE8》 《_深入理解Java_虚拟机:JVM高级特性与最佳… 深入_分析 _Java I/O 的工作机制 2011年10月31日 - 关于 I/O 编码问题请参考另一篇文章 《深入_分析_Java_中的中文编码问题》。 下图是写字符的 _I/O 操作接口涉及到的类,Writer 类提供了一个抽象方法 write(char … 深入理解Java 7:核心技术与最佳实践免费阅读_百度阅读 2017年7月12日 - _Java_平台提供了丰富的标准类库来满足应用程序中可能出现的与_I/O_操作相关的需求。…在第10章介绍_Java_对象序列化时,会_深入_讨论ObjectInputStream类和Ob… Java _I/O_体系从原理到应用,这一篇全说清楚了_慕课手记 2019年11月13日 - 本文介绍操作系统I/O_工作原理,_Java _I/O_设计,基本使用,开源项目中实现高性能_I/O_常见方法和实现,彻底搞懂高性能_I/O_之道 基础概念 在介绍_I/O_原理之前,先… _深入了解_Netty【四】_IO_模型丶一个站在_Java_后端设计之路的男青年… 2019年12月1日 - 这种模型与信号驱动模型的主要区别在于:信号驱动I/O_是由内核通知应用程序何时启动…_深入了解 Java-Netty高性能高并发理解 阅读更多 深入了解Kafka【… Java _IO深入理解_BufferedWriter(代码实例) - _JAVA_编程…_红黑联盟 2018年2月13日 - BufferedWriter是缓冲字符输出流,它继承于Writer。 BufferedWriter的作用是为其他字符输出流添加一些缓冲功能。 BufferedWriter通过字符数组来缓冲数… 深入理解JAVA _I/O_系列一:File - 冬瓜蔡 - 博客园 2016年7月9日 - _I/O_问题可以说是当今web应用中所面临的的主要问题之一,大部分的web应用系统的瓶颈都是_I/O_瓶颈。这个系列主要介绍_JAVA_的_I/O_类库基本架构、磁盘_I/O_工作… 深入理解JAVA _I/O_系列二:字节流详解 - 冬瓜蔡 - 博客园 2016年7月16日 - 深入理解JAVA _I/O_系列二:字节流详解 流的概念 JAVA程序通过流来完成输入/输出。流是生产或消费信息的抽象,流通过JAVA的输入输出与物理设备链接,尽管与它们链接的… 深入理解JAVA _I/O_系列五:对象序列化 - 冬瓜蔡 - 博客园 2016年7月30日 - 深入理解JAVA _I/O_系列五:对象序列化 序列化 对象序列化的目标是将对象保存到磁盘中,或者允许在网络中直接传输对象。对象序列化机制允许把内存中的JAVA对象转换成跟… 深入理解JAVA _I/O_系列六:Linux中的_IO_模型 - 冬瓜蔡 - 博客园 2016年8月14日 - 多路复用技术应用于JAVA NIO的核心类库多路复用器Selector中,目前支持_I/O_多路复用的系统调用有select、pselect、poll、epoll,在linux编程中有一段时间… 深入理解JAVA _I/O_系列四:RandomAccessFile - 冬瓜蔡 - 博客园 2016年7月24日 - 1、是JAVA _I/O_流体系中功能最丰富的文件内容访问类,它提供了众多方法来访问文件内容。 2、由于可以自由访问文件的任意位置,所以如果需要访问文件的部… 深入理解JAVA _I/O_系列三:字符流详解 - 冬瓜蔡 - 博客园 2016年7月23日 - 深入理解JAVA _I/O_系列三:字符流详解 字符流为何存在 既然字节流提供了能够处理任何类型的输入/输出操作的功能,那为什么还要存在字符流呢?容我慢慢道来… 深入理解JAVA I/O —File类_Java_景培培哎的博客-CSDN博客 2019年4月28日 - 深入理解java IO 阅读数 116 一、Java的_I/O_类库的基本架构Java的_I/O_操作类在包java._io_下,大概有将近80个类,这些类大概可以分成如下四组。◎ 基于字节… 深入理解Java_中的_IO - Zohnn - 博客园 2019年8月30日 - 本文转载自:深入理解Java_中的_IO 为了方便理解与阐述,先引入两张图 在整个Java….(); // readLine()方法运行时若发生_I/O_错误,将抛出IOException异常 w… 深入理解java _IO__zjltju1203的博客-CSDN博客 2019年4月13日 - 一、Java_的_I/O_类库的基本架构_Java_的_I/O_操作类在包_java.io_下,大概有将近80个类,这… _Java Socket的工作机制 NIO的工作方式 BIO即阻塞I/O,不管是磁盘I/… _深入理解Java_中的_IO__二丁目的丰功笔记-CSDN博客 2016年4月21日 - 掌握了这些IO_的核心操作那么对于_Java_中的_IO_体系也就有了一个初步的认识了 _Java _I/O_主要包括如下几个层次,包含三个部分: 1.流式部分――_IO_的主体部分; … 深入理解Java_中的_IO - 菜鸟程序员成长路 2018年6月8日 - 在Java语言中使用字节流和字符流的步骤基本相同,以输入流为例,首先创建一个与数据…_深入理解JavaI/O_流 阅读数 2435 其实我个人觉得,java_I/O_流是一种… 深入理解Java_中的_IO - 哎喔别走 - 博客园 深入理解Java_中的_IO 引言: 对程序语言的设计者来说,创建一个好的输入/输出(I/O)系统是一项艰难的任务 &lt; Thinking in Java &gt; 本文的目录视图如下: Java _IO_概… 深入理解Java_中的_IO - 素颜甜甜 - 博客园 2018年2月27日 - 标准I/O Java程序可通过命令行参数与外界进行简短的信息交换,同时,也规定了与…Java Scoket编程(6447) 2. 深入理解Java_中的_IO(731) 推荐排行榜 1. Ja… 深入理解Java_中的_IO - silyvin - 博客园 2018年2月5日 - 深入理解Java_中的_IO_引言:对程序语言的设计者来说,创建一个好的输入/输出(_I/O)系统是一项艰难的任务 &lt; Thinking in Java &gt;本文的目录视图如下:Java IO… 深入理解Java_中的_IO - KeepLearning的博客 2018年3月19日 - 引言: 对程序语言的设计者来说,创建一个好的输入/输出(I/O)系统是一项艰难的任务 &lt; Thinking in _Java_ &gt; 本文的目录视图如下:Java IO_概要 a._Java… Java IO 深入理解 - 简书 Java IO 深入理解 1、概述 Java 的_IO_”家族“看起来十分吓人。不仅多而且还有_io_与nio之分。没用用过的很容易就踩坑。 本文主要从用法上为主,适当源码分析,来… 深入理解JAVA _I/O_系列一:File - 冬瓜蔡 - 博客园 2016年7月9日 - _I/O_问题可以说是当今web应用中所面临的的主要问题之一,大部分的web应用系统的瓶颈都是_I/O_瓶颈。这个系列主要介绍_JAVA_的_I/O_类库基本架构、磁盘_I/O_工作… 从设计者的角度理解Java _IO_流 - 简书 摘要Java I/O_是Java技术体系中非常基础的部分,它是学习Java NIO的基础。而_深入理解Java NIO则是学习现代高性能网络通信框架(比如Netty)的基础。本… 深入理解java io - y41992910的博客 2018年2月27日 - import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import…_深入理解JavaI/O_流 阅读数 2433 其实我个人觉得,java_I/O_流是… 深入理解JAVA _I/O_系列六:Linux中的_IO_模型_changhenshui…_CSDN博客 2018年3月1日 - 多路复用技术应用于JAVA NIO的核心类库多路复用器Selector中,目前支持_I/O_多路复用的系统调用有select、pselect、poll、epoll,在linux编程中有一段时间… 由装饰者模式来深入理解Java _I/O_整体框架 - newday0_0 - CSDN博客 2018年4月23日 - 每次看得我如入云里雾里,直到后面看了设计模式这一块,才算真正的对Java I/O_这一块有了整体的_了解,_理解_起_Java_流也就容易许多。这篇博客先介绍装饰者模… Java _I/O_体系从原理到应用,这一篇全说清楚了__Java_知音-CSDN博客 2019年11月24日 - 本文介绍操作系统I/O_工作原理,_Java _I/O_设计,基本使用,开源项目中实现高性能_I/O_常见方法和 JAVA 深入理解 _IO___Java__LEE-CSDN博客 2018年12月20日 - _深入理解IO_、NIO 阅读数 88 _JAVA_中的 I/OI/O 指以流为基础进行输入输出(input、output)的,所有数据被串行化写入输出流,或者从输入流读入。按流向分:… JAVA IO (一) 基础深入理解 - shuizhaosi888的专栏 2015年3月17日 - _深入理解IO_、NIO 阅读数 65 _JAVA_中的 I/OI/O 指以流为基础进行输入输出(input、output)的,所有数据被串行化写入输出流,或者从输入流读入。按流向分:… 深入_分析_Java _I/O_的工作机制 (一) - 就让文谦先行 - 博客园 2019年1月14日 - 此篇博客看至许令波的深入_分析_java_Web内幕书籍, 此篇博客写的是自己看完之后_理解_的重点内容,加一些_理解,希望对你有帮助。 1._Java_的_I/O_类库的基本架构 … 深入理解Java_中的_IO - csdn_kenneth的博客 2018年3月30日 - https://www.cnblogs.com/ylspace/p/8128112.html… 深入理解java IO 阅读数 92 一、Java的_I/O_类库的基本架构Java的_I/O_操作类在包java._io_下,大概有… 深入理解JAVA I/O:对象序列化_对象序列化_自律则自由的…_CSDN博客 2018年11月6日 - 对象序列化机制允许把内存中的_JAVA_对象转换成跟平台无关的二进制流,从而允许将这种二进制流持久地保存在磁盘上,通过网络将这种二进制流传输到另一个网络节点,其他… JAVA _IO_流_深入理解___java__LoveStudy_girl的博客-CSDN博客 2016年6月23日 - 输入/输出流 - 深入理解Java_中的流 (Stream)_深入理解JAVA I/O_系列二:字节流详解_深入理解Java_中的_IO_JAVA:_IO_流 之 节点流与处理流java _io 节点流和处理… 深入_分析 _Java I/O 的工作机制 - 闲杂人等 - 博客园 2017年12月17日 - 关于 I/O 编码问题请参考另一篇文章 《深入_分析_Java_中的中文编码问题》。 下图是写字符的 _I/O 操作接口涉及到的类,Writer 类提供了一个抽象方法 write(char … 深入理解JAVA _I/O_系列四:RandomAccessFile - changhenshui1990的… 2018年3月1日 - 1、是JAVA _I/O_流体系中功能最丰富的文件内容访问类,它提供了众多方法来访问文件内容。 2、由于可以自由访问文件的任意位置,所以如果需要访问文件的部… _深入理解JavaIO_流_梦醒,已千年的专栏-CSDN博客 2015年6月17日 - _深入理解JavaI/O_流 阅读数 2445 其实我个人觉得,java_I/O_流是一种比较乏味的…一、声明:此文章属于个人阅读_深入理解java_虚拟机的总结记录,如有错误望… Java _I/O_体系从原理到应用,这一篇全说清楚了_u01471461…_CSDN博客 2019年11月13日 - 本文介绍操作系统I/O_工作原理,_Java _I/O_设计,基本使用,开源项目中实现高性能_I/O_常见方法和 Java_之多线程优化与CPU、_I/O_之间的_深入理解 - 云+社区 - 腾讯云 2019年9月26日 - 在高并发的场景之下,Java_经常使用到的技术就是多线程。而多线程的使用,到底是否…今天,就来介绍一下多线程,与系统CPU、核数,以及_I/O_等之间的关系。来_… 由装饰者模式来深入理解Java _I/O_整体框架 - 有图有真相 - CSDN博客 2017年7月22日 - 前言_Java_里面的_I/O_这一部分看过很多遍,每次看完之后特别混乱,又是输入流,又是输出流,又是字符流,又是字节流,还有什么过滤流,缓冲流。每次看得我如入云… 由装饰者模式来深入理解Java _I/O_整体框架 - HappyDevelop…_博客园 2018年12月12日 - _Java_里面的_I/O_这一部分看过很多遍,每次看完之后特别混乱,又是输入流,又是输出流,又是字符流,又是字节流,还有什么过滤流,缓冲流。每次看得我如入云里雾… Java深入理解IO NIO在文件复制过程中的应用 - skymouse2002的专栏 2018年6月4日 - 它在标准java_代码中提供了高速的面向块的_IO_操作。一、基本概念描述1.1 _I/O…_深入理解_HashMap 阅读数 1万+ 什么是 HashMap?​ HashMap 是基于哈希表… Java I/O理解(五)字符流的使用 - 热心网友 2018年7月4日 - 如果JAVA不能直接操作字符,我会感到JAVA对这个世界满满的恶意,所以提供对直接的…深入理解JAVA _I/O_系列二:字节流详解 阅读数 2 流的概念 JAVA程序通… 第二章:深入_分析_java _I/O_的工作机制 - tonbby - 博客园 2018年5月16日 - _I/O_的机器获取和交换信息的主要渠道,在当今数据大爆炸时代,_I/O_问题尤其突出,很容易成为一个性能瓶颈,_Java_在_I/O_上也一直做持续的优化,现在也引入了NIO,… _JavaI/O深入_学习之输入和输出__java__脚本之家 2019年6月18日 - 这篇文章主要介绍了_JavaI/O深入_学习之输入和输出,_Java_类库中的_I/O_类分成输入和输出两部分,可以在JDK文档里的类层次结构中查看到。,需要的朋友可以参考下 _深入理解IO_、NIO__Java__woshigenghua的博客-CSDN博客 2019年5月16日 - JAVA_中的 _I/OI/O 指以流为基础进行输入输出(input、output)的,所有数据被串行化Java… JAVA_中的 _I/O I/O 指以流为基础进行输入输出(input、output)的… _深入理解JAVA_的_IO_模型_Danny_idea的博客-CSDN博客 2019年4月13日 - 通俗易懂的来讲,个人比较喜欢把_io_理解成对于文件中的数据进行读取或者修改的一…_深入理解JavaI/O_流 阅读数 2445 其实我个人觉得,java_I/O_流是一种比较乏味的… 教你如何_理解JAVA_的_I/O_类库 - Java团长 - 博客园 2020年2月28日 - Java的普通 I/O 就介绍到这里了。Java的 I/O 类库用到了两个经典设计模式,装饰器跟适配器。如果想更深入_的_理解Java I/O 类库除了多读源码外(感兴趣的… 深入_分析 _Java I/O 的工作机制 2011年10月31日 - 关于 I/O 编码问题请参考另一篇文章 《深入_分析_Java_中的中文编码问题》。 下图是写字符的 _I/O 操作接口涉及到的类,Writer 类提供了一个抽象方法 write(char … Java I/O理解(二)File类的使用_热心网友-CSDN博客 2018年7月4日 - 深入理解Java _I/O_系列一:File 阅读数 620 _I/O_简介 _I/O_问题可以说是当今web应用中所面临的的主要问题之一,大部分的web应用系统的瓶颈都是_I/O_瓶颈。这… Java 中的 I/O - Dream_ling的博客 - CSDN博客 2018年9月10日 - I/O 指的是 input 和 output ,也就是输入和输出,我们说的是 Java 中的 I/O,那我们就在站在虚拟机的角度去看看有哪些输入和输出。输入又可以称为数据源… Java _IO深入理解_BufferedWriter - yhl_jxy的博客 - CSDN博客 2018年2月12日 - import java.io.BufferedWriter; import java.io.File; import java.io.FileWriter; import java.io.IOException; public class TestBufferedWriter {… java _I/O_体系总结_wthfeng的专栏-CSDN博客 2018年9月10日 - java _I/O_体系总结_I/O_流的_理解_先看看流的概念 流是一组有顺序的,有起点和终点的字节集合,是 Java _I/O_体系从原理到应用,这一篇全说清楚了 - 分布式系…_博客园 2019年11月13日 - 本文介绍操作系统I/O_工作原理,_Java _I/O_设计,基本使用,开源项目中实现高性能I/…《_深入理解_Linux内核 —— Daniel P.Bovet》 Netty之_Java_堆外内存扫盲… Java 从设计者的角度理解Java _IO_流 - Gaos的BLOG - CSDN博客 2017年7月26日 - Java I/O_是Java技术体系中非常基础的部分,它是学习Java NIO的基础。而_深入理解Java NIO则是学习现代高性能网络通信框架(比如Netty)的基础。本文试图从… 深入_分析_Java _I/O_的工作机制 (二) - 就让文谦先行 - 博客园 2019年1月14日 - 同步访问文件的方式比较容易理解,就是数据的读取和写入都是同步操作的,它与标准…历史上的今天: 2019-01-14 深入_分析_Java _I/O_的工作机制 (一) … Java _I/O_流体系 - weixin_33743880的博客 - CSDN博客 2019年1月11日 - 深入理解JAVA _I/O_系列四:RandomAccessFile 阅读数 95 一、简述 这个是JDK上的截图,我们可以看到它的父类是Object,没有继承字节流、字符流家族中任何… _Java_学到什么程度才能叫精通? - 知乎 2019年1月7日 - 《_深入理解Java_虚拟机(第2版)周志明》(推荐,豆瓣评分 8.9,1.0K+人评价):…磁盘的_I/O_操作也少一些,而且B类树是平衡树,每个结点到叶子结点的高度都是相… 深入_分析 _Java I/O 的工作机制 2011年10月31日 - 关于 I/O 编码问题请参考另一篇文章 《深入_分析_Java_中的中文编码问题》。 下图是写字符的 _I/O 操作接口涉及到的类,Writer 类提供了一个抽象方法 write… 深入理解Java Web技术笔记 - 简书 2017年9月17日 - 不会对要点进行分析,因为具体分析,可以参考&lt;_深入_分析_Java_ Web技术(修订版)&gt;这…总之,同步/异步、阻塞/非阻塞这4种模式存在都是为了具体场景提高_I/O_读… 深入_分析 _Java I/O 的工作机制 关于 I/O 编码问题请参考另一篇文章 《深入_分析_Java_中的中文编码问题》。 下图是写字符的 _I/O 操作接口涉及到的类,Writer 类提供了一个抽象方法 write(char … _深入理解Java_中的各种_IO_流_java_i6223671的博客-CSDN博客 2019年4月5日 - 深入理解Java_中的_IO_引言: 对程序语言的设计者来说,创建一个… _深入理解Java_中的_IO 引言: 对程序语言的设计者来说,创建一个好的输入/输出(I/O)系统是… 从原理到应用,一文说透 Java 的 I/O 体系__Java_学习之道-CSDN博客 2020年3月16日 - 本文介绍操作系统I/O_工作原理,_Java _I/O_设计,基本使用,开源项目中实现高性能I/…《_深入理解_Linux内核 —— Daniel P.Bovet》 Netty之_Java_堆外内存扫盲贴 ——… 深入理解java:3. NIO 编程 - 张俊鸿 - 博客园 2017年4月26日 - 深入理解java:3. NIO 编程 I/O_简介 _I/O_即输入输出,是计算机与外界世界的一个借口。 _IO_操作的实际主题是操作系统。 在Java编程中,一般使用流的方式来处理_IO,… 深入理解java NIO - 辉哥的博客 2018年6月21日 - 深入理解Java NIO 阅读数 8 初识NIO:在 JDK 1. 4 中新加入了 NIO( New Input/ Output)类,引入了一种基于通道和缓冲区的 I/O 方式,它可以使用 Native … Java _I/O_不迷茫,一文为你导航! - 简书 2018年8月15日 - 前言:在之前的面试中,每每问到关于Java I/O 方面的东西都感觉自己吃了大亏..所以这里抢救一下..来深入_的_了解_一下在_Java_之中的 _I/O 到底是怎么回事..文章… _Java_核心(五)_深入理解_BIO、NIO、AIO - 王磊的博客的个人空间 - OS… 2018年12月3日 - Java_核心(五)_深入理解_BIO、NIO、AIO 原王磊的博客 发布于 2018/12/03 10:…是备份记录会写到其它机器上,这些备份记录通常都是采用异步阻塞的方式写 _… Java I/O理解(一)编码问题_热心网友-CSDN博客 2018年7月3日 - java i/o 学习总结(二)在上一篇博客中,我总结了Java _i/o_中面向字节的部分。…_深入理解IO_流中字符编码问题 阅读数 1496 首先了解一下常用的编码:ASCI… java _I/O_流关系图_Saurfang-CSDN博客 2018年6月1日 - 首先需要_了解_的就是什么是流。流呢就是一连串的字符,它是根据先进先出的方式来…_Java_笔记十九._深入_解析_I/O_编程之流的层次结构 阅读数 1731 _深入_解析_I/O_编程… 精通_java_之_IO_流详解 - 皮皮王的专栏 - CSDN博客 2016年12月20日 - Java 流在处理上分为字符流和字节流。字符流处理的单元为 2 个字节的 Unicode…深入理解Java _I/O_系列二:字节流详解 阅读数 530 流的概念JAVA程序通… 浅谈_JAVA_中的_I/O_流(一)_qq_32303793的博客-CSDN博客 2018年8月2日 - 今天学习了_I/O_流,所以和大家聊一下 关于_I/O_流的一些写法与个人心得! 首先…_深入理解 Java_中的 流 (Stream) 阅读数 19 个人小站,正在持续整理中,欢… Java _I/O_体系从原理到应用,这一篇全说清楚了 - 简书 2019年11月13日 - 本文介绍操作系统I/O_工作原理,_Java _I/O_设计,基本使用,开源项目中实现高性能_I/O_常见方法和实现,彻底搞懂高性能_I/O_之道 基础概念 在介绍_I/O_原理之前,先… Java _I/O_不迷茫,一文为你导航! - 我没有三颗心脏 - 博客园 2018年8月16日 - 前言:在之前的面试中,每每问到关于Java I/O 方面的东西都感觉自己吃了大亏..所以这里抢救一下..来深入_的_了解_一下在_Java_之中的 _I/O 到底是怎么回事..文章… 第2章 深入_分析_java _I/O_的工作机制(上) - 刘大飞 - 博客园 2017年8月3日 - 基于字符操作的_I/O_接口:Writer 和 Reader。(一个字符占两个字节),字符流处理的单元是2个字节的Unicode字符。字符流是由_JAVA_虚拟机将字节转化为2个字节… 深入理解Java NIO - 爱传文档的专栏 2018年12月11日 - 在正式介绍 Buffer 之前,我们先来 Stream,以便更深刻的理解 Java IO 与 NIO 的不同。2.1 StreamJava IO 是面向流的 I/O,这意味着我们需要从流中读取一个… Java _IO深入理解_BufferedInputStream - yhl_jxy的博客 2018年2月12日 - Java IO深入理解_InputStream 阅读数 448 InputStream类是_Java IO API中所有输入…Java:利用_I/O_流读取文件内容 阅读数 7万+ 要利用_I/O_流读取文件内… 深入_分析 _Java I/O 的工作机制__IO__Baple的专栏-CSDN博客 2014年6月30日 - 【转自】https://www.ibm.com/developerworks/cn/_java_/j-l… 深入_分析_Java _I/O_的工作机制_I/O_问题是当今Web应用中所面临的主要问题之一。因为在当… 一。深入了解_JDK1.8 从Package _java._io_开始 - harry的博客 2018年3月23日 - IO_Error 当出现严重_I / O_错误时抛出。 Package _java.io Description 通过数据流…背景:因为面试被问到了,而且一直以来想去_深入了解_一下JDK1.8的新特… 《深入理解 Java 虚拟机》读书笔记:Java 内存模型与线程…_博客园 11小时前 - 大量的时间都花费在磁盘 I/O_、网络通信或者数据库访问上,导致处理器在大部分…0 0 « 上一篇: 《_深入理解 Java 虚拟机》读书笔记:晚期(运行期)优化 posted… Java _I/O_简介_小晶的博客-CSDN博客 2019年7月31日 - 1、IO_可以写作_I/O,是Input/Output的缩写,也就是输入输出,这里的输入输出是指不同系统… 深入理解Java 字节I/O,字符I/O,字节流于字符流的区别,阻塞I/O… Java I/O : 概述 - CSDN博客 2016年6月23日 - Java I/O 是机器获取和交换信息的主要渠道,当前在这个海量数据时代,数据在网络中随处流动,这个六到的过程都涉及到_I/O_问题,可以说_I/O_问题是整个人机交… 一、Java _I/O_是什么? - fubo1990的博客 - CSDN博客 2018年9月26日 - 我们既然要学习JavaI/O_那我们首先要知道_JavaI/O_是什么?以及_JavaI/O_在_java_开发中应用。今天我们主要就这两个大问题进行讲解,然后在接下来的课程中,不断_… 深入_分析 _Java I/O 的工作机制 2011年10月31日 - 本文的目的正是分析 I/O 的内在工作机制,你将了解_到:_Java 的 I/O 类库的基本架构;磁盘 I/O 工作机制;网络 I/O 的工作机制;其中以网络 I/O 为重点介绍 … Java _IO深入理解_BufferedReader(代码实例) - _JAVA_编程…_红黑联盟 2018年2月13日 - BufferedReader是缓冲字符输入流,它继承于Reader。 BufferedReader的作用是为其他字符输入流添加一些缓冲功能。 创建BufferReader时,我们会通过它的构… Java_高级篇(四十)—_Java IO深入理解 - 小码农——虚竹 2017年8月31日 - 深入理解Java_中的_IO_引言: 对程序语言的设计者来说,创建一个好的输入/输出(_I/O)系统是一项艰难的任务 本文的目录视图如下:Java _IO_概要 a.Java _IO_中常用… 深入_分析 _Java I/O (七)_IO_模型一基础知识__Java__keep_tr…_CSDN博客 2018年2月24日 - 当您了解_到 _I/O 花在一个数据单元上的时间是处理时间的 20 倍,这样的结果…深入_分析 _Java I/O (八)… qq_35495763:Java 呢? 标题不对吧,兄弟 RPC… Java _I/O_学习(附实例和详解)__java_,_io__小宝鸽-CSDN博客 2016年3月6日 - 一、Java I/O_类结构以及流的基本概念在阅读_Java _I/O_的实例之前我们必须清楚一些概念,我们 java _I/O_底层是如何工作的? - Code-lover’s Learning N…_CSDN博客 2015年6月6日 - 本博文主要讨论I/O_在底层是如何工作的。本文服务的读者,迫切希望_了解Java _I/O_操作是在机器层面如何进行映射,以及应用运行时硬件都做了什么。假定你熟… _深入理解Java_Web技术内幕之中文编码 - 高适 - 博客园 2015年7月2日 - Reader类是Java I/O 中读取字符的父类,InputStream是读取字节的父类。InputStream…3. _深入理解Java_Web技术内幕(一)(3088) 4. Struts2+Ajax实现检测… 深入了解 Java 字节码 - mgh_io_ - 博客园 2020年3月19日 - 中常量池分别得到字段名为: numberA,描述符为: I(在JVM 中的I_代表 _Java 中…了解_字节码文件的组成结构对后面进一步_了解_虚拟机和_深入_学习 _Java 有很重要的意义… 深入理解Java AIO(三) - 肥宅快乐码 - 博客园 2020年3月4日 - 深入理解Java AIO(三)—— Linux中的AIO实现 我们调用的Java AIO底层也是要…在 Linux 的缓存 I/O 机制中,操作系统会将 I/O 的数据缓存在文件系统的页… 深入理解Java NIO_houboTech的博客-CSDN博客 2018年11月4日 - 深入理解Java NIO转载自:https://www.cnblogs.com/geason/p/5… I/O 方式,它可以使用 Native 函数库直接分配堆外内存,然后通过一个存储在 Java 堆的 … 深入_分析 _Java I/O (四)AIO_keep_trying的专栏-CSDN博客 2018年2月9日 - 在之前博客中学习了Java_中的BIO和NIO的模型及使用(初始_Java_BIO和NIO),今天来学习一种新的_I/O_模型——AIO。3.1 什么是AIO AIO(Asynchronous _IO):AI… java I/O_和N_I/O 详解_topdeveloperr的博客-CSDN博客 2018年9月4日 - 目录I/O_概述字符流字节流理解_I/O_超类结构FileInputStream详解 FileOutput… java _I/O_就是指的java在输入输出上的技术…_深入理解Java 字节I/O,字符I/… java _I/O__gao_sl的博客-CSDN博客 2018年6月4日 - 以及Java I/O_在_java_开发中应用。今天我们主要就这两个大问题进行讲解,然后在接下来的课程中,不断_深入_的_了解… 博文 来自: fubo1990的博客 Java_—_I/O… Java 中的 _I/O__余同学的开发之路-CSDN博客 2018年9月10日 - I/O 指的是 input 和 output ,也就是输入和输出,我们说的是 Java 中的 I/O… I/O 指的是 input 和 output ,也就是输入和输出,我们说的是 Java 中的… _深入理解java_集合框架(jdk1.6源码) - I_M_ROOKIE的博客 2018年6月10日 - _深入理解java_集合框架(jdk1.6源码) 原创 I_M_ROOKIE 发布于2018-06-10 18:…publicboolean contains(Object o){ Iterator e = iterator(); if(o==… _JavaI/O_体系详解 - weixin_34250434的博客 - CSDN博客 2016年3月27日 - Java中_IO_操作主要是指使用Java进行输入,输出操作,Java中所有的_IO_操作类都存放在Java._io_包中,在使用…_深入理解JavaI/O_流 阅读数 2336 其实我个人觉得… _Java_8 _I/O_源码-整体结构_潘威威的博客-CSDN博客 2017年9月22日 - 在详细地对_JavaI/O_系统中的各个类进行讲解前,先复习下_JavaI/O_的整体结构。如下图所示,基本 Java File I/O - 习惯成自然 - CSDN博客 2019年3月13日 - java.nio.file软件包为文件_I/O_和访问默认文件系统提供了全面支持。 虽然软件包…_深入理解JavaI/O_流 阅读数 2115 其实我个人觉得,java_I/O_流是一种比… 20200321——_深入java_中的_io__xixi-CSDN博客 2020年3月21日 - Java Io_流共涉及40多个类,这些类看上去很杂乱,但…_Java IO_流的40多个类都是从如下4个抽象类基类中…_深入_分析_Java_Web技术内幕——_深入_分析_Java _I/O_的… Java 干货之_深入理解Java_泛型 - 逸游Java - 博客园 2018年9月28日 - 泛型大家都接触的不少,但是由于Java 历史的原因,Java…{ Object o1 = a[i]; Object o2 = a2[i];…2. Java 干货之深入理解_String(2) 3. _Java 干货… 深入_分析 _Java I/O 的工作机制 - OSCHINA 2011年11月2日 - Java 的 I/O 类库的基本架构 I/O 问题是任何编程语言都无法回避的问题,可以说 I/O 问题是整个人机交互的核心问题,因为 I/O 是机器获取和交换信息的主要渠道… java I/O 模型_whp404的博客-CSDN博客 2018年8月27日 - 在Java_语言中,一共提供了三种_IO_模型,分别是阻塞_IO(BIO)、非阻塞IO(NIO)、异步…java I/O_模型 博文 来自: xinyuan的专栏 _java 23种设计模式 深入理解… Java _I/O_流知识综合实战 - _Java_软贱攻城狮 - CSDN博客 2018年1月25日 - import java.util.Date; import java.util.Scanner; /* * 优化了上一个Demo的代码,新增获取文件属性内容的方法 * 运用的知识点有: * 1._I/O_类; * 2.Sca… Java 7之异步_I/O_第5篇 - 异步_I/O_操作之通道_聚沙成塔…_CSDN博客 2014年2月1日 - 与 java.net 的类(Socket、ServerSocket和Datagram…对象上尝试一个 I/O 操作会导致 …后续我们将_了解_到如何使用选择器来避免进行轮询并在… 轻松_理解java_中的_IO_与NIO - zuiyingong6567的博客 2018年4月12日 - 传统_JavaIO_是基于阻塞_I/O_模型。这意味着,当一个线程调用read() 或 write()时…_深入理解_MVC w1070216393:想问下 这样和mvp 还有区别吗 _深入理解_MVC … Java _I/O_流体系 - weixin_34054931的博客 - CSDN博客 2019年1月8日 - 深入理解JAVA _I/O_系列四:RandomAccessFile 阅读数 95 一、简述 这个是JDK上的截图,我们可以看到它的父类是Object,没有继承字节流、字符流家族中任何… java I/O 流知识点总结 - 王文强的博客 - CSDN博客 2019年5月24日 - Stream在以面向字节形式的_I/O_中可以提供极有价值的…Reader和Writer则提供兼容Unicode与面向字符的_I/O_功能…_深入理解JavaI/O_流 阅读数 2218 其实我… Java _I/O_— 梳理各种“流”_To Begin,Begin -CSDN博客 2015年6月7日 - 背景Java_的核心库_java.io_提供了全面的_IO_接口。包括:文件读写、标准设备输出等。Ja… 本文的目标是梳理_java._io_中各个类的关系,_了解_各个类的应用场景。… Java 的 I/O 类库的基本架构 - 如.若 - 博客园 2018年11月30日 - 关于 I/O 编码问题请参考另一篇文章 《深入_分析_Java_中的中文编码问题》。 下图是写字符的 _I/O 操作接口涉及到的类,Writer 类提供了一个抽象方法 write(char … _深入理解Java_的三大特性之多态 - 程序员-陈生 - 博客园 2018年12月15日 - [i].toString() + “–” + wines[i].drink()…(super)O),this 为 b,O 为 C,(super)O 即 …5. Java_多线程_深入理解(1) 推荐排行榜 1. 对于Java… Java _I/O_之 实现目录列表 - C_U_N_Z的博客 - CSDN博客 2019年5月19日 - 由装饰者模式来深入理解Java _I/O_整体框架 阅读数 950 前言Java里面的_I/O_这一部分看过很多遍,每次看完之后特别混乱,又是输入流,又是输出流,又是字符流… java nio_深入理解__东东的专栏-CSDN博客 2019年3月7日 - 初识NIO:在 JDK 1. 4 中新加入了 NIO( New Input/ Output)类,引入… 引入了一种基于通道和缓冲区的 I/O 方式…java NIO selector全面深入理解 阅读数 86… Java I/O Streams - 习惯成自然 2019年3月13日 - 前言Java_中基础的_I/O_知识包括两方面:_I/O Streams 和 File I/O_。这部分学习_I/O Streams。I/O Streams_I/O_ Streams 大大简化了IO_操作。_java.io 包中包含了… i/o_流的_理解 - leng15183596537的博客 2018年9月19日 - 深入理解 Java_中的 流 (Stream) 阅读数 11 个人小站,正在持续整理中,欢迎访问…_I/O_是什么我的理解_I/O_就是用于读写的一个流官方解释:_I/O(英语:Input/… 关于_Java_中的_I/O_流的总结 - _Java__han的专栏 - CSDN博客 2015年4月25日 - 1. _java_中_I/O_的相关概念介绍:_Java_中的读写操作基本分为两种形式:字节流(byte、8位、一般以Stream结尾)、字符流(char、16位、一般以Reader、Writer结尾… 深入_浅出_理解Java NIO系列—第1篇 - Jin_Kwok的博客 2018年5月23日 - 深入_浅出_理解Java NIO系列—第1篇 概述 1. IO_和NIO的含义 1.1 _IO_的含义 …由于之前老的_I/O_类库是阻塞_I/O,New _I/O_类库的目标就是要让Java支持非阻塞… java _I/O_之装饰者模式 - 博学而笃志,切问而近思 - CSDN博客 2013年8月24日 - 由装饰者模式来深入理解Java _I/O_整体框架 - 有图有真相 421 前言Java里面的_I/O_这一部分看过很多遍,每次看完之后特别混乱,又是输入流,又是输出流,又是… Java _I/O_流概念 - u012934551的博客 - CSDN博客 2015年12月31日 - Java_的原始版本(_Java 1.0)不包括字符流,因此所有的I/O_都是以字节为单位。 …_深入理解 I/O 概念 阅读数 283 _I/O_空间—–_I/O_端口和_I/O_内存 首先上图… _深入理解IO_流中字符编码问题__Java__dream_goon的专栏-CSDN博客 2014年7月11日 - 首先_了解_一下常用的编码: ASCII:ASCII码是7位编码,…每个_Java_程序员都应该记住,_Java_使用的是Unicode编码。… 深入理解 I/O 概念_qq_33620667的博客-CSDN博客 2017年5月1日 - _I/O_空间—–_I/O_端口和_I/O_内存 首先上图,如下:外设中的寄存器被称为_I/O_端口,外设中的… 首先上图,如下:外设中的寄存器被称为_I/O_端口,外设中的内存被称… 3句话帮你搞定Java _I/O_底层原理之一:字符流、字节流及其区别 3天前 - Java中的流是对字节序列的抽象。 数据在两设备间的…Java中的字节流处理的最基本单位为单个字节,它通常用来…深入理解Java 字节I/O,字符I/O,字节流于字符流的… Java _I/O_系统_xingweiyang的博客-CSDN博客 2018年9月29日 - Java _I/O_系统 **Java I/O_系统概述… 要_深入_学习_Java _I/O_系统,首先必须_理解_流(Stream)的概念。那么,什么是流呢?流是一个很形象的概念,当程序需要… Java _I/O_介绍_anshanzhan4329的博客-CSDN博客 2018年12月1日 - Java _I/O_介绍转载于:https://www.cnblogs.com/HopkinsCybn/… _深入理解JavaI/O_流 阅读数 2445 其实我个人觉得,java_I/O_流是一种比较乏味的事情。因为… I/O - _理解Java_中字符流与字节流的区别__I/O__YellowStar…_CSDN博客 2018年9月9日 - Java中的流是对字节序列的抽象,我们可以想象有一个水管,只不过现在流动在水管中…_深入理解JavaI/O_流 阅读数 2445 其实我个人觉得,java_I/O_流是一种比较乏味的… Java _IO深入理解_BufferedReader__Java__yhl_jxy的博客-CSDN博客 2018年2月12日 - 一BufferedReader概述BufferedReader是缓冲字符输入流,它继承于Reade_Java_… Java _IO深入理解_BufferedReader 原创 街灯下的…一、控制台_I/O_读取键盘输入内置函数input… _Java_基础(14):_IO_流—_理解I/_0概念和掌握相关类的作用(附有操作代码… 2017年4月9日 - 在Java中如果要进行输出和输入操作,就需要使用到_IO_流,例如第一次写的语句System…_深入理解JavaI/O_流 阅读数 2431 其实我个人觉得,java_I/O_流是一种比… Java _IO_编程全解(一)——_Java_的_I/O_演进之路 - weixin_3…_CSDN博客 2017年10月16日 - 在Java_支持异步_I/O_之前的很长一段时间里,高性能服务端开发领域一直被C++和C长期占据,_Java_的同步阻塞_I/O_被大家所诟病。在JDK1.4推出_Java NIO之前,基于J… _Java_进阶–_深入理解_ArrayList实现原理_有图有真相-CSDN博客 2017年5月19日 - (int i=0;i&lt;10;i++) list_2.add(i); …上面代码做几点说明:lastIndexOf(Object o)在…_Java_进阶–_深入理解_ArrayList实现原理 阅读数 33429 … Java NIO编程理论基础篇——Java _I/O_的发展以及linux网络_I/O_模型 2019年1月1日 - 发展简述:Java在jdk1.4之前,Java对I/O_的支持并不完善,开发人员会遇到许多问题,例如:… _深入理解JAVA _I/O_系列六:Linux中的_IO_模型 阅读数 2 _IO_模型 linux系统… 对_Java_中File _I/O_的_理解__Coder编程的博客-CSDN博客 2016年7月26日 - 下面我谈下自己的理解_。 对于相对路径名,绝对路径名大家一般都是叫相对路径,绝对路径。很少用到抽象路径名。 相对路径名:比如一个项目存在D:\\Work_Java_Work_IO … _Java_中_I/O_流 - scbiaosdo的博客 - CSDN博客 2018年5月17日 - _深入理解JavaI/O_流 阅读数 2406 其实我个人觉得,java_I/O_流是一种比较乏味的事情。因为看不到明显的运行效果,但是输入输出程序都需要用到_I/O_操作即:允… Java _I/O_体系从原理到应用,这一篇全说清楚了-站长资讯中心 2019年11月13日 - Java I/O_体系从原理到应用,这一篇全说清楚了 本文介绍操作系统_I/O_工作原理,_Java _I/O_设计,基本使用,开源项目中实现高性能_I/O_常见方法和实现,彻 深入理解Java PriorityQueue - CarpenterLee - 博客园 2016年5月13日 - Java中PriorityQueue通过二叉小顶堆实现,可以用一棵完全…i])元素的下标 int i = indexOf(o); if (i …分类: _深入理解Java_集合框架 标签: JCF, Java, … Java NIO1:_I/O_模型概述 - 五月的仓颉 - 博客园 2015年12月24日 - 在开始NIO的学习之前,先对I/O_的模型有一个_理解,这对NIO的学习是绝对有好处的…可以,和我看的深入_分析_Java Web中类似 支持(0) 反对(0) #3楼 2017-02… java_高级特性与实战项目——第三张-File _I/o,课后作业 - qq… 2018年5月20日 - 黑马程序员——_Java_基础—_I/O_流(上[异常]) 阅读数 319 ——_Java_培训、…_深入理解_ArrayList 阅读数 1万+ 什么是ArrayList? ArrayList的实现原理其… _Java_学到什么程度才能叫精通? - 知乎 2015年3月20日 - 磁盘的_I/O_操作也少一些,而且B类树是平衡树,每个结点到叶子结点的高度都是相同…《写给大忙人看的JavaSE8》 《_深入理解Java_虚拟机:JVM高级特性与最佳… 通过观察者模式和Reactor模式深入理解JAVA NIO 线程 - 迷失代码… 2013年9月2日 - Java NIO非堵塞应用通常适用用在_I/O_读写等方面,我们知道,系统运行的性能瓶颈通常在_I/O_读写,包括对端口和文件的操作上,过去,在打 开一个_I/O_通道� … Java I/O 操作及优化建议(I/O,NIO,AIO) - 正走向大牛的菜鸟 - IT… 2015年6月24日 - Java I/O_I/O_,即 Input/Output(输入/输出) 的简称。就 I/O 而言,概念上有 5 种模型:blocking I/O,nonblocking I/O,I/O multiplexing (select and poll… 从设计者的角度理解Java _IO_流 - 51Testing软件测试网 2017年2月13日 - 摘要Java I/O_是Java技术体系中非常基础的部分,它是学习Java NIO的基础。而_深入理解Java NIO则是学习现代高性能网络通信框架(比如Netty)的基础。本文… JAVA _IO_流精讲上_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliJava NIO核心组件的深入理解-_java_教程-PHP中文网 2018年11月16日 - 本篇文章给大家带来的内容是关于Java NIO核心组件的深入理解,有一定的参考价值,…基于此,诞生了Java NIO,NIO的代表性特征就是非阻塞_I/O_。紧接着我们发现,简单… 26.Java IO(一)-教育-高清完整正版视频在线观看-优酷程序员:_java_集合介绍,带你_深入理解_list集合 2019年12月12日 - 作为一个程序猿,_Java_集合类可以说是我们在工作中运用…boolean contains(Object o):判断集合中是否存在指定… java_打 _i/o-i/o-高_i/o_型本地盘 - 阿里云 阿里云云栖社区为您免费提供java_打 _i/o_的相关博客问答等,同时为你提供_java_打 _i/o-i/o-高_i/o_型本地盘等,云栖社区以分享专业、优质、高效的技术为己任,帮助… _深入理解Java_多线程——线程池 java java8 java开发 _深入理解Java_多线程——线程池目录 定义 不同线程池的…如果是需要较多等待的任务,例如_I/O_操作比较多,可以参考Brain Goetz推荐的计算… Java-IO 流 - h3399 Java 中可以通过对象流将一个序列化的对象保存到硬盘中, 或者硬盘中读取一个对象…java 成神之 – 文件 IO 深入理解 java I/O Java 基础知识 (JAVA 之 IO… Java IO:理解 阻塞/非阻塞式IO_、同步/异步_IO - 程序员大本营 “I/O Models ”,Stevens在这节中详细说明了各种_IO_的特点和区别,如果英文够好…Stevens的文风是有名的_深入_浅出,所以不用担心看不懂。本文中的流程图也是截取… 深入_分析_java web技术内幕电子书-深入_分析_Java Web技术内幕pdf完… 2015年6月29日 - “总体来说可读性不大,如果你都理解,读这个比较浪费时间,如果你都不清楚,这本…其次_深入_介绍_Java_技术,包括_I/O_技术、中文编码问题、_Java_c编译原理、class文件结构… IO_流(_JAVA)面试题_百度文库 IO_流(_JAVA)面试题_面试求职/职场_实用文档。_IO_流(_JAVA)面试题:包含原理、字节流及字符流输入和输出方法、PrintStream与BufferedWriter、PrintWriter的区别 … 标签: IO | _Java_技术栈,分享最新最主流的_Java_技术 专注分享_Java_技术干货,包括多线程、JVM、Spring Boot、Spring Cloud、Intellij IDEA、Dubbo、Zookeeper、Redis、架构设计、微服务、消息队列、Git、面试题、程序员攻略… java _io_流分不清_新网移动 2天前 - 分不清的伤java 处理 nbsp_java_ nbsp java &amp;nbspios nbsp_java_如何去掉nbsp_java_ 转换 nbsp java 去掉 nbsp_java_过滤 nbsp_java_ script _java_中的 nbsp… JavaIO 一_腾讯视频Java _IO_基础 - 教程|迷思爱学习乐园|兴趣是最好的老师 2020年3月13日 - 1. 什么是_IO_IO:_Java_对数据的操作是通过流的方式,_IO_流用来处理设备之间的数据传输,上传文件和下载文件,_Java_用于操作流的对象都在_IO_包中。I:Input输入,O… 关于_Java_异常处理机制_深入理解__Linux编程_Linux公社-Linux系统… 2019年8月4日 - Java 中的异常(Exception)又称为例外,是一个在程序执行期间发生的事件,它中断…IOException I/O 异常的根类 F ileN otF oundException 找不到文件 EOFException… 《深入_分析_Java Web技术内幕(修订版)》(许令波)【摘要 书评…_京东 2014年8月1日 - 让读者充分并深入理解_它们的内部工作原理,同时还结合了设计模式来介绍这些技术背后…第2章 深入分析_Java _I/O_的工作机制 26 2.1 _Java_的_I/O_类库的基本… _深入理解_Android(一):Gradle详解 - 『移动安全区…_吾爱破解 2018年1月29日 - 转帖《深入理解_Android》系列图书作者邓凡平,大家互相学习,共同进步!…所以,请各位开发者牢记Groovy _I/O_操作相关类的SDK地址: _java.io.File: http:… _Java_技术培训__IO_ 2013年6月20日 - 打开优酷APP,流畅到起飞_Java_技术培训__IO_简介 热度24 评论 极清 缓存 分享为你推荐 如果未来地球上100年不下雨, 会发生什么?03:20 APP内观看热度351 换… 图书管理系统(java _IO_操作)-_Java_文档类资源-CSDN下载 2009年8月13日 - 图书馆管理系统(java),桌面应用程序,包括借书还书,读者办理、遗补借阅证,图书管理等模块。 立即下载图书馆管理系统(java)上传时间: 2010-09-30资源大… - 深入理解 Android 之 Gradle - 极客学院Wiki 本节介绍下 Groovy 的文件 I/O 操作。直接来看例子吧,虽然比 Java 看起来简单,但要_理解_起来其实比较难。尤其是当你要自己查 SDK 并编写代码的时候。 … _Java_就业指导课程 - 「dt猫」 45分钟前 - 熟悉常用的Java API,包括集合框架、多线程(并发编程)、I/O(NIO)、…对Servlet和JSP的工作原理和生命周期有深入了解,熟练的使用JSTL和EL编写无… _Java_——_I/O_学习(一)_IT_dream_FeiYang的博客-CSDN博客 2018年3月29日 - Java I/O_学习(一)什么是_I/O?I/O_就是数据输入输出数据流,也称作数据流。_Java I/O… Java _I/O_操作主要指的是使用_Java_进行输入、输出操作,_Java_中的所有… _深入理解Java_虚拟机的重点知识_fallwind_of_july的博客-CSDN博客 2019年5月20日 - 欢迎访问:https://andyofjuly.github._io_/博文主要介绍了java虚拟机的相… JAVA虚拟机是理解JAVA特性、JAVA多线程编程的重要基础,这篇文章整理自:《_深入理解JAVA_虚拟… Java _I/O_各种流使用方法及编程举例 - 妖精小狗的博客 2018年8月5日 - 以及Java I/O_在_java_开发中应用。今天我们主要就这两个大问题进行讲解,然后在接下来的课程中,不断_深入_的_了解… 博文 来自: fubo1990的博客 Java_—_I/O… Java _I/O_流基础知识点详解_LaoYe的博客-CSDN博客 2019年3月8日 - 目录一、Java-_IO_流的概述二、流的概念和作用三、流的分类 3.1输入流和输出流 3.2… 【_I/O_流】 Input/Output:输入输出机制 输入机制:允许_java_程序获取… _深入理解_C语言—标准_I/O_小结(缓冲区,_I/O_函数及其他相…_CSDN博客 2014年4月11日 - 与文件_I/O_围绕文件描述符操作不同,标准_I/O_的操作是围绕… 这三个标准_I/O_流通过预定义(stdio.h)文件指针stdin,stdout,stderr加以引用当一个进程正常终… Java _IO深入理解_FileOutputStream - yhl_jxy的博客 2018年2月11日 - Java IO深入理解_OutputStream 阅读数 249 OutputStream…的是_java _io_包中的FileInputStream类和File_Oo_utput…I don’t care how disappointing it m… 【_Java_核心技术卷】_I/O_详析__Java_核心技术卷_醉里挑灯看…_CSDN博客 2019年9月9日 - 在文件_I/O_中,要从一个文件读取数据,应用程序首先要调用操作系统函数并传送文件…【Java核心技术卷】_深入理解Java_的接口 阅读数 1215 人若是没有梦想… Java—关于_I/O_流的一些总结 - weixin_40777510的博客 - CSDN博客 2018年8月23日 - Java 1. _I/O_流中常用的类 文件和目录路径名的抽象表示形式。 File 字节输入流:读 FileInputstream(实现类) Inputstream(根类) 字节输出流:写 FileO… _深入_分析_Java_中的_I/O_类的特征及适用场合 - Bettarwang的专栏 2014年11月17日 - _Java_中有40多个与输入输出有关的类,如果不理清它们之间的关系,就不能灵活地运用它们。 本文利用EA绘制了_I/O_相关的类的关系,特别是继承关系示意图,并且… _Java_内存模型的_深入理解___java_,面试,架构_烂猪皮的博客-CSDN博客 2019年4月25日 - 在Java 中,所有实例域、静态域 和 数组元素存储在堆内存中,堆内存在线程之间共享…在一个处理器执行总线事务期间,总线会禁止其它所有的处理器和 I/O 设备执行… _深入理解Java_序列化机制:ObjectOutputStream源码简要分…_CSDN博客 2018年9月3日 - Java的_I/O_框架之ObjectOutputStream和ObjectInputStream 阅读数 68 ObjectInputStream…_深入理解java_序列化机制 阅读数 513 序列化是指对象通过写… _Java_常见的_I/O_读写方法 - 子耶 2018年6月20日 - _Java_的_I/O_操作比较多,具体可以查询_Java_文档,Chrome中使用Ctrl+F查询_io_或nio即可…_深入理解_HashMap 阅读数 7393 什么是 HashMap?​ HashMap 是基于哈… _Java_常见的_I/O_读写方法 - 子耶 2018年6月20日 - _Java_的_I/O_操作比较多,具体可以查询_Java_文档,Chrome中使用Ctrl+F查询_io_或nio即可…_深入理解_HashMap 阅读数 7393 什么是 HashMap?​ HashMap 是基于哈… Java-_I/O_学习(1)__java_,大数据,编程语言_Coder_py的博客-CSDN博客 3天前 - Java-I/O_学习(1)_Java _IO_是_java_中的相关API,主要目的为读数据与写数据(inpu… 原文出处:lbd’s blog _java_中_i/o_操作…2篇_深入理解_计算机系统笔记系列 1篇操作… Java _IO深入理解_InputStream - yhl_jxy的博客 2018年2月9日 - Java IO深入理解_FileInputStream 阅读数 733 一FileInputStream概述FileInputStream…_Java I/O 教程(七) DataOutputStream和DataInputStream 阅读数… 深入理解_NIO系列 - _Java NIO类概述_I Have A Dream-CSDN博客 2019年3月2日 - JDK1.4新引入的NIO概念,一种全新的、极好的Java I/O_示例,提供与_I/O_服务的…_java NIO selector全面深入理解 阅读数 8650 java NIO selector全面深入理解 … 图解_java_的BI0,NIO,最简单直白的_理解_同步和异步_IO_模型 - Seeker… 2017年3月31日 - 最古老的javaIO_通信模式BIO,即阻塞_IO,同步调用,性能低: 在服务器端:有专门的…_深入理解IO_、NIO 阅读数 65 _JAVA_中的 I/OI/O 指以流为基础进行输入输… _java_中的_I/O_与NIO区别 - remember_rng的博客 2018年12月21日 - java_中的_I/O_与NIO区别一、_I/O_于NIO的基本概念:_I/O_即普通_I/O,是我们比较常用的一种形式,_I/O_又称阻塞_IO_。在默认情况下,文件操作都是阻塞_IO_。当线程需要… _深入理解Java_中的String_Java_efan的博客-CSDN博客 2018年4月11日 - String类先看一下源码(jdk1.8.0_144)中的对于类的定义public final cl_Java_… public final class String implements java.io.Serializable, Comparab… Java _IO深入理解_FileInputStream - yhl_jxy的博客 2018年2月11日 - Java _IO深入理解_FileInputStream 原创 街灯下的小草 发布于2018-02-11 11:01:…_I/O_流之进步认识、InputStream以及FileInputStream 阅读数 2万+ File… Java_自学-_I/O 对象流_我的博客-CSDN博客 2019年5月17日 - Java 对象流 ObjectInputStream,ObjectOutputStream对象流指的… Java 对象流 ObjectInputStream,ObjectOutputStream 对象流指的是可以直接把一个对象以流的形式传输给其… java _I/O_———内存操作流 - qq_43223415的博客 - CSDN博客 2019年2月13日 - import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; …_深入理解JavaI/O_流 阅读数 2072 其实我个人觉得,java_I/O_流是一种… java _I/O_库中设计模式的应用 - 像风一样奔跑 2016年6月4日 - 在_java_语言 _I/O_库的设计中,使用了两个结构模式,即装饰模式和适配器模式。 在任何一种计算机语言中,输入/输出都是一个很重要的部分。与一般的计算机语言相比,… _javaI/O_流简介与文件流、缓存流、对象流编写测试 - wei…_CSDN博客 2019年1月14日 - Java所有的_I/O_机制都是基于数据流进行输入输出,这些数据流表示了字符或者字节…_深入理解JavaI/O_流 阅读数 2340 其实我个人觉得,java_I/O_流是一种比较… 深入理解_磁盘_I/O - YABAJ的专栏 2019年4月25日 - 磁盘_I/O_原理 磁盘每个盘片为双面,每个面上分布一圈一圈的同心圆磁道,磁道由扇区组成。外围的扇区更宽,扇区的存储空间是一样的,一般每个扇区600字节,数据存储区… 【Java.IO_】_I/O 流,流的分类_王晓斌的专栏-CSDN博客 2014年9月26日 - 在Java中,一个可以读取字符序列的对象被称为shuruliu… 在JAVA中,对于数据的输入/输出操作都是以“流”的方式…_深入理解JavaI/O_流 阅读数 2440 其… 【_深入理解_计算机系统】系统级_I/O__漫游学海之旅-CSDN博客 2017年11月12日 - 【深入理解_计算机系统】第十章 系统级_I/O_1.UNIX _I/O_所有的_I/O_设备(如磁盘…参考博客[1]https://www.byteslounge.com/tutorials/_java-ee-html5-websoc… [JDK1.8] Java-_I/O_流使用概述 - vivisoul的专栏 - CSDN博客 2018年6月14日 - Java I/O_分为两大类: 字节与数字型 _I/O 和字符与文本型 I/O_。而_Java_中…_深入了解_JDK1.8 从Package _java.io_开始 _Java IO _JAVA_的节点流和处理流 _IO_、… _Java_对多路复用_I/O_技术的支持__Java__TomWu的博客-CSDN博客 2017年9月14日 - Java_对多路复用_I/O_技术的支持一、重要概念:Channel Channel通道,是一个用来_Java JDK学习—_深入理解java_中的HashMap、HashSet底层实现…_博客园 2017年9月24日 - 刚刚添加好《JDK学习—_深入理解java_中的String》一篇…这样真正的拥有的a&lt;i+1&gt; 数据元素的结点就没有了…Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o;… JAVA Coder 的《深入_分析_Java Web 技术内幕》读书笔记…_博客园 2019年7月13日 - 大部分Web应用系统的瓶颈都是I/O_瓶颈,包括Java的_I/O_类库的基本结构,磁盘_I/O…这一部分内容不如 周志明 的《_深入理解Java_虚拟机:JVM高级特性与最佳实… _java_基础——_I/O_流_jiangmanshan的博客-CSDN博客 2016年11月25日 - _Java_的_I/O_流提供了… 博文 来自: weixin_30794491的博客 Java _I/O_流总结 阅读数 308 近期学习Hadoop的过程中,发现对流的概念_理解_的不是很_深入_。决… _Java_之_I/O_流 - 卑鄙的我 - CSDN博客 2019年3月5日 - 前言 一个好的程序语言,完善的输入输出功能是必不可少的。在_Java_中将不同来源和目标的数据统一抽象为流,通过对流对象的操作来完成_I/O_功能。_Java_中的流… …第十七、十八章(容器的深入_研究,_Java _I/O_系统) - keyto1的… 2019年6月23日 - 终于到了容器的深入_研究这一章,这一章的内容可以说…随便把作者的总结写一下(实际上是自己_理解_的不行,…_Java _I/O_流类库的确能满足我们的基本需求:我… _Java_的_I/O_类库的基本架构 - 听风不是雨,归来是少年 - CSDN博客 2019年11月16日 - _I/O_问题是任何编程语音都无法回避的问题、可以说_I/O_问题是整个人机交互的核心问题…虽然_Java_的序列化能够保证对象的状态的持久保存,但是遇到一些对象结构复杂的情况… Java _I/O_系统学习笔记(File以及Stream) - weixin_34326…_CSDN博客 2017年11月8日 - “流”屏蔽了实际的_I/O_设备中处理数据的细节。_Java_类库中的_I/O_类分成输入和输出两部分,可以在JDK文档里的类层次中查看到。通过继承,任何自InputStream… Java NIO之—什么是I/O? - Java_升级攻略 启蒙进阶_深入 - CSDN博客 2015年1月28日 - 本笔记来自《Java NIO》(译本,来自互联网)和原著《Java NIO》(Ron Hitchens,O…深入理解Java_字节_I/O,字符I/O,字节流于字符流的区别,阻塞_I/O_的缺点,非… Java_中输入输出(_IO)和流的基本概念 - 你只管努力, - CSDN博客 2017年4月20日 - 输入输出(I/O)是指程序与外部设备或其他计算机进行交互的操作。几乎所有的程序都…java23种设计模式 28篇 Linux篇 4篇 _深入理解java_虚拟机篇 3篇 … _java_中的_I/O_操作 - sinat_25905165的博客 - CSDN博客 2018年11月10日 - _Java_中_I/O_操作主要是指使用_Java_进行输入,输出操作. _Java_所有的_I/O_机制都是基于数据流进行输入输出,这些数据流表示了字符或者字节数据的流动序列。 数… JAVA_编程学习记录(file类/字节流输入输出(_I/O)) - 学编…_CSDN博客 2018年5月16日 - 设备之间的传输称为流,流的本质就是数据传输,在Java中流的类都放在java._io_的…_深入理解JavaI/O_流 阅读数 2230 其实我个人觉得,java_I/O_流是一种比较… Java NIO_深入理解_与编程实例_纸上得来终觉浅,绝知此事…_CSDN博客 2019年10月30日 - Github示例:https://github.com/Nuclear-Core-Learning/… (New I/O) ,为所有的原始类型(boolean类型除外)…java NIO selector全面深入理解 阅读数 … Java _I/O_流 与 随机存取 以及 序列化 - weixin_34293141的博客… 2017年10月28日 - _深入理解JavaI/O_流 阅读数 2217 其实我个人觉得,java_I/O_流是一种比较乏味的事情。因为看不到明显的运行效果,但是输入输出程序都需要用到_I/O_操作即:允… java NIO selector全面深入理解 - vevoly的博客 2018年2月26日 - 最近在学习java NIO,发现java nio selector 相对 channel ,buffer 这两个概念是比较难_理解_的 ,把学习_理解_的东西以文字的东西记录下来,就像从内存落地… 彻底_理解I/O_架构_每天早上醒来,看见你和阳光都在,这就…_CSDN博客 2017年12月8日 - 必须要有data paths的机制来确保CPU, RAM和I/O…可见,总线的类型影响到I/O_设备的内部设计同时影响到…_深入_分析 _Java I/O 的工作机制(I/O 调优)简介:… 深入了解_MyBatis二级缓存__Java__偶尔记一下 - mybatis._io-CSDN博客 2015年3月30日 - 创建_Java_的cache对象方法为builderAssistant.useNewCache,我们看看这段代码: public…_深入理解_MyBatis(四)—MyBatis的Select操作执行流程 MyBatis的… 彻底_理解I/O_架构_铁匠Smith先生的专栏-CSDN博客 2015年1月21日 - 对于计算机系统而言,必须要有data paths的机制来确保CPU, RAM和_I/O_设备之间的信息数据能正确的流动。这些data paths,通常被称为总线(BUS),是计算机内… 详解Java 中 4 种 I/O 模型_勇往直前的专栏-CSDN博客 2018年12月28日 - 本篇会先介绍一下_I/O_的基本概念,通过一个生活例子来分别解释下这几种_I/O_模型,以及_Java_支持的_I/O_模型。 基本概念 在解释_I/O_模型之前,我先说明一下几个… Java_粗浅认识-_I/O(四)-AIO - Nick_Name的专栏 - CSDN博客 2018年12月18日 - 9.4 Linux异步I/O_9.4.1 AIO概念与GNU C库AIOLinux中最常用的输入/输出(I…_深入理解Java 字节I/O,字符I/O,字节流于字符流的区别,阻塞_I/O_的缺点,非阻塞… Java IO_模型–边学边写边_理解(一)_u013374645的博客-CSDN博客 2018年9月24日 - 前言中秋节不出去玩,除了加班一天,花两天时间死磕IO_模型。1 _IO_定义 _IO (Input_/O_ut… 接着我们介绍常见的3种_Java_网络_IO_编程模式,BIO(伪异步_IO_其实也是BIO),NIO,… [Java I/O] 字符流的使用详解_番茄萝卜是红色-CSDN博客 2019年6月6日 - 概念java中一切都是面向对象的,在I/O_流操作中,可分为数据对象和操作数据对象,…_深入理解JAVA _I/O_系列三:字符流详解 阅读数 7 字符流为何存在既然字… Java I/O 和 oKio - Kibaco的博客 - CSDN博客 2019年7月4日 - Java I/O 和 oKioGithub: https://github.com/MicroKibaco/AndroidMindMap/tree/master/24__io_掘金: https://juejin.im/user/57cf5da0a0bb9f0057b9b9c5… _深入理解java_泛型详解_java_脚本之家 2017年4月13日 - _深入理解java_泛型详解更新时间:2017年04月13日 15:…System.out.println(o); } 上面代码中的问号是一…Integer i = ifThenElse(b, new Integer(1),… Java NIO - milanleon的专栏 2018年9月25日 - 1、NIO概述 使用Java_新的_I/O_技术(NIO)要比面向流的_I/O_效率要高,因为它使用的是内存映射文件的方式来处理_I/O,Java NIO的类都放在java.nio包及其子包下,… Java _I/O_系统之转换流__java_,_io__御良私塾-CSDN博客 2017年11月9日 - Java编程思想 - 第十八章 - Java _I/O_系统File类它既能代表一个特定文件的名称…Java中的反射 阅读数 1394 _深入理解Java_中的反射反射的概念反射的主… Java I/O - BalmyLee - 博客园 2019年4月19日 - java_把一组有序的数据序列称为流(Stream)。根据操作的类型,可以把流分为输入流和输出流。 _java I/O_系统负责处理程序的输入和输出,_I/O_类库位于_java._io_包中,它… _深入理解Java_对象序列化 - 51CTO.COM 2012年2月14日 - _Java_对象序列化就能够帮助我们实现该功能。 使用_Java_对象序列化,在保存对象时,会把其状态保存为一组字节,在未来,再将这些字节组装成对象。必须注意地… _Java_8 _I/O_源码-目录 - 潘威威的博客 - CSDN博客 2017年9月20日 - 从今天开始,就要开始学习_I/O_了。本专栏从将根据源码,详细_深入_地讲解_JavaI/O_的实现。本专栏主要参考《ThinkIn_Java_》一书,还有网上的一些技术文章。主要… Java _I/O_不迷茫,一文为你导航!__Java_, _I/O__GarfieldEr00…_CSDN博客 2019年10月28日 - 前言:在之前的面试中,每每问到关于Java I/O 方面的东西都感觉自己吃了大亏..所以这里抢救一下 _Java_中的几种_I/O_策略简述_qq_39523768的博客-CSDN博客 2018年6月22日 - 1.Reading/WritingFileReader inputStream = null;Fil… 来类比Java IO_模型的演变,帮助_理解_几种模型的功能和…_深入_分析 _Java I/O 的工作机制 阅读数… 深入理解java:3.NIO编程(一)_燎野_新浪博客 2018年9月19日 - 深入理解java:3.NIO编程(一)(2018-09-19 10:51:32) 转载▼分类: Java技术 _I/O_简介 _I/O_即输入输出,是计算机… _JavaIO_流学习总结- - aizhenmafan - 博客园 1天前 - import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io… guava_深入理解_(5)-_IO___o_83290102_o_5的博客-CSDN博客 2018年1月19日 - 除了_java_之外的其他几种jvm语言,例如kotlin,groovy,scala,在自带的库里,已经… 除了_java_之外的其他几种jvm语言,例如kotlin,groovy,scala,在自带的库… guava_深入理解_(5)-_IO___o_83290102_o_5的博客-CSDN博客 2018年1月19日 - 除了_java_之外的其他几种jvm语言,例如kotlin,groovy,scala,在自带的库里,已经… 除了_java_之外的其他几种jvm语言,例如kotlin,groovy,scala,在自带的库… _Java_中的_I/O_通道分析整理_weixin_34355881的博客-CSDN博客 2017年6月20日 - 它具有执行I/O_指令的能力,并通过执行通道(_I/O)程序来控制I/O_操作。但_I/O…深入理解Java 字节I/O,字符I/O,字节流于字符流的区别,阻塞_I/O_的缺点,非阻塞… java I/O Streams - c1523456的博客 - CSDN博客 2018年5月6日 - java_平台为我们定义了许多字节流,我们聚焦于文件字节流,这样我们可以更好的演示,…_I/O 和Formatting进行_深入_讨论,但是现在我们只聚焦于他们所支持的… Java _I/O_操作五 - dongcheng123456789的博客 - CSDN博客 2019年3月16日 - JAVA _I/O_基本操作JAVA文件操作JAVA字节流JAVA字符流JAVA缓存流JAVA对象流JAVA数据流本文主要借鉴以下博客和网站:how2j.cn_深入理解java_中的_I/O_JAVA文件… _Java_基础学习之对_IO_流的_理解__QJZ的成长之路-CSDN博客 2016年8月17日 - 1 什么是IO _Java_中_I/O_操作主要是指使用_Java_进行输入,输出操作。_Java_所有的_I/O_机… _Java_中_I/O_操作主要是指使用_Java_进行输入,输出操作。_Java_所有的_I/O_机制都是… _Java_中_I/O_操作总结 - BaoEr_Xu 2017年7月7日 - 原文地址:https://mp.weixin.qq.com/s/xBQYOG6uF-ORuuvEL80Mhg_Java_中_I/O_操作主要是指使用_Java_进行输入,输出操作. _Java_所有的_I/O_机制都是基于数据流进… 深入了解_MyBatis二级缓存__Java__偶尔记一下 - mybatis._io-CSDN博客 2015年3月30日 - mybatis 二级缓存 博客 hxp_java_1 403 浏览器打开 ibatis的cacheModel配置不满足…_深入理解_MyBatis(四)—MyBatis的Select操作执行流程 博客 u0139671… 理解I/O Completion Port - 李昱成的专栏 2008年2月29日 - I/O_完成端口可能是Win32提供的最复杂的内核对象。 …,如果想_深入理解_IOCP, Jeffrey Ritchter的Advanced …若结果出乎你的意料,那就很有必要来了解_了… 五种I/O_模型和_Java NIO源码分析 - KHOST的博客 2019年8月27日 - 这里,就将最近我学习的知识总结一下,以供大家了解_。 为了节约你的时间,本文主要内容如下: 异步,阻塞的概念 操作系统_I/O_的类型 _Java NIO的底层实现… 深入理解 Java 中的 Lambda - 知乎 2018年6月22日 - 我花了相当多的阅读和编码时间才最终理解Java …interface MapFunction&lt;_I_, _O_&gt; { O apply(I in)… 深入_浅出_理解Java NIO - xiaoxiya55的博客 2019年10月13日 - 深入_浅出_理解Java NIO系列—第1篇 阅读数 600 NIO含义 NIO的本意是:New I/O,原因在于它相对于之前的I/O_类库是新增的。由于之前老的_I/O_类库是阻塞_I/O,… Java 标准_I/O_重定向__java_,io,标准_薛瑄的博客-CSDN博客 2016年6月16日 - 转载:http://blog.csdn.net/zhy_cheng/article/details/… Java_重定向标准输入输出流_I/O(理解) 阅读数 1935…_深入_源码分析Handler 消息机制 、Loope… _java_中_I/O_流之字节流和字符流学习总结_追梦的小蚂蚁-CSDN博客 2018年5月13日 - java _I/O_流-字节流和字符流 阅读数 500 字节流和字符流操作的方式基本相同,区别在于操作的数据单元不同,字节流操作的数据单元是字节,字符流操作的数… _Java_核心(五)_深入理解_BIO、NIO、AIO__java_core_王磊的博客-CSDN博客 2018年12月3日 - 同步阻塞 最常用的一种用法,使用也是最简单的,但是 I/O 性能一般很差,CPU 大…_Java_核心-_深入理解_BIO、NIO、AIO 阅读数 29 导读:本文你将获取到:同/异步 … _java_中_I/O_的心得笔记(可以使用流的方法复制音频文件…_CSDN博客 2019年4月12日 - 参考博客如下:_深入理解Java_中的_IO_Java中_IO_流,输入输出流概述与总结_IO_流上:概述…Java的_I/O_类库的基本架构Java的_I/O_操作类在包java._io_下,大概有将近80… _Java_8 _I/O_源码-OutputStream - 潘威威的博客 - CSDN博客 2017年9月29日 - 上篇文章_Java_8 _I/O_源码-InputStream介绍了所有表示字节输入流的类的父类IntputStream,本文简单介绍所有表示字节输出流的类的父类OutputStream。 Outpu… 【Core Java_】 The _Java I/O System - SAm - CSDN博客 2014年9月9日 - I/O 1. 最common的用法,从一个文件按行读取数据。 public String getFileAs…浅谈android系统_java_调用C++函数传参过程 阅读数 1308 读了《_深入理解_a… Java I/O 和 oKio - Kibaco的博客 - CSDN博客 2019年7月4日 - Java I/O 和 oKioGithub: https://github.com/MicroKibaco/AndroidMindMap/tree/master/24__io_掘金: https://juejin.im/user/57cf5da0a0bb9f0057b9b9c5… _Java_核心_深入理解_BIO、NIO、AIO_向着高亮的地方-CSDN博客 2020年1月12日 - _Java_核心_深入理解_BIO、NIO、AIOBIO、NIO、AIO 的区别是什么?同/异步、阻/非阻塞… _Java_核心-_深入理解_BIO、NIO、AIO 阅读数 30 导读:本文你将获取到:… JVM使用的编码方式和_Java_的_I/O_流_Alexwym的博客-CSDN博客 2018年8月7日 - Java_的_I/O_系统中能够制定转换编码的地方,也就在字符和直接转换的地方,那就是Input…_深入理解_计算机系统 3篇 _JAVA 34篇 Python 3篇 Android 5篇 j…","link":"/2020/04/02/%E6%B7%B1%E5%85%A5Java%E7%B3%BB%E5%88%97%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA-I-O/"},{"title":"Vue手册：Vue.js的完整介绍","text":"Vue是一种非常流行的JavaScript前端框架，正在经历巨大的增长。 它很简单，很小（〜24KB），并且性能很高。感觉与所有其他JavaScript前端框架和视图库不同。让我们找出原因。 首先，什么是JavaScript前端框架？如果不确定什么是JavaScript框架，那么Vue是一个完美的初体验。 JavaScript框架可帮助我们创建现代应用程序。现代JavaScript应用程序主要在Web上使用，但也为许多桌面和移动应用程序提供支持。 直到2000年代初，浏览器才拥有现在所没有的功能。它们的功能要弱得多，并且在它们内部构建复杂的应用程序在性能上并不可行。人们甚至都没有想到过这种工具。 当Google推出浏览器中运行的两个应用程序Google Maps和GMail时，一切都发生了变化。Ajax使异步网络请求成为可能。随着时间的流逝，开发人员开始在Web平台之上进行构建，而工程师在该平台本身上进行工作-浏览器，Web标准，浏览器API和JavaScript语言。 像jQuery和Mootools这样的库是第一个基于JavaScript的大型项目，并在一段时间内大受欢迎。他们基本上提供了一个更好的API与浏览器进行交互，并提供了各种浏览器之间的错误和不一致的解决方法。 诸如Backbone，Ember，Knockout和AngularJS之类的框架是现代JavaScript框架的第一波潮流。 第二波是当前波，其主要参与者是React，Angular和Vue。 请注意，jQuery，Ember和我提到的其他项目仍在大量使用，积极维护和数百万个网站依赖它们。 也就是说，技术和工具不断发展，作为JavaScript开发人员，您现在可能需要了解React，Angular或Vue，而不是那些较旧的框架。 框架抽象了与浏览器和DOM的交互。我们不是在DOM中通过引用元素来操作元素，而是在更高的级别上以声明方式定义它们并与之交互。 使用框架就像使用C编程语言而不是使用汇编语言编写系统程序一样。就像使用计算机来编写文档而不是使用打字机一样。这就像拥有自动驾驶汽车，而不是自己驾驶汽车。 好吧，不是很远，但是您知道了。您不必使用由浏览器提供的低级API来操纵元素，而是使用非常聪明的人构建的工具来使我们的生活更轻松，这些工具可以构建非常复杂的系统来编写应用程序。 Vue的受欢迎程度Vue.js的受欢迎程度如何？ Vue有： 2016年在GitHub上获得7,600星 2017年在GitHub上有36,700星 截至2018年6月，它在GitHub上拥有超过100,000个星星。 它的npm下载数量每天都在增长，现在每周大约有350,000次下载。 鉴于这些数字，我会说Vue非常受欢迎。 相对而言，它的GitHub星星数量与几年前诞生的React大致相同。 当然，数字并不是万能的。我对Vue的印象是开发人员喜欢它。 Vue兴起的关键时刻是在Laravel生态系统中的采用，Laravel生态系统是一种非常流行的PHP Web应用程序框架。但是从那以后，它已经在许多其他开发社区中广泛传播。 为什么开发人员喜欢Vue首先，Vue被称为渐进框架。 这意味着它可以适应开发人员的需求。其他框架则需要开发人员或团队的全面支持，并且由于它们需要某些特定的约定集，因此常常希望您重写现有的应用程序。Vue从一个简单的script标签开始就很高兴地落在您的应用程序内部，它可以随着您的需求而增长，从3行扩展到管理整个视图层。 您不需要了解webpack，Babel，npm或任何有关Vue入门的知识。但是，当您准备就绪时，Vue使您可以轻松依赖它们。 这是一个很大的卖点，尤其是在当前的JavaScript前端框架和库生态系统中，这些生态系统倾向于疏远新手和经验丰富的开发人员，他们迷失在可能性和选择的海洋中。 Vue.js可能是最容易接近的前端框架。有人称Vue为新的jQuery，因为它很容易通过script标签进入应用程序，并从那里逐渐获得空间。自从jQuery在过去几年中统治了Web以来，它一直是一种赞美，现在它仍然在大量站点上发挥作用。 Vue的构建是通过选择Angular，React和Knockout等框架的最佳思想，并挑选这些框架的最佳选择来完成的。通过排除一些不太出色的产品，它开始成为“最佳”产品，并从那里发展起来。 Vue.js在框架环境中的什么位置？在谈论Web开发时，会议室中的两个大象是React和Angular。Vue如何相对于这两个流行的大型框架定位自己？ Vue由Evan You在Google上使用AngularJS（Angular 1.0）应用程序创建时创建。它是出于创建更多高性能应用程序的需要而诞生的。Vue选择了一些Angular模板语法，但删除了Angular所需的，自以为是的复杂堆栈，并使其表现出色。 新的Angular（Angular 2.0）也解决了许多AngularJS问题，但是方式却截然不同。它还需要TypeScript的支持，并非所有开发人员都喜欢使用（或想学习）。 那React呢？Vue从React获得了很多好主意，最重要的是虚拟DOM。但是Vue通过某种自动依赖管理来实现它。这跟踪状态更改影响哪些组件，以便在状态属性更改时仅重新呈现那些组件。 另一方面，在React中，当影响组件的一部分状态发生变化时，组件将被重新渲染。默认情况下，其所有子级也会重新渲染。为避免这种情况，您需要使用shouldComponentUpdate每个组件的方法并确定是否应重新渲染该组件。在易用性和开箱即用的性能方面，这给Vue带来了一些优势。 与React的一大不同是JSX。尽管您可以在Vue中使用JSX，但它不是一种流行的方法，而是使用了模板系统。任何HTML文件都是有效的Vue模板。JSX与HTML截然不同，它为团队中的人员提供了学习曲线，他们可能只需要使用应用程序的HTML部分，例如设计师。 Vue模板与Moustache和Handlebars非常相似（尽管它们在灵活性方面有所不同）。因此，对于已经使用Angular和Ember等框架的开发人员来说，它们更加熟悉。 官方状态管理库Vuex遵循Flux架构，其概念在某种程度上类似于Redux。再次，这是关于Vue的积极事情的一部分，Vue在React中看到了这种良好模式，并将其借用于其生态系统。尽管可以将Redux与Vue结合使用，但Vuex是专门为Vue及其内部功能量身定制的。 Vue非常灵活，但是核心团队维护着两个对任何Web应用都非常重要的软件包（例如路由和状态管理），这一事实使得它比React更加零碎。例如：vue-router和vuex是Vue成功的关键。 您无需选择或担心您将来选择的库是否将要维护，并会跟上框架更新的步伐。由于它们是官方的，因此它们是其利基市场的规范性去库（但您当然可以选择使用喜欢的库）。 与React和Angular相比，使Vue处于不同的类别的一件事是，Vue是一个独立项目：它没有像Facebook或Google这样的大型公司的支持。 相反，它得到了社区的完全支持，该社区通过捐赠和赞助者促进发展。这可以确保Vue的路线图不受单个公司议程的驱动。 您的第一个Vue应用如果您从未创建过Vue.js应用程序，那么我将指导您完成创建应用程序的任务，以便您了解其工作方式。 第一个例子首先，我将介绍使用Vue的最基本示例。 您创建一个HTML文件，其中包含： 1234567891011121314&lt;html&gt; &lt;body&gt; &lt;div id=&quot;example&quot;&gt; &lt;p&gt;{.{ hello }}&lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue({ el: '#example', data: { hello: 'Hello World!' } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 然后在浏览器中打开它。这是您的第一个Vue应用！该页面应显示“ Hello World！”消息。 我将脚本标签放在正文的末尾，以便在加载DOM之后按顺序执行它们。 该代码的作用是实例化一个新的Vue应用程序，该应用程序链接到该#example元素作为其模板。通常是使用CSS选择器定义的，但您也可以传入HTMLElement。 然后，它将模板与data对象相关联。这是一个特殊的对象，用于承载我们希望Vue呈现的数据。 在模板中，特殊{.{ }}标记表示这是动态模板的一部分，应在Vue应用程序数据中查找其内容。 您可以在CodePen上看到此示例。 CodePen与使用纯HTML文件有点不同，您需要对其进行配置以指向Pen设置中的Vue库位置： 第二个示例：Vue CLI默认应用让我们稍微升级一下游戏。我们将要构建的下一个应用程序已经完成，它是Vue CLI的默认应用程序。 什么是Vue CLI？它是一个命令行实用程序，通过安装适当的示例应用程序来为您架设一个应用程序框架，从而有助于加快开发速度。 有两种方法可以获取此应用程序： 在本地使用Vue CLI 首先是在计算机上安装Vue CLI并运行以下命令： 1vue create &lt;enter the app name&gt; 使用CodeSandbox 一个简单的方法（无需安装任何软件）是转到CodeSandbox。该链接将打开Vue CLI默认应用程序。 CodeSandbox是一个很棒的代码编辑器，可让您在云中构建应用程序。您可以使用任何npm软件包，并且可以轻松地与Zeit Now集成以实现轻松部署，并可以与GitHub集成以管理版本控制。 无论您是选择在本地使用Vue CLI还是通过CodeSandbox，我们都将详细检查该Vue应用程序。 文件结构在旁边package.json，其中包含配置，这些是初始项目结构中包含的文件： index.html src/App.vue src/main.js src/assets/logo.png src/components/HelloWorld.vue index.html该index.html文件是主应用程序文件。 在主体中，它仅包含一个简单元素：&lt;div id=&quot;app&quot;&gt;&lt;/ div&gt;。这是我们将用于附加到DOM的Vue应用程序的元素。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;title&gt;CodeSandbox Vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt;&lt;/body&gt;&lt;/html&gt; src/main.js这是驱动我们的应用程序的主要JavaScript文件。 我们首先从中导入Vue库和App组件App.vue。 我们设置productionTip为false，以避免Vue在控制台中输出“您处于开发模式”提示。 接下来，我们通过将Vue实例分配给在中#app定义的标识的DOM元素来创建Vue实例，index.html并告诉它使用App组件。 12345678910111213import Vue from 'vue'import App from './App'Vue.config.productionTip = false/* eslint-disable no-new */new Vue({ el: '#app', components: { App }, template: '&lt;App/&gt;'}) src/App.vueApp.vue是单个文件组件。它包含三个代码块：HTML，CSS和JavaScript。 乍一看似乎很奇怪，但是“单个文件组件”是一种创建独立组件的好方法，这些组件可以在单个文件中包含所有需要的组件。 我们具有标记，将要与之交互的JavaScript以及应用于该标记的样式，可以对其范围进行限制。在这种情况下，它没有作用域，只是输出了像常规CSS一样应用到页面的CSS。 有趣的部分在于script标签。 我们从components/HelloWorld.vue文件中导入一个组件，我们将在后面描述。 该组件将在我们的组件中引用。这是一个依赖关系。我们将输出此代码 1234&lt;div id=&quot;app&quot;&gt; &lt;img width=&quot;25%&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;HelloWorld/&gt;&lt;/div&gt; 从该组件中，您将看到该HelloWorld组件。Vue会自动将该组件插入此占位符。 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img width=&quot;25%&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;HelloWorld/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HelloWorld from './components/HelloWorld'export default { name: 'App', components: { HelloWorld }}&lt;/script&gt;&lt;style&gt;#app { font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;}&lt;/style&gt; src/components/HelloWorld.vue这是HelloWorld组件，它包含在App组件中。 该组件输出一组链接以及一条消息。 还记得上面我们讨论过App.vue中的CSS，但没有作用域吗？该HelloWorld组件的作用域为CSS。 您可以通过查看style标签轻松地确定它。如果具有scoped属性，则其作用域为：&lt;style scoped&gt; 这意味着生成的CSS将通过Vue透明应用的类来唯一地定位组件。您无需为此担心，并且知道CSS不会泄漏到页面的其他部分。 组件输出的消息存储在dataVue实例的属性中，并在模板中输出{.{ msg }}。 data可以使用自己的名称直接在模板中访问存储在其中的任何内容。我们不必说data.msg了msg。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;{.{ msg }}&lt;/h1&gt; &lt;h2&gt;Essential Links&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;https://vuejs.org&quot; target=&quot;_blank&quot; &gt; Core Docs &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;https://forum.vuejs.org&quot; target=&quot;_blank&quot; &gt; Forum &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;https://chat.vuejs.org&quot; target=&quot;_blank&quot; &gt; Community Chat &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;https://twitter.com/vuejs&quot; target=&quot;_blank&quot; &gt; Twitter &lt;/a&gt; &lt;/li&gt; &lt;br&gt; &lt;li&gt; &lt;a href=&quot;http://vuejs-templates.github.io/webpack/&quot; target=&quot;_blank&quot; &gt; Docs for This Template &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;Ecosystem&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;http://router.vuejs.org/&quot; target=&quot;_blank&quot; &gt; vue-router &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;http://vuex.vuejs.org/&quot; target=&quot;_blank&quot; &gt; vuex &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;http://vue-loader.vuejs.org/&quot; target=&quot;_blank&quot; &gt; vue-loader &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;https://github.com/vuejs/awesome-vue&quot; target=&quot;_blank&quot; &gt; awesome-vue &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'HelloWorld', data() { return { msg: 'Welcome to Your Vue.js App' } }}&lt;/script&gt;&lt;style scoped&gt;h1,h2 { font-weight: normal;}ul { list-style-type: none; padding: 0;}li { display: inline-block; margin: 0 10px;}a { color: #42b983;}&lt;/style&gt; 运行应用CodeSandbox具有很酷的预览功能。您可以运行该应用程序并编辑源代码中的任何内容，以使其立即反映在预览中。 Vue CLICodeSandbox非常适合在线编码和工作，而无需在本地设置Vue。在本地工作的一种好方法是设置Vue CLI（命令行界面）。让我们进一步了解它。 在上一个示例中，我介绍了一个基于Vue CLI的示例项目。Vue CLI到底是什么，它如何适合Vue生态系统？另外，我们如何在本地设置基于Vue CLI的项目？让我们找出答案！ 注意：从版本2到版本3，现在正在对CLI进行大量修改。虽然尚不稳定，但我将介绍版本3，因为它是对版本2的巨大改进，并且有很大的不同。 安装Vue CLI是一个命令行实用程序，您可以使用npm在全球范围内安装它： 1npm install -g @vue/cli 或使用纱线： 1yarn global add @vue/cli 完成后，您可以调用该vue命令。 Vue CLI提供了什么？CLI对于快速Vue.js开发至关重要。 它的主要目标是确保所需的所有工具都可以正常工作，执行所需的工作，并抽象出单独使用每种工具所需的所有细节。 它可以执行初始项目设置和脚手架。 这是一个灵活的工具。使用CLI创建项目后，您可以进行配置调整，而不必退出应用程序（就像使用一样create-react-app）。 从中弹出时，create-react-app可以更新和调整所需的内容，但不能依赖所提供的出色功能create-react-app。 您可以配置任何内容，但仍然可以轻松升级。 创建和配置应用程序后，它充当基于Webpack的运行时依赖工具。 与CLI的第一次接触是在创建新的Vue项目时。 如何使用CLI创建新的Vue项目使用CLI要做的第一件事是创建一个Vue应用程序： 1vue create example 最酷的是，这是一个交互式过程。您需要选择一个预设。默认情况下，有一个预设可提供Babel和ESLint集成： 我将按向下箭头⬇️并手动选择所需的功能： 按space启用您需要的其中一项，然后按enter继续。由于选择Linter / Formatter，因此Vue CLI会提示我进行配置。我选择了，ESLint + Prettier因为这是我最喜欢的设置： 接下来的事情是选择如何应用棉绒。我选择Lint on save。 接下来：测试。Vue CLI让我在两种最受欢迎​​的单元测试解决方案之间进行选择：Mocha + Chai和Jest。 Vue CLI询问我将所有配置放在何处：在package.json文件或专用配置文件中，每个工具一个。我选择了后者。 接下来，Vue CLI询问我是否要保存这些预设，并允许我下次使用Vue CLI创建新应用时选择它们。这是一个非常方便的功能，因为根据我的喜好进行快速设置可以减轻复杂性： 然后，Vue CLI询问我是否更喜欢使用Yarn或NPM： 这是它问我的最后一件事，然后继续下载依赖项并创建Vue应用程序： 如何启动新创建的Vue CLI应用程序Vue CLI已为我们创建了该应用程序，我们可以进入该example文件夹并运行yarn serve以在开发模式下启动我们的第一个应用程序： 入门示例应用程序源包含一些文件，包括package.json： 这是定义所有CLI命令的地方，其中包括yarn serve我们刚才使用的。其他命令是 yarn build，开始生产构建 yarn lint，运行lint yarn test:unit，运行单元测试 我将在单独的教程中描述由Vue CLI生成的示例应用程序。 Git仓库注意masterVS Code左下角的单词吗？这是因为Vue CLI自动创建存储库并进行第一次提交。这样我们就可以跳进去，进行更改，然后我们知道更改了什么： 这很酷。您投入了多少次并进行了更改，才意识到，当您要提交结果时，您没有提交初始状态？ 从命令行使用预设您可以跳过交互式面板，并指示Vue CLI使用特定的预设： 1vue create -p favourite example-2 预设存储在哪里预设存储在.vuejs主目录中的文件中。创建第一个“收藏夹”预设后，这是我的： 123456789101112131415161718192021{ &quot;useTaobaoRegistry&quot;: false, &quot;packageManager&quot;: &quot;yarn&quot;, &quot;presets&quot;: { &quot;favourite&quot;: { &quot;useConfigFiles&quot;: true, &quot;plugins&quot;: { &quot;@vue/cli-plugin-babel&quot;: {}, &quot;@vue/cli-plugin-eslint&quot;: { &quot;config&quot;: &quot;prettier&quot;, &quot;lintOn&quot;: [ &quot;save&quot; ] }, &quot;@vue/cli-plugin-unit-jest&quot;: {} }, &quot;router&quot;: true, &quot;vuex&quot;: true } }} 外挂程式从阅读配置可以看到，预设基本上是插件的集合，带有一些可选配置。 创建项目后，您可以使用来添加更多插件vue add： 1vue add @vue/cli-plugin-babel 所有这些插件均以可用的最新版本使用。您可以通过传递version属性来强制Vue CLI使用特定版本： 123&quot;@vue/cli-plugin-eslint&quot;: { &quot;version&quot;: &quot;^3.0.0&quot;} 如果新版本具有重大更改或错误，并且您需要稍等片刻才能使用它，这将很有用。 远程存储预设通过创建包含preset.json文件的存储库，可以将预设存储在GitHub（或其他服务）中，该文件包含单个预设配置。 从以上摘录中，我制作了一个包含以下配置的示例预设： 1{ &quot;useConfigFiles&quot;: true, &quot;plugins&quot;: { &quot;@vue/cli-plugin-babel&quot;: {}, &quot;@vue/cli-plugin-eslint&quot;: { &quot;config&quot;: &quot;prettier&quot;, &quot;lintOn&quot;: [ &quot;save&quot; ] }, &quot;@vue/cli-plugin-unit-jest&quot;: {} }, &quot;router&quot;: true, &quot;vuex&quot;: true} 可以使用以下命令来引导新应用程序： 1vue create --preset flaviocopes/vue-cli-preset example3 Vue CLI的另一种用法：快速原型制作到现在为止，我已经解释了如何使用Vue CLI从头开始创建所有项目。但是对于真正快速的原型制作，您可以创建一个非常简单的Vue应用程序（甚至是一个包含在单个.vue文件中的应用程序）并提供该服务，而不必下载node_modules文件夹中的所有依赖项。 怎么样？首先安装cli-service-global全局软件包： 1npm install -g @vue/cli-service-global 1//or 1yarn global add @vue/cli-service-global 创建一个app.vue文件： 1&lt;template&gt; &lt;div&gt; &lt;h2&gt;Hello world!&lt;/h2&gt; &lt;marquee&gt;Heyyy&lt;/marquee&gt; &lt;/div&gt;&lt;/template&gt; 然后运行 1vue serve app.vue 独立应用 您还可以提供由JavaScript和HTML文件组成的更有条理的项目。默认情况下，Vue CLI使用Vue CLI main.js / index.js 作为其入口点，并且您可以package.json设置和任何工具配置。vue serve会捡起来。 由于这使用了全局依赖关系，因此除了演示或快速测试之外，它不是最佳方法。 运行vue build将准备在中部署项目dist/，并将生成所有相应的代码（也用于供应商依赖性）。 Webpack在内部，Vue CLI使用Webpack，但是配置是抽象的，我们甚至在文件夹中都看不到配置文件。您仍然可以通过以下方式访问它vue inspect： Vue开发工具首次尝试使用Vue时，如果打开浏览器开发人员工具，则会发现以下消息：“下载Vue Devtools扩展以获得更好的开发体验：https : //github.com/vuejs/vue-devtools ” 提示安装Vue devtools 这是一个友好的提醒，请安装Vue Devtools Extension。那是什么？任何流行的框架都有其自己的devtools扩展名，该扩展名通常会向浏览器开发人员工具添加一个新面板，该面板比浏览器默认提供的工具更加专业。在这种情况下，面板将使我们检查Vue应用程序并与之交互。 构建Vue应用程序时，此工具将为您提供惊人的帮助。开发人员工具只能在处于开发模式时检查Vue应用程序。这样可以确保没有人可以使用它们与您的生产应用程序进行交互，并且可以使Vue的性能更高，因为它不必关心开发工具。 让我们安装它！ 有3种安装Vue Dev Tools的方法： 在Chrome上 在Firefox上 作为独立的应用程序 自定义扩展不支持Safari，Edge和其他浏览器，但是使用独立应用程序，您可以调试在任何浏览器中运行的Vue.js应用程序。 在Chrome上安装转到Google Chrome 商店中的此页面，然后单击**Add to Chrome**。 完成安装过程： Vue.js devtools图标显示在工具栏中。如果页面没有正在运行的Vue.js实例，则该页面显示为灰色。 如果检测到Vue.js，则图标具有Vue徽标的颜色。 图标什么也不做只是告诉我们，有是一个Vue.js实例。要使用devtools，我们必须使用“查看→开发人员→开发人员工具”打开“开发人员工具”面板，或者Cmd-Alt-i 在Firefox上安装您可以在Mozilla附加组件商店中找到Firefox开发工具扩展。 单击“添加到Firefox”，将安装扩展名。与Chrome一样，工具栏中会显示灰色图标 当您访问正在运行Vue实例的站点时，它将变为绿色，并且当我们打开开发工具时，我们将看到一个“ Vue”面板： 安装独立应用或者，您可以使用DevTools独立应用程序。 只需使用以下命令安装它： 1npm install -g @vue/devtools 1//or 1yarn global add @vue/devtools 并通过调用来运行它： 1vue-devtools 这将打开独立的基于电子的应用程序。 现在，粘贴显示给您的脚本标签 1&lt;script src=&quot;http://localhost:8098&quot;&gt;&lt;/script&gt; 在项目index.html文件中，然后等待应用程序重新加载。它将自动连接到应用程序。 如何使用开发人员工具如前所述，可以通过在浏览器中打开开发人员工具并移至Vue面板来激活Vue DevTools。 另一个选项是右键单击页面中的任何元素，然后选择“检查Vue组件”： 打开Vue DevTools面板后，我们可以导航组件树。当我们从左侧的列表中选择一个组件时，右侧面板将显示其持有的道具和数据： 在顶部有四个按钮： 组件（当前面板），其中列出了当前页面中运行的所有组件实例。Vue可以同时运行多个实例。例如，它可以使用单独的轻型应用程序管理购物车小部件和幻灯片。 在Vuex中，您可以检查通过Vuex管理的状态。 事件显示所有发出的事件。 刷新将重新加载devtools面板。 注意= $vm0组件旁边的小文本吗？这是使用控制台检查组件的便捷方法。按下“ esc”键将在devtools底部显示控制台，您可以键入$vm0以访问Vue组件： 检查组件并与之交互非常酷，而不必在代码中将它们分配给全局变量。 过滤组件开始输入组件名称，组件树将过滤出不匹配的组件。 在页面中选择一个组件点击**Select component in the page**按钮。 在页面中选择组件 您可以用鼠标悬停在页面上的任何组件上，单击它，然后它将在devtools中打开。 格式化组件名称您可以选择在camelCase中显示组件或使用破折号。 筛选检查的数据在右侧面板上，您可以输入任何单词来过滤与之不匹配的属性。 检查DOM单击“检查DOM”按钮，将其带到DevTools Elements检查器中，该DOM元素由组件生成： 检查DOM 在编辑器中打开任何用户组件（不是框架级组件）都有一个按钮，可在默认编辑器中将其打开。非常便利。 设置VS Code以与Vue一起使用Visual Studio Code是目前世界上最常用的代码编辑器之一。像许多软件产品一样，编辑器有一个循环。一旦TextMate成为开发人员的最爱，那么它就是Sublime Text，现在是VS Code。 受欢迎的有趣之处在于，人们花了很多时间来为他们可以想象的一切构建插件。 一个这样的插件是一个很棒的工具，可以帮助我们Vue.js开发人员。 威图它叫做Vetur，非常受欢迎（下载量超过300万），您可以在Visual Studio Marketplace上找到它。 安装Vetur单击“安装”按钮将在VS Code中触发安装面板： 您也可以简单地在VS Code中打开扩展，然后搜索“ vetur”： 此扩展程序提供什么？ 语法高亮Vetur为所有Vue源代码文件提供语法高亮显示。 如果没有Vetur，.vueVS Code将以这种方式显示文件： 安装了Vetur时： VS Code能够从其扩展名识别文件中包含的代码类型。 使用单个文件组件，您可以在同一文件中混合使用不同类型的代码，从CSS到JavaScript到HTML。 默认情况下，VS Code无法识别这种情况，而Vetur为您使用的每种代码提供语法高亮显示。 Vetur支持以下方面的支持： HTML CSS JavaScript Pug Haml SCSS PostCSS Sass Stylus TypeScript 片段与语法突出显示一样，由于VS Code无法确定.vue文件一部分中包含的代码种类，因此无法提供我们都喜欢的代码段。代码片段是我们可以添加到文件中的代码片段，由专用插件提供。 Vetur使VS Code能够在单个文件组件中使用您喜欢的代码段。 智能感知Vetur还为每种不同的语言启用了IntelliSense，并具有自动完成功能： 脚手架除了启用自定义片段外，Vetur还提供了自己的片段集。每个人都使用自己的语言创建一个特定的标签（模板，脚本或样式）： scaffold template with html template with pug script with JavaScript script with TypeScript style with CSS style with CSS (scoped) style with scss style with scss (scoped) style with less style with less (scoped) style with sass style with sass (scoped) style with postcss style with postcss (scoped) style with stylus style with stylus (scoped) 如果输入scaffold，您将获得单个文件组件的入门包： 1&lt;template&gt; 1&lt;/template&gt; 1&lt;script&gt;export default { 1}&lt;/script&gt; 1&lt;style&gt; 1&lt;/style&gt; 其他的是特定的，并创建单个代码块。 注意：上面列表中的（作用域）意味着它仅适用于当前组件。 Emmet默认情况下，Emmet是流行的HTML / CSS缩写引擎。您可以键入Emmet的缩写之一，然后按tabVS Code将自动将其扩展为等效的HTML： 整理和错误检查Vetur通过VS Code ESLint插件与ESLint集成。 代码格式化Vetur与&quot;editor.formatOnSave&quot;VS Code设置结合使用，为代码格式化提供自动支持，以在保存时格式化整个文件。 您可以通过在VS Code设置中将设置为vetur.format.defaultFormatter.XXXXX来选择禁用某些特定语言的自动格式none设置。要更改这些设置之一，只需开始搜索字符串，然后在右侧面板的用户设置中覆盖所需的内容即可。 支持的大多数语言都使用Prettier进行自动格式化，该工具已成为行业标准。它使用您的Prettier配置来确定您的首选项。 介绍Vue组件组件是接口的单个​​独立单元。他们可以具有自己的状态，标记和样式。 如何使用组件Vue组件可以通过四种主要方式进行定义。让我们谈谈代码。 第一个是： 1new Vue({ /* options */}) 第二个是： 1Vue.component('component-name', { /* options */}) 第三是通过使用本地组件。这些是只能由特定组件访问的组件，而在其他地方则不可用（非常适合封装）。 第四个在.vue文件中，也称为“单个文件组件”。 让我们详细介绍前三种方式。 在构建不是单页应用程序（SPA）的应用程序时，使用new Vue()或是Vue.component()使用Vue的标准方法。相反，当您仅在某些页面中使用Vue.js（例如在联系表单或购物车中）时，就使用此方法。也许在所有页面中都使用了Vue，但是服务器正在渲染布局，然后您将HTML提供给客户端，然后客户端将加载您构建的Vue应用程序。 在SPA中，是由Vue构建HTML的，使用单文件组件更为方便，因此更为常见。 您可以通过将Vue安装在DOM元素上来实例化Vue。如果您有&lt;div id=&quot;app&quot;&gt;&lt;/ div&gt;标签，则将使用： 1new Vue({ el: '#app' }) 使用初始化的组件new Vue没有相应的标签名称，因此通常是主要的容器组件。 使用初始化应用程序中使用的其他组件Vue.component()。这样的组件允许您定义一个标记-您可以使用该标记在应用程序中多次嵌入该组件-并在template属性中指定该组件的输出： 1&lt;div id=&quot;app&quot;&gt; &lt;user-name name=&quot;Flavio&quot;&gt;&lt;/user-name&gt;&lt;/div&gt; 1Vue.component('user-name', { props: ['name'], template: '&lt;p&gt;Hi {.{ name }}&lt;/p&gt;'}) 1new Vue({ el: '#app'}) 在JSFiddle上查看 我们在做什么？我们正在上初始化一个Vue根组件#app，在其中，我们使用Vue组件user-name，它向用户抽象了问候语。 该组件接受一个prop，这是我们用来将数据向下传递给子组件的属性。 在Vue.component()调用中，我们将其user-name作为第一个参数传递。这为组件命名。您可以在此处以两种方式输入名称。第一个是我们使用的那个，叫做kebab-case。第二个称为PascalCase，类似于camelCase，但首字母大写： 1Vue.component('UserName', { /* ... */}) Vue的自动创建从内部的别名user-name来UserName，反之亦然，所以你可以使用任何你喜欢的。通常最好UserName在JavaScript和user-name模板中使用。 本地组件使用创建的任何组件Vue.component()都是全局注册的。您无需将其分配给变量或将其传递以在模板中重复使用。 您可以通过将定义组件对象的对象分配给变量来在本地封装组件： 1const Sidebar = { template: '&lt;aside&gt;Sidebar&lt;/aside&gt;'} 然后使用该components属性使其在另一个组件内可用： 1new Vue({ el: '#app', components: { Sidebar }}) 您可以在同一文件中编写组件，但是一种很好的方法是使用JavaScript模块： 1import Sidebar from './Sidebar' 1export default { el: '#app', components: { Sidebar }} 重用组件子组件可以添加多次。每个单独的实例都独立于其他实例： 1&lt;div id=&quot;app&quot;&gt; &lt;user-name name=&quot;Flavio&quot;&gt;&lt;/user-name&gt; &lt;user-name name=&quot;Roger&quot;&gt;&lt;/user-name&gt; &lt;user-name name=&quot;Syd&quot;&gt;&lt;/user-name&gt;&lt;/div&gt; 1Vue.component('user-name', { props: ['name'], template: '&lt;p&gt;Hi {.{ name }}&lt;/p&gt;'}) 1new Vue({ el: '#app'}) 在JSFiddle上查看 组件的组成部分到目前为止，我们已经看到了一个组件如何接受el，props并且template性能。 el仅在使用初始化的根组件中使用new Vue({})，并标识组件将安装在其上的DOM元素。 props 列出了我们可以传递给子组件的所有属性 template 我们可以在其中设置组件模板，该模板将负责定义组件生成的输出。 组件接受其他属性： data 组件本地状态 methods：组成方法 computed：与组件关联的计算属性 watch：组件观察者 单个文件组件可以在JavaScript文件（.js）中声明Vue组件，如下所示： 1Vue.component('component-name', { /* options */}) 或者： 1new Vue({ /* options */}) 或者可以在.vue文件中指定。 该.vue文件非常酷，因为它允许您定义： JavaScript logic HTML code template CSS styling 全部都在一个文件中。因此，它的名称为“单个文件组件”。 这是一个例子： 1&lt;template&gt; &lt;p&gt;{.{ hello }}&lt;/p&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { hello: 'Hello World!' } }}&lt;/script&gt; 1&lt;style scoped&gt; p { color: blue; }&lt;/style&gt; 由于使用了Webpack，所有这些都是可能的。Vue CLI使得此操作非常容易，并且开箱即用。.vue如果没有Webpack设置，则无法使用这些文件，因此，它们非常不适合仅在页面上使用Vue而又不是完整的单页面应用程序（SPA）的应用程序。 由于单个文件组件依赖Webpack，因此我们免费获得了使用现代Web功能的功能。 您可以使用SCSS或Stylus定义CSS，可以使用Pug构建模板，而要做的就是向Vue声明要使用哪种语言预处理器。 支持的预处理器列表包括 TypeScript SCSS Sass Less PostCSS Pug 无论使用Babel集成的目标浏览器是什么，我们都可以使用现代JavaScript（ES6-7-8），并且ES模块也是如此，因此我们可以使用import/export语句。 我们可以使用CSS模块来定义CSS范围。 说到对CSS进行范围界定，通过使用ed&gt;标签，单个文件组件使编写不会泄漏到其他组件的CSS绝对容易&lt;style scop。 如果省略scoped，则定义的CSS将是全局的。但是添加scoped标签后，Vue会自动向组件添加特定于您的应用程序的特定类，因此可以确保CSS不会泄漏到其他组件。 也许您的JavaScript非常庞大，因为您需要注意一些逻辑。如果要为JavaScript使用单独的文件怎么办？ 您可以使用src属性将其外部化： 1&lt;template&gt; &lt;p&gt;{.{ hello }}&lt;/p&gt;&lt;/template&gt;&lt;script src=&quot;./hello.js&quot;&gt;&lt;/script&gt; 这也适用于您的CSS： 1&lt;template&gt; &lt;p&gt;{.{ hello }}&lt;/p&gt;&lt;/template&gt;&lt;script src=&quot;./hello.js&quot;&gt;&lt;/script&gt;&lt;style src=&quot;./hello.css&quot;&gt;&lt;/style&gt; 注意我如何使用 1export default { data() { return { hello: 'Hello World!' } }} 在组件的JavaScript中设置数据。 您将看到的其他常见方式是： 1export default { data: function() { return { name: 'Flavio' } }} 以上等同于我们之前所做的工作。 要么： 1export default { data: () =&gt; { return { name: 'Flavio' } }} 这是不同的，因为它使用箭头功能。箭头函数很好，直到我们需要访问组件方法为止。如果我们需要使用，这是一个问题this，并且使用箭头功能未将此类属性绑定到组件。因此，必须使用常规函数而不是箭头函数。 您可能还会看到： 1module.exports = { data: () =&gt; { return { name: 'Flavio' } }} 这使用CommonJS语法，并且也可以正常工作。但是我建议使用ES模块语法，因为这是JavaScript标准。 Vue模板Vue.js使用的模板语言是HTML的超集。 任何HTML都是有效的Vue.js模板。除此之外，Vue.js还提供了两个强大的功能：插值和指令。 这是有效的Vue.js模板： 1&lt;span&gt;Hello!&lt;/span&gt; 可以将该模板放入显式声明的Vue组件中： 1new Vue({ template: '&lt;span&gt;Hello!&lt;/span&gt;'}) 或者可以将其放入单个文件组件中： 1&lt;template&gt; &lt;span&gt;Hello!&lt;/span&gt;&lt;/template&gt; 第一个示例非常基础。下一步是使其输出部分组件状态，例如名称。 这可以使用插值来完成。首先，我们向组件添加一些数据： 123456new Vue({ data: { name: 'Flavio' }, template: '&lt;span&gt;Hello!&lt;/span&gt;'}) 然后我们可以使用双括号语法将其添加到模板中： 1new Vue({ data: { name: 'Flavio' }, template: '&lt;span&gt;Hello {.{name}}!&lt;/span&gt;'}) 这里一件有趣的事。看看我们是怎么name代替的this.data.name？ 这是因为Vue.js进行了一些内部绑定，并允许模板像使用本地属性一样使用该属性。很方便。 在单个文件组件中，将是： 1&lt;template&gt; &lt;span&gt;Hello {.{name}}!&lt;/span&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { name: 'Flavio' } }}&lt;/script&gt; 我在导出中使用了常规函数。为什么不使用箭头功能？ 这是因为在这种情况下，data我们可能需要访问组件实例中的方法，并且如果this未绑定到组件，则无法执行该操作，因此无法使用箭头功能。 请注意，我们可以使用箭头功能，但是如果我使用，则需要记住切换到常规功能this。我认为最好安全一点。 现在，回到插值。 {.{ name }} 应该使您想起Mustache / Handlebars模板插值，但这只是视觉上的提醒。 尽管在那些模板引擎中它们是“哑巴”，但在Vue中，您可以做更多的事情，并且更加灵活。 您可以在插值中使用任何JavaScript表达式，但仅限于一个表达式： 1{.{ name.reverse() }} 1{.{ name === 'Flavio' ? 'Flavio' : 'stranger' }} Vue提供对模板中某些全局对象的访问，包括Math和Date，因此您可以使用它们： 1{.{ Math.sqrt(16) * Math.random() }} 最好避免向模板添加复杂的逻辑，但是Vue允许这样做的事实为我们提供了更大的灵活性，尤其是在尝试时。 我们可以先尝试将表达式放入模板中，然后再将其移动到计算的属性或方法中。 任何插值中包含的值将在其依赖的任何数据属性发生更改时进行更新。 您可以通过使用v-once指令来避免这种反应。 结果总是转义的，因此输出中不能包含HTML。 如果需要HTML片段，则需要使用v-html指令。 使用CSS样式化组件将CSS添加到Vue.js组件的最简单选择是使用style标签，就像在HTML中一样： 1&lt;template&gt; &lt;p style=&quot;text-decoration: underline&quot;&gt;Hi!&lt;/p&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { decoration: 'underline' } }}&lt;/script&gt; 这是尽可能静态的。如果要underline在组件数据中定义怎么办？您可以按照以下方法进行操作： 1&lt;template&gt; &lt;p :style=&quot;{'text-decoration': decoration}&quot;&gt;Hi!&lt;/p&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { decoration: 'underline' } }}&lt;/script&gt; :style是的简写v-bind:style。在本教程中，我将使用此速记。 注意我们必须如何text-decoration用引号引起来。这是因为破折号不是有效的JavaScript标识符的一部分。 您可以使用Vue.js启用的特殊camelCase语法并将其重写为textDecoration： 1&lt;template&gt; &lt;p :style=&quot;{textDecoration: decoration}&quot;&gt;Hi!&lt;/p&gt;&lt;/template&gt; 除了style可以将对象绑定到之外，您还可以引用计算属性： 1&lt;template&gt; &lt;p :style=&quot;styling&quot;&gt;Hi!&lt;/p&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { textDecoration: 'underline', textWeight: 'bold' } }, computed: { styling: function() { return { textDecoration: this.textDecoration, textWeight: this.textWeight } } }}&lt;/script&gt; Vue组件生成纯HTML，因此您可以选择向每个元素添加一个类，并添加具有样式设置其属性的相应CSS选择器： 1&lt;template&gt; &lt;p class=&quot;underline&quot;&gt;Hi!&lt;/p&gt;&lt;/template&gt; 1&lt;style&gt;.underline { text-decoration: underline; }&lt;/style&gt; 您可以像这样使用SCSS： 1&lt;template&gt; &lt;p class=&quot;underline&quot;&gt;Hi!&lt;/p&gt;&lt;/template&gt; 1&lt;style lang=&quot;scss&quot;&gt;body { .underline { text-decoration: underline; }}&lt;/style&gt; 您可以像上面的示例一样对类进行硬编码。或者，您可以将类绑定到组件属性，以使其具有动态性，并且仅在data属性为true时才应用于该类： 1&lt;template&gt; &lt;p :class=&quot;{underline: isUnderlined}&quot;&gt;Hi!&lt;/p&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { isUnderlined: true } }}&lt;/script&gt; 1&lt;style&gt;.underline { text-decoration: underline; }&lt;/style&gt; &lt;p :class=&quot;{text: isText}&quot;&gt;H您可以直接绑定一个字符串，而不是像我们对i！那样将对象绑定到类！&lt;/ p&gt;，它将引用一个数据属性： 1&lt;template&gt; &lt;p :class=&quot;paragraphClass&quot;&gt;Hi!&lt;/p&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { paragraphClass: 'underline' } }}&lt;/script&gt; 1&lt;style&gt;.underline { text-decoration: underline; }&lt;/style&gt; 您可以分配多个类，paragraphClass在这种情况下，可以添加两个类，也可以使用数组： 1&lt;template&gt; &lt;p :class=&quot;[decoration, weight]&quot;&gt;Hi!&lt;/p&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { decoration: 'underline', weight: 'weight', } }}&lt;/script&gt; 1&lt;style&gt;.underline { text-decoration: underline; }.weight { font-weight: bold; }&lt;/style&gt; 使用类绑定中内联的对象可以完成相同的操作： 1&lt;template&gt; &lt;p :class=&quot;{underline: isUnderlined, weight: isBold}&quot;&gt;Hi!&lt;/p&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { isUnderlined: true, isBold: true } }}&lt;/script&gt; 1&lt;style&gt;.underline { text-decoration: underline; }.weight { font-weight: bold; }&lt;/style&gt; 您可以结合以下两个语句： 1&lt;template&gt; &lt;p :class=&quot;[decoration, {weight: isBold}]&quot;&gt;Hi!&lt;/p&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { decoration: 'underline', isBold: true } }}&lt;/script&gt; 1&lt;style&gt;.underline { text-decoration: underline; }.weight { font-weight: bold; }&lt;/style&gt; 您还可以使用返回对象的计算属性，当您将多个CSS类添加到同一元素时，该属性最有效： 1&lt;template&gt; &lt;p :class=&quot;paragraphClasses&quot;&gt;Hi!&lt;/p&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { isUnderlined: true, isBold: true } }, computed: { paragraphClasses: function() { return { underlined: this.isUnderlined, bold: this.isBold } } }}&lt;/script&gt; 1&lt;style&gt;.underlined { text-decoration: underline; }.bold { font-weight: bold; }&lt;/style&gt; 请注意，在计算属性中，您需要使用来引用组件数据this.[propertyName]，而在模板数据中，属性可以方便地放置为第一级属性。 Vue将处理任何未像第一个示例中那样进行硬编码的CSS，Vue会为我们自动为CSS加上前缀。这使我们可以编写干净的CSS，同时仍可以针对较旧的浏览器（这仍然意味着Vue支持的浏览器，因此是IE9 +）。 指令我们在Vue.js模板和插值中看到了如何将数据嵌入Vue模板。 本节说明Vue.js在模板中提供的另一种技术：指令。 指令基本上类似于添加在模板内部的HTML属性。它们都以开头v-，以表示这是Vue的特殊属性。 让我们详细了解每个Vue指令。 v-text代替使用插值，可以使用v-text指令。它执行相同的工作： 1&lt;span v-text=&quot;name&quot;&gt;&lt;/span&gt; v-once您知道如何{.{ name }}绑定到name组件数据的属性。 每当name您的组件数据发生更改时，Vue都会更新浏览器中表示的值。 除非使用v-once伪指令，否则伪指令基本上类似于HTML属性： 1&lt;span v-once&gt;{.{ name }}&lt;/span&gt; v-html使用插值打印数据属性时，将转义HTML。这是Vue自动防御XSS攻击的一种好方法。 但是，在某些情况下，您想输出HTML并让浏览器解释它。您可以使用v-html指令： 1&lt;span v-html=&quot;someHtml&quot;&gt;&lt;/span&gt; v-bind插值仅适用于标签内容。您不能在属性上使用它。 属性必须使用v-bind： 1&lt;a v-bind:href=&quot;url&quot;&gt;{.{ linkText }}&lt;/a&gt; v-bind 非常普遍，以至于它有一个简写语法： 1&lt;a v-bind:href=&quot;url&quot;&gt;{.{ linkText }}&lt;/a&gt;&lt;a :href=&quot;url&quot;&gt;{.{ linkText }}&lt;/a&gt; 双向绑定使用 v-model例如 v-model ，让我们绑定一个表单输入元素，并在用户更改字段内容时使它更改Vue数据属性 1&lt;input v-model=&quot;message&quot; placeholder=&quot;Enter a message&quot;&gt;&lt;p&gt;Message is: {.{ message }}&lt;/p&gt; 1&lt;select v-model=&quot;selected&quot;&gt; &lt;option disabled value=&quot;&quot;&gt;Choose a fruit&lt;/option&gt; &lt;option&gt;Apple&lt;/option&gt; &lt;option&gt;Banana&lt;/option&gt; &lt;option&gt;Strawberry&lt;/option&gt;&lt;/select&gt;&lt;span&gt;Fruit chosen: {.{ selected }}&lt;/span&gt; 使用表达式您可以在指令内使用任何JavaScript表达式： 1&lt;span v-text=&quot;'Hi, ' + name + '!'&quot;&gt;&lt;/span&gt; 1&lt;a v-bind:href=&quot;'https://' + domain + path&quot;&gt;{.{ linkText }}&lt;/a&gt; 指令中使用的任何变量都引用相应的data属性。 有条件的在指令内部，您可以使用三元运算符执行条件检查，因为这是一个表达式： 1&lt;span v-text=&quot;name == Flavio ? 'Hi Flavio!' : 'Hi' + name + '!'&quot;&gt;&lt;/span&gt; 有专门的指令，让您执行更为有组织的条件句：v-if，v-else和v-else-if。 1&lt;p v-if=&quot;shouldShowThis&quot;&gt;Hey!&lt;/p&gt; shouldShowThis 是包含在组件数据中的布尔值。 循环v-for允许您呈现项目列表。结合使用v-bind可以设置列表中每个项目的属性。 您可以迭代一个简单的值数组： 1&lt;template&gt; &lt;ul&gt; &lt;li v-for=&quot;item in items&quot;&gt;{.{ item }}&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { items: ['car', 'bike', 'dog'] } }}&lt;/script&gt; 或在一组对象上： 1&lt;template&gt; &lt;div&gt; &lt;!-- using interpolation --&gt; &lt;ul&gt; &lt;li v-for=&quot;todo in todos&quot;&gt;{.{ todo.title }}&lt;/li&gt; &lt;/ul&gt; &lt;!-- using v-text --&gt; &lt;ul&gt; &lt;li v-for=&quot;todo in todos&quot; v-text=&quot;todo.title&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { todos: [ { id: 1, title: 'Do something' }, { id: 2, title: 'Do something else' } ] } }}&lt;/script&gt; v-for 可以使用以下方式为您提供索引： 1&lt;li v-for=&quot;(todo, index) in todos&quot;&gt;&lt;/li&gt; 大事记v-on允许您侦听DOM事件，并在事件发生时触发方法。在这里，我们监听点击事件： 1&lt;template&gt; &lt;a v-on:click=&quot;handleClick&quot;&gt;Click me!&lt;/a&gt;&lt;/template&gt; 1&lt;script&gt;export default { methods: { handleClick: function() { alert('test') } }}&lt;/script&gt; 您可以将参数传递给任何事件： 1&lt;template&gt; &lt;a v-on:click=&quot;handleClick('test')&quot;&gt;Click me!&lt;/a&gt;&lt;/template&gt; 1&lt;script&gt;export default { methods: { handleClick: function(value) { alert(value) } }}&lt;/script&gt; 少量的JavaScript（单个表达式）可以直接放入模板中： 1&lt;template&gt; &lt;a v-on:click=&quot;counter = counter + 1&quot;&gt;{.{counter}}&lt;/a&gt;&lt;/template&gt; 1&lt;script&gt;export default { data: function() { return { counter: 0 } }}&lt;/script&gt; click只是一种事件。一个常见的事件是submit，您可以使用绑定该事件v-on:submit。 v-on非常普遍，以至于它有一个简写语法@： 1&lt;a v-on:click=&quot;handleClick&quot;&gt;Click me!&lt;/a&gt;&lt;a @click=&quot;handleClick&quot;&gt;Click me!&lt;/a&gt; 显示或隐藏如果Vue实例的特定属性评估为true，则可以选择仅在DOM中显示元素，方法是v-show： 1&lt;p v-show=&quot;isTrue&quot;&gt;Something&lt;/p&gt; 元素仍插入DOM中，但display: none如果不满足条件则设置为。 事件指令修饰符Vue提供了一些可选的事件修饰符，您可以将它们与结合使用v-on，这些修饰符会自动使事件执行某些操作，而无需在事件处理程序中对其进行显式编码。 一个很好的例子是.prevent，它会自动调用preventDefault()该事件。 在这种情况下，该表单不会导致页面被重新加载，这是默认行为： 1&lt;form v-on:submit.prevent=&quot;formSubmitted&quot;&gt;&lt;/form&gt; 其它调节剂包括.stop，.capture，.self，.once，.passive和他们详细的官方文档描述。 自定义指令Vue默认指令已经可以完成很多工作，但是如果需要，您可以随时添加新的自定义指令。 如果您有兴趣了解更多信息，请阅读此处。 方法什么是Vue.js方法？Vue方法是与Vue实例关联的函数。 方法在methods属性内定义： 1new Vue({ methods: { handleClick: function() { alert('test') } }}) 或对于单个文件组件： 1&lt;script&gt;export default { methods: { handleClick: function() { alert('test') } }}&lt;/script&gt; 当您需要执行操作并将v-on指令附加到元素上以处理事件时，方法特别有用。像这样，handleClick当元素被点击时调用： 1&lt;template&gt; &lt;a @click=&quot;handleClick&quot;&gt;Click me!&lt;/a&gt;&lt;/template&gt; 将参数传递给Vue.js方法方法可以接受参数。 在这种情况下，您只需在模板中传递参数： 1&lt;template&gt; &lt;a @click=&quot;handleClick('something')&quot;&gt;Click me!&lt;/a&gt;&lt;/template&gt; 1new Vue({ methods: { handleClick: function(text) { alert(text) } }}) 或对于单个文件组件： 1&lt;script&gt;export default { methods: { handleClick: function(text) { alert(text) } }}&lt;/script&gt; 如何从方法访问数据您可以使用以下命令访问Vue组件的任何数据属性this.propertyName： 1&lt;template&gt; &lt;a @click=&quot;handleClick()&quot;&gt;Click me!&lt;/a&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { name: 'Flavio' } }, methods: { handleClick: function() { console.log(this.name) } }}&lt;/script&gt; 我们不必使用this.data.name，只是this.name。Vue确实为我们提供了透明的绑定。使用this.data.name将引发错误。 如您在事件描述中之前所看到的，方法与事件紧密关联，因为它们被用作事件处理程序。每次事件发生时，都会调用该方法。 观察者监视程序是Vue.js的一项特殊功能，它使您可以监视组件状态的一个属性，并在该属性值更改时运行一个函数。 这是一个例子。我们有一个显示名称的组件，并允许您通过单击按钮进行更改： 1&lt;template&gt; &lt;p&gt;My name is {.{name}}&lt;/p&gt; &lt;button @click=&quot;changeName()&quot;&gt;Change my name!&lt;/button&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { name: 'Flavio' } }, methods: { changeName: function() { this.name = 'Flavius' } }}&lt;/script&gt; 名称更改后，我们想做一些事情，例如打印控制台日志。 我们可以通过在watch对象上添加一个名为data属性的属性来实现此目的： 1&lt;script&gt;export default { data() { return { name: 'Flavio' } }, methods: { changeName: function() { this.name = 'Flavius' } }, watch: { name: function() { console.log(this.name) } }}&lt;/script&gt; 分配给的功能watch.name可以选择接受2个参数。首先是新的属性值。第二个是旧的属性值： 1&lt;script&gt;export default { /* ... */ watch: { name: function(newValue, oldValue) { console.log(newValue, oldValue) } }}&lt;/script&gt; 无法像使用计算属性一样从模板中查找观察者。 计算属性什么是计算属性在Vue.js中，您可以使用括号输出任何数据值： 1&lt;template&gt; &lt;p&gt;{.{ count }}&lt;/p&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { count: 1 } }}&lt;/script&gt; 此属性可以托管一些小的计算。例如： 1&lt;template&gt; {.{ count * 10 }}&lt;/template&gt; 但是您只能使用一个JavaScript 表达式。 除此技术限制外，您还需要考虑模板应仅与向用户显示数据有关，而不应执行逻辑计算。 若要执行多个操作而不是单个表达式，并具有更多的声明性模板，请使用计算属性。 计算属性是在computedVue组件的属性中定义的： 123&lt;script&gt;export default { computed: {``` ```}}&lt;/script&gt; 计算属性的示例这是一个使用计算属性count计算输出的示例。 注意： 我不必打电话{.{ count() }}。Vue.js自动调用该函数 我使用常规函数（而不是箭头函数）来定义count计算所得的属性，因为我需要能够通过来访问组件实例this。 1&lt;template&gt; &lt;p&gt;{.{ count }}&lt;/p&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { items: [1, 2, 3] } }, computed: { count: function() { return 'The count is ' + this.items.length * 10 } }}&lt;/script&gt; 计算属性与方法如果您已经了解Vue方法，您可能会想知道有什么区别。 首先，必须调用方法，而不仅仅是引用方法，因此您需要执行以下操作： 1&lt;template&gt; &lt;p&gt;{.{ count() }}&lt;/p&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { items: [1, 2, 3] } }, methods: { count: function() { return 'The count is ' + this.items.length * 10 } }}&lt;/script&gt; 但是主要区别在于，已计算的属性已缓存。 count计算属性的结果在内部缓存，直到items数据属性更改。 重要：仅当反应性源更新时，才会更新计算属性。常规JavaScript方法不是被动的，因此一个常见的示例是使用Date.now()： 1&lt;template&gt; &lt;p&gt;{.{ now }}&lt;/p&gt;&lt;/template&gt; 1&lt;script&gt;export default { computed: { now: function () { return Date.now() } }}&lt;/script&gt; 它只会渲染一次，即使重新渲染组件也不会更新。当Vue组件退出并重新初始化时，它仅在页面刷新时更新。 在这种情况下，一种方法更适合您的需求。 方法与观察者与计算属性既然您知道方法，观察者和计算属性，那么您可能想知道什么时候应该使用一种方法。 这是这个问题的细分。 何时使用方法 对DOM中发生的某些事件做出反应 当组件中发生某些事情时调用函数。您可以从计算的属性或观察程序中调用方法。 何时使用计算属性 您需要从现有数据源中组合新数据 您有一个在模板中使用的变量，该变量是根据一个或多个数据属性构建的 您希望将复杂的嵌套属性名称简化为更易读和易于使用的名称（但是在原始属性更改时进行更新） 您需要从模板中引用一个值。在这种情况下，最好创建一个计算属性，因为它已缓存。 您需要聆听多个数据属性的更改 何时使用观察者 您想在数据属性更改时进行监听，并执行一些操作 您想听听道具价值的变化 您只需要听一个特定的属性（您不能同时观看多个属性） 您要监视一个数据属性，直到达到某个特定值，然后再执行某些操作 道具：将数据传递给子组件道具是组件可以从包含它们的组件（父组件）接受数据的方式。 当组件需要一个或多个道具时，必须在其props属性中定义它们： 1Vue.component('user-name', { props: ['name'], template: '&lt;p&gt;Hi {.{ name }}&lt;/p&gt;'}) 或者，在Vue单个文件组件中： 1&lt;template&gt; &lt;p&gt;{.{ name }}&lt;/p&gt;&lt;/template&gt; 1&lt;script&gt;export default { props: ['name']}&lt;/script&gt; 接受多个道具您可以通过简单地将它们附加到数组来获得多个props： 1Vue.component('user-name', { props: ['firstName', 'lastName'], template: '&lt;p&gt;Hi {.{ firstName }} {.{ lastName }}&lt;/p&gt;'}) 设置道具类型您可以使用对象而不是数组，使用属性名称作为每个属性的键，并使用类型作为值来非常简单地指定道具的类型： 1Vue.component('user-name', { props: { firstName: String, lastName: String }, template: '&lt;p&gt;Hi {.{ firstName }} {.{ lastName }}&lt;/p&gt;'}) 您可以使用的有效类型是： String Number Boolean Array Object Date Function Symbol 当类型不匹配时，Vue会在控制台中以警告方式警告您（处于开发模式）。 道具类型可以更清晰地表达。 您可以允许多种不同的值类型： 1props: { firstName: [String, Number]} 将道具设置为强制性您可以要求道具是强制性的： 1props: { firstName: { type: String, required: true }} 设置道具的默认值您可以指定一个默认值： 1props: { firstName: { type: String, default: 'Unknown person' }} 对于对象： 1props: { name: { type: Object, default: { firstName: 'Unknown', lastName: '' } }} default 也可以是返回适当值的函数，而不是实际值。 您甚至可以构建一个自定义验证器，该验证器对复杂数据很酷： 1props: { name: { validator: name =&gt; { return name === 'Flavio' } }} 将道具传递到组件您使用语法将prop传递给组件 1&lt;ComponentName color=&quot;white&quot; /&gt; 如果您传递的是静态值。 如果它是数据属性，则使用 1&lt;template&gt; &lt;ComponentName :color=color /&gt;&lt;/template&gt; 1&lt;script&gt;...export default { //... data: function() { return { color: 'white' } }, //...}&lt;/script&gt; 您可以在prop值内使用三元运算符来检查真实条件并传递依赖于该条件的值： 1&lt;template&gt; &lt;ComponentName :colored=&quot;color == 'white' ? true : false&quot; /&gt;&lt;/template&gt; 1&lt;script&gt;...export default { //... data: function() { return { color: 'white' } }, //...}&lt;/script&gt; 在Vue中处理事件什么是Vue.js事件？Vue.js允许我们通过使用v-on元素上的指令来拦截任何DOM事件。 如果我们想在此元素中发生点击事件时采取措施： 1&lt;template&gt; &lt;a&gt;Click me!&lt;/a&gt;&lt;/template&gt; 我们添加一条v-on指令： 1&lt;template&gt; &lt;a v-on:click=&quot;handleClick&quot;&gt;Click me!&lt;/a&gt;&lt;/template&gt; Vue还为此提供了一种非常方便的替代语法： 1&lt;template&gt; &lt;a @click=&quot;handleClick&quot;&gt;Click me!&lt;/a&gt;&lt;/template&gt; 您可以选择是否使用括号。@click=&quot;handleClick&quot;等同于@click=&quot;handleClick()&quot;。 handleClick 是附加到组件的方法： 1&lt;script&gt;export default { methods: { handleClick: function(event) { console.log(event) } }}&lt;/script&gt; 您需要在这里知道的是，您可以通过事件传递参数：@click=&quot;handleClick(param)&quot;它们将在方法内部接收。 访问原始事件对象在许多情况下，您将要对事件对象执行操作或在其中查找某些属性。您如何访问它？ 使用特殊$event指令： 1&lt;template&gt; &lt;a @click=&quot;handleClick($event)&quot;&gt;Click me!&lt;/a&gt;&lt;/template&gt; 1&lt;script&gt;export default { methods: { handleClick: function(event) { console.log(event) } }}&lt;/script&gt; 并且如果您已经传递了变量： 1&lt;template&gt; &lt;a @click=&quot;handleClick('something', $event)&quot;&gt;Click me!&lt;/a&gt;&lt;/template&gt; 1&lt;script&gt;export default { methods: { handleClick: function(text, event) { console.log(text) console.log(event) } }}&lt;/script&gt; 从那里可以调用event.preventDefault()，但是有一个更好的方法：事件修饰符。 事件修饰符告诉Vue为您处理事情，而不是弄乱方法中的DOM“事物”： @click.prevent 呼叫 event.preventDefault() @click.stop 呼叫 event.stopPropagation() @click.passive利用addEventListener的被动选项 @click.capture 使用事件捕获而不是事件冒泡 @click.self 确保click事件没有从子事件中冒出，而是直接发生在该元素上 @click.once 事件只会被触发一次 所有这些选项可以通过在一个修饰符之后附加一个修饰符来组合。 有关传播，冒泡和捕获的更多信息，请参阅我的JavaScript事件指南。 使用广告位注入内容组件可以选择完全定义其内容，例如在这种情况下： 1Vue.component('user-name', { props: ['name'], template: '&lt;p&gt;Hi {.{ name }}&lt;/p&gt;'}) 或者，它也可以让父组件通过使用插槽将任何种类的内容注入其中。 什么是插槽？ 您可以通过将&lt;slot&gt;&amp;lt; / slot&gt;放在组件模板中来定义它： 1Vue.component('user-information', { template: '&lt;div class=&quot;user-information&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;'}) 使用此组件时，在开始和结束标记之间添加的所有内容都将添加到广告位占位符内： 1&lt;user-information&gt; &lt;h2&gt;Hi!&lt;/h2&gt; &lt;user-name name=&quot;Flavio&quot;&gt;&lt;/user-information&gt; 如果将任何内容放在&lt;slot&gt;&amp;lt; / slot&gt;标记旁边，这将作为默认内容，以防万一。 复杂的组件布局可能需要更好的方式来组织内容。 输入命名的插槽。 使用命名插槽，可以将插槽的各个部分分配到组件模板布局中的特定位置，并且可以slot对任何标签使用属性，以将内容分配给该插槽。 模板标签之外的所有内容都会添加到main中slot。 为了方便起见，page在此示例中，我使用单个文件组件： 1&lt;template&gt; &lt;div&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;sidebar&gt; &lt;slot name=&quot;sidebar&quot;&gt;&lt;/slot&gt; &lt;/sidebar&gt; &lt;/div&gt;&lt;/template&gt; 123&lt;page&gt; &lt;ul slot=&quot;sidebar&quot;&gt; &lt;li&gt;Home&lt;/li&gt; &lt;li&gt;Contact&lt;/li&gt; &lt;/ul&gt;``` ```&lt;h2&gt;Page title&lt;/h2&gt; &lt;p&gt;Page content&lt;/p&gt;&lt;/page&gt; 筛选器，模板的帮手过滤器是Vue组件提供的功能，可让您将格式设置和转换应用于模板动态数据的任何部分。 它们不会更改组件的数据或其他任何内容，而只会影响输出。 假设您正在打印名称： 1&lt;template&gt; &lt;p&gt;Hi {.{ name }}!&lt;/p&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { name: 'Flavio' } }}&lt;/script&gt; 如果要检查name实际上是否包含一个值，如果不打印，则该怎么办，以便我们的模板将打印“嗨，那里！”？ 输入过滤器： 1&lt;template&gt; &lt;p&gt;Hi {.{ name | fallback }}!&lt;/p&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { name: 'Flavio' } }, filters: { fallback: function(name) { return name ? name : 'there' } }}&lt;/script&gt; 请注意，应用过滤器的语法为| filterName。如果您熟悉Unix，那就是Unix管道运算符，用于将操作的输出作为输入传递给下一个操作。 filters组件的属性是一个对象。单个过滤器是一个接受一个值并返回另一个值的函数。 返回的值是Vue.js模板中实际打印的值。 过滤器当然可以访问组件数据和方法。 过滤器的好用例是什么？ 转换字符串，例如大写或将其小写 格式化价格 在上方，您看到了一个简单的过滤器示例：{.{ name | fallback }}。 通过重复管道语法，可以链接过滤器： 1{.{ name | fallback | capitalize }} 首先应用fallback过滤器，然后应用过滤capitalize器（我们没有定义，但尝试创建一个！）。 高级过滤器还可以使用常规函数参数语法接受参数： 1&lt;template&gt; &lt;p&gt;Hello {.{ name | prepend('Dr.') }}&lt;/p&gt;&lt;/template&gt; 1&lt;script&gt;export default { data() { return { name: 'House' } }, filters: { prepend: (name, prefix) =&gt; { return `${prefix} ${name}` } }}&lt;/script&gt; 如果将参数传递给过滤器，则传递给过滤器函数的第一个参数始终是模板插值中的项（name在这种情况下），然后是传递的显式参数。 您可以通过使用逗号分隔多个参数来使用它们。 注意，我使用了箭头功能。通常，我们避免在方法和计算属性中使用箭头函数，因为它们几乎总是引用this来访问组件数据。但是在这种情况下，过滤器不需要访问，this而是通过参数接收它需要的所有数据，并且我们可以安全地使用更简单的箭头函数语法。 这个包有很多预先制成的过滤器，为您的模板，其中包括直接使用capitalize，uppercase，lowercase，placeholder，truncate，currency，pluralize等等。 组件之间的通讯Vue中的组件可以通过各种方式进行通信。 使用道具第一种方法是使用道具。 父级通过在组件声明中添加参数来“传递”数据： 1&lt;template&gt; &lt;div&gt; &lt;Car color=&quot;green&quot; /&gt; &lt;/div&gt;&lt;/template&gt; 1&lt;script&gt;import Car from './components/Car' 1export default { name: 'App', components: { Car }}&lt;/script&gt; 道具是单向的：从父母到孩子。每当父母更改道具时，新值就会发送给孩子并重新渲染。 反之则不成立，您永远都不应在子组件内部变异道具。 使用事件从孩子与父母沟通通过事件，您可以从孩子到父母进行交流： 1&lt;script&gt;export default { name: 'Car', methods: { handleClick: function() { this.$emit('clickedSomething') } }}&lt;/script&gt; v-on当组件在其模板中包含组件时，父级可以使用指令截获此消息： 1&lt;template&gt; &lt;div&gt; &lt;Car v-on:clickedSomething=&quot;handleClickInParent&quot; /&gt; &lt;!-- or --&gt; &lt;Car @clickedSomething=&quot;handleClickInParent&quot; /&gt; &lt;/div&gt;&lt;/template&gt; 1&lt;script&gt;export default { name: 'App', methods: { handleClickInParent: function() { //... } }}&lt;/script&gt; 您当然可以传递参数： 1&lt;script&gt;export default { name: 'Car', methods: { handleClick: function() { this.$emit('clickedSomething', param1, param2) } }}&lt;/script&gt; 并从父级检索它们： 1&lt;template&gt; &lt;div&gt; &lt;Car v-on:clickedSomething=&quot;handleClickInParent&quot; /&gt; &lt;!-- or --&gt; &lt;Car @clickedSomething=&quot;handleClickInParent&quot; /&gt; &lt;/div&gt;&lt;/template&gt; 1&lt;script&gt;export default { name: 'App', methods: { handleClickInParent: function(param1, param2) { //... } }}&lt;/script&gt; 使用事件总线在任何组件之间进行通信使用事件，您不仅限于儿童与父母之间的关系。您可以使用所谓的事件总线。 上面我们曾经this.$emit在组件实例上发出一个事件。 相反，我们可以做的是在更易于访问的组件上发出事件。 this.$root根组件，通常用于此目的。 您还可以创建专用于此作业的Vue组件，然后将其导入所需的位置。 1&lt;script&gt;export default { name: 'Car', methods: { handleClick: function() { this.$root.$emit('clickedSomething') } }}&lt;/script&gt; 任何其他组件都可以侦听此事件。您可以在mounted回调中执行此操作： 1&lt;script&gt;export default { name: 'App', mounted() { this.$root.$on('clickedSomething', () =&gt; { //... }) }}&lt;/script&gt; 这就是Vue开箱即用的功能。 当您超出此范围时，可以查看Vuex或其他第三部分库。 使用Vuex管理状态Vuex是Vue.js的官方状态管理库。 它的工作是在应用程序的各个组件之间共享数据。 开箱即用的Vue.js中的组件可以使用 道具，将状态从父级传递到子级组件 事件，以从子级更改父组件的状态，或将根组件用作事件总线 有时候事情变得比这些简单的选项所允许的更为复杂。 在这种情况下，一个好的选择是将状态集中在一个存储中。这就是Vuex所做的。 为什么要使用Vuex？Vuex不是您可以在Vue中使用的唯一状态管理选项（您也可以使用Redux），但是它的主要优点是它是官方的，并且与Vue.js的集成才使它发光。 使用React，您将不得不选择众多可用库中的一种，因为该生态系统庞大且没有实际标准。最近，Redux是最受欢迎的选择，MobX在人气方面紧随其后。有了Vue，我想说的就是，除了Vuex之外，您无需四处寻找其他东西，尤其是在入门时。 Vuex从React生态系统中借鉴了许多想法，因为这是Redux流行的Flux模式。 如果您已经了解Flux或Redux，那么Vuex将非常熟悉。如果您不这样做，那就没问题-我将彻底解释每个概念。 Vue应用程序中的组件可以具有自己的状态。例如，一个输入框将在本地存储输入到其中的数据。这非常好，即使使用Vuex，组件也可以具有局部状态。 您知道开始进行大量工作来传递状态时需要Vuex之类的东西。 在这种情况下，Vuex为状态提供了一个中央存储库，您可以通过请求状态来对状态进行更改。 依赖于状态的特定部分的每个组件都将使用商店中的getter来访问它，以确保在状态发生变化时立即对其进行更新。 使用Vuex会给应用程序带来一些复杂性，因为需要以某种方式进行设置才能正常工作。但是，如果这有助于解决过于复杂的杂乱无章的道具传递和事件系统（如果变得过于复杂，则可能会变成意大利面条），那么这是一个不错的选择。 开始吧在此示例中，我从Vue CLI应用程序开始。通过直接将Vuex加载到脚本标签中，也可以使用它。但是，由于Vuex更适合大型应用程序，因此您很有可能会在结构化的应用程序上使用它，例如可以通过Vue CLI快速启动的应用程序。 我使用的示例将放在CodeSandbox中，它是一项很棒的服务，具有准备就绪的Vue CLI 示例。我建议使用它来玩耍。 到达之后，单击“添加依赖项”按钮，输入“ vuex”，然后单击它。 现在，Vuex将列在项目依赖项中。 要在本地安装Vuex，您可以简单地运行npm install vuex或yarn add vuex在项目文件夹中。 创建Vuex商店现在，我们准备创建Vuex商店。 该文件可以放在任何地方。通常建议将其放入src/store/store.js文件中，因此我们将这样做。 在此文件中，我们初始化Vuex并告诉Vue使用它： 123import Vue from 'vue'import Vuex from 'vuex'``` Vue.use(Vuex) 1 export const store = new Vuex.Store({}) 12345678910111213141516![](https://cdn-media-1.freecodecamp.org/images/p2kPCCKdhaHsHfXd4Nti975YVgvKMnbHbMRd)我们导出使用`Vuex.Store()`API 创建的Vuex存储对象。#### 商店的用例现在我们有了一个框架，让我们提出一个关于Vuex的好用例的想法，以便我介绍它的概念。例如，我有两个同级组件，一个带有一个输入字段，另一个打印该输入字段的内容。当输入字段更改时，我还要更改第二个组件中的内容。非常简单，但这将为我们完成工作。#### 介绍我们需要的新组件我删除HelloWorld组件，并添加一个Form组件和一个Display组件。 Favorite ice cream flavor? 12```&lt;template&gt; &lt;div&gt; &lt;p&gt;You chose ???&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 将这些组件添加到应用程序我们将它们添加到App.vue代码中，而不是HelloWorld组件中： 1&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;Form/&gt; &lt;Display/&gt; &lt;/div&gt;&lt;/template&gt; 1&lt;script&gt;import Form from './components/Form'import Display from './components/Display' 1export default { name: 'App', components: { Form, Display }}&lt;/script&gt; 将状态添加到商店因此，有了这个，我们回到store.js文件。我们向名为的商店添加了一个属性，该属性state是一个包含该flavor属性的对象。最初是一个空字符串。 1import Vue from 'vue'import Vuex from 'vuex' 1Vue.use(Vuex) 1export const store = new Vuex.Store({ state: { flavor: '' }}) 当用户在输入字段中键入内容时，我们将对其进行更新。 添加突变除非使用突变，否则无法操纵状态。我们设置了一个突变，该突变将在Form组件内部用于通知商店状态应该更改。 1import Vue from 'vue'import Vuex from 'vuex' 1Vue.use(Vuex) 1export const store = new Vuex.Store({ state: { flavor: '' }, mutations: { change(state, flavor) { state.flavor = flavor } }}) 添加获取器以引用状态属性设置好之后，我们需要添加一种查看状态的方法。我们使用吸气剂。我们为该flavor属性设置了一个吸气剂： 1import Vue from 'vue'import Vuex from 'vuex' 1Vue.use(Vuex) 1export const store = new Vuex.Store({ state: { flavor: '' }, mutations: { change(state, flavor) { state.flavor = flavor } }, getters: { flavor: state =&gt; state.flavor }}) 注意getters对象如何。flavor是此对象的属性，该对象接受状态作为参数，并返回flavor状态的属性。 将Vuex商店添加到应用程序现在该商店已准备就绪，可以使用。我们回到应用程序代码，在main.js文件中，我们需要导入状态并将其在我们的Vue应用程序中可用。 我们增加 1import { store } from './store/store' 并将其添加到Vue应用程序中： 1new Vue({ el: '#app', store, components: { App }, template: '&lt;App/&gt;'}) 一旦添加它，由于这是主要的Vue组件，因此store每个Vue组件中的变量都将指向Vuex存储。 使用提交更新用户操作的状态让我们在用户键入内容时更新状态。 我们通过使用store.commit()API来实现。 但是首先，让我们创建一个在输入内容更改时调用的方法。我们使用@input而不是@change因为后者仅在焦点移离输入框时触发，而@input每次按键时都会调用。 1&lt;template&gt; &lt;div&gt; &lt;label for=&quot;flavor&quot;&gt;Favorite ice cream flavor?&lt;/label&gt; &lt;input @input=&quot;changed&quot; name=&quot;flavor&quot;&gt; &lt;/div&gt;&lt;/template&gt; 1&lt;script&gt;export default { methods: { changed: function(event) { alert(event.target.value) } }}&lt;/script&gt; 现在我们有了风味的价值，我们使用Vuex API： 1&lt;script&gt;export default { methods: { changed: function(event) { this.$store.commit('change', event.target.value) } }}&lt;/script&gt; 看看我们如何使用来引用商店this.$store？这是由于store在主Vue组件初始化中包含了该对象。 该commit()方法接受一个突变名称（我们change在Vuex存储中使用了）和一个有效负载，这些负载将作为其回调函数的第二个参数传递给该突变。 使用吸气剂打印状态值现在，我们需要通过使用在Display模板中引用此值的getter $store.getters.flavor。this可以删除，因为我们在模板中，并且this是隐式的。 1&lt;template&gt; &lt;div&gt; &lt;p&gt;You chose {.{ $store.getters.flavor }}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 完整的有效源代码可在此处获得。 这个难题中仍然缺少许多概念： 行动 模组 帮手 外挂程式 但是现在您有了基本知识，可以在官方文档中阅读它们。 使用Vue路由器处理URL在JavaScript Web应用程序中，路由器是将当前显示的视图与浏览器地址栏内容同步的部分。 换句话说，这是使您在单击页面中的某些内容时更改URL的部分，并有助于在您单击特定的URL时显示正确的视图。 传统上，Web是围绕URL构建的。当您点击某个URL时，将显示一个特定页面。 随着在浏览器中运行的应用程序的引入并改变了用户的外观，许多应用程序中断了这种交互，因此您必须使用浏览器的History API手动更新URL。 当您需要将URL同步到应用程序中的视图时，需要一个路由器。这是非常普遍的需求，现在所有主要的现代框架都允许您管理路由。 Vue路由器库是用于Vue.js应用程序的方式。Vue不强制使用此库。您可以使用任何所需的通用路由库，也可以创建自己的History API集成，但是使用Vue Router的好处是它是官方的。 这意味着它由维护Vue的同一个人维护，因此您将在框架中获得更一致的集成，并保证无论将来如何，它始终是兼容的。 安装Vue Router可以通过名为npm的软件包通过npm获得vue-router。 如果通过脚本标签使用Vue，则可以使用 1&lt;script src=&quot;https://unpkg.com/vue-router&quot;&gt;&lt;/script&gt; UNPKG是一个非常方便的工具，它可以通过简单的链接在浏览器中提供每个npm软件包。 如果使用Vue CLI，请使用以下命令进行安装： 1npm install vue-router vue-router使用脚本标签或通过Vue CLI 安装并使其可用后，现在可以将其导入应用程序中。 您在之后导入它vue，然后调用Vue.use(VueRouter)将其安装在应用程序中： 1import Vue from 'vue'import VueRouter from 'vue-router' 1Vue.use(VueRouter) 调用Vue.use()传递路由器对象后，在应用程序的任何组件中您都可以访问以下对象： this.$router 是路由器对象 this.$route 是当前路线对象 路由器对象this.$router当Vue路由器安装在根Vue组件中时，可以使用任何组件访问该路由器对象，这些对象具有许多不错的功能。 我们可以使用以下方法使应用导航到新路线 this.$router.push() this.$router.replace() this.$router.go() 这类似于pushState，replaceState和go历史API的方法。 push() 用于转到新路线，将新项目添加到浏览器历史记录中 replace() 是相同的，只是它不会将新状态推向历史记录 用法样本： 1this.$router.push('about') //named route, see laterthis.$router.push({ path: 'about' })this.$router.push({ path: 'post', query: { post_slug: 'hello-world' } }) //using query parameters (post?post_slug=hello-world)this.$router.replace({ path: 'about' }) go() 来回移动，接受可以在历史记录中返回的正数或负数： 1this.$router.go(-1) //go back 1 stepthis.$router.go(1) //go forward 1 step 定义路线在此示例中，我正在使用Vue单个文件组件。 在模板中，我使用了一个nav标签，该标签包含三个router-link组件，分别具有标签Home，Login和About。URL通过to属性分配。 router-viewVue路由器将在该组件中放置与当前URL匹配的内容。 1&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;nav&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; &lt;router-link to=&quot;/login&quot;&gt;Login&lt;/router-link&gt; &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/nav&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 一个router-link组件显示的a默认标签（你可以改变）。每次更改路线时，通过单击链接或更改URL，都会将一个router-link-active类添加到引用活动路线的元素中，以设置其样式。 在JavaScript部分，我们首先包括并安装路由器，然后定义三个路由组件。 我们将它们传递给router对象的初始化，然后将此对象传递给Vue根实例。 这是代码： 1&lt;script&gt;import Vue from 'vue'import VueRouter from 'vue-router' 1Vue.use(Router) 1const Home = { template: '&lt;div&gt;Home&lt;/div&gt;'} 1const Login = { template: '&lt;div&gt;Login&lt;/div&gt;'} 1const About = { template: '&lt;div&gt;About&lt;/div&gt;'} 1const router = new VueRouter({ routes: [ { path: '/', component: Home }, { path: '/login', component: Login }, { path: '/about', component: About } ]}) 1new Vue({ router}).$mount('#app')&lt;/script&gt; 通常，在Vue应用程序中，您可以使用以下方法实例化并挂载根应用程序： 1new Vue({ render: h =&gt; h(App)}).$mount('#app') 使用Vue路由器时，您不会传递render属性，而是使用router。 上例中使用的语法： 1new Vue({ router}).$mount('#app') 是以下内容的简写： 1new Vue({ router: router}).$mount('#app') 在示例中看到，我们将routes数组传递给VueRouter构造函数。此数组中的每个路由都有path和component参数。 如果您也通过了name参数，那么您将具有命名路线。 使用命名的路由将参数传递到路由器的推入和替换方法还记得我们以前如何使用Router对象推送新状态吗？ 1this.$router.push({ path: 'about' }) 使用命名路由，我们可以将参数传递给新路由： 1this.$router.push({ name: 'post', params: { post_slug: 'hello-world' } }) 同样适用于replace()： 1this.$router.replace({ name: 'post', params: { post_slug: 'hello-world' } }) 当用户点击一个 router-link?该应用程序将呈现与传递给链接的URL匹配的路由组件。 实例化处理URL的新路由组件，并调用其防护措施，旧的路由组件将被销毁。 路线守卫既然我们提到了守卫，让我们对其进行介绍。 您可以将它们视为生命周期挂钩或中间件。这些是在应用程序执行期间的特定时间调用的函数。您可以加入并更改路由的执行，重定向或简单地取消请求。 您可以通过向路由器的beforeEach()and afterEach()属性添加回调来获得全局保护。 beforeEach() 在确认导航之前调用 beforeResolve()在beforeEach()执行并调用所有组件beforeRouterEnter和beforeRouteUpdate防护时但在确认导航之前调用。最后检查。 afterEach() 导航确认后调用 “导航已确认”是什么意思？我们将在一秒钟内看到它。同时，将其视为“应用程序可以走那条路”。 用法是： 1this.$router.beforeEach((to, from, next) =&gt; { // ...}) 1this.$router.afterEach((to, from) =&gt; { // ...}) to并from代表我们往返的路线对象。 beforeEach有一个附加参数next，如果我们调用false作为参数，它将阻止导航并导致其不确定。 就像在Node中间件中一样，如果您熟悉的话，next()应始终调用它，否则执行将被卡住。 单路径组件还具有防护装置： beforeRouteEnter(from, to, next) 在确认当前路线之前调用 beforeRouteUpdate(from, to, next)当路由更改但管理它的组件仍然相同时调用（使用动态路由，请参见next） beforeRouteLeave(from, to, next) 当我们离开这里时被称为 我们提到了导航。要确定是否确认导航到路线，Vue Router会执行一些检查： 它会beforeRouteLeave在当前组件中发出警戒 它称呼路由器beforeEach()守卫 它调用beforeRouteUpdate()需要重用的任何组件（如果存在） 它beforeEnter()在路由对象上调用了守卫（我没有提到它，但是您可以在这里查看） 它调用了beforeRouterEnter()我们应该输入的组件 它称呼路由器beforeResolve()守卫 如果一切正常，导航已确认！ 它称呼路由器afterEach()守卫 您可以使用路由的具体卫士（beforeRouteEnter和beforeRouteUpdate动态路由的情况下）的生命周期挂钩，这样你就可以开始进行数据抓取，例如请求。 动态路由以上示出了例如基于该URL不同的看法，处理/，/login和/about路由。 一个非常普遍的需求是处理动态路由，例如将所有帖子都放在之下/post/，每个帖子都带有一个名字。 /post/first /post/another-post /post/hello-world 您可以使用动态细分来实现。 这些是静态段： 1const router = new VueRouter({ routes: [ { path: '/', component: Home }, { path: '/login', component: Login }, { path: '/about', component: About } ]}) 我们添加了一个动态细分来处理博客文章： 1const router = new VueRouter({ routes: [ { path: '/', component: Home }, { path: '/post/:post_slug', component: Post }, { path: '/login', component: Login }, { path: '/about', component: About } ]}) 注意:post_slug语法。这意味着您可以使用任何字符串，并将其映射到post_slug占位符。 您不仅限于这种语法。Vue依靠此库来解析动态路由，并且您可以使用正则表达式疯狂。 现在，在“发布路线”组件内部，我们可以使用引用该路线$route，并使用$route.params.post_slug： 1const Post = { template: '&lt;div&gt;Post: {.{ $route.params.post_slug }}&lt;/div&gt;'} 我们可以使用此参数从后端加载内容。 在相同的URL中，您可以具有任意数量的动态细分： /post/:author/:post_slug 还记得我们谈论用户导航到新路线时会发生什么情况吗？ 在动态路线的情况下，发生的情况有些不同。 为了提高Vue的效率，它可以重用当前实例，而不是销毁当前路由组件并重新实例化它。 发生这种情况时，Vue会调用beforeRouteUpdate生命周期事件。 在那里您可以执行所需的任何操作： 1const Post = { template: '&lt;div&gt;Post: {.{ $route.params.post_slug }}&lt;/div&gt;' beforeRouteUpdate(to, from, next) { console.log(`Updating slug from ${from} to ${to}`) next() //make sure you always call next() }} 使用道具在示例中，我曾经$route.params.*访问过路线数​​据。组件不应与路由器紧密耦合，而可以使用道具： 1const Post = { props: ['post_slug'], template: '&lt;div&gt;Post: {.{ post_slug }}&lt;/div&gt;'} 1const router = new VueRouter({ routes: [ { path: '/post/:post_slug', component: Post, props: true } ]}) 请注意props: true传递给route对象以启用此功能。 嵌套路线在我提到之前，您可以在同一URL中具有任意数量的动态细分，例如： /post/:author/:post_slug 因此，假设我们有一个Author组件负责第一个动态段： 1&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 1&lt;script&gt;import Vue from 'vue'import VueRouter from 'vue-router' 1Vue.use(Router) 1const Author = { template: '&lt;div&gt;Author: {.{ $route.params.author}}&lt;/div&gt;'} 1const router = new VueRouter({ routes: [ { path: '/post/:author', component: Author } ]}) 1new Vue({ router}).$mount('#app')&lt;/script&gt; 我们可以router-view在Author模板中插入另一个组件实例： 1const Author = { template: '&lt;div&gt;Author: {.{ $route.params.author}}&lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;'} 我们添加Post组件： 1const Post = { template: '&lt;div&gt;Post: {.{ $route.params.post_slug }}&lt;/div&gt;'} 然后，我们将内部动态路由注入VueRouter配置中： 1const router = new VueRouter({ routes: [{ path: '/post/:author', component: Author, children: [ path: ':post_slug', component: Post ] }]})","link":"/2019/11/29/Vue%E6%89%8B%E5%86%8C%EF%BC%9AVue-js%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%8B%E7%BB%8D/"}],"tags":[{"name":"go","slug":"go","link":"/tags/go/"},{"name":"web","slug":"web","link":"/tags/web/"}],"categories":[{"name":"go","slug":"go","link":"/categories/go/"}]}