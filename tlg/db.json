{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/robot.txt","path":"robot.txt","modified":0,"renderable":0},{"_id":"source/images/pasted-10.png","path":"images/pasted-10.png","modified":0,"renderable":0},{"_id":"source/images/pasted-11.png","path":"images/pasted-11.png","modified":0,"renderable":0},{"_id":"source/images/pasted-0.png","path":"images/pasted-0.png","modified":0,"renderable":0},{"_id":"source/images/pasted-12.png","path":"images/pasted-12.png","modified":0,"renderable":0},{"_id":"source/images/pasted-15.png","path":"images/pasted-15.png","modified":0,"renderable":0},{"_id":"source/images/pasted-14.png","path":"images/pasted-14.png","modified":0,"renderable":0},{"_id":"source/images/pasted-13.png","path":"images/pasted-13.png","modified":0,"renderable":0},{"_id":"source/images/pasted-18.png","path":"images/pasted-18.png","modified":0,"renderable":0},{"_id":"source/images/pasted-17.png","path":"images/pasted-17.png","modified":0,"renderable":0},{"_id":"source/images/pasted-16.png","path":"images/pasted-16.png","modified":0,"renderable":0},{"_id":"source/images/pasted-19.png","path":"images/pasted-19.png","modified":0,"renderable":0},{"_id":"source/images/pasted-22.png","path":"images/pasted-22.png","modified":0,"renderable":0},{"_id":"source/images/pasted-20.png","path":"images/pasted-20.png","modified":0,"renderable":0},{"_id":"source/images/pasted-21.png","path":"images/pasted-21.png","modified":0,"renderable":0},{"_id":"source/images/pasted-25.png","path":"images/pasted-25.png","modified":0,"renderable":0},{"_id":"source/images/pasted-24.png","path":"images/pasted-24.png","modified":0,"renderable":0},{"_id":"source/images/pasted-23.png","path":"images/pasted-23.png","modified":0,"renderable":0},{"_id":"source/images/pasted-26.png","path":"images/pasted-26.png","modified":0,"renderable":0},{"_id":"source/images/pasted-28.png","path":"images/pasted-28.png","modified":0,"renderable":0},{"_id":"source/images/pasted-27.png","path":"images/pasted-27.png","modified":0,"renderable":0},{"_id":"source/images/pasted-29.png","path":"images/pasted-29.png","modified":0,"renderable":0},{"_id":"source/images/pasted-32.png","path":"images/pasted-32.png","modified":0,"renderable":0},{"_id":"source/images/pasted-31.png","path":"images/pasted-31.png","modified":0,"renderable":0},{"_id":"source/images/pasted-30.png","path":"images/pasted-30.png","modified":0,"renderable":0},{"_id":"source/images/pasted-33.png","path":"images/pasted-33.png","modified":0,"renderable":0},{"_id":"source/images/pasted-35.png","path":"images/pasted-35.png","modified":0,"renderable":0},{"_id":"source/images/pasted-34.png","path":"images/pasted-34.png","modified":0,"renderable":0},{"_id":"source/images/pasted-37.png","path":"images/pasted-37.png","modified":0,"renderable":0},{"_id":"source/images/pasted-36.png","path":"images/pasted-36.png","modified":0,"renderable":0},{"_id":"source/images/pasted-39.png","path":"images/pasted-39.png","modified":0,"renderable":0},{"_id":"source/images/pasted-38.png","path":"images/pasted-38.png","modified":0,"renderable":0},{"_id":"source/images/pasted-40.png","path":"images/pasted-40.png","modified":0,"renderable":0},{"_id":"source/images/pasted-41.png","path":"images/pasted-41.png","modified":0,"renderable":0},{"_id":"source/images/pasted-44.png","path":"images/pasted-44.png","modified":0,"renderable":0},{"_id":"source/images/pasted-45.png","path":"images/pasted-45.png","modified":0,"renderable":0},{"_id":"source/images/pasted-46.png","path":"images/pasted-46.png","modified":0,"renderable":0},{"_id":"source/images/pasted-6.png","path":"images/pasted-6.png","modified":0,"renderable":0},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","path":"img/article-list-background.jpeg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/school-book.png","path":"img/school-book.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"source/images/pasted-1.png","path":"images/pasted-1.png","modified":0,"renderable":0},{"_id":"source/images/pasted-43.png","path":"images/pasted-43.png","modified":0,"renderable":0},{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/iconfont.js","path":"js/iconfont.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","path":"js/jquery.autocomplete.min.js","modified":0,"renderable":1},{"_id":"source/images/pasted-8.png","path":"images/pasted-8.png","modified":0,"renderable":0},{"_id":"themes/3-hexo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","path":"js/jquery.pjax.js","modified":0,"renderable":1},{"_id":"source/images/pasted-4.png","path":"images/pasted-4.png","modified":0,"renderable":0},{"_id":"themes/3-hexo/source/img/weixin.jpg","path":"img/weixin.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":0,"renderable":1},{"_id":"source/images/pasted-42.png","path":"images/pasted-42.png","modified":0,"renderable":0},{"_id":"source/images/pasted-7.png","path":"images/pasted-7.png","modified":0,"renderable":0},{"_id":"source/images/pasted-9.png","path":"images/pasted-9.png","modified":0,"renderable":0},{"_id":"source/images/pasted-2.png","path":"images/pasted-2.png","modified":0,"renderable":0},{"_id":"source/images/pasted-3.png","path":"images/pasted-3.png","modified":0,"renderable":0},{"_id":"themes/3-hexo/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":0,"renderable":1},{"_id":"source/images/pasted-5.png","path":"images/pasted-5.png","modified":0,"renderable":0},{"_id":"themes/3-hexo/source/img/5d3521411f3f169375.png","path":"img/5d3521411f3f169375.png","modified":0,"renderable":1},{"_id":"source/images/pasted-47.png","path":"images/pasted-47.png","modified":1,"renderable":0}],"Cache":[{"_id":"themes/3-hexo/.gitignore","hash":"5e85fe97e87211619c1db29fd3f3b0dbf16be4a7","modified":1573450413717},{"_id":"themes/3-hexo/README.md","hash":"2cf4cefd4dcd71cc4d7c7664251d07acb11fb793","modified":1573450413716},{"_id":"themes/3-hexo/_config.yml","hash":"1378e90c7f24823c69d970542893a56a43bcd381","modified":1573450413715},{"_id":"source/robot.txt","hash":"49eafd7f9e9c2a42290ad4693c461f0a58d9de36","modified":1573450413467},{"_id":"themes/3-hexo/layout/indexs.md","hash":"7f57faed7e459a3e045774a6cbc91c4e73ef232a","modified":1573450413739},{"_id":"themes/3-hexo/layout/post.ejs","hash":"810f046277fc49f523a72d1552eab1e39d3c299c","modified":1573450413740},{"_id":"themes/3-hexo/layout/index.ejs","hash":"56fc95610a240e8bfe3d5b611896a819c1eb5dee","modified":1573450413719},{"_id":"source/images/pasted-10.png","hash":"5b61fc6408862eb5fb1b4cf715921e86998afc93","modified":1573450413518},{"_id":"source/images/pasted-11.png","hash":"9e73357736fae79671d20256a000c6a69b460410","modified":1573450413491},{"_id":"source/images/pasted-0.png","hash":"a3c2d2e1758d6efae4ef33248f995bdd9d10098f","modified":1573450413478},{"_id":"source/images/pasted-12.png","hash":"41d935d1da62188da49a974a014fb7260e586e82","modified":1573450413480},{"_id":"source/images/pasted-15.png","hash":"8deb0fec39595eb288fb692a187bdcc5efbd482f","modified":1573450413526},{"_id":"source/images/pasted-14.png","hash":"8deb0fec39595eb288fb692a187bdcc5efbd482f","modified":1573450413480},{"_id":"source/images/pasted-13.png","hash":"92aa50661c4908f23f77d553578299f7c23bcc4d","modified":1573450413507},{"_id":"source/images/pasted-18.png","hash":"2c7c009d8f337f9a9ca364b7407a126374e54d36","modified":1573450413483},{"_id":"source/images/pasted-17.png","hash":"bb0a0c274fc3d3863da6a2206430efb94754489f","modified":1573450413525},{"_id":"source/images/pasted-16.png","hash":"8deb0fec39595eb288fb692a187bdcc5efbd482f","modified":1573450413497},{"_id":"source/images/pasted-19.png","hash":"0910920e132be468244ee28a95d0832ad685d3b2","modified":1573450413478},{"_id":"source/images/pasted-22.png","hash":"9093b8671238eff0f45c99aa053e153131488504","modified":1573450413503},{"_id":"source/images/pasted-20.png","hash":"29dc13e68c2212d6739eefd7ec6d06fdb7117aa2","modified":1573450413494},{"_id":"source/images/pasted-21.png","hash":"93b855398c6498146884bc15e36c544e7d980b43","modified":1573450413469},{"_id":"source/images/pasted-25.png","hash":"af838e6767c91134a34964b74f288c22d370c4ff","modified":1573450413521},{"_id":"source/images/pasted-24.png","hash":"1f8d11d2a8e969721f1133496a339e8fd9303692","modified":1573450413499},{"_id":"source/images/pasted-23.png","hash":"1f8d11d2a8e969721f1133496a339e8fd9303692","modified":1573450413508},{"_id":"source/images/pasted-26.png","hash":"f0261f1234175c0b266237e4321166ff79767eee","modified":1573450413482},{"_id":"source/images/pasted-28.png","hash":"f0ed373f87b5a2be54d4b64c26b6ba10e913e534","modified":1573450413469},{"_id":"source/images/pasted-27.png","hash":"6aef92884168e893da56c4592048d4bb35e1ae2a","modified":1573450413512},{"_id":"source/images/pasted-29.png","hash":"f0ed373f87b5a2be54d4b64c26b6ba10e913e534","modified":1573450413496},{"_id":"source/images/pasted-32.png","hash":"f0ed373f87b5a2be54d4b64c26b6ba10e913e534","modified":1573450413509},{"_id":"source/images/pasted-31.png","hash":"f0ed373f87b5a2be54d4b64c26b6ba10e913e534","modified":1573450413476},{"_id":"source/images/pasted-30.png","hash":"f0ed373f87b5a2be54d4b64c26b6ba10e913e534","modified":1573450413507},{"_id":"source/images/pasted-33.png","hash":"f0ed373f87b5a2be54d4b64c26b6ba10e913e534","modified":1573450413525},{"_id":"source/images/pasted-35.png","hash":"fcf2c565ff9110bd0c6a717959416855c7918811","modified":1573450413523},{"_id":"source/images/pasted-34.png","hash":"ae2bf3f968d09d0e9e995f57201b0bba215d5839","modified":1573450413504},{"_id":"source/images/pasted-37.png","hash":"a2bf952c40d0bc78f4055df214859cd55b30ce83","modified":1573450413517},{"_id":"source/images/pasted-36.png","hash":"9bf496ffd46db1070c18a2d7e9109dc47e703b19","modified":1573450413510},{"_id":"source/images/pasted-39.png","hash":"41d1dcc59216e56cdfddea8961f72a4e7434e9f8","modified":1573450413494},{"_id":"source/images/pasted-38.png","hash":"25405dd08d2808dd07e21c7c63422f6bbd37a107","modified":1573450413519},{"_id":"source/images/pasted-40.png","hash":"f4eac91f202b5c6aadd9ae961b0388ea91ceee7a","modified":1573450413472},{"_id":"source/images/pasted-41.png","hash":"cab1e6e50d0cb19b8e6a2c9495af7f4ef05e3f1b","modified":1573450413496},{"_id":"source/images/pasted-44.png","hash":"fd0d4e4c827644410eb068fd902b48ea28cfaf95","modified":1573450413481},{"_id":"source/images/pasted-45.png","hash":"17848ec9e61e90964a37257deea1b05b5bd612ea","modified":1573450413490},{"_id":"source/images/pasted-46.png","hash":"9f71a930e96ea2cb1d7d10872230c3098848e68c","modified":1573450413511},{"_id":"source/images/pasted-6.png","hash":"586bb726534dd103c916f35403283a14afaa8030","modified":1573450413482},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"6f9f2b6234db3b99323595028f3123a80af67ce3","modified":1573450413729},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"1ecfeca2c4e11e424e92cbc1d22430a96bbdfab4","modified":1573450413721},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"5507b4dfab2032345e012a0c5356f63b01395157","modified":1573450413730},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"7f6173f5210d2e26396f132ea8861f731871738f","modified":1573450413731},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"266e4b638b71892fdca1f5870e8f2e5d695e0958","modified":1573450413720},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"374919e44ed62b11ad07c71a15bbdd2580bb7184","modified":1573450413728},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"7e6c50b6c24de864e0d6a106e6a8e423e312454a","modified":1573450413722},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"cb38ca16edfb93edcb47fdd77762d7836d4a67f6","modified":1573450413728},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"7a31274da81c076021692ff7c80a1be3bbf6fa4c","modified":1573450413736},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"c2e5cef2377884cd79e5f686fe4f74b082744306","modified":1573450413731},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"8b398109845b31d6a46cbce5224cfec565170ce0","modified":1573450413735},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"4f7e00e37783208cb350842085f1987ee854452e","modified":1573450413738},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"5416d135a65687dff9264641dd3d6bb1db7accf2","modified":1573460902000},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"6406251dabda66ef686d4c15edbc3061b6d828b8","modified":1573450413727},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"da40cb48b6b1f24cbd7107f7c97b04f063e9c299","modified":1573450413734},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1573450413753},{"_id":"themes/3-hexo/source/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1573450413747},{"_id":"themes/3-hexo/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1573450413755},{"_id":"themes/3-hexo/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1573450413753},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1573450413758},{"_id":"source/images/pasted-1.png","hash":"d1fd04ff88b18546b3e10422cfafdca926a66d7c","modified":1573450413492},{"_id":"source/images/pasted-43.png","hash":"e05bb59f201ceb5350829493ca20655db5255ca3","modified":1573450413487},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"3934bcba5095e7e6c6b3a801a6e4fa3a35096e10","modified":1573450413794},{"_id":"themes/3-hexo/source/css/style.styl","hash":"c7285882370f522c3bb17055cdf615cf92f48cd0","modified":1573450413781},{"_id":"themes/3-hexo/source/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1573450413797},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","hash":"7b8ac4d06c9e763963832529f44a56ad42a81e5f","modified":1573450413796},{"_id":"source/images/pasted-8.png","hash":"2e159d4afe19040ec7b41bf61250311c0ec978de","modified":1573450413521},{"_id":"themes/3-hexo/source/img/alipay.jpg","hash":"d2c0910565858035a608765978b9cee73523cacc","modified":1573450413756},{"_id":"themes/3-hexo/source/js/search.js","hash":"bccd29420fc9c946d6a131f48dae45fc2cedcb37","modified":1573450413794},{"_id":"themes/3-hexo/source/js/script.js","hash":"53ff0e47ef0e12b8e6ce70a73065b72f2967f598","modified":1573450413795},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1573450413803},{"_id":"source/images/pasted-4.png","hash":"9727a4005b12fb27259c74465d96ff82526b7000","modified":1573450413503},{"_id":"themes/3-hexo/source/img/weixin.jpg","hash":"fa4dfd707d67106ea31d65679cd96ef8fc9b6b94","modified":1573450413746},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1573450413761},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1573450413764},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1573450413760},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"37ac1ef28b03f46bf3ad2606c86f0e1ec3e4405f","modified":1573450413767},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","hash":"f8ed131ccf13f4bdd3ec11fc3e997339dd7b66ba","modified":1573450413769},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","hash":"3dfe8e557d9dfaf39bca088a02b76deb82dbaa3d","modified":1573450413768},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","hash":"aa087561480fb9c2cfd541e33d1e99d5ac1a56bb","modified":1573450413766},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","hash":"c61a31e5310430312677fffe4286097d29d10151","modified":1573450413762},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"69d184a682bcaeba2b180b437dc4431bc3be38aa","modified":1573450413790},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"57c7f100019d57b512aab509185cb0a6eb9aa4c8","modified":1573450413764},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1573450413789},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1573450413783},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1573450413784},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1573450413788},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1573450413783},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1573450413787},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1573450413790},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1573450413781},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1573450413787},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1573450413785},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1573450413787},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1573450413792},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1573450413787},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"933a3b196d01254dea5e6f48105ea15e210ae000","modified":1573450413787},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"359f73329b9821f3ca3554d306a04d6766110a5a","modified":1573450413725},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"cd0022ce7e6d6efb07a00e87477cdf791f7f6703","modified":1573450413726},{"_id":"themes/3-hexo/layout/_partial/comments/gentie.ejs","hash":"1d6eacdadeb247e3b349ca7168f797beae8ff4c5","modified":1573450413723},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1573450413781},{"_id":"themes/3-hexo/source/css/_partial/autocomplete.styl","hash":"f6847a2c6d35dbd6d06dc591bd34ed2019784048","modified":1573450413774},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"f16442568b43d034faaa8e3507f5ae8da34c7b72","modified":1573450413726},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"fbd3c7d72c8354d700918390c6cbfc0a11408277","modified":1573450413725},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"cc0a862b31359a85d12579e49d2eca58d128275c","modified":1573450413771},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f6447a2ac407228e1d53e3455db2919ac0e9f094","modified":1573450413777},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"4f687cbc74caf8a0887f5e89250284a9bce8b5c1","modified":1573450413776},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"4d5ac149709447c5eee45f0e23dadeea94fd98ce","modified":1573450413778},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"d7acabed9d375a0ee44d1480b68b7f50abdc7712","modified":1573450413772},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"0ba318911afbbbffbd2473b472aedf2d3900e978","modified":1573450413776},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"3da8fa04efccfd054a6a65f7153f197d4d68281d","modified":1573450413780},{"_id":"source/images/pasted-42.png","hash":"fa5289375c13a95d01a959851cbd6e289c1282a0","modified":1573450413491},{"_id":"source/images/pasted-7.png","hash":"f7855de786fbbdf651c96ca3bd5e6de240d48615","modified":1573450413506},{"_id":"source/images/pasted-9.png","hash":"e19709e1a2d3e4c4116fcc551e7dacb293259971","modified":1573450413522},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"4b996440bba8ec755aa70bc6d074d7dbba55ec0c","modified":1573450413773},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"cdead1a127e9bdd4818117e4c7fe7ac4638b4c19","modified":1573450413774},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"65efbddd23a264e7d1e85f4073228526770e833c","modified":1573450413775},{"_id":"source/images/pasted-2.png","hash":"f6f9a0478761cb2e4d692421f1705c5eec9db863","modified":1573450413475},{"_id":"source/images/pasted-3.png","hash":"a2944215ece304d078cc05649ebb0ce6435de141","modified":1573450413517},{"_id":"themes/3-hexo/source/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1573450413802},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"d1eb82a3280981bd652d9a8e323060e4311c547b","modified":1573450413799},{"_id":"source/images/pasted-5.png","hash":"7d4086cb38c890c689995bb66a53a340d2ae8c12","modified":1573450413486},{"_id":"themes/3-hexo/source/img/5d3521411f3f169375.png","hash":"1b5b9c4707634baed12b9ed02c57973c54663f09","modified":1573450413752},{"_id":"public/baidusitemap.xml","hash":"fc599a62e15c2bc3b9cab4fcf4f5b86742a33b66","modified":1573463029033},{"_id":"public/sitemap.xml","hash":"a373843c9a9135c6364952085004b3a95a283fc5","modified":1573463029033},{"_id":"public/robot.txt","hash":"49eafd7f9e9c2a42290ad4693c461f0a58d9de36","modified":1573463029075},{"_id":"public/images/pasted-10.png","hash":"5b61fc6408862eb5fb1b4cf715921e86998afc93","modified":1573463029075},{"_id":"public/images/pasted-11.png","hash":"9e73357736fae79671d20256a000c6a69b460410","modified":1573463029075},{"_id":"public/images/pasted-0.png","hash":"a3c2d2e1758d6efae4ef33248f995bdd9d10098f","modified":1573463029075},{"_id":"public/images/pasted-12.png","hash":"41d935d1da62188da49a974a014fb7260e586e82","modified":1573463029076},{"_id":"public/images/pasted-15.png","hash":"8deb0fec39595eb288fb692a187bdcc5efbd482f","modified":1573463029076},{"_id":"public/images/pasted-14.png","hash":"8deb0fec39595eb288fb692a187bdcc5efbd482f","modified":1573463029076},{"_id":"public/images/pasted-13.png","hash":"92aa50661c4908f23f77d553578299f7c23bcc4d","modified":1573463029076},{"_id":"public/images/pasted-17.png","hash":"bb0a0c274fc3d3863da6a2206430efb94754489f","modified":1573463029076},{"_id":"public/images/pasted-16.png","hash":"8deb0fec39595eb288fb692a187bdcc5efbd482f","modified":1573463029076},{"_id":"public/images/pasted-19.png","hash":"0910920e132be468244ee28a95d0832ad685d3b2","modified":1573463029076},{"_id":"public/images/pasted-22.png","hash":"9093b8671238eff0f45c99aa053e153131488504","modified":1573463029076},{"_id":"public/images/pasted-20.png","hash":"29dc13e68c2212d6739eefd7ec6d06fdb7117aa2","modified":1573463029076},{"_id":"public/images/pasted-21.png","hash":"93b855398c6498146884bc15e36c544e7d980b43","modified":1573463029076},{"_id":"public/images/pasted-25.png","hash":"af838e6767c91134a34964b74f288c22d370c4ff","modified":1573463029077},{"_id":"public/images/pasted-24.png","hash":"1f8d11d2a8e969721f1133496a339e8fd9303692","modified":1573463029077},{"_id":"public/images/pasted-23.png","hash":"1f8d11d2a8e969721f1133496a339e8fd9303692","modified":1573463029077},{"_id":"public/images/pasted-26.png","hash":"f0261f1234175c0b266237e4321166ff79767eee","modified":1573463029077},{"_id":"public/images/pasted-28.png","hash":"f0ed373f87b5a2be54d4b64c26b6ba10e913e534","modified":1573463029077},{"_id":"public/images/pasted-27.png","hash":"6aef92884168e893da56c4592048d4bb35e1ae2a","modified":1573463029077},{"_id":"public/images/pasted-29.png","hash":"f0ed373f87b5a2be54d4b64c26b6ba10e913e534","modified":1573463029077},{"_id":"public/images/pasted-32.png","hash":"f0ed373f87b5a2be54d4b64c26b6ba10e913e534","modified":1573463029077},{"_id":"public/images/pasted-31.png","hash":"f0ed373f87b5a2be54d4b64c26b6ba10e913e534","modified":1573463029077},{"_id":"public/images/pasted-30.png","hash":"f0ed373f87b5a2be54d4b64c26b6ba10e913e534","modified":1573463029077},{"_id":"public/images/pasted-33.png","hash":"f0ed373f87b5a2be54d4b64c26b6ba10e913e534","modified":1573463029078},{"_id":"public/images/pasted-36.png","hash":"9bf496ffd46db1070c18a2d7e9109dc47e703b19","modified":1573463029078},{"_id":"public/images/pasted-38.png","hash":"25405dd08d2808dd07e21c7c63422f6bbd37a107","modified":1573463029078},{"_id":"public/images/pasted-40.png","hash":"f4eac91f202b5c6aadd9ae961b0388ea91ceee7a","modified":1573463029078},{"_id":"public/images/pasted-41.png","hash":"cab1e6e50d0cb19b8e6a2c9495af7f4ef05e3f1b","modified":1573463029078},{"_id":"public/images/pasted-44.png","hash":"fd0d4e4c827644410eb068fd902b48ea28cfaf95","modified":1573463029078},{"_id":"public/images/pasted-45.png","hash":"17848ec9e61e90964a37257deea1b05b5bd612ea","modified":1573463029078},{"_id":"public/images/pasted-46.png","hash":"9f71a930e96ea2cb1d7d10872230c3098848e68c","modified":1573463029079},{"_id":"public/images/pasted-6.png","hash":"586bb726534dd103c916f35403283a14afaa8030","modified":1573463029079},{"_id":"public/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1573463029079},{"_id":"public/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1573463029101},{"_id":"public/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1573463029101},{"_id":"public/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1573463029101},{"_id":"public/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1573463029101},{"_id":"public/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1573463029101},{"_id":"public/css/fonts/icomoon.svg","hash":"37ac1ef28b03f46bf3ad2606c86f0e1ec3e4405f","modified":1573463029101},{"_id":"public/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1573463029101},{"_id":"public/css/fonts/iconfont.eot","hash":"3dfe8e557d9dfaf39bca088a02b76deb82dbaa3d","modified":1573463029101},{"_id":"public/css/fonts/iconfont.woff","hash":"f8ed131ccf13f4bdd3ec11fc3e997339dd7b66ba","modified":1573463030916},{"_id":"public/images/pasted-18.png","hash":"2c7c009d8f337f9a9ca364b7407a126374e54d36","modified":1573463030917},{"_id":"public/images/pasted-35.png","hash":"fcf2c565ff9110bd0c6a717959416855c7918811","modified":1573463030920},{"_id":"public/images/pasted-34.png","hash":"ae2bf3f968d09d0e9e995f57201b0bba215d5839","modified":1573463030920},{"_id":"public/images/pasted-37.png","hash":"a2bf952c40d0bc78f4055df214859cd55b30ce83","modified":1573463030920},{"_id":"public/images/pasted-39.png","hash":"41d1dcc59216e56cdfddea8961f72a4e7434e9f8","modified":1573463030920},{"_id":"public/css/fonts/iconfont.ttf","hash":"aa087561480fb9c2cfd541e33d1e99d5ac1a56bb","modified":1573463030920},{"_id":"public/images/pasted-1.png","hash":"d1fd04ff88b18546b3e10422cfafdca926a66d7c","modified":1573463030920},{"_id":"public/images/pasted-43.png","hash":"e05bb59f201ceb5350829493ca20655db5255ca3","modified":1573463030920},{"_id":"public/css/fonts/iconfont.svg","hash":"c61a31e5310430312677fffe4286097d29d10151","modified":1573463030920},{"_id":"public/images/pasted-8.png","hash":"2e159d4afe19040ec7b41bf61250311c0ec978de","modified":1573463030921},{"_id":"public/img/alipay.jpg","hash":"d2c0910565858035a608765978b9cee73523cacc","modified":1573463030921},{"_id":"public/img/weixin.jpg","hash":"fa4dfd707d67106ea31d65679cd96ef8fc9b6b94","modified":1573463030921},{"_id":"public/css/mobile.css","hash":"79ab291be160e0ca753512a96c5198f7477f13be","modified":1573463031025},{"_id":"public/js/jquery.autocomplete.min.js","hash":"7b8ac4d06c9e763963832529f44a56ad42a81e5f","modified":1573463031025},{"_id":"public/js/search.js","hash":"bccd29420fc9c946d6a131f48dae45fc2cedcb37","modified":1573463031026},{"_id":"public/css/hl_theme/atom-light.css","hash":"a3c8f3ee9a655594eff7ac545cb2e6914c1abcc2","modified":1573463031026},{"_id":"public/css/hl_theme/github-gist.css","hash":"7a41c1c479d09df875f99f1f6d94aac42e9e2ad0","modified":1573463031027},{"_id":"public/css/hl_theme/brown-paper.css","hash":"500c8e750373f6656ff49a7857c871ceedcf8777","modified":1573463031027},{"_id":"public/css/hl_theme/atom-dark.css","hash":"88d11052a24e8100af6248eb4dbe1ce7b0e96408","modified":1573463031027},{"_id":"public/css/hl_theme/github.css","hash":"e05a0806a508a26b9f3f3794b6b588ec6504ad3f","modified":1573463031027},{"_id":"public/css/hl_theme/kimbie-light.css","hash":"0c61926c989163faefb031d27bce3e287d6e10f2","modified":1573463031027},{"_id":"public/css/hl_theme/gruvbox-dark.css","hash":"8c440d9b4ee19ac03eaee3c6af78ba52e5ba5535","modified":1573463031027},{"_id":"public/css/hl_theme/gruvbox-light.css","hash":"30514aaa242a34647aa666cfca4fc74c595ea8f2","modified":1573463031043},{"_id":"public/css/hl_theme/darcula.css","hash":"4341074bae4bc9f0b86e32b623e27babc0159b6e","modified":1573463031043},{"_id":"public/css/hl_theme/kimbie-dark.css","hash":"728527fcc308da454722c119b89e6da3025bd1e3","modified":1573463031043},{"_id":"public/css/hl_theme/rainbow.css","hash":"7ff4251938076ddb7e4e49413db82653e5b61321","modified":1573463031043},{"_id":"public/css/hl_theme/railscasts.css","hash":"511f2fd2a84d426e5da5cb17880cc08f73beb002","modified":1573463031044},{"_id":"public/css/hl_theme/school-book.css","hash":"ffbbcd13a74ac2404262c50b7a43053dfd0096ff","modified":1573463031044},{"_id":"public/css/style.css","hash":"6bdecc63325857abe2b75293f79d5b1fd1e25fa6","modified":1573463031044},{"_id":"public/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1573463031044},{"_id":"public/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1573463031044},{"_id":"public/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1573463031044},{"_id":"public/js/script.js","hash":"53ff0e47ef0e12b8e6ce70a73065b72f2967f598","modified":1573463031044},{"_id":"public/css/fonts/selection.json","hash":"047b615ea32dc48dae5b964061427d41feaaafdf","modified":1573463031044},{"_id":"public/images/pasted-4.png","hash":"9727a4005b12fb27259c74465d96ff82526b7000","modified":1573463031044},{"_id":"public/images/pasted-42.png","hash":"fa5289375c13a95d01a959851cbd6e289c1282a0","modified":1573463031044},{"_id":"public/images/pasted-7.png","hash":"f7855de786fbbdf651c96ca3bd5e6de240d48615","modified":1573463031044},{"_id":"public/css/hl_theme/sublime.css","hash":"f65c5b116d9213afb9c324384a2f3bc86cb71121","modified":1573463031063},{"_id":"public/css/hl_theme/sunburst.css","hash":"8a135abac1512cf430d1d1ad2304b79afa1a4d6e","modified":1573463031064},{"_id":"public/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1573463031066},{"_id":"public/images/pasted-9.png","hash":"e19709e1a2d3e4c4116fcc551e7dacb293259971","modified":1573463031066},{"_id":"public/css/hl_theme/zenbum.css","hash":"0a78f74a93568e20b32ca7427c719e9bae9a0b55","modified":1573463031076},{"_id":"public/js/gitalk.js","hash":"d1eb82a3280981bd652d9a8e323060e4311c547b","modified":1573463031076},{"_id":"public/images/pasted-3.png","hash":"a2944215ece304d078cc05649ebb0ce6435de141","modified":1573463031082},{"_id":"public/images/pasted-2.png","hash":"f6f9a0478761cb2e4d692421f1705c5eec9db863","modified":1573463031082},{"_id":"public/images/pasted-5.png","hash":"7d4086cb38c890c689995bb66a53a340d2ae8c12","modified":1573463031100},{"_id":"public/img/5d3521411f3f169375.png","hash":"1b5b9c4707634baed12b9ed02c57973c54663f09","modified":1573463031110},{"_id":"source/_posts/第-02-课：基础模板用法.md","hash":"f04e3a1fbfd7b7d5ad97a7e2a910a9dd38da00d4","modified":1573466647980},{"_id":"source/_posts/test.md","hash":"761c8555ae6856d6b81ef37321bd1c3c148c7f46","modified":1573465447532},{"_id":"source/_posts/第-03-课：进阶模板用法.md","hash":"38e5b19c1416fd59a9a447ef3a37dc77ae4a8b8a","modified":1573466347968},{"_id":"source/images/pasted-47.png","hash":"177206c620ca7e60d76d86bdcb2415e1547cc45c","modified":1573465428682}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"第 02 课：基础模板用法","author":"知识铺","date":"2019-11-11T09:53:52.000Z","_content":"## 初识文本模板引擎\n\n标准库中的 [`text/template`](https://gowalker.org/text/template) 包是 Go 语言内置的文本模板引擎，虽然在灵活性上不如其它语言中第三方框架自带的模板引擎（如 Django、Ruby on Rails 等等），但功能依旧十分强大。根据标准库给出的定义，它的主要特性如下：\n\n1.  将模板应用于给定的数据结构来执行模板，模板的编码与 Go 语言源代码文件相同，需为 UTF-8 编码\n2.  模板中的注解（Annotation）会根据数据结构中的元素来执行并派生具体的显示结构，这些元素一般指结构体中的字段或 map 中的键名\n3.  模板的执行逻辑会依据点（Dot，`\".\"`）操作符来设定当前的执行位置，并按序完成所有逻辑的执行。\n4.  模板中的行为（Action）包括数据评估（Data Evaluation）和控制逻辑，且需要使用双层大括号（`{.{` 和 `}}`）包裹。除行为以外的任何内容都会原样输出不做修改。\n5.  模板解析完成后，从设计上可以并发地进行渲染，但要注意被渲染对象的并发安全性。例如，一个模板可以同时为多个客户端的响应进行渲染，因为输出对象（Writer）是相互独立的，但是被渲染的对象可能有各自的状态和时效性。\n\n接下来，让我们结合上节课所学的知识，从一个最简单的例子开始学习使用 Go 语言中的文本模板引擎。简单起见，我们依旧从输出 “Hello world!” 字符串开始。\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"text/template\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(\"Hello world!\")\n        if err != nil {\n            fmt.Fprintf(w, \"Parse: %v\", err)\n            return\n        }\n\n        // 调用模板对象的渲染方法\n        err = tmpl.Execute(w, nil)\n        if err != nil {\n            fmt.Fprintf(w, \"Execute: %v\", err)\n            return\n        }\n    })\n\n    log.Println(\"Starting HTTP server...\")\n    log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))\n}\n```\n\n如果运行上面的代码，就会发现和上节课的输出毫无区别，并且在作为处理器的匿名函数中增加了更多的逻辑。\n\n<code>➜ curl http://localhost:4000\nHello world!</code> \n\n相比之前多出来的这部分逻辑便是创建、解析和渲染模板的必要步骤：\n\n1.  [`template.New`](https://gowalker.org/text/template#New) 的作用就是根据用户给定的名称创建一个模板对象，本例中我们使用了 “test” 字符串作为这个模板对象的名称。另外，由于 [`template.New`](https://gowalker.org/text/template#New) 函数会直接返回一个 [`*template.Template`](https://gowalker.org/text/template#Template) 对象，因此可以直接链式操作调用该对象的 [`Parse`](https://gowalker.org/text/template#Template_Parse) 方法\n2.  [`template.Parse`](https://gowalker.org/text/template#Template_Parse) 方法接受一个 `string` 类型的参数，即文本模板的内容，然后对内容进行解析并返回解析过程中发生的任何错误。本例中，我们使用了没有任何模板语法的 “Hello world!” 字符串，同时获得了两个返回值。第一个返回值依旧是一个 [`*template.Template`](https://gowalker.org/text/template#Template) 对象，此时该对象已经包含了模板解析后的数据结构。第二个返回值便是在解析过程中可能出现的错误，这要求我们对该错误进行检查判断。\n3.  如果模板解析过程没有产生任何错误则表示模板可以被用于渲染了，[`template.Execute`](https://gowalker.org/text/template#Template_Execute) 就是用于渲染模板的方法，该方法接受两个参数：输出对象和指定数据对象（或根对象）。简单起见，本例中我们只使用到了第一个参数，即输出对象。凡是实现了 [`io.Writer`](https://gowalker.org/io#Writer) 接口的实例均可以作为输出对象，这在 Go 语言中是非常常见的一种编码模式。\n\n## 在模板中渲染变量\n\n学会了模板渲染的基本操作之后，我们就可以开始向模板中输出一些动态的内容了。首先，我们来快速了解一下怎么获取 HTTP 协议中 GET 请求的 URL 查询参数（即问号 “?” 之后的内容）。例如，我们想要获取 “/?val=123” 中的 “val” 的值，并返回给客户端。\n\n```\npackage main\n\nimport (\n    \"log\"\n    \"net/http\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        w.Write([]byte(r.URL.Query().Get(\"val\")))\n    })\n\n    log.Println(\"Starting HTTP server...\")\n    log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))\n}\n```\n\n我们这里用到的方法就是 `*http.Request` 对象的 `URL.Query().Get` 方法。通过终端执行可以获得如下结果，你还可以尝试赋予 “val” 其它的值，服务端也会输出对应的内容。\n\n<code>➜ curl http://localhost:4000/?val=123\n123</code> \n\n现在，我们可以结合模板语法，将这个 “val” 的值进行渲染了。\n\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"text/template\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(\"The value is: {.{.}}\")\n        if err != nil {\n            fmt.Fprintf(w, \"Parse: %v\", err)\n            return\n        }\n\n        // 获取 URL 参数的值\n        val := r.URL.Query().Get(\"val\")\n\n        // 调用模板对象的渲染方法\n        err = tmpl.Execute(w, val)\n        if err != nil {\n            fmt.Fprintf(w, \"Execute: %v\", err)\n            return\n        }\n    })\n\n    log.Println(\"Starting HTTP server...\")\n    log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))\n}\n```\n\n在上面的代码中，你可以注意到模板的内容被替换为了 `The value is: {.{.}}`，即使用了分隔符将点操作符包裹起来。在 Go 语言的标准库模板引擎中，点操作符默认指向的是根对象，即我们在调用 [`template.Execute`](https://gowalker.org/text/template#Template_Execute) 方法时传入的第二个参数。本例中，我们传入的根对象是一个单纯的 `string` 类型的变量 `val`，那么点操作符的渲染对象就是变量 `val`。\n\n尝试运行以上代码可以在终端获得以下结果：\n\n<code>➜ curl http://localhost:4000/?val=666\nThe value is: 666</code> \n\n至此，我们就成功地对 [`text/template`](https://gowalker.org/text/template) 包提供的文本模板引擎实现了第一次动态输出啦！\n\n## 在模板中渲染复杂对象\n\n你是否也正在思考，除了简单类型的变量，根对象还可以是什么类型呢？细心的你可能已经发现，[`template.Execute`](https://gowalker.org/text/template#Template_Execute) 方法的第二个参数类型为 `interface{}`，也就是说可以传入任何类型。这代表 [`text/template`](https://gowalker.org/text/template) 包提供的文本模板引擎会根据所提供的根对象进行底层类型分析，然后自动判断应该以什么样的形式去理解模板中的语法。以点操作符为例，如果根对象为变量，那么点操作符代表的就是一个变量；而如果根对象为一个复合类型，那么点操作符所代表的也就是这个复合类型。\n\n让我们来创建一个名为 `Inventory` 的复合类型，然后通过 URL 查询参数的值创建一个实例，最后通过模板渲染出各个字段的值：\n\n```\npackage main\n\nimport (\n    ...\n    \"strconv\"\n)\n\ntype Inventory struct {\n    SKU       string\n    Name      string\n    UnitPrice float64\n    Quantity  int64\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`Inventory\nSKU: {.{.SKU}}\nName: {.{.Name}}\nUnitPrice: {.{.UnitPrice}}\nQuantity: {.{.Quantity}}\n`)\n        ...\n\n        // 根据 URL 查询参数的值创建 Inventory 实例\n        inventory := &Inventory{\n            SKU:  r.URL.Query().Get(\"sku\"),\n            Name: r.URL.Query().Get(\"name\"),\n        }\n\n        // 注意：为了简化代码逻辑，这里并没有进行错误处理\n        inventory.UnitPrice, _ = strconv.ParseFloat(r.URL.Query().Get(\"unitPrice\"), 64)\n        inventory.Quantity, _ = strconv.ParseInt(r.URL.Query().Get(\"quantity\"), 10, 64)\n\n        // 调用模板对象的渲染方法\n        ...\n    })\n\n    log.Println(\"Starting HTTP server...\")\n    log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))\n}\n```\n\n（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）\n\n以上代码主要有两部分变动，第一部分是修改了模板内容（注意代码中使用反引号而非双引号）：\n\n<code>Inventory\nSKU: {.{.SKU}}\nName: {.{.Name}}\nUnitPrice: {.{.UnitPrice}}\nQuantity: {.{.Quantity}}</code> \n\n你可以注意到，使用分隔符包裹起来的内容和 `Inventory` 类型中的字段名称是一一对应的，且大小写保持一致（Go 语言是一门大小写敏感的语言）。模板中使用了点操作符指代根对象 `inventory`，即通过 URL 查询参数的值所创建的一个变量。这里用到了 [`strconv`](https://gowalker.org/strconv) 包中的 `ParseFloat` 和 `ParseInt` 函数，主要作用为解析字符串为浮点型和整型数字，感兴趣的同学可以自行阅读文档进行更加深入了解。\n\n尝试运行以上代码可以在终端获得以下结果：\n\n<code>➜ curl http://localhost:4000/?sku=1122334&name=phone&unitPrice=649.99&quantity=833\nInventory\nSKU: 1122334\nName: phone\nUnitPrice: 649.99\nQuantity: 833</code> \n\n我们看到，修改根对象为一个复合类型也可以轻易地使用标准库的文本模板引擎进行渲染。\n\n## 在模板中调用结构的方法\n\n我们已经讲解了如何在模板中显示具体对象的字段值，那么，是不是也可以使用同样的方式来调用对象所具有的方法呢？答案当然是肯定的。\n\n我们需要先为 `Inventory` 类型添加一个方法，称为 `Subtotal`，即根据该商品的单价和数量来显示当前库存所具有的价值。\n\n```\n// Subtotal 根据单价和数量计算出总价值\nfunc (i *Inventory) Subtotal() float64 {\n    return i.UnitPrice * float64(i.Quantity)\n}\n```\n然后在模板中添加相关的内容，使得计算结果能够通过模板渲染展示给客户端。\n\n```\n...\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`Inventory\nSKU: {.{.SKU}}\nName: {.{.Name}}\nUnitPrice: {.{.UnitPrice}}\nQuantity: {.{.Quantity}}\nSubtotal: {.{.Subtotal}}\n`)\n...\n```\n\n（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）\n\n可以注意到，在 [`text/template`](https://gowalker.org/text/template) 包提供的文本模板引擎中，显示方法调用结果的值和字段的值的语法是完全相同的，即不需要在方法名称后使用括号表示调用。该模板引擎会在渲染时自动识别所调用对象的具体类型，然后做出相应的操作。\n\n尝试运行以上代码可以在终端获得以下结果：\n\n<code>➜ curl http://localhost:4000/?sku=1122334&name=phone&unitPrice=649.99&quantity=833\nInventory\nSKU: 1122334\nName: phone\nUnitPrice: 649.99\nQuantity: 833\nSubtotal: 541441.67</code> \n## 使用 map 类型作为模板根对象\n\n我想聪明的你已经意识到将某个具体类型作为模板根对象的局限性，因为不论想要展示什么内容，都需要通过修改添加类型的字段或方法才能实现，在操作上非常的不灵活。但是，如果你还记得根对象的参数类型为 `interface{}` 的话，应该就不难理解通过利用一个 `map[string]interface{}` 类型的根对象，可以实现灵活地向模板中添加需要被渲染的子对象。\n\n这种方案可行的根本原因是因为在 Go 语言中，当 `interface{}` 类型作为参数时，调用者可以传入任意类型的值，效果类似 Java 中的 Object 类型。\n\n接下来，让我们通过使用 `map[string]interface{}` 类型作为根对象，实现之前展示 `Inventory` 类型中字段值的效果。\n\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"strconv\"\n    \"text/template\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`Inventory\nSKU: {.{.SKU}}\nName: {.{.Name}}\nUnitPrice: {.{.UnitPrice}}\nQuantity: {.{.Quantity}}\n`)\n        if err != nil {\n            fmt.Fprintf(w, \"Parse: %v\", err)\n            return\n        }\n\n        // 获取 URL 查询参数的值\n        // 注意：为了简化代码逻辑，这里并没有进行错误处理\n        sku := r.URL.Query().Get(\"sku\")\n        name := r.URL.Query().Get(\"name\")\n        unitPrice, _ := strconv.ParseFloat(r.URL.Query().Get(\"unitPrice\"), 64)\n        quantity, _ := strconv.ParseInt(r.URL.Query().Get(\"quantity\"), 10, 64)\n\n        // 调用模板对象的渲染方法，并创建一个 map[string]interface{} 类型的临时变量作为根对象\n        err = tmpl.Execute(w, map[string]interface{}{\n            \"SKU\":       sku,\n            \"Name\":      name,\n            \"UnitPrice\": unitPrice,\n            \"Quantity\":  quantity,\n        })\n        if err != nil {\n            fmt.Fprintf(w, \"Execute: %v\", err)\n            return\n        }\n    })\n\n    log.Println(\"Starting HTTP server...\")\n    log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))\n}\n```\n\n在以上代码中，我们将 URL 查询参数赋值给多个变量，然后将所有变量以键值对的形式生成一个 `map[string]interface{}` 类型的临时对象作为模板的根对象。相比之前需要先定义一个 `Inventory` 类型而言，这种方式可以更加灵活便利地将对象放置到模板中用于渲染。\n\n尝试运行以上代码可以在终端获得与之前相同的结果：\n\n<code>➜ curl http://localhost:4000/?sku=1122334&name=phone&unitPrice=649.99&quantity=833\nInventory\nSKU: 1122334\nName: phone\nUnitPrice: 649.99\nQuantity: 833</code> \n\n许多 Web 框架的实现都是基于这个小技巧，如果之前还不明所以的话，现在应该知道这其中的原理了吧？\n\n## 在模板中使用注释\n\n虽然目前我们所使用的模板文本还都非常简单，但当模板内容变多、逻辑更加复杂的时候就会想要使用注释来进行辅助理解，便于后期的维护和开发。在这节课的最后，我们来学习如何在 [`text/template`](https://gowalker.org/text/template) 包提供的文本模板引擎中进行注释的语法。\n\n注释的语法和 Go 语言程序代码中的块注释语法相同，即使用 `/*` 和 `*/` 将注释内容包括起来，例如：`{.{/* 这是注释内容 */}}`。\n\n简单修改一下我们已有的模板文本，就可以发现如同源代码中的注释一样，模板中的注释会在模板的解析阶段被剔除：\n\n```\n...\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`{.{/* 打印参数的值 */}}\nInventory\nSKU: {.{.SKU}}\nName: {.{.Name}}\nUnitPrice: {.{.UnitPrice}}\nQuantity: {.{.Quantity}}\n`)\n...\n```\n\n（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）\n\n尝试运行以上代码可以在终端获得与之前相同的结果：\n\n<code>➜ curl http://localhost:4000/?sku=1122334&name=phone&unitPrice=649.99&quantity=833\n\nInventory\nSKU: 1122334\nName: phone\nUnitPrice: 649.99\nQuantity: 833</code> \n\n注意 “Inventory” 字符串之前多了一个空行，就是模板文本中注释所在的那一行。\n\n## 小结\n\n这节课，我们学习了标准库中 [`text/template`](https://gowalker.org/text/template) 包提供的文本模板引擎的基础用法，了解了模板渲染和根对象的概念，并学会了有关根对象类型的一个小技巧。\n","source":"_posts/第-02-课：基础模板用法.md","raw":"title: 第 02 课：基础模板用法\nauthor: 知识铺\ndate: 2019-11-11 17:53:52\ntags:\n---\n## 初识文本模板引擎\n\n标准库中的 [`text/template`](https://gowalker.org/text/template) 包是 Go 语言内置的文本模板引擎，虽然在灵活性上不如其它语言中第三方框架自带的模板引擎（如 Django、Ruby on Rails 等等），但功能依旧十分强大。根据标准库给出的定义，它的主要特性如下：\n\n1.  将模板应用于给定的数据结构来执行模板，模板的编码与 Go 语言源代码文件相同，需为 UTF-8 编码\n2.  模板中的注解（Annotation）会根据数据结构中的元素来执行并派生具体的显示结构，这些元素一般指结构体中的字段或 map 中的键名\n3.  模板的执行逻辑会依据点（Dot，`\".\"`）操作符来设定当前的执行位置，并按序完成所有逻辑的执行。\n4.  模板中的行为（Action）包括数据评估（Data Evaluation）和控制逻辑，且需要使用双层大括号（`{.{` 和 `}}`）包裹。除行为以外的任何内容都会原样输出不做修改。\n5.  模板解析完成后，从设计上可以并发地进行渲染，但要注意被渲染对象的并发安全性。例如，一个模板可以同时为多个客户端的响应进行渲染，因为输出对象（Writer）是相互独立的，但是被渲染的对象可能有各自的状态和时效性。\n\n接下来，让我们结合上节课所学的知识，从一个最简单的例子开始学习使用 Go 语言中的文本模板引擎。简单起见，我们依旧从输出 “Hello world!” 字符串开始。\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"text/template\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(\"Hello world!\")\n        if err != nil {\n            fmt.Fprintf(w, \"Parse: %v\", err)\n            return\n        }\n\n        // 调用模板对象的渲染方法\n        err = tmpl.Execute(w, nil)\n        if err != nil {\n            fmt.Fprintf(w, \"Execute: %v\", err)\n            return\n        }\n    })\n\n    log.Println(\"Starting HTTP server...\")\n    log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))\n}\n```\n\n如果运行上面的代码，就会发现和上节课的输出毫无区别，并且在作为处理器的匿名函数中增加了更多的逻辑。\n\n<code>➜ curl http://localhost:4000\nHello world!</code> \n\n相比之前多出来的这部分逻辑便是创建、解析和渲染模板的必要步骤：\n\n1.  [`template.New`](https://gowalker.org/text/template#New) 的作用就是根据用户给定的名称创建一个模板对象，本例中我们使用了 “test” 字符串作为这个模板对象的名称。另外，由于 [`template.New`](https://gowalker.org/text/template#New) 函数会直接返回一个 [`*template.Template`](https://gowalker.org/text/template#Template) 对象，因此可以直接链式操作调用该对象的 [`Parse`](https://gowalker.org/text/template#Template_Parse) 方法\n2.  [`template.Parse`](https://gowalker.org/text/template#Template_Parse) 方法接受一个 `string` 类型的参数，即文本模板的内容，然后对内容进行解析并返回解析过程中发生的任何错误。本例中，我们使用了没有任何模板语法的 “Hello world!” 字符串，同时获得了两个返回值。第一个返回值依旧是一个 [`*template.Template`](https://gowalker.org/text/template#Template) 对象，此时该对象已经包含了模板解析后的数据结构。第二个返回值便是在解析过程中可能出现的错误，这要求我们对该错误进行检查判断。\n3.  如果模板解析过程没有产生任何错误则表示模板可以被用于渲染了，[`template.Execute`](https://gowalker.org/text/template#Template_Execute) 就是用于渲染模板的方法，该方法接受两个参数：输出对象和指定数据对象（或根对象）。简单起见，本例中我们只使用到了第一个参数，即输出对象。凡是实现了 [`io.Writer`](https://gowalker.org/io#Writer) 接口的实例均可以作为输出对象，这在 Go 语言中是非常常见的一种编码模式。\n\n## 在模板中渲染变量\n\n学会了模板渲染的基本操作之后，我们就可以开始向模板中输出一些动态的内容了。首先，我们来快速了解一下怎么获取 HTTP 协议中 GET 请求的 URL 查询参数（即问号 “?” 之后的内容）。例如，我们想要获取 “/?val=123” 中的 “val” 的值，并返回给客户端。\n\n```\npackage main\n\nimport (\n    \"log\"\n    \"net/http\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        w.Write([]byte(r.URL.Query().Get(\"val\")))\n    })\n\n    log.Println(\"Starting HTTP server...\")\n    log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))\n}\n```\n\n我们这里用到的方法就是 `*http.Request` 对象的 `URL.Query().Get` 方法。通过终端执行可以获得如下结果，你还可以尝试赋予 “val” 其它的值，服务端也会输出对应的内容。\n\n<code>➜ curl http://localhost:4000/?val=123\n123</code> \n\n现在，我们可以结合模板语法，将这个 “val” 的值进行渲染了。\n\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"text/template\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(\"The value is: {.{.}}\")\n        if err != nil {\n            fmt.Fprintf(w, \"Parse: %v\", err)\n            return\n        }\n\n        // 获取 URL 参数的值\n        val := r.URL.Query().Get(\"val\")\n\n        // 调用模板对象的渲染方法\n        err = tmpl.Execute(w, val)\n        if err != nil {\n            fmt.Fprintf(w, \"Execute: %v\", err)\n            return\n        }\n    })\n\n    log.Println(\"Starting HTTP server...\")\n    log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))\n}\n```\n\n在上面的代码中，你可以注意到模板的内容被替换为了 `The value is: {.{.}}`，即使用了分隔符将点操作符包裹起来。在 Go 语言的标准库模板引擎中，点操作符默认指向的是根对象，即我们在调用 [`template.Execute`](https://gowalker.org/text/template#Template_Execute) 方法时传入的第二个参数。本例中，我们传入的根对象是一个单纯的 `string` 类型的变量 `val`，那么点操作符的渲染对象就是变量 `val`。\n\n尝试运行以上代码可以在终端获得以下结果：\n\n<code>➜ curl http://localhost:4000/?val=666\nThe value is: 666</code> \n\n至此，我们就成功地对 [`text/template`](https://gowalker.org/text/template) 包提供的文本模板引擎实现了第一次动态输出啦！\n\n## 在模板中渲染复杂对象\n\n你是否也正在思考，除了简单类型的变量，根对象还可以是什么类型呢？细心的你可能已经发现，[`template.Execute`](https://gowalker.org/text/template#Template_Execute) 方法的第二个参数类型为 `interface{}`，也就是说可以传入任何类型。这代表 [`text/template`](https://gowalker.org/text/template) 包提供的文本模板引擎会根据所提供的根对象进行底层类型分析，然后自动判断应该以什么样的形式去理解模板中的语法。以点操作符为例，如果根对象为变量，那么点操作符代表的就是一个变量；而如果根对象为一个复合类型，那么点操作符所代表的也就是这个复合类型。\n\n让我们来创建一个名为 `Inventory` 的复合类型，然后通过 URL 查询参数的值创建一个实例，最后通过模板渲染出各个字段的值：\n\n```\npackage main\n\nimport (\n    ...\n    \"strconv\"\n)\n\ntype Inventory struct {\n    SKU       string\n    Name      string\n    UnitPrice float64\n    Quantity  int64\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`Inventory\nSKU: {.{.SKU}}\nName: {.{.Name}}\nUnitPrice: {.{.UnitPrice}}\nQuantity: {.{.Quantity}}\n`)\n        ...\n\n        // 根据 URL 查询参数的值创建 Inventory 实例\n        inventory := &Inventory{\n            SKU:  r.URL.Query().Get(\"sku\"),\n            Name: r.URL.Query().Get(\"name\"),\n        }\n\n        // 注意：为了简化代码逻辑，这里并没有进行错误处理\n        inventory.UnitPrice, _ = strconv.ParseFloat(r.URL.Query().Get(\"unitPrice\"), 64)\n        inventory.Quantity, _ = strconv.ParseInt(r.URL.Query().Get(\"quantity\"), 10, 64)\n\n        // 调用模板对象的渲染方法\n        ...\n    })\n\n    log.Println(\"Starting HTTP server...\")\n    log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))\n}\n```\n\n（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）\n\n以上代码主要有两部分变动，第一部分是修改了模板内容（注意代码中使用反引号而非双引号）：\n\n<code>Inventory\nSKU: {.{.SKU}}\nName: {.{.Name}}\nUnitPrice: {.{.UnitPrice}}\nQuantity: {.{.Quantity}}</code> \n\n你可以注意到，使用分隔符包裹起来的内容和 `Inventory` 类型中的字段名称是一一对应的，且大小写保持一致（Go 语言是一门大小写敏感的语言）。模板中使用了点操作符指代根对象 `inventory`，即通过 URL 查询参数的值所创建的一个变量。这里用到了 [`strconv`](https://gowalker.org/strconv) 包中的 `ParseFloat` 和 `ParseInt` 函数，主要作用为解析字符串为浮点型和整型数字，感兴趣的同学可以自行阅读文档进行更加深入了解。\n\n尝试运行以上代码可以在终端获得以下结果：\n\n<code>➜ curl http://localhost:4000/?sku=1122334&name=phone&unitPrice=649.99&quantity=833\nInventory\nSKU: 1122334\nName: phone\nUnitPrice: 649.99\nQuantity: 833</code> \n\n我们看到，修改根对象为一个复合类型也可以轻易地使用标准库的文本模板引擎进行渲染。\n\n## 在模板中调用结构的方法\n\n我们已经讲解了如何在模板中显示具体对象的字段值，那么，是不是也可以使用同样的方式来调用对象所具有的方法呢？答案当然是肯定的。\n\n我们需要先为 `Inventory` 类型添加一个方法，称为 `Subtotal`，即根据该商品的单价和数量来显示当前库存所具有的价值。\n\n```\n// Subtotal 根据单价和数量计算出总价值\nfunc (i *Inventory) Subtotal() float64 {\n    return i.UnitPrice * float64(i.Quantity)\n}\n```\n然后在模板中添加相关的内容，使得计算结果能够通过模板渲染展示给客户端。\n\n```\n...\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`Inventory\nSKU: {.{.SKU}}\nName: {.{.Name}}\nUnitPrice: {.{.UnitPrice}}\nQuantity: {.{.Quantity}}\nSubtotal: {.{.Subtotal}}\n`)\n...\n```\n\n（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）\n\n可以注意到，在 [`text/template`](https://gowalker.org/text/template) 包提供的文本模板引擎中，显示方法调用结果的值和字段的值的语法是完全相同的，即不需要在方法名称后使用括号表示调用。该模板引擎会在渲染时自动识别所调用对象的具体类型，然后做出相应的操作。\n\n尝试运行以上代码可以在终端获得以下结果：\n\n<code>➜ curl http://localhost:4000/?sku=1122334&name=phone&unitPrice=649.99&quantity=833\nInventory\nSKU: 1122334\nName: phone\nUnitPrice: 649.99\nQuantity: 833\nSubtotal: 541441.67</code> \n## 使用 map 类型作为模板根对象\n\n我想聪明的你已经意识到将某个具体类型作为模板根对象的局限性，因为不论想要展示什么内容，都需要通过修改添加类型的字段或方法才能实现，在操作上非常的不灵活。但是，如果你还记得根对象的参数类型为 `interface{}` 的话，应该就不难理解通过利用一个 `map[string]interface{}` 类型的根对象，可以实现灵活地向模板中添加需要被渲染的子对象。\n\n这种方案可行的根本原因是因为在 Go 语言中，当 `interface{}` 类型作为参数时，调用者可以传入任意类型的值，效果类似 Java 中的 Object 类型。\n\n接下来，让我们通过使用 `map[string]interface{}` 类型作为根对象，实现之前展示 `Inventory` 类型中字段值的效果。\n\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"strconv\"\n    \"text/template\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`Inventory\nSKU: {.{.SKU}}\nName: {.{.Name}}\nUnitPrice: {.{.UnitPrice}}\nQuantity: {.{.Quantity}}\n`)\n        if err != nil {\n            fmt.Fprintf(w, \"Parse: %v\", err)\n            return\n        }\n\n        // 获取 URL 查询参数的值\n        // 注意：为了简化代码逻辑，这里并没有进行错误处理\n        sku := r.URL.Query().Get(\"sku\")\n        name := r.URL.Query().Get(\"name\")\n        unitPrice, _ := strconv.ParseFloat(r.URL.Query().Get(\"unitPrice\"), 64)\n        quantity, _ := strconv.ParseInt(r.URL.Query().Get(\"quantity\"), 10, 64)\n\n        // 调用模板对象的渲染方法，并创建一个 map[string]interface{} 类型的临时变量作为根对象\n        err = tmpl.Execute(w, map[string]interface{}{\n            \"SKU\":       sku,\n            \"Name\":      name,\n            \"UnitPrice\": unitPrice,\n            \"Quantity\":  quantity,\n        })\n        if err != nil {\n            fmt.Fprintf(w, \"Execute: %v\", err)\n            return\n        }\n    })\n\n    log.Println(\"Starting HTTP server...\")\n    log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))\n}\n```\n\n在以上代码中，我们将 URL 查询参数赋值给多个变量，然后将所有变量以键值对的形式生成一个 `map[string]interface{}` 类型的临时对象作为模板的根对象。相比之前需要先定义一个 `Inventory` 类型而言，这种方式可以更加灵活便利地将对象放置到模板中用于渲染。\n\n尝试运行以上代码可以在终端获得与之前相同的结果：\n\n<code>➜ curl http://localhost:4000/?sku=1122334&name=phone&unitPrice=649.99&quantity=833\nInventory\nSKU: 1122334\nName: phone\nUnitPrice: 649.99\nQuantity: 833</code> \n\n许多 Web 框架的实现都是基于这个小技巧，如果之前还不明所以的话，现在应该知道这其中的原理了吧？\n\n## 在模板中使用注释\n\n虽然目前我们所使用的模板文本还都非常简单，但当模板内容变多、逻辑更加复杂的时候就会想要使用注释来进行辅助理解，便于后期的维护和开发。在这节课的最后，我们来学习如何在 [`text/template`](https://gowalker.org/text/template) 包提供的文本模板引擎中进行注释的语法。\n\n注释的语法和 Go 语言程序代码中的块注释语法相同，即使用 `/*` 和 `*/` 将注释内容包括起来，例如：`{.{/* 这是注释内容 */}}`。\n\n简单修改一下我们已有的模板文本，就可以发现如同源代码中的注释一样，模板中的注释会在模板的解析阶段被剔除：\n\n```\n...\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`{.{/* 打印参数的值 */}}\nInventory\nSKU: {.{.SKU}}\nName: {.{.Name}}\nUnitPrice: {.{.UnitPrice}}\nQuantity: {.{.Quantity}}\n`)\n...\n```\n\n（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）\n\n尝试运行以上代码可以在终端获得与之前相同的结果：\n\n<code>➜ curl http://localhost:4000/?sku=1122334&name=phone&unitPrice=649.99&quantity=833\n\nInventory\nSKU: 1122334\nName: phone\nUnitPrice: 649.99\nQuantity: 833</code> \n\n注意 “Inventory” 字符串之前多了一个空行，就是模板文本中注释所在的那一行。\n\n## 小结\n\n这节课，我们学习了标准库中 [`text/template`](https://gowalker.org/text/template) 包提供的文本模板引擎的基础用法，了解了模板渲染和根对象的概念，并学会了有关根对象类型的一个小技巧。\n","slug":"第-02-课：基础模板用法","published":1,"updated":"2019-11-11T10:04:07.980Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2uj8a0p00001idmz1l8lwdz","content":"<h2 id=\"初识文本模板引擎\"><a href=\"#初识文本模板引擎\" class=\"headerlink\" title=\"初识文本模板引擎\"></a>初识文本模板引擎</h2><p>标准库中的 <a href=\"https://gowalker.org/text/template\" target=\"_blank\" rel=\"noopener\"><code>text/template</code></a> 包是 Go 语言内置的文本模板引擎，虽然在灵活性上不如其它语言中第三方框架自带的模板引擎（如 Django、Ruby on Rails 等等），但功能依旧十分强大。根据标准库给出的定义，它的主要特性如下：</p>\n<ol>\n<li>将模板应用于给定的数据结构来执行模板，模板的编码与 Go 语言源代码文件相同，需为 UTF-8 编码</li>\n<li>模板中的注解（Annotation）会根据数据结构中的元素来执行并派生具体的显示结构，这些元素一般指结构体中的字段或 map 中的键名</li>\n<li>模板的执行逻辑会依据点（Dot，<code>&quot;.&quot;</code>）操作符来设定当前的执行位置，并按序完成所有逻辑的执行。</li>\n<li>模板中的行为（Action）包括数据评估（Data Evaluation）和控制逻辑，且需要使用双层大括号（<code>{.{</code> 和 <code>}}</code>）包裹。除行为以外的任何内容都会原样输出不做修改。</li>\n<li>模板解析完成后，从设计上可以并发地进行渲染，但要注意被渲染对象的并发安全性。例如，一个模板可以同时为多个客户端的响应进行渲染，因为输出对象（Writer）是相互独立的，但是被渲染的对象可能有各自的状态和时效性。</li>\n</ol>\n<p>接下来，让我们结合上节课所学的知识，从一个最简单的例子开始学习使用 Go 语言中的文本模板引擎。简单起见，我们依旧从输出 “Hello world!” 字符串开始。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;text/template&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(&quot;Hello world!&quot;)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Parse: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用模板对象的渲染方法</span><br><span class=\"line\">        err = tmpl.Execute(w, nil)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Execute: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果运行上面的代码，就会发现和上节课的输出毫无区别，并且在作为处理器的匿名函数中增加了更多的逻辑。</p>\n<p><code>➜ curl <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a><br>Hello world!</code> </p>\n<p>相比之前多出来的这部分逻辑便是创建、解析和渲染模板的必要步骤：</p>\n<ol>\n<li><a href=\"https://gowalker.org/text/template#New\" target=\"_blank\" rel=\"noopener\"><code>template.New</code></a> 的作用就是根据用户给定的名称创建一个模板对象，本例中我们使用了 “test” 字符串作为这个模板对象的名称。另外，由于 <a href=\"https://gowalker.org/text/template#New\" target=\"_blank\" rel=\"noopener\"><code>template.New</code></a> 函数会直接返回一个 <a href=\"https://gowalker.org/text/template#Template\" target=\"_blank\" rel=\"noopener\"><code>*template.Template</code></a> 对象，因此可以直接链式操作调用该对象的 <a href=\"https://gowalker.org/text/template#Template_Parse\" target=\"_blank\" rel=\"noopener\"><code>Parse</code></a> 方法</li>\n<li><a href=\"https://gowalker.org/text/template#Template_Parse\" target=\"_blank\" rel=\"noopener\"><code>template.Parse</code></a> 方法接受一个 <code>string</code> 类型的参数，即文本模板的内容，然后对内容进行解析并返回解析过程中发生的任何错误。本例中，我们使用了没有任何模板语法的 “Hello world!” 字符串，同时获得了两个返回值。第一个返回值依旧是一个 <a href=\"https://gowalker.org/text/template#Template\" target=\"_blank\" rel=\"noopener\"><code>*template.Template</code></a> 对象，此时该对象已经包含了模板解析后的数据结构。第二个返回值便是在解析过程中可能出现的错误，这要求我们对该错误进行检查判断。</li>\n<li>如果模板解析过程没有产生任何错误则表示模板可以被用于渲染了，<a href=\"https://gowalker.org/text/template#Template_Execute\" target=\"_blank\" rel=\"noopener\"><code>template.Execute</code></a> 就是用于渲染模板的方法，该方法接受两个参数：输出对象和指定数据对象（或根对象）。简单起见，本例中我们只使用到了第一个参数，即输出对象。凡是实现了 <a href=\"https://gowalker.org/io#Writer\" target=\"_blank\" rel=\"noopener\"><code>io.Writer</code></a> 接口的实例均可以作为输出对象，这在 Go 语言中是非常常见的一种编码模式。</li>\n</ol>\n<h2 id=\"在模板中渲染变量\"><a href=\"#在模板中渲染变量\" class=\"headerlink\" title=\"在模板中渲染变量\"></a>在模板中渲染变量</h2><p>学会了模板渲染的基本操作之后，我们就可以开始向模板中输出一些动态的内容了。首先，我们来快速了解一下怎么获取 HTTP 协议中 GET 请求的 URL 查询参数（即问号 “?” 之后的内容）。例如，我们想要获取 “/?val=123” 中的 “val” 的值，并返回给客户端。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        w.Write([]byte(r.URL.Query().Get(&quot;val&quot;)))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们这里用到的方法就是 <code>*http.Request</code> 对象的 <code>URL.Query().Get</code> 方法。通过终端执行可以获得如下结果，你还可以尝试赋予 “val” 其它的值，服务端也会输出对应的内容。</p>\n<p><code>➜ curl <a href=\"http://localhost:4000/?val=123\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/?val=123</a><br>123</code> </p>\n<p>现在，我们可以结合模板语法，将这个 “val” 的值进行渲染了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;text/template&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(&quot;The value is: &#123;.&#123;.&#125;&#125;&quot;)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Parse: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 获取 URL 参数的值</span><br><span class=\"line\">        val := r.URL.Query().Get(&quot;val&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用模板对象的渲染方法</span><br><span class=\"line\">        err = tmpl.Execute(w, val)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Execute: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，你可以注意到模板的内容被替换为了 <code>The value is: {.{.}}</code>，即使用了分隔符将点操作符包裹起来。在 Go 语言的标准库模板引擎中，点操作符默认指向的是根对象，即我们在调用 <a href=\"https://gowalker.org/text/template#Template_Execute\" target=\"_blank\" rel=\"noopener\"><code>template.Execute</code></a> 方法时传入的第二个参数。本例中，我们传入的根对象是一个单纯的 <code>string</code> 类型的变量 <code>val</code>，那么点操作符的渲染对象就是变量 <code>val</code>。</p>\n<p>尝试运行以上代码可以在终端获得以下结果：</p>\n<p><code>➜ curl <a href=\"http://localhost:4000/?val=666\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/?val=666</a><br>The value is: 666</code> </p>\n<p>至此，我们就成功地对 <a href=\"https://gowalker.org/text/template\" target=\"_blank\" rel=\"noopener\"><code>text/template</code></a> 包提供的文本模板引擎实现了第一次动态输出啦！</p>\n<h2 id=\"在模板中渲染复杂对象\"><a href=\"#在模板中渲染复杂对象\" class=\"headerlink\" title=\"在模板中渲染复杂对象\"></a>在模板中渲染复杂对象</h2><p>你是否也正在思考，除了简单类型的变量，根对象还可以是什么类型呢？细心的你可能已经发现，<a href=\"https://gowalker.org/text/template#Template_Execute\" target=\"_blank\" rel=\"noopener\"><code>template.Execute</code></a> 方法的第二个参数类型为 <code>interface{}</code>，也就是说可以传入任何类型。这代表 <a href=\"https://gowalker.org/text/template\" target=\"_blank\" rel=\"noopener\"><code>text/template</code></a> 包提供的文本模板引擎会根据所提供的根对象进行底层类型分析，然后自动判断应该以什么样的形式去理解模板中的语法。以点操作符为例，如果根对象为变量，那么点操作符代表的就是一个变量；而如果根对象为一个复合类型，那么点操作符所代表的也就是这个复合类型。</p>\n<p>让我们来创建一个名为 <code>Inventory</code> 的复合类型，然后通过 URL 查询参数的值创建一个实例，最后通过模板渲染出各个字段的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &quot;strconv&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type Inventory struct &#123;</span><br><span class=\"line\">    SKU       string</span><br><span class=\"line\">    Name      string</span><br><span class=\"line\">    UnitPrice float64</span><br><span class=\"line\">    Quantity  int64</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`Inventory</span><br><span class=\"line\">SKU: &#123;.&#123;.SKU&#125;&#125;</span><br><span class=\"line\">Name: &#123;.&#123;.Name&#125;&#125;</span><br><span class=\"line\">UnitPrice: &#123;.&#123;.UnitPrice&#125;&#125;</span><br><span class=\"line\">Quantity: &#123;.&#123;.Quantity&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        // 根据 URL 查询参数的值创建 Inventory 实例</span><br><span class=\"line\">        inventory := &amp;Inventory&#123;</span><br><span class=\"line\">            SKU:  r.URL.Query().Get(&quot;sku&quot;),</span><br><span class=\"line\">            Name: r.URL.Query().Get(&quot;name&quot;),</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 注意：为了简化代码逻辑，这里并没有进行错误处理</span><br><span class=\"line\">        inventory.UnitPrice, _ = strconv.ParseFloat(r.URL.Query().Get(&quot;unitPrice&quot;), 64)</span><br><span class=\"line\">        inventory.Quantity, _ = strconv.ParseInt(r.URL.Query().Get(&quot;quantity&quot;), 10, 64)</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用模板对象的渲染方法</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）</p>\n<p>以上代码主要有两部分变动，第一部分是修改了模板内容（注意代码中使用反引号而非双引号）：</p>\n<p><code>Inventory<br>SKU: {.{.SKU}}<br>Name: {.{.Name}}<br>UnitPrice: {.{.UnitPrice}}<br>Quantity: {.{.Quantity}}</code> </p>\n<p>你可以注意到，使用分隔符包裹起来的内容和 <code>Inventory</code> 类型中的字段名称是一一对应的，且大小写保持一致（Go 语言是一门大小写敏感的语言）。模板中使用了点操作符指代根对象 <code>inventory</code>，即通过 URL 查询参数的值所创建的一个变量。这里用到了 <a href=\"https://gowalker.org/strconv\" target=\"_blank\" rel=\"noopener\"><code>strconv</code></a> 包中的 <code>ParseFloat</code> 和 <code>ParseInt</code> 函数，主要作用为解析字符串为浮点型和整型数字，感兴趣的同学可以自行阅读文档进行更加深入了解。</p>\n<p>尝试运行以上代码可以在终端获得以下结果：</p>\n<p><code>➜ curl <a href=\"http://localhost:4000/?sku=1122334&amp;name=phone&amp;unitPrice=649.99&amp;quantity=833\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/?sku=1122334&amp;name=phone&amp;unitPrice=649.99&amp;quantity=833</a><br>Inventory<br>SKU: 1122334<br>Name: phone<br>UnitPrice: 649.99<br>Quantity: 833</code> </p>\n<p>我们看到，修改根对象为一个复合类型也可以轻易地使用标准库的文本模板引擎进行渲染。</p>\n<h2 id=\"在模板中调用结构的方法\"><a href=\"#在模板中调用结构的方法\" class=\"headerlink\" title=\"在模板中调用结构的方法\"></a>在模板中调用结构的方法</h2><p>我们已经讲解了如何在模板中显示具体对象的字段值，那么，是不是也可以使用同样的方式来调用对象所具有的方法呢？答案当然是肯定的。</p>\n<p>我们需要先为 <code>Inventory</code> 类型添加一个方法，称为 <code>Subtotal</code>，即根据该商品的单价和数量来显示当前库存所具有的价值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Subtotal 根据单价和数量计算出总价值</span><br><span class=\"line\">func (i *Inventory) Subtotal() float64 &#123;</span><br><span class=\"line\">    return i.UnitPrice * float64(i.Quantity)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在模板中添加相关的内容，使得计算结果能够通过模板渲染展示给客户端。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`Inventory</span><br><span class=\"line\">SKU: &#123;.&#123;.SKU&#125;&#125;</span><br><span class=\"line\">Name: &#123;.&#123;.Name&#125;&#125;</span><br><span class=\"line\">UnitPrice: &#123;.&#123;.UnitPrice&#125;&#125;</span><br><span class=\"line\">Quantity: &#123;.&#123;.Quantity&#125;&#125;</span><br><span class=\"line\">Subtotal: &#123;.&#123;.Subtotal&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）</p>\n<p>可以注意到，在 <a href=\"https://gowalker.org/text/template\" target=\"_blank\" rel=\"noopener\"><code>text/template</code></a> 包提供的文本模板引擎中，显示方法调用结果的值和字段的值的语法是完全相同的，即不需要在方法名称后使用括号表示调用。该模板引擎会在渲染时自动识别所调用对象的具体类型，然后做出相应的操作。</p>\n<p>尝试运行以上代码可以在终端获得以下结果：</p>\n<p><code>➜ curl <a href=\"http://localhost:4000/?sku=1122334&amp;name=phone&amp;unitPrice=649.99&amp;quantity=833\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/?sku=1122334&amp;name=phone&amp;unitPrice=649.99&amp;quantity=833</a><br>Inventory<br>SKU: 1122334<br>Name: phone<br>UnitPrice: 649.99<br>Quantity: 833<br>Subtotal: 541441.67</code> </p>\n<h2 id=\"使用-map-类型作为模板根对象\"><a href=\"#使用-map-类型作为模板根对象\" class=\"headerlink\" title=\"使用 map 类型作为模板根对象\"></a>使用 map 类型作为模板根对象</h2><p>我想聪明的你已经意识到将某个具体类型作为模板根对象的局限性，因为不论想要展示什么内容，都需要通过修改添加类型的字段或方法才能实现，在操作上非常的不灵活。但是，如果你还记得根对象的参数类型为 <code>interface{}</code> 的话，应该就不难理解通过利用一个 <code>map[string]interface{}</code> 类型的根对象，可以实现灵活地向模板中添加需要被渲染的子对象。</p>\n<p>这种方案可行的根本原因是因为在 Go 语言中，当 <code>interface{}</code> 类型作为参数时，调用者可以传入任意类型的值，效果类似 Java 中的 Object 类型。</p>\n<p>接下来，让我们通过使用 <code>map[string]interface{}</code> 类型作为根对象，实现之前展示 <code>Inventory</code> 类型中字段值的效果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;strconv&quot;</span><br><span class=\"line\">    &quot;text/template&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`Inventory</span><br><span class=\"line\">SKU: &#123;.&#123;.SKU&#125;&#125;</span><br><span class=\"line\">Name: &#123;.&#123;.Name&#125;&#125;</span><br><span class=\"line\">UnitPrice: &#123;.&#123;.UnitPrice&#125;&#125;</span><br><span class=\"line\">Quantity: &#123;.&#123;.Quantity&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Parse: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 获取 URL 查询参数的值</span><br><span class=\"line\">        // 注意：为了简化代码逻辑，这里并没有进行错误处理</span><br><span class=\"line\">        sku := r.URL.Query().Get(&quot;sku&quot;)</span><br><span class=\"line\">        name := r.URL.Query().Get(&quot;name&quot;)</span><br><span class=\"line\">        unitPrice, _ := strconv.ParseFloat(r.URL.Query().Get(&quot;unitPrice&quot;), 64)</span><br><span class=\"line\">        quantity, _ := strconv.ParseInt(r.URL.Query().Get(&quot;quantity&quot;), 10, 64)</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用模板对象的渲染方法，并创建一个 map[string]interface&#123;&#125; 类型的临时变量作为根对象</span><br><span class=\"line\">        err = tmpl.Execute(w, map[string]interface&#123;&#125;&#123;</span><br><span class=\"line\">            &quot;SKU&quot;:       sku,</span><br><span class=\"line\">            &quot;Name&quot;:      name,</span><br><span class=\"line\">            &quot;UnitPrice&quot;: unitPrice,</span><br><span class=\"line\">            &quot;Quantity&quot;:  quantity,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Execute: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在以上代码中，我们将 URL 查询参数赋值给多个变量，然后将所有变量以键值对的形式生成一个 <code>map[string]interface{}</code> 类型的临时对象作为模板的根对象。相比之前需要先定义一个 <code>Inventory</code> 类型而言，这种方式可以更加灵活便利地将对象放置到模板中用于渲染。</p>\n<p>尝试运行以上代码可以在终端获得与之前相同的结果：</p>\n<p><code>➜ curl <a href=\"http://localhost:4000/?sku=1122334&amp;name=phone&amp;unitPrice=649.99&amp;quantity=833\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/?sku=1122334&amp;name=phone&amp;unitPrice=649.99&amp;quantity=833</a><br>Inventory<br>SKU: 1122334<br>Name: phone<br>UnitPrice: 649.99<br>Quantity: 833</code> </p>\n<p>许多 Web 框架的实现都是基于这个小技巧，如果之前还不明所以的话，现在应该知道这其中的原理了吧？</p>\n<h2 id=\"在模板中使用注释\"><a href=\"#在模板中使用注释\" class=\"headerlink\" title=\"在模板中使用注释\"></a>在模板中使用注释</h2><p>虽然目前我们所使用的模板文本还都非常简单，但当模板内容变多、逻辑更加复杂的时候就会想要使用注释来进行辅助理解，便于后期的维护和开发。在这节课的最后，我们来学习如何在 <a href=\"https://gowalker.org/text/template\" target=\"_blank\" rel=\"noopener\"><code>text/template</code></a> 包提供的文本模板引擎中进行注释的语法。</p>\n<p>注释的语法和 Go 语言程序代码中的块注释语法相同，即使用 <code>/*</code> 和 <code>*/</code> 将注释内容包括起来，例如：<code>{.{/* 这是注释内容 */}}</code>。</p>\n<p>简单修改一下我们已有的模板文本，就可以发现如同源代码中的注释一样，模板中的注释会在模板的解析阶段被剔除：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`&#123;.&#123;/* 打印参数的值 */&#125;&#125;</span><br><span class=\"line\">Inventory</span><br><span class=\"line\">SKU: &#123;.&#123;.SKU&#125;&#125;</span><br><span class=\"line\">Name: &#123;.&#123;.Name&#125;&#125;</span><br><span class=\"line\">UnitPrice: &#123;.&#123;.UnitPrice&#125;&#125;</span><br><span class=\"line\">Quantity: &#123;.&#123;.Quantity&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）</p>\n<p>尝试运行以上代码可以在终端获得与之前相同的结果：</p>\n<p><code>➜ curl <a href=\"http://localhost:4000/?sku=1122334&amp;name=phone&amp;unitPrice=649.99&amp;quantity=833\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/?sku=1122334&amp;name=phone&amp;unitPrice=649.99&amp;quantity=833</a></code></p>\n<p>Inventory<br>SKU: 1122334<br>Name: phone<br>UnitPrice: 649.99<br>Quantity: 833 </p>\n<p>注意 “Inventory” 字符串之前多了一个空行，就是模板文本中注释所在的那一行。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>这节课，我们学习了标准库中 <a href=\"https://gowalker.org/text/template\" target=\"_blank\" rel=\"noopener\"><code>text/template</code></a> 包提供的文本模板引擎的基础用法，了解了模板渲染和根对象的概念，并学会了有关根对象类型的一个小技巧。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"初识文本模板引擎\"><a href=\"#初识文本模板引擎\" class=\"headerlink\" title=\"初识文本模板引擎\"></a>初识文本模板引擎</h2><p>标准库中的 <a href=\"https://gowalker.org/text/template\" target=\"_blank\" rel=\"noopener\"><code>text/template</code></a> 包是 Go 语言内置的文本模板引擎，虽然在灵活性上不如其它语言中第三方框架自带的模板引擎（如 Django、Ruby on Rails 等等），但功能依旧十分强大。根据标准库给出的定义，它的主要特性如下：</p>\n<ol>\n<li>将模板应用于给定的数据结构来执行模板，模板的编码与 Go 语言源代码文件相同，需为 UTF-8 编码</li>\n<li>模板中的注解（Annotation）会根据数据结构中的元素来执行并派生具体的显示结构，这些元素一般指结构体中的字段或 map 中的键名</li>\n<li>模板的执行逻辑会依据点（Dot，<code>&quot;.&quot;</code>）操作符来设定当前的执行位置，并按序完成所有逻辑的执行。</li>\n<li>模板中的行为（Action）包括数据评估（Data Evaluation）和控制逻辑，且需要使用双层大括号（<code>{.{</code> 和 <code>}}</code>）包裹。除行为以外的任何内容都会原样输出不做修改。</li>\n<li>模板解析完成后，从设计上可以并发地进行渲染，但要注意被渲染对象的并发安全性。例如，一个模板可以同时为多个客户端的响应进行渲染，因为输出对象（Writer）是相互独立的，但是被渲染的对象可能有各自的状态和时效性。</li>\n</ol>\n<p>接下来，让我们结合上节课所学的知识，从一个最简单的例子开始学习使用 Go 语言中的文本模板引擎。简单起见，我们依旧从输出 “Hello world!” 字符串开始。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;text/template&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(&quot;Hello world!&quot;)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Parse: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用模板对象的渲染方法</span><br><span class=\"line\">        err = tmpl.Execute(w, nil)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Execute: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果运行上面的代码，就会发现和上节课的输出毫无区别，并且在作为处理器的匿名函数中增加了更多的逻辑。</p>\n<p><code>➜ curl <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a><br>Hello world!</code> </p>\n<p>相比之前多出来的这部分逻辑便是创建、解析和渲染模板的必要步骤：</p>\n<ol>\n<li><a href=\"https://gowalker.org/text/template#New\" target=\"_blank\" rel=\"noopener\"><code>template.New</code></a> 的作用就是根据用户给定的名称创建一个模板对象，本例中我们使用了 “test” 字符串作为这个模板对象的名称。另外，由于 <a href=\"https://gowalker.org/text/template#New\" target=\"_blank\" rel=\"noopener\"><code>template.New</code></a> 函数会直接返回一个 <a href=\"https://gowalker.org/text/template#Template\" target=\"_blank\" rel=\"noopener\"><code>*template.Template</code></a> 对象，因此可以直接链式操作调用该对象的 <a href=\"https://gowalker.org/text/template#Template_Parse\" target=\"_blank\" rel=\"noopener\"><code>Parse</code></a> 方法</li>\n<li><a href=\"https://gowalker.org/text/template#Template_Parse\" target=\"_blank\" rel=\"noopener\"><code>template.Parse</code></a> 方法接受一个 <code>string</code> 类型的参数，即文本模板的内容，然后对内容进行解析并返回解析过程中发生的任何错误。本例中，我们使用了没有任何模板语法的 “Hello world!” 字符串，同时获得了两个返回值。第一个返回值依旧是一个 <a href=\"https://gowalker.org/text/template#Template\" target=\"_blank\" rel=\"noopener\"><code>*template.Template</code></a> 对象，此时该对象已经包含了模板解析后的数据结构。第二个返回值便是在解析过程中可能出现的错误，这要求我们对该错误进行检查判断。</li>\n<li>如果模板解析过程没有产生任何错误则表示模板可以被用于渲染了，<a href=\"https://gowalker.org/text/template#Template_Execute\" target=\"_blank\" rel=\"noopener\"><code>template.Execute</code></a> 就是用于渲染模板的方法，该方法接受两个参数：输出对象和指定数据对象（或根对象）。简单起见，本例中我们只使用到了第一个参数，即输出对象。凡是实现了 <a href=\"https://gowalker.org/io#Writer\" target=\"_blank\" rel=\"noopener\"><code>io.Writer</code></a> 接口的实例均可以作为输出对象，这在 Go 语言中是非常常见的一种编码模式。</li>\n</ol>\n<h2 id=\"在模板中渲染变量\"><a href=\"#在模板中渲染变量\" class=\"headerlink\" title=\"在模板中渲染变量\"></a>在模板中渲染变量</h2><p>学会了模板渲染的基本操作之后，我们就可以开始向模板中输出一些动态的内容了。首先，我们来快速了解一下怎么获取 HTTP 协议中 GET 请求的 URL 查询参数（即问号 “?” 之后的内容）。例如，我们想要获取 “/?val=123” 中的 “val” 的值，并返回给客户端。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        w.Write([]byte(r.URL.Query().Get(&quot;val&quot;)))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们这里用到的方法就是 <code>*http.Request</code> 对象的 <code>URL.Query().Get</code> 方法。通过终端执行可以获得如下结果，你还可以尝试赋予 “val” 其它的值，服务端也会输出对应的内容。</p>\n<p><code>➜ curl <a href=\"http://localhost:4000/?val=123\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/?val=123</a><br>123</code> </p>\n<p>现在，我们可以结合模板语法，将这个 “val” 的值进行渲染了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;text/template&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(&quot;The value is: &#123;.&#123;.&#125;&#125;&quot;)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Parse: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 获取 URL 参数的值</span><br><span class=\"line\">        val := r.URL.Query().Get(&quot;val&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用模板对象的渲染方法</span><br><span class=\"line\">        err = tmpl.Execute(w, val)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Execute: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，你可以注意到模板的内容被替换为了 <code>The value is: {.{.}}</code>，即使用了分隔符将点操作符包裹起来。在 Go 语言的标准库模板引擎中，点操作符默认指向的是根对象，即我们在调用 <a href=\"https://gowalker.org/text/template#Template_Execute\" target=\"_blank\" rel=\"noopener\"><code>template.Execute</code></a> 方法时传入的第二个参数。本例中，我们传入的根对象是一个单纯的 <code>string</code> 类型的变量 <code>val</code>，那么点操作符的渲染对象就是变量 <code>val</code>。</p>\n<p>尝试运行以上代码可以在终端获得以下结果：</p>\n<p><code>➜ curl <a href=\"http://localhost:4000/?val=666\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/?val=666</a><br>The value is: 666</code> </p>\n<p>至此，我们就成功地对 <a href=\"https://gowalker.org/text/template\" target=\"_blank\" rel=\"noopener\"><code>text/template</code></a> 包提供的文本模板引擎实现了第一次动态输出啦！</p>\n<h2 id=\"在模板中渲染复杂对象\"><a href=\"#在模板中渲染复杂对象\" class=\"headerlink\" title=\"在模板中渲染复杂对象\"></a>在模板中渲染复杂对象</h2><p>你是否也正在思考，除了简单类型的变量，根对象还可以是什么类型呢？细心的你可能已经发现，<a href=\"https://gowalker.org/text/template#Template_Execute\" target=\"_blank\" rel=\"noopener\"><code>template.Execute</code></a> 方法的第二个参数类型为 <code>interface{}</code>，也就是说可以传入任何类型。这代表 <a href=\"https://gowalker.org/text/template\" target=\"_blank\" rel=\"noopener\"><code>text/template</code></a> 包提供的文本模板引擎会根据所提供的根对象进行底层类型分析，然后自动判断应该以什么样的形式去理解模板中的语法。以点操作符为例，如果根对象为变量，那么点操作符代表的就是一个变量；而如果根对象为一个复合类型，那么点操作符所代表的也就是这个复合类型。</p>\n<p>让我们来创建一个名为 <code>Inventory</code> 的复合类型，然后通过 URL 查询参数的值创建一个实例，最后通过模板渲染出各个字段的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &quot;strconv&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type Inventory struct &#123;</span><br><span class=\"line\">    SKU       string</span><br><span class=\"line\">    Name      string</span><br><span class=\"line\">    UnitPrice float64</span><br><span class=\"line\">    Quantity  int64</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`Inventory</span><br><span class=\"line\">SKU: &#123;.&#123;.SKU&#125;&#125;</span><br><span class=\"line\">Name: &#123;.&#123;.Name&#125;&#125;</span><br><span class=\"line\">UnitPrice: &#123;.&#123;.UnitPrice&#125;&#125;</span><br><span class=\"line\">Quantity: &#123;.&#123;.Quantity&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        // 根据 URL 查询参数的值创建 Inventory 实例</span><br><span class=\"line\">        inventory := &amp;Inventory&#123;</span><br><span class=\"line\">            SKU:  r.URL.Query().Get(&quot;sku&quot;),</span><br><span class=\"line\">            Name: r.URL.Query().Get(&quot;name&quot;),</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 注意：为了简化代码逻辑，这里并没有进行错误处理</span><br><span class=\"line\">        inventory.UnitPrice, _ = strconv.ParseFloat(r.URL.Query().Get(&quot;unitPrice&quot;), 64)</span><br><span class=\"line\">        inventory.Quantity, _ = strconv.ParseInt(r.URL.Query().Get(&quot;quantity&quot;), 10, 64)</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用模板对象的渲染方法</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）</p>\n<p>以上代码主要有两部分变动，第一部分是修改了模板内容（注意代码中使用反引号而非双引号）：</p>\n<p><code>Inventory<br>SKU: {.{.SKU}}<br>Name: {.{.Name}}<br>UnitPrice: {.{.UnitPrice}}<br>Quantity: {.{.Quantity}}</code> </p>\n<p>你可以注意到，使用分隔符包裹起来的内容和 <code>Inventory</code> 类型中的字段名称是一一对应的，且大小写保持一致（Go 语言是一门大小写敏感的语言）。模板中使用了点操作符指代根对象 <code>inventory</code>，即通过 URL 查询参数的值所创建的一个变量。这里用到了 <a href=\"https://gowalker.org/strconv\" target=\"_blank\" rel=\"noopener\"><code>strconv</code></a> 包中的 <code>ParseFloat</code> 和 <code>ParseInt</code> 函数，主要作用为解析字符串为浮点型和整型数字，感兴趣的同学可以自行阅读文档进行更加深入了解。</p>\n<p>尝试运行以上代码可以在终端获得以下结果：</p>\n<p><code>➜ curl <a href=\"http://localhost:4000/?sku=1122334&amp;name=phone&amp;unitPrice=649.99&amp;quantity=833\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/?sku=1122334&amp;name=phone&amp;unitPrice=649.99&amp;quantity=833</a><br>Inventory<br>SKU: 1122334<br>Name: phone<br>UnitPrice: 649.99<br>Quantity: 833</code> </p>\n<p>我们看到，修改根对象为一个复合类型也可以轻易地使用标准库的文本模板引擎进行渲染。</p>\n<h2 id=\"在模板中调用结构的方法\"><a href=\"#在模板中调用结构的方法\" class=\"headerlink\" title=\"在模板中调用结构的方法\"></a>在模板中调用结构的方法</h2><p>我们已经讲解了如何在模板中显示具体对象的字段值，那么，是不是也可以使用同样的方式来调用对象所具有的方法呢？答案当然是肯定的。</p>\n<p>我们需要先为 <code>Inventory</code> 类型添加一个方法，称为 <code>Subtotal</code>，即根据该商品的单价和数量来显示当前库存所具有的价值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Subtotal 根据单价和数量计算出总价值</span><br><span class=\"line\">func (i *Inventory) Subtotal() float64 &#123;</span><br><span class=\"line\">    return i.UnitPrice * float64(i.Quantity)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在模板中添加相关的内容，使得计算结果能够通过模板渲染展示给客户端。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`Inventory</span><br><span class=\"line\">SKU: &#123;.&#123;.SKU&#125;&#125;</span><br><span class=\"line\">Name: &#123;.&#123;.Name&#125;&#125;</span><br><span class=\"line\">UnitPrice: &#123;.&#123;.UnitPrice&#125;&#125;</span><br><span class=\"line\">Quantity: &#123;.&#123;.Quantity&#125;&#125;</span><br><span class=\"line\">Subtotal: &#123;.&#123;.Subtotal&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）</p>\n<p>可以注意到，在 <a href=\"https://gowalker.org/text/template\" target=\"_blank\" rel=\"noopener\"><code>text/template</code></a> 包提供的文本模板引擎中，显示方法调用结果的值和字段的值的语法是完全相同的，即不需要在方法名称后使用括号表示调用。该模板引擎会在渲染时自动识别所调用对象的具体类型，然后做出相应的操作。</p>\n<p>尝试运行以上代码可以在终端获得以下结果：</p>\n<p><code>➜ curl <a href=\"http://localhost:4000/?sku=1122334&amp;name=phone&amp;unitPrice=649.99&amp;quantity=833\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/?sku=1122334&amp;name=phone&amp;unitPrice=649.99&amp;quantity=833</a><br>Inventory<br>SKU: 1122334<br>Name: phone<br>UnitPrice: 649.99<br>Quantity: 833<br>Subtotal: 541441.67</code> </p>\n<h2 id=\"使用-map-类型作为模板根对象\"><a href=\"#使用-map-类型作为模板根对象\" class=\"headerlink\" title=\"使用 map 类型作为模板根对象\"></a>使用 map 类型作为模板根对象</h2><p>我想聪明的你已经意识到将某个具体类型作为模板根对象的局限性，因为不论想要展示什么内容，都需要通过修改添加类型的字段或方法才能实现，在操作上非常的不灵活。但是，如果你还记得根对象的参数类型为 <code>interface{}</code> 的话，应该就不难理解通过利用一个 <code>map[string]interface{}</code> 类型的根对象，可以实现灵活地向模板中添加需要被渲染的子对象。</p>\n<p>这种方案可行的根本原因是因为在 Go 语言中，当 <code>interface{}</code> 类型作为参数时，调用者可以传入任意类型的值，效果类似 Java 中的 Object 类型。</p>\n<p>接下来，让我们通过使用 <code>map[string]interface{}</code> 类型作为根对象，实现之前展示 <code>Inventory</code> 类型中字段值的效果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;strconv&quot;</span><br><span class=\"line\">    &quot;text/template&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`Inventory</span><br><span class=\"line\">SKU: &#123;.&#123;.SKU&#125;&#125;</span><br><span class=\"line\">Name: &#123;.&#123;.Name&#125;&#125;</span><br><span class=\"line\">UnitPrice: &#123;.&#123;.UnitPrice&#125;&#125;</span><br><span class=\"line\">Quantity: &#123;.&#123;.Quantity&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Parse: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 获取 URL 查询参数的值</span><br><span class=\"line\">        // 注意：为了简化代码逻辑，这里并没有进行错误处理</span><br><span class=\"line\">        sku := r.URL.Query().Get(&quot;sku&quot;)</span><br><span class=\"line\">        name := r.URL.Query().Get(&quot;name&quot;)</span><br><span class=\"line\">        unitPrice, _ := strconv.ParseFloat(r.URL.Query().Get(&quot;unitPrice&quot;), 64)</span><br><span class=\"line\">        quantity, _ := strconv.ParseInt(r.URL.Query().Get(&quot;quantity&quot;), 10, 64)</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用模板对象的渲染方法，并创建一个 map[string]interface&#123;&#125; 类型的临时变量作为根对象</span><br><span class=\"line\">        err = tmpl.Execute(w, map[string]interface&#123;&#125;&#123;</span><br><span class=\"line\">            &quot;SKU&quot;:       sku,</span><br><span class=\"line\">            &quot;Name&quot;:      name,</span><br><span class=\"line\">            &quot;UnitPrice&quot;: unitPrice,</span><br><span class=\"line\">            &quot;Quantity&quot;:  quantity,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Execute: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在以上代码中，我们将 URL 查询参数赋值给多个变量，然后将所有变量以键值对的形式生成一个 <code>map[string]interface{}</code> 类型的临时对象作为模板的根对象。相比之前需要先定义一个 <code>Inventory</code> 类型而言，这种方式可以更加灵活便利地将对象放置到模板中用于渲染。</p>\n<p>尝试运行以上代码可以在终端获得与之前相同的结果：</p>\n<p><code>➜ curl <a href=\"http://localhost:4000/?sku=1122334&amp;name=phone&amp;unitPrice=649.99&amp;quantity=833\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/?sku=1122334&amp;name=phone&amp;unitPrice=649.99&amp;quantity=833</a><br>Inventory<br>SKU: 1122334<br>Name: phone<br>UnitPrice: 649.99<br>Quantity: 833</code> </p>\n<p>许多 Web 框架的实现都是基于这个小技巧，如果之前还不明所以的话，现在应该知道这其中的原理了吧？</p>\n<h2 id=\"在模板中使用注释\"><a href=\"#在模板中使用注释\" class=\"headerlink\" title=\"在模板中使用注释\"></a>在模板中使用注释</h2><p>虽然目前我们所使用的模板文本还都非常简单，但当模板内容变多、逻辑更加复杂的时候就会想要使用注释来进行辅助理解，便于后期的维护和开发。在这节课的最后，我们来学习如何在 <a href=\"https://gowalker.org/text/template\" target=\"_blank\" rel=\"noopener\"><code>text/template</code></a> 包提供的文本模板引擎中进行注释的语法。</p>\n<p>注释的语法和 Go 语言程序代码中的块注释语法相同，即使用 <code>/*</code> 和 <code>*/</code> 将注释内容包括起来，例如：<code>{.{/* 这是注释内容 */}}</code>。</p>\n<p>简单修改一下我们已有的模板文本，就可以发现如同源代码中的注释一样，模板中的注释会在模板的解析阶段被剔除：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`&#123;.&#123;/* 打印参数的值 */&#125;&#125;</span><br><span class=\"line\">Inventory</span><br><span class=\"line\">SKU: &#123;.&#123;.SKU&#125;&#125;</span><br><span class=\"line\">Name: &#123;.&#123;.Name&#125;&#125;</span><br><span class=\"line\">UnitPrice: &#123;.&#123;.UnitPrice&#125;&#125;</span><br><span class=\"line\">Quantity: &#123;.&#123;.Quantity&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）</p>\n<p>尝试运行以上代码可以在终端获得与之前相同的结果：</p>\n<p><code>➜ curl <a href=\"http://localhost:4000/?sku=1122334&amp;name=phone&amp;unitPrice=649.99&amp;quantity=833\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/?sku=1122334&amp;name=phone&amp;unitPrice=649.99&amp;quantity=833</a></code></p>\n<p>Inventory<br>SKU: 1122334<br>Name: phone<br>UnitPrice: 649.99<br>Quantity: 833 </p>\n<p>注意 “Inventory” 字符串之前多了一个空行，就是模板文本中注释所在的那一行。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>这节课，我们学习了标准库中 <a href=\"https://gowalker.org/text/template\" target=\"_blank\" rel=\"noopener\"><code>text/template</code></a> 包提供的文本模板引擎的基础用法，了解了模板渲染和根对象的概念，并学会了有关根对象类型的一个小技巧。</p>\n"},{"title":"第 01 课：初窥 HTTP 服务器","author":"知识铺","date":"2019-11-11T09:03:52.000Z","_content":"## Hello world!\n\n第一步，就让我们使用 Go 语言来搭建一个 HTTP 版的 ”Hello world“ 程序吧！\n\n我们先创建一个名为 `http_server.go` 的文件，然后输入以下代码：\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"Hello world!\"))\n\t})\n\n\tlog.Println(\"Starting HTTP server...\")\n\tlog.Fatal(http.ListenAndServe(\"localhost:4000\", nil))\n}\n```\n当我们通过终端运行这段代码的时候，就能够看到如下输出：\n\n<code>➜ go run http_server.go\n2018/11/25 07:34:49 Starting HTTP server...</code> \n\n此时，我们的 HTTP 服务器已经监听在本机的 4000 端口，并准备好接受来自客户端的请求了。有两种方式可以验证这个小程序的正确性：终端调用 cURL 或者打开浏览器访问。\n\n调用 cURL 的命令非常简单，回车运行之后即可看到服务端响应的字符串 ”Hello world!“：\n\n<code>➜ curl http://localhost:4000\nHello world!</code> \n\n同样的，如果直接打开浏览器访问地址 http://localhost:4000 的话，我们也可以看到一样的字符串：\n\n![知识铺-pasted-47.png](https:\\/\\/blog.zshipu.com/tlg/images/pasted-47.png)\n\n是不是感觉几个简单的步骤就实现了一个完全可用的 HTTP 服务器？这就是 Go 语言的魅力之一！\n\n接下来，让我们分析一下这段代码具体都做了什么事情。\n\n我们需要明白这里有三个关键点：\n\n1.  `http.HandleFunc` 函数的作用是将某一个函数与一个路由规则进行绑定，当用户访问指定路由时（某个路由规则匹配成功），所绑定的函数就会被执行。它接受两个参数，第一个参数就是指定的路由规则，本例中我们使用 `/` 来表示根路径；第二个参数就是与该路由进行绑定的函数。\n\n2.  `http.HandleFunc` 的第二个参数必须符合函数签名 `func(http.ResponseWriter, *http.Request)`，这个函数同样接受两个参数，第一个参数是请求所对应的响应对象 `http.ResponseWriter`，包括响应码（Response Code）、响应头（Response Header）和响应体（Response Body）等等，我们就是通过调用这个对象的 `Write` 方法向响应体写入 ”Hello world!“ 字符串的；第二个参数则是请求所对应的请求对象 `*http.Request`，该对象包含当前这个 HTTP 请求所有的信息，包括请求头（Request Header）、请求体（Request Body）和其它相关的内容。\n\n3.  `http.ListenAndServe` 函数的作用就是启动 HTTP 服务器，并监听发送到指定地址和端口号的 HTTP 请求，本例中我们要求 HTTP 服务器监听并接受发送到地址 localhost 且端口号为 4000 的 HTTP 请求。这个函数也接受两个参数，我们目前只使用到了第一个参数，即监听地址和端口号；第二个参数会在后文讲解，因此暂时可以使用 nil 作为它的值。另外，如果监听地址为 127.0.0.1 或者 localhost，则可以使用更加简洁的写法，即 `http.ListenAndServe(\":4000\", nil) `。\n\n除此之外，你可能已经注意到为了节省代码行数，我们在这段代码中使用了匿名函数来编写 HTTP 请求的处理逻辑。这在编写简单的逻辑时非常方便，但当逻辑处理较为复杂时，应该定义一个独立的函数以提升代码的可读性。我们可以将这段代码等价地转化为如下形式：\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", hello)\n\n\tlog.Println(\"Starting HTTP server...\")\n\tlog.Fatal(http.ListenAndServe(\":4000\", nil))\n}\n\nfunc hello(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Hello world!\"))\n}\n```\n重新运行这段代码在输出结果上并没有任何不同，只是代码结构稍稍改变了。\n\n实际上，`http.HandleFunc` 也是标准库提供给用户的一种简便写法，它的第二个参数的函数签名必须为 `func(http.ResponseWriter, *http.Request)` 是因为在 `http.HandleFunc` 函数内部会将我们传入的绑定函数转化为类型 `http.HandlerFunc`，即一个 Go 语言中标准的 HTTP 请求处理器对象，这个对象类型实现了 `http.Handler` 接口：\n\ntype Handler interface {\n    ServeHTTP(ResponseWriter, *Request)\n}\n\n通过 `http.Handler` 的接口定义我们发现，函数签名 `func(http.ResponseWriter, *http.Request)` 的由来是因为要实现接口的 `ServeHTTP` 方法。\n\n现在我们知道了 `http.HandleFunc` 的根本作用是将一个函数转化为一个实现了 `http.Handler` 接口的类型（`http.HandlerFunc`），那么我们可不可以自己创建一个类型并实现 `http.Handler` 接口呢？答案当然是肯定的。\n\n一模一样的功能，下面的代码使用了更加复杂的用法：\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.Handle(\"/\", &helloHandler{})\n\n\tlog.Println(\"Starting HTTP server...\")\n\tlog.Fatal(http.ListenAndServe(\":4000\", nil))\n}\n\ntype helloHandler struct{}\n\nfunc (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Hello world!\"))\n}\n```\n这段代码不再使用 `http.HandleFunc` 函数，取而代之的是直接调用 `http.Handle` 并传入我们自定义的 `http.Handler` 实现。\n\n初学者有一点需要特别注意，即 Go 语言是一门大小写敏感的语言（否则无法通过首字母大小写区分一个对象是公开的还是私有的）。因此，想要实现`http.Handler` 接口，方法名称必须连大小写也保持一致，即这里的方法名称必须是 `ServeHTTP` 而不可以是 `ServeHttp`。\n\n## 服务复用器（ServeMux）\n\n好奇的你可能会问，前文中 `http.ListenAndServe(\":4000\", nil)` 用 nil 代替的到底是一个东西？Go 语言标准库的设计非常精妙，不可能平白无故地提供给我们一个没有用处的参数。\n\n根据 `http.ListenAndServe` 的函数声明可以得知，这里的 nil 代替的其实是一个实现了 `http.Handler` 接口的对象：\n\nfunc ListenAndServe(addr string, handler Handler) error {...}\n\n是不是有点眼熟？因为这说明我们之前的定义的 `helloHandler` 就可以被用作这里的参数：\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tlog.Println(\"Starting HTTP server...\")\n\tlog.Fatal(http.ListenAndServe(\"localhost:4000\", &helloHandler{}))\n}\n\ntype helloHandler struct{}\n\nfunc (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Hello world!\"))\n}\n```\n运行这段代码同样可以得到和之前一模一样的结果！\n\n不过，在实际开发中很少直接将一个纯粹的处理器（Handler）作为这里的参数，因为它缺失了一个非常重要的功能，它不能像之前调用 `http.HandleFunc` 或 `http.Handle` 那样方便地将路由规则和执行函数进行绑定。\n\n通过查看 `http.Handle` 源码可以得知，它其实是对一个默认的 `http.ServeMux` 对象（`http.DefaultServeMux`）进行了一层封装：\n\nfunc Handle(pattern string, handler Handler) {\n    DefaultServeMux.Handle(pattern, handler)\n}\n\n这个 `http.ServeMux` 的作用是什么呢？它就是 Go 语言标准库实现的一个带有基本路由功能的服务复用器（Multiplexer）。除了可以通过 `http.HandleFunc` 或 `http.Handle` 这类方法操作 `http.DefaultServeMux` 对象之外，我们也可以通过标准库提供的方法 `http.NewServeMux` 来创建一个新的 `http.ServeMux` 对象：\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/\", &helloHandler{})\n\tlog.Println(\"Starting HTTP server...\")\n\tlog.Fatal(http.ListenAndServe(\"localhost:4000\", mux))\n}\n\ntype helloHandler struct{}\n\nfunc (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Hello world!\"))\n}\n```\n你可能已经猜到，这段代码依旧和之前做的是一模一样的事情。不过做到这个程度，便是大多数 Web 框架的底层用法了。它们本质上就是一个带有路由层的 `http.Handler` 具体实现，并以此为基础提供大量便利的辅助方法。\n\n## 服务器对象（Server）\n\n既然 `http.HandleFunc` 和 `http.Handle` 都是对一个默认对象 `http.DefaultServeMux` 的封装，那 `http.ListenAndServe` 是否也是如此？我们可以从它的源码中找到答案：\n\nfunc ListenAndServe(addr string, handler Handler) error {\n    server := &Server{Addr: addr, Handler: handler}\n    return server.ListenAndServe()\n}\n\n显而易见，虽然不是针对某个全局对象的封装，但也同样是在调用的时候创建了另一个 `http.Server` 的对象。相比较而言，`http.Server` 的自定义程度就非常高了，它包含了 Go 语言标准库提供的所有可能的选项，包括监听地址、服务复用器和读写超时等等。\n\n接下来，让我们使用 `http.Server` 对象来改写一下我们的小程序：\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/\", &helloHandler{})\n\n\tserver := &http.Server{\n\t\tAddr:    \":4000\",\n\t\tHandler: mux,\n\t}\n\tlog.Println(\"Starting HTTP server...\")\n\tlog.Fatal(server.ListenAndServe())\n}\n\ntype helloHandler struct{}\n\nfunc (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Hello world!\"))\n}\n```\n如果只是单纯地将标准库的封装强行抽离出来未免显得有点小题大做，那么我们可以对这个自定义的 `http.Server` 对象做点什么事情呢？不如就设置一个写超时（Write Timeout）好啦。写超时包含的范围是当请求头被解析后直到响应完成，浅显一点的理解就是从我们绑定的函数开始执行到执行结束为止，如果这个时间范围超过定义的周期则会触发写超时。\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc main() {\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/\", &helloHandler{})\n\tmux.HandleFunc(\"/timeout\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttime.Sleep(2 * time.Second)\n\t\tw.Write([]byte(\"Timeout\"))\n\t})\n\n\tserver := &http.Server{\n\t\tAddr:         \":4000\",\n\t\tHandler:      mux,\n\t\tWriteTimeout: 2 * time.Second,\n\t}\n\tlog.Println(\"Starting HTTP server...\")\n\tlog.Fatal(server.ListenAndServe())\n}\n\ntype helloHandler struct{}\n\nfunc (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Hello world!\"))\n}\n```\n在这段代码里，我们添加了对 `WriteTimeout` 字段的赋值，设为 2 秒钟，同时添加了一个新的执行函数用于先休眠 2 秒然后向客户端输出 ”Timeout“ 字符串。\n\n启动服务器后，如果我们访问 http://localhost:4000 会收到和之前一样的结果，但如果尝试访问 http://localhost:4000/timeout 则不会收到任何消息：\n\n<code>➜ curl http://localhost:4000/timeout\ncurl: (52) Empty reply from server</code> \n\n这是因为我们的执行函数在休眠 2 秒后被 `http.Server` 对象认为已经超时，提前关闭了与客户端之间的连接，因此无论执行函数后面向响应体写入任何东西都不会有任何作用。\n\n部分 Web 框架使用的便是自定义的 `http.Server` 对象，因此你只能通过调用框架提供的特定方法来启动服务。\n\n## 优雅地停止服务\n\n在产生环境中，许多开发者面临的一个困难就是当需要更新服务端程序时需要重启服务，但此时可能有一部分请求进行到一半，如果强行中断这些请求可能会导致意外的结果。因此，开源社区提供了多种优雅停止的方案，像 facebookgo/grace 就是其中的代表作之一。不过从 Go 1.8 版本开始，标准库终于支持原生的优雅停止方案了。\n\n这种方案同样要求用户创建自定义的 `http.Server` 对象，因为对应的 `Close` 方法无法通过其它途径调用。\n\n我们来看下面的代码，这段代码通过结合捕捉系统信号（Signal）、goroutine 和管道（Channel）来实现服务器的优雅停止：\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n)\n\nfunc main() {\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/\", &helloHandler{})\n\n\tserver := &http.Server{\n\t\tAddr:    \":4000\",\n\t\tHandler: mux,\n\t}\n\n\t// 创建系统信号接收器\n\tquit := make(chan os.Signal)\n\tsignal.Notify(quit, os.Interrupt)\n\tgo func() {\n\t\t<-quit\n\n\t\tif err := server.Close(); err != nil {\n\t\t\tlog.Fatal(\"Close server:\", err)\n\t\t}\n\t}()\n\n\tlog.Println(\"Starting HTTP server...\")\n\terr := server.ListenAndServe()\n\tif err != nil {\n\t\tif err == http.ErrServerClosed {\n\t\t\tlog.Print(\"Server closed under request\")\n\t\t} else {\n\t\t\tlog.Fatal(\"Server closed unexpected\")\n\t\t}\n\t}\n}\n\ntype helloHandler struct{}\n\nfunc (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Hello world!\"))\n}\n```\n这段代码通过捕捉 `os.Interrupt` 信号（Ctrl+C）然后调用 `server.Close` 方法告知服务器应停止接受新的请求并在处理完当前已接受的请求后关闭服务器。为了与普通错误相区别，标准库提供了一个特定的错误类型 `http.ErrServerClosed`，我们可以在代码中通过判断是否为该错误类型来确定服务器是正常关闭的还是意外关闭的。\n\n如果我们运行程序后按下 Ctrl+C 便可以看到如下输出：\n\n<code>➜ go run http_server.go\n2018/11/25 10:23:28 Starting HTTP server...\n^C2018/11/25 10:23:30 Server closed under request</code> \n\n是不是很酷？\n\n## 小结\n\n这节课，我们通过编写 HTTP 服务器的 N 种写法由浅入深地学习了如何在 Go 语言中建立一个 HTTP 服务器，并了解了它们之间的相同和不同之处。相信此时的同学们已经能够对 Go 语言的 HTTP 服务器有一定程度的认识，并可以自如地运用到实际开发中了。","source":"_posts/test.md","raw":"title: 第 01 课：初窥 HTTP 服务器\nauthor: 知识铺\ndate: 2019-11-11 17:03:52\ntags:\n---\n## Hello world!\n\n第一步，就让我们使用 Go 语言来搭建一个 HTTP 版的 ”Hello world“ 程序吧！\n\n我们先创建一个名为 `http_server.go` 的文件，然后输入以下代码：\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"Hello world!\"))\n\t})\n\n\tlog.Println(\"Starting HTTP server...\")\n\tlog.Fatal(http.ListenAndServe(\"localhost:4000\", nil))\n}\n```\n当我们通过终端运行这段代码的时候，就能够看到如下输出：\n\n<code>➜ go run http_server.go\n2018/11/25 07:34:49 Starting HTTP server...</code> \n\n此时，我们的 HTTP 服务器已经监听在本机的 4000 端口，并准备好接受来自客户端的请求了。有两种方式可以验证这个小程序的正确性：终端调用 cURL 或者打开浏览器访问。\n\n调用 cURL 的命令非常简单，回车运行之后即可看到服务端响应的字符串 ”Hello world!“：\n\n<code>➜ curl http://localhost:4000\nHello world!</code> \n\n同样的，如果直接打开浏览器访问地址 http://localhost:4000 的话，我们也可以看到一样的字符串：\n\n![知识铺-pasted-47.png](https:\\/\\/blog.zshipu.com/tlg/images/pasted-47.png)\n\n是不是感觉几个简单的步骤就实现了一个完全可用的 HTTP 服务器？这就是 Go 语言的魅力之一！\n\n接下来，让我们分析一下这段代码具体都做了什么事情。\n\n我们需要明白这里有三个关键点：\n\n1.  `http.HandleFunc` 函数的作用是将某一个函数与一个路由规则进行绑定，当用户访问指定路由时（某个路由规则匹配成功），所绑定的函数就会被执行。它接受两个参数，第一个参数就是指定的路由规则，本例中我们使用 `/` 来表示根路径；第二个参数就是与该路由进行绑定的函数。\n\n2.  `http.HandleFunc` 的第二个参数必须符合函数签名 `func(http.ResponseWriter, *http.Request)`，这个函数同样接受两个参数，第一个参数是请求所对应的响应对象 `http.ResponseWriter`，包括响应码（Response Code）、响应头（Response Header）和响应体（Response Body）等等，我们就是通过调用这个对象的 `Write` 方法向响应体写入 ”Hello world!“ 字符串的；第二个参数则是请求所对应的请求对象 `*http.Request`，该对象包含当前这个 HTTP 请求所有的信息，包括请求头（Request Header）、请求体（Request Body）和其它相关的内容。\n\n3.  `http.ListenAndServe` 函数的作用就是启动 HTTP 服务器，并监听发送到指定地址和端口号的 HTTP 请求，本例中我们要求 HTTP 服务器监听并接受发送到地址 localhost 且端口号为 4000 的 HTTP 请求。这个函数也接受两个参数，我们目前只使用到了第一个参数，即监听地址和端口号；第二个参数会在后文讲解，因此暂时可以使用 nil 作为它的值。另外，如果监听地址为 127.0.0.1 或者 localhost，则可以使用更加简洁的写法，即 `http.ListenAndServe(\":4000\", nil) `。\n\n除此之外，你可能已经注意到为了节省代码行数，我们在这段代码中使用了匿名函数来编写 HTTP 请求的处理逻辑。这在编写简单的逻辑时非常方便，但当逻辑处理较为复杂时，应该定义一个独立的函数以提升代码的可读性。我们可以将这段代码等价地转化为如下形式：\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", hello)\n\n\tlog.Println(\"Starting HTTP server...\")\n\tlog.Fatal(http.ListenAndServe(\":4000\", nil))\n}\n\nfunc hello(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Hello world!\"))\n}\n```\n重新运行这段代码在输出结果上并没有任何不同，只是代码结构稍稍改变了。\n\n实际上，`http.HandleFunc` 也是标准库提供给用户的一种简便写法，它的第二个参数的函数签名必须为 `func(http.ResponseWriter, *http.Request)` 是因为在 `http.HandleFunc` 函数内部会将我们传入的绑定函数转化为类型 `http.HandlerFunc`，即一个 Go 语言中标准的 HTTP 请求处理器对象，这个对象类型实现了 `http.Handler` 接口：\n\ntype Handler interface {\n    ServeHTTP(ResponseWriter, *Request)\n}\n\n通过 `http.Handler` 的接口定义我们发现，函数签名 `func(http.ResponseWriter, *http.Request)` 的由来是因为要实现接口的 `ServeHTTP` 方法。\n\n现在我们知道了 `http.HandleFunc` 的根本作用是将一个函数转化为一个实现了 `http.Handler` 接口的类型（`http.HandlerFunc`），那么我们可不可以自己创建一个类型并实现 `http.Handler` 接口呢？答案当然是肯定的。\n\n一模一样的功能，下面的代码使用了更加复杂的用法：\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.Handle(\"/\", &helloHandler{})\n\n\tlog.Println(\"Starting HTTP server...\")\n\tlog.Fatal(http.ListenAndServe(\":4000\", nil))\n}\n\ntype helloHandler struct{}\n\nfunc (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Hello world!\"))\n}\n```\n这段代码不再使用 `http.HandleFunc` 函数，取而代之的是直接调用 `http.Handle` 并传入我们自定义的 `http.Handler` 实现。\n\n初学者有一点需要特别注意，即 Go 语言是一门大小写敏感的语言（否则无法通过首字母大小写区分一个对象是公开的还是私有的）。因此，想要实现`http.Handler` 接口，方法名称必须连大小写也保持一致，即这里的方法名称必须是 `ServeHTTP` 而不可以是 `ServeHttp`。\n\n## 服务复用器（ServeMux）\n\n好奇的你可能会问，前文中 `http.ListenAndServe(\":4000\", nil)` 用 nil 代替的到底是一个东西？Go 语言标准库的设计非常精妙，不可能平白无故地提供给我们一个没有用处的参数。\n\n根据 `http.ListenAndServe` 的函数声明可以得知，这里的 nil 代替的其实是一个实现了 `http.Handler` 接口的对象：\n\nfunc ListenAndServe(addr string, handler Handler) error {...}\n\n是不是有点眼熟？因为这说明我们之前的定义的 `helloHandler` 就可以被用作这里的参数：\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tlog.Println(\"Starting HTTP server...\")\n\tlog.Fatal(http.ListenAndServe(\"localhost:4000\", &helloHandler{}))\n}\n\ntype helloHandler struct{}\n\nfunc (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Hello world!\"))\n}\n```\n运行这段代码同样可以得到和之前一模一样的结果！\n\n不过，在实际开发中很少直接将一个纯粹的处理器（Handler）作为这里的参数，因为它缺失了一个非常重要的功能，它不能像之前调用 `http.HandleFunc` 或 `http.Handle` 那样方便地将路由规则和执行函数进行绑定。\n\n通过查看 `http.Handle` 源码可以得知，它其实是对一个默认的 `http.ServeMux` 对象（`http.DefaultServeMux`）进行了一层封装：\n\nfunc Handle(pattern string, handler Handler) {\n    DefaultServeMux.Handle(pattern, handler)\n}\n\n这个 `http.ServeMux` 的作用是什么呢？它就是 Go 语言标准库实现的一个带有基本路由功能的服务复用器（Multiplexer）。除了可以通过 `http.HandleFunc` 或 `http.Handle` 这类方法操作 `http.DefaultServeMux` 对象之外，我们也可以通过标准库提供的方法 `http.NewServeMux` 来创建一个新的 `http.ServeMux` 对象：\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/\", &helloHandler{})\n\tlog.Println(\"Starting HTTP server...\")\n\tlog.Fatal(http.ListenAndServe(\"localhost:4000\", mux))\n}\n\ntype helloHandler struct{}\n\nfunc (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Hello world!\"))\n}\n```\n你可能已经猜到，这段代码依旧和之前做的是一模一样的事情。不过做到这个程度，便是大多数 Web 框架的底层用法了。它们本质上就是一个带有路由层的 `http.Handler` 具体实现，并以此为基础提供大量便利的辅助方法。\n\n## 服务器对象（Server）\n\n既然 `http.HandleFunc` 和 `http.Handle` 都是对一个默认对象 `http.DefaultServeMux` 的封装，那 `http.ListenAndServe` 是否也是如此？我们可以从它的源码中找到答案：\n\nfunc ListenAndServe(addr string, handler Handler) error {\n    server := &Server{Addr: addr, Handler: handler}\n    return server.ListenAndServe()\n}\n\n显而易见，虽然不是针对某个全局对象的封装，但也同样是在调用的时候创建了另一个 `http.Server` 的对象。相比较而言，`http.Server` 的自定义程度就非常高了，它包含了 Go 语言标准库提供的所有可能的选项，包括监听地址、服务复用器和读写超时等等。\n\n接下来，让我们使用 `http.Server` 对象来改写一下我们的小程序：\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/\", &helloHandler{})\n\n\tserver := &http.Server{\n\t\tAddr:    \":4000\",\n\t\tHandler: mux,\n\t}\n\tlog.Println(\"Starting HTTP server...\")\n\tlog.Fatal(server.ListenAndServe())\n}\n\ntype helloHandler struct{}\n\nfunc (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Hello world!\"))\n}\n```\n如果只是单纯地将标准库的封装强行抽离出来未免显得有点小题大做，那么我们可以对这个自定义的 `http.Server` 对象做点什么事情呢？不如就设置一个写超时（Write Timeout）好啦。写超时包含的范围是当请求头被解析后直到响应完成，浅显一点的理解就是从我们绑定的函数开始执行到执行结束为止，如果这个时间范围超过定义的周期则会触发写超时。\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc main() {\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/\", &helloHandler{})\n\tmux.HandleFunc(\"/timeout\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttime.Sleep(2 * time.Second)\n\t\tw.Write([]byte(\"Timeout\"))\n\t})\n\n\tserver := &http.Server{\n\t\tAddr:         \":4000\",\n\t\tHandler:      mux,\n\t\tWriteTimeout: 2 * time.Second,\n\t}\n\tlog.Println(\"Starting HTTP server...\")\n\tlog.Fatal(server.ListenAndServe())\n}\n\ntype helloHandler struct{}\n\nfunc (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Hello world!\"))\n}\n```\n在这段代码里，我们添加了对 `WriteTimeout` 字段的赋值，设为 2 秒钟，同时添加了一个新的执行函数用于先休眠 2 秒然后向客户端输出 ”Timeout“ 字符串。\n\n启动服务器后，如果我们访问 http://localhost:4000 会收到和之前一样的结果，但如果尝试访问 http://localhost:4000/timeout 则不会收到任何消息：\n\n<code>➜ curl http://localhost:4000/timeout\ncurl: (52) Empty reply from server</code> \n\n这是因为我们的执行函数在休眠 2 秒后被 `http.Server` 对象认为已经超时，提前关闭了与客户端之间的连接，因此无论执行函数后面向响应体写入任何东西都不会有任何作用。\n\n部分 Web 框架使用的便是自定义的 `http.Server` 对象，因此你只能通过调用框架提供的特定方法来启动服务。\n\n## 优雅地停止服务\n\n在产生环境中，许多开发者面临的一个困难就是当需要更新服务端程序时需要重启服务，但此时可能有一部分请求进行到一半，如果强行中断这些请求可能会导致意外的结果。因此，开源社区提供了多种优雅停止的方案，像 facebookgo/grace 就是其中的代表作之一。不过从 Go 1.8 版本开始，标准库终于支持原生的优雅停止方案了。\n\n这种方案同样要求用户创建自定义的 `http.Server` 对象，因为对应的 `Close` 方法无法通过其它途径调用。\n\n我们来看下面的代码，这段代码通过结合捕捉系统信号（Signal）、goroutine 和管道（Channel）来实现服务器的优雅停止：\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n)\n\nfunc main() {\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/\", &helloHandler{})\n\n\tserver := &http.Server{\n\t\tAddr:    \":4000\",\n\t\tHandler: mux,\n\t}\n\n\t// 创建系统信号接收器\n\tquit := make(chan os.Signal)\n\tsignal.Notify(quit, os.Interrupt)\n\tgo func() {\n\t\t<-quit\n\n\t\tif err := server.Close(); err != nil {\n\t\t\tlog.Fatal(\"Close server:\", err)\n\t\t}\n\t}()\n\n\tlog.Println(\"Starting HTTP server...\")\n\terr := server.ListenAndServe()\n\tif err != nil {\n\t\tif err == http.ErrServerClosed {\n\t\t\tlog.Print(\"Server closed under request\")\n\t\t} else {\n\t\t\tlog.Fatal(\"Server closed unexpected\")\n\t\t}\n\t}\n}\n\ntype helloHandler struct{}\n\nfunc (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Hello world!\"))\n}\n```\n这段代码通过捕捉 `os.Interrupt` 信号（Ctrl+C）然后调用 `server.Close` 方法告知服务器应停止接受新的请求并在处理完当前已接受的请求后关闭服务器。为了与普通错误相区别，标准库提供了一个特定的错误类型 `http.ErrServerClosed`，我们可以在代码中通过判断是否为该错误类型来确定服务器是正常关闭的还是意外关闭的。\n\n如果我们运行程序后按下 Ctrl+C 便可以看到如下输出：\n\n<code>➜ go run http_server.go\n2018/11/25 10:23:28 Starting HTTP server...\n^C2018/11/25 10:23:30 Server closed under request</code> \n\n是不是很酷？\n\n## 小结\n\n这节课，我们通过编写 HTTP 服务器的 N 种写法由浅入深地学习了如何在 Go 语言中建立一个 HTTP 服务器，并了解了它们之间的相同和不同之处。相信此时的同学们已经能够对 Go 语言的 HTTP 服务器有一定程度的认识，并可以自如地运用到实际开发中了。","slug":"test","published":1,"updated":"2019-11-11T09:44:07.532Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2uj8a1c00011idmfvl7l87v","content":"<h2 id=\"Hello-world\"><a href=\"#Hello-world\" class=\"headerlink\" title=\"Hello world!\"></a>Hello world!</h2><p>第一步，就让我们使用 Go 语言来搭建一个 HTTP 版的 ”Hello world“ 程序吧！</p>\n<p>我们先创建一个名为 <code>http_server.go</code> 的文件，然后输入以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\thttp.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">\t\tw.Write([]byte(&quot;Hello world!&quot;))</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我们通过终端运行这段代码的时候，就能够看到如下输出：</p>\n<p><code>➜ go run http_server.go<br>2018/11/25 07:34:49 Starting HTTP server...</code> </p>\n<p>此时，我们的 HTTP 服务器已经监听在本机的 4000 端口，并准备好接受来自客户端的请求了。有两种方式可以验证这个小程序的正确性：终端调用 cURL 或者打开浏览器访问。</p>\n<p>调用 cURL 的命令非常简单，回车运行之后即可看到服务端响应的字符串 ”Hello world!“：</p>\n<p><code>➜ curl <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a><br>Hello world!</code> </p>\n<p>同样的，如果直接打开浏览器访问地址 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a> 的话，我们也可以看到一样的字符串：</p>\n<p><img src=\"https://blog.zshipu.com/tlg/images/pasted-47.png\" alt=\"知识铺-pasted-47.png\"></p>\n<p>是不是感觉几个简单的步骤就实现了一个完全可用的 HTTP 服务器？这就是 Go 语言的魅力之一！</p>\n<p>接下来，让我们分析一下这段代码具体都做了什么事情。</p>\n<p>我们需要明白这里有三个关键点：</p>\n<ol>\n<li><p><code>http.HandleFunc</code> 函数的作用是将某一个函数与一个路由规则进行绑定，当用户访问指定路由时（某个路由规则匹配成功），所绑定的函数就会被执行。它接受两个参数，第一个参数就是指定的路由规则，本例中我们使用 <code>/</code> 来表示根路径；第二个参数就是与该路由进行绑定的函数。</p>\n</li>\n<li><p><code>http.HandleFunc</code> 的第二个参数必须符合函数签名 <code>func(http.ResponseWriter, *http.Request)</code>，这个函数同样接受两个参数，第一个参数是请求所对应的响应对象 <code>http.ResponseWriter</code>，包括响应码（Response Code）、响应头（Response Header）和响应体（Response Body）等等，我们就是通过调用这个对象的 <code>Write</code> 方法向响应体写入 ”Hello world!“ 字符串的；第二个参数则是请求所对应的请求对象 <code>*http.Request</code>，该对象包含当前这个 HTTP 请求所有的信息，包括请求头（Request Header）、请求体（Request Body）和其它相关的内容。</p>\n</li>\n<li><p><code>http.ListenAndServe</code> 函数的作用就是启动 HTTP 服务器，并监听发送到指定地址和端口号的 HTTP 请求，本例中我们要求 HTTP 服务器监听并接受发送到地址 localhost 且端口号为 4000 的 HTTP 请求。这个函数也接受两个参数，我们目前只使用到了第一个参数，即监听地址和端口号；第二个参数会在后文讲解，因此暂时可以使用 nil 作为它的值。另外，如果监听地址为 127.0.0.1 或者 localhost，则可以使用更加简洁的写法，即 <code>http.ListenAndServe(&quot;:4000&quot;, nil)</code>。</p>\n</li>\n</ol>\n<p>除此之外，你可能已经注意到为了节省代码行数，我们在这段代码中使用了匿名函数来编写 HTTP 请求的处理逻辑。这在编写简单的逻辑时非常方便，但当逻辑处理较为复杂时，应该定义一个独立的函数以提升代码的可读性。我们可以将这段代码等价地转化为如下形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\thttp.HandleFunc(&quot;/&quot;, hello)</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(&quot;:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func hello(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">\tw.Write([]byte(&quot;Hello world!&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重新运行这段代码在输出结果上并没有任何不同，只是代码结构稍稍改变了。</p>\n<p>实际上，<code>http.HandleFunc</code> 也是标准库提供给用户的一种简便写法，它的第二个参数的函数签名必须为 <code>func(http.ResponseWriter, *http.Request)</code> 是因为在 <code>http.HandleFunc</code> 函数内部会将我们传入的绑定函数转化为类型 <code>http.HandlerFunc</code>，即一个 Go 语言中标准的 HTTP 请求处理器对象，这个对象类型实现了 <code>http.Handler</code> 接口：</p>\n<p>type Handler interface {<br>    ServeHTTP(ResponseWriter, *Request)<br>}</p>\n<p>通过 <code>http.Handler</code> 的接口定义我们发现，函数签名 <code>func(http.ResponseWriter, *http.Request)</code> 的由来是因为要实现接口的 <code>ServeHTTP</code> 方法。</p>\n<p>现在我们知道了 <code>http.HandleFunc</code> 的根本作用是将一个函数转化为一个实现了 <code>http.Handler</code> 接口的类型（<code>http.HandlerFunc</code>），那么我们可不可以自己创建一个类型并实现 <code>http.Handler</code> 接口呢？答案当然是肯定的。</p>\n<p>一模一样的功能，下面的代码使用了更加复杂的用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\thttp.Handle(&quot;/&quot;, &amp;helloHandler&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(&quot;:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type helloHandler struct&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">\tw.Write([]byte(&quot;Hello world!&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码不再使用 <code>http.HandleFunc</code> 函数，取而代之的是直接调用 <code>http.Handle</code> 并传入我们自定义的 <code>http.Handler</code> 实现。</p>\n<p>初学者有一点需要特别注意，即 Go 语言是一门大小写敏感的语言（否则无法通过首字母大小写区分一个对象是公开的还是私有的）。因此，想要实现<code>http.Handler</code> 接口，方法名称必须连大小写也保持一致，即这里的方法名称必须是 <code>ServeHTTP</code> 而不可以是 <code>ServeHttp</code>。</p>\n<h2 id=\"服务复用器（ServeMux）\"><a href=\"#服务复用器（ServeMux）\" class=\"headerlink\" title=\"服务复用器（ServeMux）\"></a>服务复用器（ServeMux）</h2><p>好奇的你可能会问，前文中 <code>http.ListenAndServe(&quot;:4000&quot;, nil)</code> 用 nil 代替的到底是一个东西？Go 语言标准库的设计非常精妙，不可能平白无故地提供给我们一个没有用处的参数。</p>\n<p>根据 <code>http.ListenAndServe</code> 的函数声明可以得知，这里的 nil 代替的其实是一个实现了 <code>http.Handler</code> 接口的对象：</p>\n<p>func ListenAndServe(addr string, handler Handler) error {…}</p>\n<p>是不是有点眼熟？因为这说明我们之前的定义的 <code>helloHandler</code> 就可以被用作这里的参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tlog.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, &amp;helloHandler&#123;&#125;))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type helloHandler struct&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">\tw.Write([]byte(&quot;Hello world!&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行这段代码同样可以得到和之前一模一样的结果！</p>\n<p>不过，在实际开发中很少直接将一个纯粹的处理器（Handler）作为这里的参数，因为它缺失了一个非常重要的功能，它不能像之前调用 <code>http.HandleFunc</code> 或 <code>http.Handle</code> 那样方便地将路由规则和执行函数进行绑定。</p>\n<p>通过查看 <code>http.Handle</code> 源码可以得知，它其实是对一个默认的 <code>http.ServeMux</code> 对象（<code>http.DefaultServeMux</code>）进行了一层封装：</p>\n<p>func Handle(pattern string, handler Handler) {<br>    DefaultServeMux.Handle(pattern, handler)<br>}</p>\n<p>这个 <code>http.ServeMux</code> 的作用是什么呢？它就是 Go 语言标准库实现的一个带有基本路由功能的服务复用器（Multiplexer）。除了可以通过 <code>http.HandleFunc</code> 或 <code>http.Handle</code> 这类方法操作 <code>http.DefaultServeMux</code> 对象之外，我们也可以通过标准库提供的方法 <code>http.NewServeMux</code> 来创建一个新的 <code>http.ServeMux</code> 对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tmux := http.NewServeMux()</span><br><span class=\"line\">\tmux.Handle(&quot;/&quot;, &amp;helloHandler&#123;&#125;)</span><br><span class=\"line\">\tlog.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, mux))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type helloHandler struct&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">\tw.Write([]byte(&quot;Hello world!&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可能已经猜到，这段代码依旧和之前做的是一模一样的事情。不过做到这个程度，便是大多数 Web 框架的底层用法了。它们本质上就是一个带有路由层的 <code>http.Handler</code> 具体实现，并以此为基础提供大量便利的辅助方法。</p>\n<h2 id=\"服务器对象（Server）\"><a href=\"#服务器对象（Server）\" class=\"headerlink\" title=\"服务器对象（Server）\"></a>服务器对象（Server）</h2><p>既然 <code>http.HandleFunc</code> 和 <code>http.Handle</code> 都是对一个默认对象 <code>http.DefaultServeMux</code> 的封装，那 <code>http.ListenAndServe</code> 是否也是如此？我们可以从它的源码中找到答案：</p>\n<p>func ListenAndServe(addr string, handler Handler) error {<br>    server := &amp;Server{Addr: addr, Handler: handler}<br>    return server.ListenAndServe()<br>}</p>\n<p>显而易见，虽然不是针对某个全局对象的封装，但也同样是在调用的时候创建了另一个 <code>http.Server</code> 的对象。相比较而言，<code>http.Server</code> 的自定义程度就非常高了，它包含了 Go 语言标准库提供的所有可能的选项，包括监听地址、服务复用器和读写超时等等。</p>\n<p>接下来，让我们使用 <code>http.Server</code> 对象来改写一下我们的小程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tmux := http.NewServeMux()</span><br><span class=\"line\">\tmux.Handle(&quot;/&quot;, &amp;helloHandler&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tserver := &amp;http.Server&#123;</span><br><span class=\"line\">\t\tAddr:    &quot;:4000&quot;,</span><br><span class=\"line\">\t\tHandler: mux,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlog.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">\tlog.Fatal(server.ListenAndServe())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type helloHandler struct&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">\tw.Write([]byte(&quot;Hello world!&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果只是单纯地将标准库的封装强行抽离出来未免显得有点小题大做，那么我们可以对这个自定义的 <code>http.Server</code> 对象做点什么事情呢？不如就设置一个写超时（Write Timeout）好啦。写超时包含的范围是当请求头被解析后直到响应完成，浅显一点的理解就是从我们绑定的函数开始执行到执行结束为止，如果这个时间范围超过定义的周期则会触发写超时。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;net/http&quot;</span><br><span class=\"line\">\t&quot;time&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tmux := http.NewServeMux()</span><br><span class=\"line\">\tmux.Handle(&quot;/&quot;, &amp;helloHandler&#123;&#125;)</span><br><span class=\"line\">\tmux.HandleFunc(&quot;/timeout&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">\t\ttime.Sleep(2 * time.Second)</span><br><span class=\"line\">\t\tw.Write([]byte(&quot;Timeout&quot;))</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tserver := &amp;http.Server&#123;</span><br><span class=\"line\">\t\tAddr:         &quot;:4000&quot;,</span><br><span class=\"line\">\t\tHandler:      mux,</span><br><span class=\"line\">\t\tWriteTimeout: 2 * time.Second,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlog.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">\tlog.Fatal(server.ListenAndServe())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type helloHandler struct&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">\tw.Write([]byte(&quot;Hello world!&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这段代码里，我们添加了对 <code>WriteTimeout</code> 字段的赋值，设为 2 秒钟，同时添加了一个新的执行函数用于先休眠 2 秒然后向客户端输出 ”Timeout“ 字符串。</p>\n<p>启动服务器后，如果我们访问 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a> 会收到和之前一样的结果，但如果尝试访问 <a href=\"http://localhost:4000/timeout\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/timeout</a> 则不会收到任何消息：</p>\n<p><code>➜ curl <a href=\"http://localhost:4000/timeout\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/timeout</a><br>curl: (52) Empty reply from server</code> </p>\n<p>这是因为我们的执行函数在休眠 2 秒后被 <code>http.Server</code> 对象认为已经超时，提前关闭了与客户端之间的连接，因此无论执行函数后面向响应体写入任何东西都不会有任何作用。</p>\n<p>部分 Web 框架使用的便是自定义的 <code>http.Server</code> 对象，因此你只能通过调用框架提供的特定方法来启动服务。</p>\n<h2 id=\"优雅地停止服务\"><a href=\"#优雅地停止服务\" class=\"headerlink\" title=\"优雅地停止服务\"></a>优雅地停止服务</h2><p>在产生环境中，许多开发者面临的一个困难就是当需要更新服务端程序时需要重启服务，但此时可能有一部分请求进行到一半，如果强行中断这些请求可能会导致意外的结果。因此，开源社区提供了多种优雅停止的方案，像 facebookgo/grace 就是其中的代表作之一。不过从 Go 1.8 版本开始，标准库终于支持原生的优雅停止方案了。</p>\n<p>这种方案同样要求用户创建自定义的 <code>http.Server</code> 对象，因为对应的 <code>Close</code> 方法无法通过其它途径调用。</p>\n<p>我们来看下面的代码，这段代码通过结合捕捉系统信号（Signal）、goroutine 和管道（Channel）来实现服务器的优雅停止：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;net/http&quot;</span><br><span class=\"line\">\t&quot;os&quot;</span><br><span class=\"line\">\t&quot;os/signal&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tmux := http.NewServeMux()</span><br><span class=\"line\">\tmux.Handle(&quot;/&quot;, &amp;helloHandler&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tserver := &amp;http.Server&#123;</span><br><span class=\"line\">\t\tAddr:    &quot;:4000&quot;,</span><br><span class=\"line\">\t\tHandler: mux,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 创建系统信号接收器</span><br><span class=\"line\">\tquit := make(chan os.Signal)</span><br><span class=\"line\">\tsignal.Notify(quit, os.Interrupt)</span><br><span class=\"line\">\tgo func() &#123;</span><br><span class=\"line\">\t\t&lt;-quit</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif err := server.Close(); err != nil &#123;</span><br><span class=\"line\">\t\t\tlog.Fatal(&quot;Close server:&quot;, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">\terr := server.ListenAndServe()</span><br><span class=\"line\">\tif err != nil &#123;</span><br><span class=\"line\">\t\tif err == http.ErrServerClosed &#123;</span><br><span class=\"line\">\t\t\tlog.Print(&quot;Server closed under request&quot;)</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tlog.Fatal(&quot;Server closed unexpected&quot;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type helloHandler struct&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">\tw.Write([]byte(&quot;Hello world!&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码通过捕捉 <code>os.Interrupt</code> 信号（Ctrl+C）然后调用 <code>server.Close</code> 方法告知服务器应停止接受新的请求并在处理完当前已接受的请求后关闭服务器。为了与普通错误相区别，标准库提供了一个特定的错误类型 <code>http.ErrServerClosed</code>，我们可以在代码中通过判断是否为该错误类型来确定服务器是正常关闭的还是意外关闭的。</p>\n<p>如果我们运行程序后按下 Ctrl+C 便可以看到如下输出：</p>\n<p><code>➜ go run http_server.go<br>2018/11/25 10:23:28 Starting HTTP server...<br>^C2018/11/25 10:23:30 Server closed under request</code> </p>\n<p>是不是很酷？</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>这节课，我们通过编写 HTTP 服务器的 N 种写法由浅入深地学习了如何在 Go 语言中建立一个 HTTP 服务器，并了解了它们之间的相同和不同之处。相信此时的同学们已经能够对 Go 语言的 HTTP 服务器有一定程度的认识，并可以自如地运用到实际开发中了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Hello-world\"><a href=\"#Hello-world\" class=\"headerlink\" title=\"Hello world!\"></a>Hello world!</h2><p>第一步，就让我们使用 Go 语言来搭建一个 HTTP 版的 ”Hello world“ 程序吧！</p>\n<p>我们先创建一个名为 <code>http_server.go</code> 的文件，然后输入以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\thttp.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">\t\tw.Write([]byte(&quot;Hello world!&quot;))</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我们通过终端运行这段代码的时候，就能够看到如下输出：</p>\n<p><code>➜ go run http_server.go<br>2018/11/25 07:34:49 Starting HTTP server...</code> </p>\n<p>此时，我们的 HTTP 服务器已经监听在本机的 4000 端口，并准备好接受来自客户端的请求了。有两种方式可以验证这个小程序的正确性：终端调用 cURL 或者打开浏览器访问。</p>\n<p>调用 cURL 的命令非常简单，回车运行之后即可看到服务端响应的字符串 ”Hello world!“：</p>\n<p><code>➜ curl <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a><br>Hello world!</code> </p>\n<p>同样的，如果直接打开浏览器访问地址 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a> 的话，我们也可以看到一样的字符串：</p>\n<p><img src=\"https://blog.zshipu.com/tlg/images/pasted-47.png\" alt=\"知识铺-pasted-47.png\"></p>\n<p>是不是感觉几个简单的步骤就实现了一个完全可用的 HTTP 服务器？这就是 Go 语言的魅力之一！</p>\n<p>接下来，让我们分析一下这段代码具体都做了什么事情。</p>\n<p>我们需要明白这里有三个关键点：</p>\n<ol>\n<li><p><code>http.HandleFunc</code> 函数的作用是将某一个函数与一个路由规则进行绑定，当用户访问指定路由时（某个路由规则匹配成功），所绑定的函数就会被执行。它接受两个参数，第一个参数就是指定的路由规则，本例中我们使用 <code>/</code> 来表示根路径；第二个参数就是与该路由进行绑定的函数。</p>\n</li>\n<li><p><code>http.HandleFunc</code> 的第二个参数必须符合函数签名 <code>func(http.ResponseWriter, *http.Request)</code>，这个函数同样接受两个参数，第一个参数是请求所对应的响应对象 <code>http.ResponseWriter</code>，包括响应码（Response Code）、响应头（Response Header）和响应体（Response Body）等等，我们就是通过调用这个对象的 <code>Write</code> 方法向响应体写入 ”Hello world!“ 字符串的；第二个参数则是请求所对应的请求对象 <code>*http.Request</code>，该对象包含当前这个 HTTP 请求所有的信息，包括请求头（Request Header）、请求体（Request Body）和其它相关的内容。</p>\n</li>\n<li><p><code>http.ListenAndServe</code> 函数的作用就是启动 HTTP 服务器，并监听发送到指定地址和端口号的 HTTP 请求，本例中我们要求 HTTP 服务器监听并接受发送到地址 localhost 且端口号为 4000 的 HTTP 请求。这个函数也接受两个参数，我们目前只使用到了第一个参数，即监听地址和端口号；第二个参数会在后文讲解，因此暂时可以使用 nil 作为它的值。另外，如果监听地址为 127.0.0.1 或者 localhost，则可以使用更加简洁的写法，即 <code>http.ListenAndServe(&quot;:4000&quot;, nil)</code>。</p>\n</li>\n</ol>\n<p>除此之外，你可能已经注意到为了节省代码行数，我们在这段代码中使用了匿名函数来编写 HTTP 请求的处理逻辑。这在编写简单的逻辑时非常方便，但当逻辑处理较为复杂时，应该定义一个独立的函数以提升代码的可读性。我们可以将这段代码等价地转化为如下形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\thttp.HandleFunc(&quot;/&quot;, hello)</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(&quot;:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func hello(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">\tw.Write([]byte(&quot;Hello world!&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重新运行这段代码在输出结果上并没有任何不同，只是代码结构稍稍改变了。</p>\n<p>实际上，<code>http.HandleFunc</code> 也是标准库提供给用户的一种简便写法，它的第二个参数的函数签名必须为 <code>func(http.ResponseWriter, *http.Request)</code> 是因为在 <code>http.HandleFunc</code> 函数内部会将我们传入的绑定函数转化为类型 <code>http.HandlerFunc</code>，即一个 Go 语言中标准的 HTTP 请求处理器对象，这个对象类型实现了 <code>http.Handler</code> 接口：</p>\n<p>type Handler interface {<br>    ServeHTTP(ResponseWriter, *Request)<br>}</p>\n<p>通过 <code>http.Handler</code> 的接口定义我们发现，函数签名 <code>func(http.ResponseWriter, *http.Request)</code> 的由来是因为要实现接口的 <code>ServeHTTP</code> 方法。</p>\n<p>现在我们知道了 <code>http.HandleFunc</code> 的根本作用是将一个函数转化为一个实现了 <code>http.Handler</code> 接口的类型（<code>http.HandlerFunc</code>），那么我们可不可以自己创建一个类型并实现 <code>http.Handler</code> 接口呢？答案当然是肯定的。</p>\n<p>一模一样的功能，下面的代码使用了更加复杂的用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\thttp.Handle(&quot;/&quot;, &amp;helloHandler&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(&quot;:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type helloHandler struct&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">\tw.Write([]byte(&quot;Hello world!&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码不再使用 <code>http.HandleFunc</code> 函数，取而代之的是直接调用 <code>http.Handle</code> 并传入我们自定义的 <code>http.Handler</code> 实现。</p>\n<p>初学者有一点需要特别注意，即 Go 语言是一门大小写敏感的语言（否则无法通过首字母大小写区分一个对象是公开的还是私有的）。因此，想要实现<code>http.Handler</code> 接口，方法名称必须连大小写也保持一致，即这里的方法名称必须是 <code>ServeHTTP</code> 而不可以是 <code>ServeHttp</code>。</p>\n<h2 id=\"服务复用器（ServeMux）\"><a href=\"#服务复用器（ServeMux）\" class=\"headerlink\" title=\"服务复用器（ServeMux）\"></a>服务复用器（ServeMux）</h2><p>好奇的你可能会问，前文中 <code>http.ListenAndServe(&quot;:4000&quot;, nil)</code> 用 nil 代替的到底是一个东西？Go 语言标准库的设计非常精妙，不可能平白无故地提供给我们一个没有用处的参数。</p>\n<p>根据 <code>http.ListenAndServe</code> 的函数声明可以得知，这里的 nil 代替的其实是一个实现了 <code>http.Handler</code> 接口的对象：</p>\n<p>func ListenAndServe(addr string, handler Handler) error {…}</p>\n<p>是不是有点眼熟？因为这说明我们之前的定义的 <code>helloHandler</code> 就可以被用作这里的参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tlog.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, &amp;helloHandler&#123;&#125;))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type helloHandler struct&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">\tw.Write([]byte(&quot;Hello world!&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行这段代码同样可以得到和之前一模一样的结果！</p>\n<p>不过，在实际开发中很少直接将一个纯粹的处理器（Handler）作为这里的参数，因为它缺失了一个非常重要的功能，它不能像之前调用 <code>http.HandleFunc</code> 或 <code>http.Handle</code> 那样方便地将路由规则和执行函数进行绑定。</p>\n<p>通过查看 <code>http.Handle</code> 源码可以得知，它其实是对一个默认的 <code>http.ServeMux</code> 对象（<code>http.DefaultServeMux</code>）进行了一层封装：</p>\n<p>func Handle(pattern string, handler Handler) {<br>    DefaultServeMux.Handle(pattern, handler)<br>}</p>\n<p>这个 <code>http.ServeMux</code> 的作用是什么呢？它就是 Go 语言标准库实现的一个带有基本路由功能的服务复用器（Multiplexer）。除了可以通过 <code>http.HandleFunc</code> 或 <code>http.Handle</code> 这类方法操作 <code>http.DefaultServeMux</code> 对象之外，我们也可以通过标准库提供的方法 <code>http.NewServeMux</code> 来创建一个新的 <code>http.ServeMux</code> 对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tmux := http.NewServeMux()</span><br><span class=\"line\">\tmux.Handle(&quot;/&quot;, &amp;helloHandler&#123;&#125;)</span><br><span class=\"line\">\tlog.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, mux))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type helloHandler struct&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">\tw.Write([]byte(&quot;Hello world!&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可能已经猜到，这段代码依旧和之前做的是一模一样的事情。不过做到这个程度，便是大多数 Web 框架的底层用法了。它们本质上就是一个带有路由层的 <code>http.Handler</code> 具体实现，并以此为基础提供大量便利的辅助方法。</p>\n<h2 id=\"服务器对象（Server）\"><a href=\"#服务器对象（Server）\" class=\"headerlink\" title=\"服务器对象（Server）\"></a>服务器对象（Server）</h2><p>既然 <code>http.HandleFunc</code> 和 <code>http.Handle</code> 都是对一个默认对象 <code>http.DefaultServeMux</code> 的封装，那 <code>http.ListenAndServe</code> 是否也是如此？我们可以从它的源码中找到答案：</p>\n<p>func ListenAndServe(addr string, handler Handler) error {<br>    server := &amp;Server{Addr: addr, Handler: handler}<br>    return server.ListenAndServe()<br>}</p>\n<p>显而易见，虽然不是针对某个全局对象的封装，但也同样是在调用的时候创建了另一个 <code>http.Server</code> 的对象。相比较而言，<code>http.Server</code> 的自定义程度就非常高了，它包含了 Go 语言标准库提供的所有可能的选项，包括监听地址、服务复用器和读写超时等等。</p>\n<p>接下来，让我们使用 <code>http.Server</code> 对象来改写一下我们的小程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tmux := http.NewServeMux()</span><br><span class=\"line\">\tmux.Handle(&quot;/&quot;, &amp;helloHandler&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tserver := &amp;http.Server&#123;</span><br><span class=\"line\">\t\tAddr:    &quot;:4000&quot;,</span><br><span class=\"line\">\t\tHandler: mux,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlog.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">\tlog.Fatal(server.ListenAndServe())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type helloHandler struct&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">\tw.Write([]byte(&quot;Hello world!&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果只是单纯地将标准库的封装强行抽离出来未免显得有点小题大做，那么我们可以对这个自定义的 <code>http.Server</code> 对象做点什么事情呢？不如就设置一个写超时（Write Timeout）好啦。写超时包含的范围是当请求头被解析后直到响应完成，浅显一点的理解就是从我们绑定的函数开始执行到执行结束为止，如果这个时间范围超过定义的周期则会触发写超时。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;net/http&quot;</span><br><span class=\"line\">\t&quot;time&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tmux := http.NewServeMux()</span><br><span class=\"line\">\tmux.Handle(&quot;/&quot;, &amp;helloHandler&#123;&#125;)</span><br><span class=\"line\">\tmux.HandleFunc(&quot;/timeout&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">\t\ttime.Sleep(2 * time.Second)</span><br><span class=\"line\">\t\tw.Write([]byte(&quot;Timeout&quot;))</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tserver := &amp;http.Server&#123;</span><br><span class=\"line\">\t\tAddr:         &quot;:4000&quot;,</span><br><span class=\"line\">\t\tHandler:      mux,</span><br><span class=\"line\">\t\tWriteTimeout: 2 * time.Second,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlog.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">\tlog.Fatal(server.ListenAndServe())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type helloHandler struct&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">\tw.Write([]byte(&quot;Hello world!&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这段代码里，我们添加了对 <code>WriteTimeout</code> 字段的赋值，设为 2 秒钟，同时添加了一个新的执行函数用于先休眠 2 秒然后向客户端输出 ”Timeout“ 字符串。</p>\n<p>启动服务器后，如果我们访问 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a> 会收到和之前一样的结果，但如果尝试访问 <a href=\"http://localhost:4000/timeout\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/timeout</a> 则不会收到任何消息：</p>\n<p><code>➜ curl <a href=\"http://localhost:4000/timeout\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/timeout</a><br>curl: (52) Empty reply from server</code> </p>\n<p>这是因为我们的执行函数在休眠 2 秒后被 <code>http.Server</code> 对象认为已经超时，提前关闭了与客户端之间的连接，因此无论执行函数后面向响应体写入任何东西都不会有任何作用。</p>\n<p>部分 Web 框架使用的便是自定义的 <code>http.Server</code> 对象，因此你只能通过调用框架提供的特定方法来启动服务。</p>\n<h2 id=\"优雅地停止服务\"><a href=\"#优雅地停止服务\" class=\"headerlink\" title=\"优雅地停止服务\"></a>优雅地停止服务</h2><p>在产生环境中，许多开发者面临的一个困难就是当需要更新服务端程序时需要重启服务，但此时可能有一部分请求进行到一半，如果强行中断这些请求可能会导致意外的结果。因此，开源社区提供了多种优雅停止的方案，像 facebookgo/grace 就是其中的代表作之一。不过从 Go 1.8 版本开始，标准库终于支持原生的优雅停止方案了。</p>\n<p>这种方案同样要求用户创建自定义的 <code>http.Server</code> 对象，因为对应的 <code>Close</code> 方法无法通过其它途径调用。</p>\n<p>我们来看下面的代码，这段代码通过结合捕捉系统信号（Signal）、goroutine 和管道（Channel）来实现服务器的优雅停止：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;net/http&quot;</span><br><span class=\"line\">\t&quot;os&quot;</span><br><span class=\"line\">\t&quot;os/signal&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tmux := http.NewServeMux()</span><br><span class=\"line\">\tmux.Handle(&quot;/&quot;, &amp;helloHandler&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tserver := &amp;http.Server&#123;</span><br><span class=\"line\">\t\tAddr:    &quot;:4000&quot;,</span><br><span class=\"line\">\t\tHandler: mux,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 创建系统信号接收器</span><br><span class=\"line\">\tquit := make(chan os.Signal)</span><br><span class=\"line\">\tsignal.Notify(quit, os.Interrupt)</span><br><span class=\"line\">\tgo func() &#123;</span><br><span class=\"line\">\t\t&lt;-quit</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif err := server.Close(); err != nil &#123;</span><br><span class=\"line\">\t\t\tlog.Fatal(&quot;Close server:&quot;, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">\terr := server.ListenAndServe()</span><br><span class=\"line\">\tif err != nil &#123;</span><br><span class=\"line\">\t\tif err == http.ErrServerClosed &#123;</span><br><span class=\"line\">\t\t\tlog.Print(&quot;Server closed under request&quot;)</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tlog.Fatal(&quot;Server closed unexpected&quot;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type helloHandler struct&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (_ *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">\tw.Write([]byte(&quot;Hello world!&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码通过捕捉 <code>os.Interrupt</code> 信号（Ctrl+C）然后调用 <code>server.Close</code> 方法告知服务器应停止接受新的请求并在处理完当前已接受的请求后关闭服务器。为了与普通错误相区别，标准库提供了一个特定的错误类型 <code>http.ErrServerClosed</code>，我们可以在代码中通过判断是否为该错误类型来确定服务器是正常关闭的还是意外关闭的。</p>\n<p>如果我们运行程序后按下 Ctrl+C 便可以看到如下输出：</p>\n<p><code>➜ go run http_server.go<br>2018/11/25 10:23:28 Starting HTTP server...<br>^C2018/11/25 10:23:30 Server closed under request</code> </p>\n<p>是不是很酷？</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>这节课，我们通过编写 HTTP 服务器的 N 种写法由浅入深地学习了如何在 Go 语言中建立一个 HTTP 服务器，并了解了它们之间的相同和不同之处。相信此时的同学们已经能够对 Go 语言的 HTTP 服务器有一定程度的认识，并可以自如地运用到实际开发中了。</p>\n"},{"title":"第 03 课：进阶模板用法","author":"知识铺","date":"2019-11-11T09:56:48.000Z","_content":"在模板中定义变量\n变量不仅是 Go 语言中程序代码的重要组成部分，同样也是模板引擎中的主要元素。因为只有通过定义和操作变量，才能使得模板引擎在逻辑和用法上更加灵活和便利。\n\ntext/template 包提供的文本模板引擎支持使用字母数字（Alphanumeric）作为变量的名称，并使用一个美元符号（$）作为前缀，例如：$name、$age 和 $round2。在模板中的定义语法和程序代码中类似，即使用 := 连接变量名和赋值语句。\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"text/template\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`\n{{$name := \"Alice\"}}\n{{$age := 18}}\n{{$round2 := true}}\nName: {{$name}}\nAge: {{$age}}\nRound2: {{$round2}}\n`)\n        if err != nil {\n            fmt.Fprintf(w, \"Parse: %v\", err)\n            return\n        }\n\n        // 调用模板对象的渲染方法\n        err = tmpl.Execute(w, nil)\n        if err != nil {\n            fmt.Fprintf(w, \"Execute: %v\", err)\n            return\n        }\n    })\n\n    log.Println(\"Starting HTTP server...\")\n    log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))\n}\n```\n尝试运行以上代码可以在终端获得以下结果：\n\n➜ curl http://localhost:4000\nName: Alice\nAge: 18\nRound2: true\n不难发现，这个示例的核心就是包含变量使用的模板内容：\n```\n{{$name := \"Alice\"}}\n{{$age := 18}}\n{{$round2 := true}}\nName: {{$name}}\nAge: {{$age}}\nRound2: {{$round2}}\n```\n在这里，我们需要注意的是以下三点：\n\n变量的定义（或首次获得赋值）必须使用 := 的语法。\n获取变量值时，直接在相应位置使用美元符号加上变量名称即可。\n所有有关变量的操作都属于模板语法的一部分，因此需要使用双层大括号将其包裹起来。\n那么，在变量被定义之后，如何修改变量的值呢？很简单，只需要和程序代码中那样，直接使用等号（=）即可。\n```\n...\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`\n{{$name := \"Alice\"}}\n{{$age := 18}}\n{{$round2 := true}}\nName: {{$name}}\nAge: {{$age}}\nRound2: {{$round2}}\n\n{{$name = \"Bob\"}}\nName: {{$name}}\n`)\n...\n```\n（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）\n\n尝试运行变动后的代码可以在终端获得以下结果：\n\n➜ curl http://localhost:4000\nName: Alice\nAge: 18\nRound2: true\nName: Bob\n感兴趣的同学可以尝试一下，如果重复使用 := 的语法给相同名称的变量多次赋值会发生什么呢？\n\n在模板中使用条件判断（if 语句）\n标准库 text/template 包供的文本模板引擎除了可以进行单纯的数据展示外，还能够像程序代码那样进行基本的逻辑控制，而逻辑控制语句中最常见的便是 if 语句了。\n\n接下来，我们需要编写一个能够进行除法运算的 Web 服务，即通过 URL 查询参数接收两个值，分别为 x 和 y（被除数与除数），然后进行 x/y 的运算，再将运算结果返回给客户端。由于除法的特殊性，当 y 为 0 的时候是无法进行运算的。因此，我们需要在 y 等于 0 的时候提示客户端参数错误（利用模板的 if 语句）。\n```\npackage main\n\nimport (\n    ...\n    \"strconv\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`\n{{if .yIsZero}}\n    除数不能为 0\n{{else}}\n    {{.result}}\n{{end}}\n`)\n        if err != nil {\n            fmt.Fprintf(w, \"Parse: %v\", err)\n            return\n        }\n\n        // 获取 URL 查询参数的值\n        // 注意：为了简化代码逻辑，这里并没有进行错误处理\n        x, _ := strconv.ParseInt(r.URL.Query().Get(\"x\"), 10, 64)\n        y, _ := strconv.ParseInt(r.URL.Query().Get(\"y\"), 10, 64)\n\n        // 当 y 不为 0 时进行除法运算\n        yIsZero := y == 0\n        result := 0.0\n        if !yIsZero {\n            result = float64(x) / float64(y)\n        }\n\n        // 调用模板对象的渲染方法\n        err = tmpl.Execute(w, map[string]interface{}{\n            \"yIsZero\": yIsZero,\n            \"result\":  result,\n        })\n        if err != nil {\n            fmt.Fprintf(w, \"Execute: %v\", err)\n            return\n        }\n    })\n\n    ...\n}\n```\n（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）\n\n以上代码的逻辑非常简单，即首先通过程序判断除数 y 是否为 0，然后将判断结果和可能的除法运算结果都赋值到 map 类型的根对象中。\n\n在模板中，我们需要将条件语句放置在 if 关键字之后，使用空格将它们分隔，并将整个语句使用分隔符 {{ 和 }} 进行包裹。需要注意的是，条件语句必须要返回一个布尔类型（bool）的值，本例中 yIsZero 变量自身即是 bool 类型的值，因此不需要再做额外的类型转换。\n\n尝试运行以上代码可以在终端获得以下结果：\n\n➜ curl http://localhost:4000?x=1&y=2\n0.5\n➜ curl http://localhost:4000?x=1&y=0\n除数不能为 0\n本例中展示的条件语句十分简单，但在实际开发过程中，if 语句通常会被大量使用，然后根据给定的条件判断渲染出不同的内容。\n\n模板中的等式与不等式\n如果所有的条件判断都只能在程序代码中完成，然后直接输出给模板计算好的条件，未免有点太不方便了。因此，Go 语言的文本模板引擎同样可以在模板中完成等式与不等式的判断，为更加复杂的条件判断提供了必要的支持。\n\n用于等式与不等式判断的函数主要有以下六种（均接受两个，分别名为 arg1 和 arg2 的参数）：\n\neq：当等式 arg1 == arg2 成立时，返回 true，否则返回 false\nne：当不等式 arg1 != arg2 成立时，返回 true，否则返回 false\nlt：当不等式 arg1 < arg2 成立时，返回 true，否则返回 false\nle：当不等式 arg1 <= arg2 成立时，返回 true，否则返回 false\ngt：当不等式 arg1 > arg2 成立时，返回 true，否则返回 false\nge：当不等式 arg1 >= arg2 成立时，返回 true，否则返回 false\n如果你对这些函数的名字感到奇怪，其实不难发现这些名字本质上就是相关英文的缩写。如 “eq” 是 “equal” 的缩写，”ne” 表示 “not equal”，”lt” 表示 “less than“，”le” 表示 “less than or equal” 等等。\n\n接下来，我们就结合目前所学的知识，将更多的判断逻辑放置到模板当中完成。\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"text/template\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`\n{{$name1 := \"alice\"}}\n{{$name2 := \"bob\"}}\n{{$age1 := 18}}\n{{$age2 := 23}}\n\n{{if eq $age1 $age2}}\n    年龄相同\n{{else}}\n    年龄不相同\n{{end}}\n\n{{if ne $name1 $name2}}\n    名字不相同\n{{end}}\n\n{{if gt $age1 $age2}}\n    alice 年龄比较大\n{{else}}\n    bob 年龄比较大\n{{end}}\n`)\n        if err != nil {\n            fmt.Fprintf(w, \"Parse: %v\", err)\n            return\n        }\n\n        // 调用模板对象的渲染方法\n        err = tmpl.Execute(w, nil)\n        if err != nil {\n            fmt.Fprintf(w, \"Execute: %v\", err)\n            return\n        }\n    })\n\n    log.Println(\"Starting HTTP server...\")\n    log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))\n}\n```\n在这个例子中，我们使用到了 eq、ne 和 gt 三个函数。尝试运行以上代码可以在终端获得以下结果：\n\n➜ curl http://localhost:4000\n年龄不相同\n名字不相同\nbob 年龄比较大\n你可能会对这个例子中 if 条件语句的用法感到怪异，这是因为 eq、ne 和 gt 等本质上属于函数，而函数的调用都是以 函数名称（参数 1，参数 2，...） 的形式，只是在大部分情况下，Go 语言标准库提供的这套模板引擎可以在语法上省略括号的使用。\n\n在模板中使用迭代操作（range 语句）\n除了可以在模板中进行条件判断以外，Go 语言标准库提供的模板引擎还支持通过 range 语句进行迭代操作，以方便直接在模板中对集合类型的数据进行处理和渲染。\n\nGo 语言中一般来说有三种类型可以进行迭代操作，数组（Array）、切片（Slice）和 map 类型。\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"text/template\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`\n{{range $name := .Names}}\n    {{$name}}\n{{end}}\n`)\n        if err != nil {\n            fmt.Fprintf(w, \"Parse: %v\", err)\n            return\n        }\n\n        // 调用模板对象的渲染方法\n        err = tmpl.Execute(w, map[string]interface{}{\n            \"Names\": []string{\n                \"Alice\",\n                \"Bob\",\n                \"Carol\",\n                \"David\",\n            },\n        })\n        if err != nil {\n            fmt.Fprintf(w, \"Execute: %v\", err)\n            return\n        }\n    })\n\n    log.Println(\"Starting HTTP server...\")\n    log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))\n}\n```\n上例中的代码作用非常简单，即先通过 map[string]interface{} 类型的根对象传递一个名为 “Names” 的切片，该切片包含了四个人名。然后通过模板的 range 语句对这个切片进行迭代，依次输出每个人名。\n\n值得注意的是，这里我们使用的语法结构为 range $name := .Names，其中 .Names 是被迭代的集合，而变量 $name 则是当次迭代中获取到的单个对象。在本例中，变量 $name 实际上为 string 类型。\n\n尝试运行以上代码可以在终端获得以下结果：\n\n➜ curl http://localhost:4000\nAlice\nBob\nCarol\nDavid\nrange 语句除了可以获取到当次迭代的对象以外，还能够和 Go 语言源代码中一样，获取到一个当前迭代所对应的索引值。\n```\n...\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`\n{{range $i, $name := .Names}}\n    {{$i}}. {{$name}}\n{{end}}\n`)\n\n...\n```\n（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）\n\n尝试运行以上代码可以在终端获得以下结果：\n\n➜ curl http://localhost:4000\n0. Alice\n1. Bob\n2. Carol\n3. David\n可以看到，通过使用语法结构 range $i, $name := .Names，我们可以再获取变量 $name 的同时获取变量 $i （索引）的值。\n\n就模板语法而言，迭代不同类型的集合是没有区别的，我们可以来看一下如何在模板中对 map 类型的集合进行迭代操作：\n```\n...\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`\n{{range $name, $val := .}}\n    {{$name}}: {{$val}}\n{{end}}\n`)\n\n        ...\n\n        // 调用模板对象的渲染方法\n        err = tmpl.Execute(w, map[string]interface{}{\n            \"Names\": []string{\n                \"Alice\",\n                \"Bob\",\n                \"Carol\",\n                \"David\",\n            },\n            \"Numbers\": []int{1, 3, 5, 7},\n        })\n\n        ...\n}\n```\n（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）\n\n尝试运行以上代码可以在终端获得以下结果：\n\n➜ curl http://localhost:4000\nNames: [Alice Bob Carol David]\nNumbers: [1 3 5 7]\n上例中，我们通过直接迭代作为根对象的 map，然后打印其中所包含的键值对。和迭代其它类型集合的唯一不同在于，语法结构 range $name, $val := . 获得到的第一个变量不再是索引，而是当次迭代所对应的键名。\n\n在模板中使用语境操作（with 语句）\n在学习如何使用语境操作（with 语句）之前，我们先来看一看下面的示例：\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"text/template\"\n)\n\ntype Inventory struct {\n    SKU       string\n    Name      string\n    UnitPrice float64\n    Quantity  int64\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`Inventory\nSKU: {{.Inventory.SKU}}\nName: {{.Inventory.Name}}\nUnitPrice: {{.Inventory.UnitPrice}}\nQuantity: {{.Inventory.Quantity}}\n`)\n        if err != nil {\n            fmt.Fprintf(w, \"Parse: %v\", err)\n            return\n        }\n\n        // 调用模板对象的渲染方法\n        err = tmpl.Execute(w, map[string]interface{}{\n            \"Inventory\": Inventory{\n                SKU:       \"11000\",\n                Name:      \"Phone\",\n                UnitPrice: 699.99,\n                Quantity:  666,\n            },\n        })\n        if err != nil {\n            fmt.Fprintf(w, \"Execute: %v\", err)\n            return\n        }\n    })\n\n    log.Println(\"Starting HTTP server...\")\n    log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))\n}\n```\n本例中，我们定义和创建了一个 Inventory 类型的对象，并将它放入对根对象中，关联键名为 “Inventory”。尝试运行以上代码可以在终端获得以下结果：\n\n➜ curl http://localhost:4000\nInventory\nSKU: 11000\nName: Phone\nUnitPrice: 699.99\nQuantity: 666\n这里我们要关注的并不是程序的运行结果，而是模板的内容：\n```\nInventory\nSKU: {{.Inventory.SKU}}\nName: {{.Inventory.Name}}\nUnitPrice: {{.Inventory.UnitPrice}}\nQuantity: {{.Inventory.Quantity}}\n```\n不难发现，为了能够渲染 “Inventory” 的每一个值，我们都需要先通过点操作获取根对象中键名为 “Inventory” 的对象，然后再通过第二次点操作才能获取到具体某个字段的值。\n\n在模板内容较少的情况下，这样的做法没有什么问题，但如果 “Inventory” 对象需要被使用非常多次数，或者甚至我们需要通过多次点操作才能获取到我们所要获得的值呢？例如：.Storage.Repository.Inventory。在这种情况下，模板的内容就会显得非常冗余。\n\n为了解决这个问题，就可以使用语境操作（with 语句）啦！学习使用过 Visual Basic 的同学可能会对 with 语句的用法和作用比较熟悉。\n```\n...\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`Inventory\n{{with .Inventory}}\n    SKU: {{.SKU}}\n    Name: {{.Name}}\n    UnitPrice: {{.UnitPrice}}\n    Quantity: {{.Quantity}}\n{{end}}\n`)\n\n...\n```\n（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）\n\n尝试运行以上代码可以得到和之前一模一样的运行结果。\n\n在使用了 with 语句之后，是不是觉得模板内容更加简洁易懂了呢？\n\n模板中的空白符号处理\n细心的你可能已经发现，在运行之前示例的时候，终端得到的响应实际上会带有多余的空行，例如：\n\n➜ curl http://localhost:4000\nInventory\n\n    SKU: 11000\n    Name: Phone\n    UnitPrice: 699.99\n    Quantity: 666\n这是因为我们在编写模板内容的时候，为了格式上的清晰加入了这些空行。如果我们想要更加整洁的输出结果的话，就可以使用 Go 语言标准库模板引擎的一个特殊语法，{{- 和 -}}。\n\n{{- 表示剔除模板内容左侧的所有空白符号，-}} 表示剔除模板内容右侧的所有空白符号。\n```\n...\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`Inventory\n{{- with .Inventory}}\n    SKU: {{.SKU}}\n    Name: {{.Name}}\n    UnitPrice: {{.UnitPrice}}\n    Quantity: {{.Quantity}}\n{{- end}}\n`)\n\n...\n```\n（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）\n\n这里需要特别注意减号两侧的空格，如果没有使用空格将减号与模板中其它内容分开的话，会被模板引擎误以为是表达式的一部分。例如，使用 {{-with .Inventory}} 则会报如下错误：\n\nunexpected bad number syntax: \"-w\" in command  \n小结\n这节课，我们主要学习了标准库中 text/template 包提供的文本模板引擎的逻辑控制、集合对象迭代和空白符号处理的用法。\n\n下节课，我们将基于这节课所学的基础用法上，进一步学习如何在 Go 语言提供的模板引擎中使用自定义模板、模板函数和响应 HTML 内容。","source":"_posts/第-03-课：进阶模板用法.md","raw":"title: 第 03 课：进阶模板用法\nauthor: 知识铺\ndate: 2019-11-11 17:56:48\ntags:\n---\n在模板中定义变量\n变量不仅是 Go 语言中程序代码的重要组成部分，同样也是模板引擎中的主要元素。因为只有通过定义和操作变量，才能使得模板引擎在逻辑和用法上更加灵活和便利。\n\ntext/template 包提供的文本模板引擎支持使用字母数字（Alphanumeric）作为变量的名称，并使用一个美元符号（$）作为前缀，例如：$name、$age 和 $round2。在模板中的定义语法和程序代码中类似，即使用 := 连接变量名和赋值语句。\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"text/template\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`\n{{$name := \"Alice\"}}\n{{$age := 18}}\n{{$round2 := true}}\nName: {{$name}}\nAge: {{$age}}\nRound2: {{$round2}}\n`)\n        if err != nil {\n            fmt.Fprintf(w, \"Parse: %v\", err)\n            return\n        }\n\n        // 调用模板对象的渲染方法\n        err = tmpl.Execute(w, nil)\n        if err != nil {\n            fmt.Fprintf(w, \"Execute: %v\", err)\n            return\n        }\n    })\n\n    log.Println(\"Starting HTTP server...\")\n    log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))\n}\n```\n尝试运行以上代码可以在终端获得以下结果：\n\n➜ curl http://localhost:4000\nName: Alice\nAge: 18\nRound2: true\n不难发现，这个示例的核心就是包含变量使用的模板内容：\n```\n{{$name := \"Alice\"}}\n{{$age := 18}}\n{{$round2 := true}}\nName: {{$name}}\nAge: {{$age}}\nRound2: {{$round2}}\n```\n在这里，我们需要注意的是以下三点：\n\n变量的定义（或首次获得赋值）必须使用 := 的语法。\n获取变量值时，直接在相应位置使用美元符号加上变量名称即可。\n所有有关变量的操作都属于模板语法的一部分，因此需要使用双层大括号将其包裹起来。\n那么，在变量被定义之后，如何修改变量的值呢？很简单，只需要和程序代码中那样，直接使用等号（=）即可。\n```\n...\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`\n{{$name := \"Alice\"}}\n{{$age := 18}}\n{{$round2 := true}}\nName: {{$name}}\nAge: {{$age}}\nRound2: {{$round2}}\n\n{{$name = \"Bob\"}}\nName: {{$name}}\n`)\n...\n```\n（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）\n\n尝试运行变动后的代码可以在终端获得以下结果：\n\n➜ curl http://localhost:4000\nName: Alice\nAge: 18\nRound2: true\nName: Bob\n感兴趣的同学可以尝试一下，如果重复使用 := 的语法给相同名称的变量多次赋值会发生什么呢？\n\n在模板中使用条件判断（if 语句）\n标准库 text/template 包供的文本模板引擎除了可以进行单纯的数据展示外，还能够像程序代码那样进行基本的逻辑控制，而逻辑控制语句中最常见的便是 if 语句了。\n\n接下来，我们需要编写一个能够进行除法运算的 Web 服务，即通过 URL 查询参数接收两个值，分别为 x 和 y（被除数与除数），然后进行 x/y 的运算，再将运算结果返回给客户端。由于除法的特殊性，当 y 为 0 的时候是无法进行运算的。因此，我们需要在 y 等于 0 的时候提示客户端参数错误（利用模板的 if 语句）。\n```\npackage main\n\nimport (\n    ...\n    \"strconv\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`\n{{if .yIsZero}}\n    除数不能为 0\n{{else}}\n    {{.result}}\n{{end}}\n`)\n        if err != nil {\n            fmt.Fprintf(w, \"Parse: %v\", err)\n            return\n        }\n\n        // 获取 URL 查询参数的值\n        // 注意：为了简化代码逻辑，这里并没有进行错误处理\n        x, _ := strconv.ParseInt(r.URL.Query().Get(\"x\"), 10, 64)\n        y, _ := strconv.ParseInt(r.URL.Query().Get(\"y\"), 10, 64)\n\n        // 当 y 不为 0 时进行除法运算\n        yIsZero := y == 0\n        result := 0.0\n        if !yIsZero {\n            result = float64(x) / float64(y)\n        }\n\n        // 调用模板对象的渲染方法\n        err = tmpl.Execute(w, map[string]interface{}{\n            \"yIsZero\": yIsZero,\n            \"result\":  result,\n        })\n        if err != nil {\n            fmt.Fprintf(w, \"Execute: %v\", err)\n            return\n        }\n    })\n\n    ...\n}\n```\n（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）\n\n以上代码的逻辑非常简单，即首先通过程序判断除数 y 是否为 0，然后将判断结果和可能的除法运算结果都赋值到 map 类型的根对象中。\n\n在模板中，我们需要将条件语句放置在 if 关键字之后，使用空格将它们分隔，并将整个语句使用分隔符 {{ 和 }} 进行包裹。需要注意的是，条件语句必须要返回一个布尔类型（bool）的值，本例中 yIsZero 变量自身即是 bool 类型的值，因此不需要再做额外的类型转换。\n\n尝试运行以上代码可以在终端获得以下结果：\n\n➜ curl http://localhost:4000?x=1&y=2\n0.5\n➜ curl http://localhost:4000?x=1&y=0\n除数不能为 0\n本例中展示的条件语句十分简单，但在实际开发过程中，if 语句通常会被大量使用，然后根据给定的条件判断渲染出不同的内容。\n\n模板中的等式与不等式\n如果所有的条件判断都只能在程序代码中完成，然后直接输出给模板计算好的条件，未免有点太不方便了。因此，Go 语言的文本模板引擎同样可以在模板中完成等式与不等式的判断，为更加复杂的条件判断提供了必要的支持。\n\n用于等式与不等式判断的函数主要有以下六种（均接受两个，分别名为 arg1 和 arg2 的参数）：\n\neq：当等式 arg1 == arg2 成立时，返回 true，否则返回 false\nne：当不等式 arg1 != arg2 成立时，返回 true，否则返回 false\nlt：当不等式 arg1 < arg2 成立时，返回 true，否则返回 false\nle：当不等式 arg1 <= arg2 成立时，返回 true，否则返回 false\ngt：当不等式 arg1 > arg2 成立时，返回 true，否则返回 false\nge：当不等式 arg1 >= arg2 成立时，返回 true，否则返回 false\n如果你对这些函数的名字感到奇怪，其实不难发现这些名字本质上就是相关英文的缩写。如 “eq” 是 “equal” 的缩写，”ne” 表示 “not equal”，”lt” 表示 “less than“，”le” 表示 “less than or equal” 等等。\n\n接下来，我们就结合目前所学的知识，将更多的判断逻辑放置到模板当中完成。\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"text/template\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`\n{{$name1 := \"alice\"}}\n{{$name2 := \"bob\"}}\n{{$age1 := 18}}\n{{$age2 := 23}}\n\n{{if eq $age1 $age2}}\n    年龄相同\n{{else}}\n    年龄不相同\n{{end}}\n\n{{if ne $name1 $name2}}\n    名字不相同\n{{end}}\n\n{{if gt $age1 $age2}}\n    alice 年龄比较大\n{{else}}\n    bob 年龄比较大\n{{end}}\n`)\n        if err != nil {\n            fmt.Fprintf(w, \"Parse: %v\", err)\n            return\n        }\n\n        // 调用模板对象的渲染方法\n        err = tmpl.Execute(w, nil)\n        if err != nil {\n            fmt.Fprintf(w, \"Execute: %v\", err)\n            return\n        }\n    })\n\n    log.Println(\"Starting HTTP server...\")\n    log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))\n}\n```\n在这个例子中，我们使用到了 eq、ne 和 gt 三个函数。尝试运行以上代码可以在终端获得以下结果：\n\n➜ curl http://localhost:4000\n年龄不相同\n名字不相同\nbob 年龄比较大\n你可能会对这个例子中 if 条件语句的用法感到怪异，这是因为 eq、ne 和 gt 等本质上属于函数，而函数的调用都是以 函数名称（参数 1，参数 2，...） 的形式，只是在大部分情况下，Go 语言标准库提供的这套模板引擎可以在语法上省略括号的使用。\n\n在模板中使用迭代操作（range 语句）\n除了可以在模板中进行条件判断以外，Go 语言标准库提供的模板引擎还支持通过 range 语句进行迭代操作，以方便直接在模板中对集合类型的数据进行处理和渲染。\n\nGo 语言中一般来说有三种类型可以进行迭代操作，数组（Array）、切片（Slice）和 map 类型。\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"text/template\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`\n{{range $name := .Names}}\n    {{$name}}\n{{end}}\n`)\n        if err != nil {\n            fmt.Fprintf(w, \"Parse: %v\", err)\n            return\n        }\n\n        // 调用模板对象的渲染方法\n        err = tmpl.Execute(w, map[string]interface{}{\n            \"Names\": []string{\n                \"Alice\",\n                \"Bob\",\n                \"Carol\",\n                \"David\",\n            },\n        })\n        if err != nil {\n            fmt.Fprintf(w, \"Execute: %v\", err)\n            return\n        }\n    })\n\n    log.Println(\"Starting HTTP server...\")\n    log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))\n}\n```\n上例中的代码作用非常简单，即先通过 map[string]interface{} 类型的根对象传递一个名为 “Names” 的切片，该切片包含了四个人名。然后通过模板的 range 语句对这个切片进行迭代，依次输出每个人名。\n\n值得注意的是，这里我们使用的语法结构为 range $name := .Names，其中 .Names 是被迭代的集合，而变量 $name 则是当次迭代中获取到的单个对象。在本例中，变量 $name 实际上为 string 类型。\n\n尝试运行以上代码可以在终端获得以下结果：\n\n➜ curl http://localhost:4000\nAlice\nBob\nCarol\nDavid\nrange 语句除了可以获取到当次迭代的对象以外，还能够和 Go 语言源代码中一样，获取到一个当前迭代所对应的索引值。\n```\n...\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`\n{{range $i, $name := .Names}}\n    {{$i}}. {{$name}}\n{{end}}\n`)\n\n...\n```\n（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）\n\n尝试运行以上代码可以在终端获得以下结果：\n\n➜ curl http://localhost:4000\n0. Alice\n1. Bob\n2. Carol\n3. David\n可以看到，通过使用语法结构 range $i, $name := .Names，我们可以再获取变量 $name 的同时获取变量 $i （索引）的值。\n\n就模板语法而言，迭代不同类型的集合是没有区别的，我们可以来看一下如何在模板中对 map 类型的集合进行迭代操作：\n```\n...\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`\n{{range $name, $val := .}}\n    {{$name}}: {{$val}}\n{{end}}\n`)\n\n        ...\n\n        // 调用模板对象的渲染方法\n        err = tmpl.Execute(w, map[string]interface{}{\n            \"Names\": []string{\n                \"Alice\",\n                \"Bob\",\n                \"Carol\",\n                \"David\",\n            },\n            \"Numbers\": []int{1, 3, 5, 7},\n        })\n\n        ...\n}\n```\n（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）\n\n尝试运行以上代码可以在终端获得以下结果：\n\n➜ curl http://localhost:4000\nNames: [Alice Bob Carol David]\nNumbers: [1 3 5 7]\n上例中，我们通过直接迭代作为根对象的 map，然后打印其中所包含的键值对。和迭代其它类型集合的唯一不同在于，语法结构 range $name, $val := . 获得到的第一个变量不再是索引，而是当次迭代所对应的键名。\n\n在模板中使用语境操作（with 语句）\n在学习如何使用语境操作（with 语句）之前，我们先来看一看下面的示例：\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"text/template\"\n)\n\ntype Inventory struct {\n    SKU       string\n    Name      string\n    UnitPrice float64\n    Quantity  int64\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`Inventory\nSKU: {{.Inventory.SKU}}\nName: {{.Inventory.Name}}\nUnitPrice: {{.Inventory.UnitPrice}}\nQuantity: {{.Inventory.Quantity}}\n`)\n        if err != nil {\n            fmt.Fprintf(w, \"Parse: %v\", err)\n            return\n        }\n\n        // 调用模板对象的渲染方法\n        err = tmpl.Execute(w, map[string]interface{}{\n            \"Inventory\": Inventory{\n                SKU:       \"11000\",\n                Name:      \"Phone\",\n                UnitPrice: 699.99,\n                Quantity:  666,\n            },\n        })\n        if err != nil {\n            fmt.Fprintf(w, \"Execute: %v\", err)\n            return\n        }\n    })\n\n    log.Println(\"Starting HTTP server...\")\n    log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))\n}\n```\n本例中，我们定义和创建了一个 Inventory 类型的对象，并将它放入对根对象中，关联键名为 “Inventory”。尝试运行以上代码可以在终端获得以下结果：\n\n➜ curl http://localhost:4000\nInventory\nSKU: 11000\nName: Phone\nUnitPrice: 699.99\nQuantity: 666\n这里我们要关注的并不是程序的运行结果，而是模板的内容：\n```\nInventory\nSKU: {{.Inventory.SKU}}\nName: {{.Inventory.Name}}\nUnitPrice: {{.Inventory.UnitPrice}}\nQuantity: {{.Inventory.Quantity}}\n```\n不难发现，为了能够渲染 “Inventory” 的每一个值，我们都需要先通过点操作获取根对象中键名为 “Inventory” 的对象，然后再通过第二次点操作才能获取到具体某个字段的值。\n\n在模板内容较少的情况下，这样的做法没有什么问题，但如果 “Inventory” 对象需要被使用非常多次数，或者甚至我们需要通过多次点操作才能获取到我们所要获得的值呢？例如：.Storage.Repository.Inventory。在这种情况下，模板的内容就会显得非常冗余。\n\n为了解决这个问题，就可以使用语境操作（with 语句）啦！学习使用过 Visual Basic 的同学可能会对 with 语句的用法和作用比较熟悉。\n```\n...\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`Inventory\n{{with .Inventory}}\n    SKU: {{.SKU}}\n    Name: {{.Name}}\n    UnitPrice: {{.UnitPrice}}\n    Quantity: {{.Quantity}}\n{{end}}\n`)\n\n...\n```\n（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）\n\n尝试运行以上代码可以得到和之前一模一样的运行结果。\n\n在使用了 with 语句之后，是不是觉得模板内容更加简洁易懂了呢？\n\n模板中的空白符号处理\n细心的你可能已经发现，在运行之前示例的时候，终端得到的响应实际上会带有多余的空行，例如：\n\n➜ curl http://localhost:4000\nInventory\n\n    SKU: 11000\n    Name: Phone\n    UnitPrice: 699.99\n    Quantity: 666\n这是因为我们在编写模板内容的时候，为了格式上的清晰加入了这些空行。如果我们想要更加整洁的输出结果的话，就可以使用 Go 语言标准库模板引擎的一个特殊语法，{{- 和 -}}。\n\n{{- 表示剔除模板内容左侧的所有空白符号，-}} 表示剔除模板内容右侧的所有空白符号。\n```\n...\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        // 创建模板对象并解析模板内容\n        tmpl, err := template.New(\"test\").Parse(`Inventory\n{{- with .Inventory}}\n    SKU: {{.SKU}}\n    Name: {{.Name}}\n    UnitPrice: {{.UnitPrice}}\n    Quantity: {{.Quantity}}\n{{- end}}\n`)\n\n...\n```\n（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）\n\n这里需要特别注意减号两侧的空格，如果没有使用空格将减号与模板中其它内容分开的话，会被模板引擎误以为是表达式的一部分。例如，使用 {{-with .Inventory}} 则会报如下错误：\n\nunexpected bad number syntax: \"-w\" in command  \n小结\n这节课，我们主要学习了标准库中 text/template 包提供的文本模板引擎的逻辑控制、集合对象迭代和空白符号处理的用法。\n\n下节课，我们将基于这节课所学的基础用法上，进一步学习如何在 Go 语言提供的模板引擎中使用自定义模板、模板函数和响应 HTML 内容。","slug":"第-03-课：进阶模板用法","published":1,"updated":"2019-11-11T09:59:07.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2uj8a4l00021idmeb9f7d7n","content":"<p>在模板中定义变量<br>变量不仅是 Go 语言中程序代码的重要组成部分，同样也是模板引擎中的主要元素。因为只有通过定义和操作变量，才能使得模板引擎在逻辑和用法上更加灵活和便利。</p>\n<p>text/template 包提供的文本模板引擎支持使用字母数字（Alphanumeric）作为变量的名称，并使用一个美元符号（$）作为前缀，例如：$name、$age 和 $round2。在模板中的定义语法和程序代码中类似，即使用 := 连接变量名和赋值语句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;text/template&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`</span><br><span class=\"line\">&#123;&#123;$name := &quot;Alice&quot;&#125;&#125;</span><br><span class=\"line\">&#123;&#123;$age := 18&#125;&#125;</span><br><span class=\"line\">&#123;&#123;$round2 := true&#125;&#125;</span><br><span class=\"line\">Name: &#123;&#123;$name&#125;&#125;</span><br><span class=\"line\">Age: &#123;&#123;$age&#125;&#125;</span><br><span class=\"line\">Round2: &#123;&#123;$round2&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Parse: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用模板对象的渲染方法</span><br><span class=\"line\">        err = tmpl.Execute(w, nil)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Execute: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>尝试运行以上代码可以在终端获得以下结果：</p>\n<p>➜ curl <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a><br>Name: Alice<br>Age: 18<br>Round2: true<br>不难发现，这个示例的核心就是包含变量使用的模板内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123;$name := &quot;Alice&quot;&#125;&#125;</span><br><span class=\"line\">&#123;&#123;$age := 18&#125;&#125;</span><br><span class=\"line\">&#123;&#123;$round2 := true&#125;&#125;</span><br><span class=\"line\">Name: &#123;&#123;$name&#125;&#125;</span><br><span class=\"line\">Age: &#123;&#123;$age&#125;&#125;</span><br><span class=\"line\">Round2: &#123;&#123;$round2&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们需要注意的是以下三点：</p>\n<p>变量的定义（或首次获得赋值）必须使用 := 的语法。<br>获取变量值时，直接在相应位置使用美元符号加上变量名称即可。<br>所有有关变量的操作都属于模板语法的一部分，因此需要使用双层大括号将其包裹起来。<br>那么，在变量被定义之后，如何修改变量的值呢？很简单，只需要和程序代码中那样，直接使用等号（=）即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`</span><br><span class=\"line\">&#123;&#123;$name := &quot;Alice&quot;&#125;&#125;</span><br><span class=\"line\">&#123;&#123;$age := 18&#125;&#125;</span><br><span class=\"line\">&#123;&#123;$round2 := true&#125;&#125;</span><br><span class=\"line\">Name: &#123;&#123;$name&#125;&#125;</span><br><span class=\"line\">Age: &#123;&#123;$age&#125;&#125;</span><br><span class=\"line\">Round2: &#123;&#123;$round2&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&#123;$name = &quot;Bob&quot;&#125;&#125;</span><br><span class=\"line\">Name: &#123;&#123;$name&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）</p>\n<p>尝试运行变动后的代码可以在终端获得以下结果：</p>\n<p>➜ curl <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a><br>Name: Alice<br>Age: 18<br>Round2: true<br>Name: Bob<br>感兴趣的同学可以尝试一下，如果重复使用 := 的语法给相同名称的变量多次赋值会发生什么呢？</p>\n<p>在模板中使用条件判断（if 语句）<br>标准库 text/template 包供的文本模板引擎除了可以进行单纯的数据展示外，还能够像程序代码那样进行基本的逻辑控制，而逻辑控制语句中最常见的便是 if 语句了。</p>\n<p>接下来，我们需要编写一个能够进行除法运算的 Web 服务，即通过 URL 查询参数接收两个值，分别为 x 和 y（被除数与除数），然后进行 x/y 的运算，再将运算结果返回给客户端。由于除法的特殊性，当 y 为 0 的时候是无法进行运算的。因此，我们需要在 y 等于 0 的时候提示客户端参数错误（利用模板的 if 语句）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &quot;strconv&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`</span><br><span class=\"line\">&#123;&#123;if .yIsZero&#125;&#125;</span><br><span class=\"line\">    除数不能为 0</span><br><span class=\"line\">&#123;&#123;else&#125;&#125;</span><br><span class=\"line\">    &#123;&#123;.result&#125;&#125;</span><br><span class=\"line\">&#123;&#123;end&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Parse: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 获取 URL 查询参数的值</span><br><span class=\"line\">        // 注意：为了简化代码逻辑，这里并没有进行错误处理</span><br><span class=\"line\">        x, _ := strconv.ParseInt(r.URL.Query().Get(&quot;x&quot;), 10, 64)</span><br><span class=\"line\">        y, _ := strconv.ParseInt(r.URL.Query().Get(&quot;y&quot;), 10, 64)</span><br><span class=\"line\"></span><br><span class=\"line\">        // 当 y 不为 0 时进行除法运算</span><br><span class=\"line\">        yIsZero := y == 0</span><br><span class=\"line\">        result := 0.0</span><br><span class=\"line\">        if !yIsZero &#123;</span><br><span class=\"line\">            result = float64(x) / float64(y)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用模板对象的渲染方法</span><br><span class=\"line\">        err = tmpl.Execute(w, map[string]interface&#123;&#125;&#123;</span><br><span class=\"line\">            &quot;yIsZero&quot;: yIsZero,</span><br><span class=\"line\">            &quot;result&quot;:  result,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Execute: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）</p>\n<p>以上代码的逻辑非常简单，即首先通过程序判断除数 y 是否为 0，然后将判断结果和可能的除法运算结果都赋值到 map 类型的根对象中。</p>\n<p>在模板中，我们需要将条件语句放置在 if 关键字之后，使用空格将它们分隔，并将整个语句使用分隔符  进行包裹。需要注意的是，条件语句必须要返回一个布尔类型（bool）的值，本例中 yIsZero 变量自身即是 bool 类型的值，因此不需要再做额外的类型转换。</p>\n<p>尝试运行以上代码可以在终端获得以下结果：</p>\n<p>➜ curl <a href=\"http://localhost:4000?x=1&amp;y=2\" target=\"_blank\" rel=\"noopener\">http://localhost:4000?x=1&amp;y=2</a><br>0.5<br>➜ curl <a href=\"http://localhost:4000?x=1&amp;y=0\" target=\"_blank\" rel=\"noopener\">http://localhost:4000?x=1&amp;y=0</a><br>除数不能为 0<br>本例中展示的条件语句十分简单，但在实际开发过程中，if 语句通常会被大量使用，然后根据给定的条件判断渲染出不同的内容。</p>\n<p>模板中的等式与不等式<br>如果所有的条件判断都只能在程序代码中完成，然后直接输出给模板计算好的条件，未免有点太不方便了。因此，Go 语言的文本模板引擎同样可以在模板中完成等式与不等式的判断，为更加复杂的条件判断提供了必要的支持。</p>\n<p>用于等式与不等式判断的函数主要有以下六种（均接受两个，分别名为 arg1 和 arg2 的参数）：</p>\n<p>eq：当等式 arg1 == arg2 成立时，返回 true，否则返回 false<br>ne：当不等式 arg1 != arg2 成立时，返回 true，否则返回 false<br>lt：当不等式 arg1 &lt; arg2 成立时，返回 true，否则返回 false<br>le：当不等式 arg1 &lt;= arg2 成立时，返回 true，否则返回 false<br>gt：当不等式 arg1 &gt; arg2 成立时，返回 true，否则返回 false<br>ge：当不等式 arg1 &gt;= arg2 成立时，返回 true，否则返回 false<br>如果你对这些函数的名字感到奇怪，其实不难发现这些名字本质上就是相关英文的缩写。如 “eq” 是 “equal” 的缩写，”ne” 表示 “not equal”，”lt” 表示 “less than“，”le” 表示 “less than or equal” 等等。</p>\n<p>接下来，我们就结合目前所学的知识，将更多的判断逻辑放置到模板当中完成。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;text/template&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`</span><br><span class=\"line\">&#123;&#123;$name1 := &quot;alice&quot;&#125;&#125;</span><br><span class=\"line\">&#123;&#123;$name2 := &quot;bob&quot;&#125;&#125;</span><br><span class=\"line\">&#123;&#123;$age1 := 18&#125;&#125;</span><br><span class=\"line\">&#123;&#123;$age2 := 23&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&#123;if eq $age1 $age2&#125;&#125;</span><br><span class=\"line\">    年龄相同</span><br><span class=\"line\">&#123;&#123;else&#125;&#125;</span><br><span class=\"line\">    年龄不相同</span><br><span class=\"line\">&#123;&#123;end&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&#123;if ne $name1 $name2&#125;&#125;</span><br><span class=\"line\">    名字不相同</span><br><span class=\"line\">&#123;&#123;end&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&#123;if gt $age1 $age2&#125;&#125;</span><br><span class=\"line\">    alice 年龄比较大</span><br><span class=\"line\">&#123;&#123;else&#125;&#125;</span><br><span class=\"line\">    bob 年龄比较大</span><br><span class=\"line\">&#123;&#123;end&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Parse: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用模板对象的渲染方法</span><br><span class=\"line\">        err = tmpl.Execute(w, nil)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Execute: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们使用到了 eq、ne 和 gt 三个函数。尝试运行以上代码可以在终端获得以下结果：</p>\n<p>➜ curl <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a><br>年龄不相同<br>名字不相同<br>bob 年龄比较大<br>你可能会对这个例子中 if 条件语句的用法感到怪异，这是因为 eq、ne 和 gt 等本质上属于函数，而函数的调用都是以 函数名称（参数 1，参数 2，…） 的形式，只是在大部分情况下，Go 语言标准库提供的这套模板引擎可以在语法上省略括号的使用。</p>\n<p>在模板中使用迭代操作（range 语句）<br>除了可以在模板中进行条件判断以外，Go 语言标准库提供的模板引擎还支持通过 range 语句进行迭代操作，以方便直接在模板中对集合类型的数据进行处理和渲染。</p>\n<p>Go 语言中一般来说有三种类型可以进行迭代操作，数组（Array）、切片（Slice）和 map 类型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;text/template&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`</span><br><span class=\"line\">&#123;&#123;range $name := .Names&#125;&#125;</span><br><span class=\"line\">    &#123;&#123;$name&#125;&#125;</span><br><span class=\"line\">&#123;&#123;end&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Parse: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用模板对象的渲染方法</span><br><span class=\"line\">        err = tmpl.Execute(w, map[string]interface&#123;&#125;&#123;</span><br><span class=\"line\">            &quot;Names&quot;: []string&#123;</span><br><span class=\"line\">                &quot;Alice&quot;,</span><br><span class=\"line\">                &quot;Bob&quot;,</span><br><span class=\"line\">                &quot;Carol&quot;,</span><br><span class=\"line\">                &quot;David&quot;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Execute: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上例中的代码作用非常简单，即先通过 map[string]interface{} 类型的根对象传递一个名为 “Names” 的切片，该切片包含了四个人名。然后通过模板的 range 语句对这个切片进行迭代，依次输出每个人名。</p>\n<p>值得注意的是，这里我们使用的语法结构为 range $name := .Names，其中 .Names 是被迭代的集合，而变量 $name 则是当次迭代中获取到的单个对象。在本例中，变量 $name 实际上为 string 类型。</p>\n<p>尝试运行以上代码可以在终端获得以下结果：</p>\n<p>➜ curl <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a><br>Alice<br>Bob<br>Carol<br>David<br>range 语句除了可以获取到当次迭代的对象以外，还能够和 Go 语言源代码中一样，获取到一个当前迭代所对应的索引值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`</span><br><span class=\"line\">&#123;&#123;range $i, $name := .Names&#125;&#125;</span><br><span class=\"line\">    &#123;&#123;$i&#125;&#125;. &#123;&#123;$name&#125;&#125;</span><br><span class=\"line\">&#123;&#123;end&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）</p>\n<p>尝试运行以上代码可以在终端获得以下结果：</p>\n<p>➜ curl <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a></p>\n<ol start=\"0\">\n<li>Alice</li>\n<li>Bob</li>\n<li>Carol</li>\n<li>David<br>可以看到，通过使用语法结构 range $i, $name := .Names，我们可以再获取变量 $name 的同时获取变量 $i （索引）的值。</li>\n</ol>\n<p>就模板语法而言，迭代不同类型的集合是没有区别的，我们可以来看一下如何在模板中对 map 类型的集合进行迭代操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`</span><br><span class=\"line\">&#123;&#123;range $name, $val := .&#125;&#125;</span><br><span class=\"line\">    &#123;&#123;$name&#125;&#125;: &#123;&#123;$val&#125;&#125;</span><br><span class=\"line\">&#123;&#123;end&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用模板对象的渲染方法</span><br><span class=\"line\">        err = tmpl.Execute(w, map[string]interface&#123;&#125;&#123;</span><br><span class=\"line\">            &quot;Names&quot;: []string&#123;</span><br><span class=\"line\">                &quot;Alice&quot;,</span><br><span class=\"line\">                &quot;Bob&quot;,</span><br><span class=\"line\">                &quot;Carol&quot;,</span><br><span class=\"line\">                &quot;David&quot;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &quot;Numbers&quot;: []int&#123;1, 3, 5, 7&#125;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）</p>\n<p>尝试运行以上代码可以在终端获得以下结果：</p>\n<p>➜ curl <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a><br>Names: [Alice Bob Carol David]<br>Numbers: [1 3 5 7]<br>上例中，我们通过直接迭代作为根对象的 map，然后打印其中所包含的键值对。和迭代其它类型集合的唯一不同在于，语法结构 range $name, $val := . 获得到的第一个变量不再是索引，而是当次迭代所对应的键名。</p>\n<p>在模板中使用语境操作（with 语句）<br>在学习如何使用语境操作（with 语句）之前，我们先来看一看下面的示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;text/template&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type Inventory struct &#123;</span><br><span class=\"line\">    SKU       string</span><br><span class=\"line\">    Name      string</span><br><span class=\"line\">    UnitPrice float64</span><br><span class=\"line\">    Quantity  int64</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`Inventory</span><br><span class=\"line\">SKU: &#123;&#123;.Inventory.SKU&#125;&#125;</span><br><span class=\"line\">Name: &#123;&#123;.Inventory.Name&#125;&#125;</span><br><span class=\"line\">UnitPrice: &#123;&#123;.Inventory.UnitPrice&#125;&#125;</span><br><span class=\"line\">Quantity: &#123;&#123;.Inventory.Quantity&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Parse: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用模板对象的渲染方法</span><br><span class=\"line\">        err = tmpl.Execute(w, map[string]interface&#123;&#125;&#123;</span><br><span class=\"line\">            &quot;Inventory&quot;: Inventory&#123;</span><br><span class=\"line\">                SKU:       &quot;11000&quot;,</span><br><span class=\"line\">                Name:      &quot;Phone&quot;,</span><br><span class=\"line\">                UnitPrice: 699.99,</span><br><span class=\"line\">                Quantity:  666,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Execute: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>本例中，我们定义和创建了一个 Inventory 类型的对象，并将它放入对根对象中，关联键名为 “Inventory”。尝试运行以上代码可以在终端获得以下结果：</p>\n<p>➜ curl <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a><br>Inventory<br>SKU: 11000<br>Name: Phone<br>UnitPrice: 699.99<br>Quantity: 666<br>这里我们要关注的并不是程序的运行结果，而是模板的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inventory</span><br><span class=\"line\">SKU: &#123;&#123;.Inventory.SKU&#125;&#125;</span><br><span class=\"line\">Name: &#123;&#123;.Inventory.Name&#125;&#125;</span><br><span class=\"line\">UnitPrice: &#123;&#123;.Inventory.UnitPrice&#125;&#125;</span><br><span class=\"line\">Quantity: &#123;&#123;.Inventory.Quantity&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不难发现，为了能够渲染 “Inventory” 的每一个值，我们都需要先通过点操作获取根对象中键名为 “Inventory” 的对象，然后再通过第二次点操作才能获取到具体某个字段的值。</p>\n<p>在模板内容较少的情况下，这样的做法没有什么问题，但如果 “Inventory” 对象需要被使用非常多次数，或者甚至我们需要通过多次点操作才能获取到我们所要获得的值呢？例如：.Storage.Repository.Inventory。在这种情况下，模板的内容就会显得非常冗余。</p>\n<p>为了解决这个问题，就可以使用语境操作（with 语句）啦！学习使用过 Visual Basic 的同学可能会对 with 语句的用法和作用比较熟悉。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`Inventory</span><br><span class=\"line\">&#123;&#123;with .Inventory&#125;&#125;</span><br><span class=\"line\">    SKU: &#123;&#123;.SKU&#125;&#125;</span><br><span class=\"line\">    Name: &#123;&#123;.Name&#125;&#125;</span><br><span class=\"line\">    UnitPrice: &#123;&#123;.UnitPrice&#125;&#125;</span><br><span class=\"line\">    Quantity: &#123;&#123;.Quantity&#125;&#125;</span><br><span class=\"line\">&#123;&#123;end&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）</p>\n<p>尝试运行以上代码可以得到和之前一模一样的运行结果。</p>\n<p>在使用了 with 语句之后，是不是觉得模板内容更加简洁易懂了呢？</p>\n<p>模板中的空白符号处理<br>细心的你可能已经发现，在运行之前示例的时候，终端得到的响应实际上会带有多余的空行，例如：</p>\n<p>➜ curl <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a><br>Inventory</p>\n<pre><code>SKU: 11000\nName: Phone\nUnitPrice: 699.99\nQuantity: 666</code></pre><p>这是因为我们在编写模板内容的时候，为了格式上的清晰加入了这些空行。如果我们想要更加整洁的输出结果的话，就可以使用 Go 语言标准库模板引擎的一个特殊语法，。</p>表示剔除模板内容右侧的所有空白符号。\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`Inventory</span><br><span class=\"line\">&#123;&#123;- with .Inventory&#125;&#125;</span><br><span class=\"line\">    SKU: &#123;&#123;.SKU&#125;&#125;</span><br><span class=\"line\">    Name: &#123;&#123;.Name&#125;&#125;</span><br><span class=\"line\">    UnitPrice: &#123;&#123;.UnitPrice&#125;&#125;</span><br><span class=\"line\">    Quantity: &#123;&#123;.Quantity&#125;&#125;</span><br><span class=\"line\">&#123;&#123;- end&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）</p>\n<p>这里需要特别注意减号两侧的空格，如果没有使用空格将减号与模板中其它内容分开的话，会被模板引擎误以为是表达式的一部分。例如，使用 则会报如下错误：</p>\n<p>unexpected bad number syntax: “-w” in command<br>小结<br>这节课，我们主要学习了标准库中 text/template 包提供的文本模板引擎的逻辑控制、集合对象迭代和空白符号处理的用法。</p>\n<p>下节课，我们将基于这节课所学的基础用法上，进一步学习如何在 Go 语言提供的模板引擎中使用自定义模板、模板函数和响应 HTML 内容。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在模板中定义变量<br>变量不仅是 Go 语言中程序代码的重要组成部分，同样也是模板引擎中的主要元素。因为只有通过定义和操作变量，才能使得模板引擎在逻辑和用法上更加灵活和便利。</p>\n<p>text/template 包提供的文本模板引擎支持使用字母数字（Alphanumeric）作为变量的名称，并使用一个美元符号（$）作为前缀，例如：$name、$age 和 $round2。在模板中的定义语法和程序代码中类似，即使用 := 连接变量名和赋值语句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;text/template&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`</span><br><span class=\"line\">&#123;&#123;$name := &quot;Alice&quot;&#125;&#125;</span><br><span class=\"line\">&#123;&#123;$age := 18&#125;&#125;</span><br><span class=\"line\">&#123;&#123;$round2 := true&#125;&#125;</span><br><span class=\"line\">Name: &#123;&#123;$name&#125;&#125;</span><br><span class=\"line\">Age: &#123;&#123;$age&#125;&#125;</span><br><span class=\"line\">Round2: &#123;&#123;$round2&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Parse: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用模板对象的渲染方法</span><br><span class=\"line\">        err = tmpl.Execute(w, nil)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Execute: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>尝试运行以上代码可以在终端获得以下结果：</p>\n<p>➜ curl <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a><br>Name: Alice<br>Age: 18<br>Round2: true<br>不难发现，这个示例的核心就是包含变量使用的模板内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123;$name := &quot;Alice&quot;&#125;&#125;</span><br><span class=\"line\">&#123;&#123;$age := 18&#125;&#125;</span><br><span class=\"line\">&#123;&#123;$round2 := true&#125;&#125;</span><br><span class=\"line\">Name: &#123;&#123;$name&#125;&#125;</span><br><span class=\"line\">Age: &#123;&#123;$age&#125;&#125;</span><br><span class=\"line\">Round2: &#123;&#123;$round2&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们需要注意的是以下三点：</p>\n<p>变量的定义（或首次获得赋值）必须使用 := 的语法。<br>获取变量值时，直接在相应位置使用美元符号加上变量名称即可。<br>所有有关变量的操作都属于模板语法的一部分，因此需要使用双层大括号将其包裹起来。<br>那么，在变量被定义之后，如何修改变量的值呢？很简单，只需要和程序代码中那样，直接使用等号（=）即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`</span><br><span class=\"line\">&#123;&#123;$name := &quot;Alice&quot;&#125;&#125;</span><br><span class=\"line\">&#123;&#123;$age := 18&#125;&#125;</span><br><span class=\"line\">&#123;&#123;$round2 := true&#125;&#125;</span><br><span class=\"line\">Name: &#123;&#123;$name&#125;&#125;</span><br><span class=\"line\">Age: &#123;&#123;$age&#125;&#125;</span><br><span class=\"line\">Round2: &#123;&#123;$round2&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&#123;$name = &quot;Bob&quot;&#125;&#125;</span><br><span class=\"line\">Name: &#123;&#123;$name&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）</p>\n<p>尝试运行变动后的代码可以在终端获得以下结果：</p>\n<p>➜ curl <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a><br>Name: Alice<br>Age: 18<br>Round2: true<br>Name: Bob<br>感兴趣的同学可以尝试一下，如果重复使用 := 的语法给相同名称的变量多次赋值会发生什么呢？</p>\n<p>在模板中使用条件判断（if 语句）<br>标准库 text/template 包供的文本模板引擎除了可以进行单纯的数据展示外，还能够像程序代码那样进行基本的逻辑控制，而逻辑控制语句中最常见的便是 if 语句了。</p>\n<p>接下来，我们需要编写一个能够进行除法运算的 Web 服务，即通过 URL 查询参数接收两个值，分别为 x 和 y（被除数与除数），然后进行 x/y 的运算，再将运算结果返回给客户端。由于除法的特殊性，当 y 为 0 的时候是无法进行运算的。因此，我们需要在 y 等于 0 的时候提示客户端参数错误（利用模板的 if 语句）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &quot;strconv&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`</span><br><span class=\"line\">&#123;&#123;if .yIsZero&#125;&#125;</span><br><span class=\"line\">    除数不能为 0</span><br><span class=\"line\">&#123;&#123;else&#125;&#125;</span><br><span class=\"line\">    &#123;&#123;.result&#125;&#125;</span><br><span class=\"line\">&#123;&#123;end&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Parse: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 获取 URL 查询参数的值</span><br><span class=\"line\">        // 注意：为了简化代码逻辑，这里并没有进行错误处理</span><br><span class=\"line\">        x, _ := strconv.ParseInt(r.URL.Query().Get(&quot;x&quot;), 10, 64)</span><br><span class=\"line\">        y, _ := strconv.ParseInt(r.URL.Query().Get(&quot;y&quot;), 10, 64)</span><br><span class=\"line\"></span><br><span class=\"line\">        // 当 y 不为 0 时进行除法运算</span><br><span class=\"line\">        yIsZero := y == 0</span><br><span class=\"line\">        result := 0.0</span><br><span class=\"line\">        if !yIsZero &#123;</span><br><span class=\"line\">            result = float64(x) / float64(y)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用模板对象的渲染方法</span><br><span class=\"line\">        err = tmpl.Execute(w, map[string]interface&#123;&#125;&#123;</span><br><span class=\"line\">            &quot;yIsZero&quot;: yIsZero,</span><br><span class=\"line\">            &quot;result&quot;:  result,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Execute: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）</p>\n<p>以上代码的逻辑非常简单，即首先通过程序判断除数 y 是否为 0，然后将判断结果和可能的除法运算结果都赋值到 map 类型的根对象中。</p>\n<p>在模板中，我们需要将条件语句放置在 if 关键字之后，使用空格将它们分隔，并将整个语句使用分隔符  进行包裹。需要注意的是，条件语句必须要返回一个布尔类型（bool）的值，本例中 yIsZero 变量自身即是 bool 类型的值，因此不需要再做额外的类型转换。</p>\n<p>尝试运行以上代码可以在终端获得以下结果：</p>\n<p>➜ curl <a href=\"http://localhost:4000?x=1&amp;y=2\" target=\"_blank\" rel=\"noopener\">http://localhost:4000?x=1&amp;y=2</a><br>0.5<br>➜ curl <a href=\"http://localhost:4000?x=1&amp;y=0\" target=\"_blank\" rel=\"noopener\">http://localhost:4000?x=1&amp;y=0</a><br>除数不能为 0<br>本例中展示的条件语句十分简单，但在实际开发过程中，if 语句通常会被大量使用，然后根据给定的条件判断渲染出不同的内容。</p>\n<p>模板中的等式与不等式<br>如果所有的条件判断都只能在程序代码中完成，然后直接输出给模板计算好的条件，未免有点太不方便了。因此，Go 语言的文本模板引擎同样可以在模板中完成等式与不等式的判断，为更加复杂的条件判断提供了必要的支持。</p>\n<p>用于等式与不等式判断的函数主要有以下六种（均接受两个，分别名为 arg1 和 arg2 的参数）：</p>\n<p>eq：当等式 arg1 == arg2 成立时，返回 true，否则返回 false<br>ne：当不等式 arg1 != arg2 成立时，返回 true，否则返回 false<br>lt：当不等式 arg1 &lt; arg2 成立时，返回 true，否则返回 false<br>le：当不等式 arg1 &lt;= arg2 成立时，返回 true，否则返回 false<br>gt：当不等式 arg1 &gt; arg2 成立时，返回 true，否则返回 false<br>ge：当不等式 arg1 &gt;= arg2 成立时，返回 true，否则返回 false<br>如果你对这些函数的名字感到奇怪，其实不难发现这些名字本质上就是相关英文的缩写。如 “eq” 是 “equal” 的缩写，”ne” 表示 “not equal”，”lt” 表示 “less than“，”le” 表示 “less than or equal” 等等。</p>\n<p>接下来，我们就结合目前所学的知识，将更多的判断逻辑放置到模板当中完成。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;text/template&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`</span><br><span class=\"line\">&#123;&#123;$name1 := &quot;alice&quot;&#125;&#125;</span><br><span class=\"line\">&#123;&#123;$name2 := &quot;bob&quot;&#125;&#125;</span><br><span class=\"line\">&#123;&#123;$age1 := 18&#125;&#125;</span><br><span class=\"line\">&#123;&#123;$age2 := 23&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&#123;if eq $age1 $age2&#125;&#125;</span><br><span class=\"line\">    年龄相同</span><br><span class=\"line\">&#123;&#123;else&#125;&#125;</span><br><span class=\"line\">    年龄不相同</span><br><span class=\"line\">&#123;&#123;end&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&#123;if ne $name1 $name2&#125;&#125;</span><br><span class=\"line\">    名字不相同</span><br><span class=\"line\">&#123;&#123;end&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&#123;if gt $age1 $age2&#125;&#125;</span><br><span class=\"line\">    alice 年龄比较大</span><br><span class=\"line\">&#123;&#123;else&#125;&#125;</span><br><span class=\"line\">    bob 年龄比较大</span><br><span class=\"line\">&#123;&#123;end&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Parse: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用模板对象的渲染方法</span><br><span class=\"line\">        err = tmpl.Execute(w, nil)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Execute: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们使用到了 eq、ne 和 gt 三个函数。尝试运行以上代码可以在终端获得以下结果：</p>\n<p>➜ curl <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a><br>年龄不相同<br>名字不相同<br>bob 年龄比较大<br>你可能会对这个例子中 if 条件语句的用法感到怪异，这是因为 eq、ne 和 gt 等本质上属于函数，而函数的调用都是以 函数名称（参数 1，参数 2，…） 的形式，只是在大部分情况下，Go 语言标准库提供的这套模板引擎可以在语法上省略括号的使用。</p>\n<p>在模板中使用迭代操作（range 语句）<br>除了可以在模板中进行条件判断以外，Go 语言标准库提供的模板引擎还支持通过 range 语句进行迭代操作，以方便直接在模板中对集合类型的数据进行处理和渲染。</p>\n<p>Go 语言中一般来说有三种类型可以进行迭代操作，数组（Array）、切片（Slice）和 map 类型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;text/template&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`</span><br><span class=\"line\">&#123;&#123;range $name := .Names&#125;&#125;</span><br><span class=\"line\">    &#123;&#123;$name&#125;&#125;</span><br><span class=\"line\">&#123;&#123;end&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Parse: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用模板对象的渲染方法</span><br><span class=\"line\">        err = tmpl.Execute(w, map[string]interface&#123;&#125;&#123;</span><br><span class=\"line\">            &quot;Names&quot;: []string&#123;</span><br><span class=\"line\">                &quot;Alice&quot;,</span><br><span class=\"line\">                &quot;Bob&quot;,</span><br><span class=\"line\">                &quot;Carol&quot;,</span><br><span class=\"line\">                &quot;David&quot;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Execute: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上例中的代码作用非常简单，即先通过 map[string]interface{} 类型的根对象传递一个名为 “Names” 的切片，该切片包含了四个人名。然后通过模板的 range 语句对这个切片进行迭代，依次输出每个人名。</p>\n<p>值得注意的是，这里我们使用的语法结构为 range $name := .Names，其中 .Names 是被迭代的集合，而变量 $name 则是当次迭代中获取到的单个对象。在本例中，变量 $name 实际上为 string 类型。</p>\n<p>尝试运行以上代码可以在终端获得以下结果：</p>\n<p>➜ curl <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a><br>Alice<br>Bob<br>Carol<br>David<br>range 语句除了可以获取到当次迭代的对象以外，还能够和 Go 语言源代码中一样，获取到一个当前迭代所对应的索引值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`</span><br><span class=\"line\">&#123;&#123;range $i, $name := .Names&#125;&#125;</span><br><span class=\"line\">    &#123;&#123;$i&#125;&#125;. &#123;&#123;$name&#125;&#125;</span><br><span class=\"line\">&#123;&#123;end&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）</p>\n<p>尝试运行以上代码可以在终端获得以下结果：</p>\n<p>➜ curl <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a></p>\n<ol start=\"0\">\n<li>Alice</li>\n<li>Bob</li>\n<li>Carol</li>\n<li>David<br>可以看到，通过使用语法结构 range $i, $name := .Names，我们可以再获取变量 $name 的同时获取变量 $i （索引）的值。</li>\n</ol>\n<p>就模板语法而言，迭代不同类型的集合是没有区别的，我们可以来看一下如何在模板中对 map 类型的集合进行迭代操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`</span><br><span class=\"line\">&#123;&#123;range $name, $val := .&#125;&#125;</span><br><span class=\"line\">    &#123;&#123;$name&#125;&#125;: &#123;&#123;$val&#125;&#125;</span><br><span class=\"line\">&#123;&#123;end&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用模板对象的渲染方法</span><br><span class=\"line\">        err = tmpl.Execute(w, map[string]interface&#123;&#125;&#123;</span><br><span class=\"line\">            &quot;Names&quot;: []string&#123;</span><br><span class=\"line\">                &quot;Alice&quot;,</span><br><span class=\"line\">                &quot;Bob&quot;,</span><br><span class=\"line\">                &quot;Carol&quot;,</span><br><span class=\"line\">                &quot;David&quot;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &quot;Numbers&quot;: []int&#123;1, 3, 5, 7&#125;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）</p>\n<p>尝试运行以上代码可以在终端获得以下结果：</p>\n<p>➜ curl <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a><br>Names: [Alice Bob Carol David]<br>Numbers: [1 3 5 7]<br>上例中，我们通过直接迭代作为根对象的 map，然后打印其中所包含的键值对。和迭代其它类型集合的唯一不同在于，语法结构 range $name, $val := . 获得到的第一个变量不再是索引，而是当次迭代所对应的键名。</p>\n<p>在模板中使用语境操作（with 语句）<br>在学习如何使用语境操作（with 语句）之前，我们先来看一看下面的示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;text/template&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type Inventory struct &#123;</span><br><span class=\"line\">    SKU       string</span><br><span class=\"line\">    Name      string</span><br><span class=\"line\">    UnitPrice float64</span><br><span class=\"line\">    Quantity  int64</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`Inventory</span><br><span class=\"line\">SKU: &#123;&#123;.Inventory.SKU&#125;&#125;</span><br><span class=\"line\">Name: &#123;&#123;.Inventory.Name&#125;&#125;</span><br><span class=\"line\">UnitPrice: &#123;&#123;.Inventory.UnitPrice&#125;&#125;</span><br><span class=\"line\">Quantity: &#123;&#123;.Inventory.Quantity&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Parse: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 调用模板对象的渲染方法</span><br><span class=\"line\">        err = tmpl.Execute(w, map[string]interface&#123;&#125;&#123;</span><br><span class=\"line\">            &quot;Inventory&quot;: Inventory&#123;</span><br><span class=\"line\">                SKU:       &quot;11000&quot;,</span><br><span class=\"line\">                Name:      &quot;Phone&quot;,</span><br><span class=\"line\">                UnitPrice: 699.99,</span><br><span class=\"line\">                Quantity:  666,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, &quot;Execute: %v&quot;, err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Println(&quot;Starting HTTP server...&quot;)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(&quot;localhost:4000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>本例中，我们定义和创建了一个 Inventory 类型的对象，并将它放入对根对象中，关联键名为 “Inventory”。尝试运行以上代码可以在终端获得以下结果：</p>\n<p>➜ curl <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a><br>Inventory<br>SKU: 11000<br>Name: Phone<br>UnitPrice: 699.99<br>Quantity: 666<br>这里我们要关注的并不是程序的运行结果，而是模板的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inventory</span><br><span class=\"line\">SKU: &#123;&#123;.Inventory.SKU&#125;&#125;</span><br><span class=\"line\">Name: &#123;&#123;.Inventory.Name&#125;&#125;</span><br><span class=\"line\">UnitPrice: &#123;&#123;.Inventory.UnitPrice&#125;&#125;</span><br><span class=\"line\">Quantity: &#123;&#123;.Inventory.Quantity&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不难发现，为了能够渲染 “Inventory” 的每一个值，我们都需要先通过点操作获取根对象中键名为 “Inventory” 的对象，然后再通过第二次点操作才能获取到具体某个字段的值。</p>\n<p>在模板内容较少的情况下，这样的做法没有什么问题，但如果 “Inventory” 对象需要被使用非常多次数，或者甚至我们需要通过多次点操作才能获取到我们所要获得的值呢？例如：.Storage.Repository.Inventory。在这种情况下，模板的内容就会显得非常冗余。</p>\n<p>为了解决这个问题，就可以使用语境操作（with 语句）啦！学习使用过 Visual Basic 的同学可能会对 with 语句的用法和作用比较熟悉。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`Inventory</span><br><span class=\"line\">&#123;&#123;with .Inventory&#125;&#125;</span><br><span class=\"line\">    SKU: &#123;&#123;.SKU&#125;&#125;</span><br><span class=\"line\">    Name: &#123;&#123;.Name&#125;&#125;</span><br><span class=\"line\">    UnitPrice: &#123;&#123;.UnitPrice&#125;&#125;</span><br><span class=\"line\">    Quantity: &#123;&#123;.Quantity&#125;&#125;</span><br><span class=\"line\">&#123;&#123;end&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）</p>\n<p>尝试运行以上代码可以得到和之前一模一样的运行结果。</p>\n<p>在使用了 with 语句之后，是不是觉得模板内容更加简洁易懂了呢？</p>\n<p>模板中的空白符号处理<br>细心的你可能已经发现，在运行之前示例的时候，终端得到的响应实际上会带有多余的空行，例如：</p>\n<p>➜ curl <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a><br>Inventory</p>\n<pre><code>SKU: 11000\nName: Phone\nUnitPrice: 699.99\nQuantity: 666</code></pre><p>这是因为我们在编写模板内容的时候，为了格式上的清晰加入了这些空行。如果我们想要更加整洁的输出结果的话，就可以使用 Go 语言标准库模板引擎的一个特殊语法，。</p>表示剔除模板内容右侧的所有空白符号。\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 创建模板对象并解析模板内容</span><br><span class=\"line\">        tmpl, err := template.New(&quot;test&quot;).Parse(`Inventory</span><br><span class=\"line\">&#123;&#123;- with .Inventory&#125;&#125;</span><br><span class=\"line\">    SKU: &#123;&#123;.SKU&#125;&#125;</span><br><span class=\"line\">    Name: &#123;&#123;.Name&#125;&#125;</span><br><span class=\"line\">    UnitPrice: &#123;&#123;.UnitPrice&#125;&#125;</span><br><span class=\"line\">    Quantity: &#123;&#123;.Quantity&#125;&#125;</span><br><span class=\"line\">&#123;&#123;- end&#125;&#125;</span><br><span class=\"line\">`)</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>（为了缩减篇幅并更好地专注于有变动的部分，部分未改动的代码块使用了 “…” 进行替代。）</p>\n<p>这里需要特别注意减号两侧的空格，如果没有使用空格将减号与模板中其它内容分开的话，会被模板引擎误以为是表达式的一部分。例如，使用 则会报如下错误：</p>\n<p>unexpected bad number syntax: “-w” in command<br>小结<br>这节课，我们主要学习了标准库中 text/template 包提供的文本模板引擎的逻辑控制、集合对象迭代和空白符号处理的用法。</p>\n<p>下节课，我们将基于这节课所学的基础用法上，进一步学习如何在 Go 语言提供的模板引擎中使用自定义模板、模板函数和响应 HTML 内容。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}