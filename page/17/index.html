<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>知识铺</title><meta property="og:type" content="blog"><meta property="og:title" content="知识铺"><meta property="og:url" content="https://zshipu.com/"><meta property="og:site_name" content="知识铺"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zshipu.com/img/og_image.png"><meta property="article:author" content="edwin"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zshipu.com"},"headline":"知识铺","image":["https://zshipu.com/img/og_image.png"],"author":{"@type":"Person","name":"edwin"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script data-ad-client="2183476622" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="generator" content="Hexo 5.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="知识铺" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-03-22T08:45:58.000Z" title="2020-03-22T08:45:58.000Z">2020-03-22</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.420Z" title="2020-09-08T14:03:00.420Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">9 分钟读完 (大约1330个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/03/22/WebRTC%E7%B3%BB%E5%88%97%EF%BC%9AgetUserMedia-API%E5%8F%8AHTML5-%E8%B0%83%E7%94%A8%E6%89%8B%E6%9C%BA%E6%91%84%E5%83%8F%E5%A4%B4%E6%8B%8D%E7%85%A7/">WebRTC系列：getUserMedia API及HTML5 调用手机摄像头拍照</a></h1><div class="content"><h2 id="getUserMedia-API简介"><a href="#getUserMedia-API简介" class="headerlink" title="getUserMedia API简介"></a>getUserMedia API简介</h2><p>HTML5的<strong>getUserMedia API</strong>为用户提供访问硬件设备媒体（摄像头、视频、音频、地理位置等）的接口，基于该接口，开发者可以在不依赖任何浏览器插件的条件下访问硬件媒体设备。<br>getUserMedia API最初是<code>navigator.getUserMedia</code>，目前已被最新Web标准废除，变更为<code>navigator.mediaDevices.getUserMedia（）</code>，但浏览器支持情况不如旧版API普及。<br><code>MediaDevices.getUserMedia（）</code>方法提示用户允许使用一个视频和/或一个音频输入设备，例如相机或屏幕共享和/或麦克风。如果用户给予许可，就返回一个<code>Promise</code>对象，<code>MediaStream</code>对象作为此<code>Promise</code>对象的<code>Resolved</code>［成功］状态的回调函数参数，相应的，如果用户拒绝了许可，或者没有媒体可用的情况下<code>PermissionDeniedError</code>或者<code>NotFoundError</code>作为此<code>Promise</code>的<code>Rejected</code>［失败］状态的回调函数参数。注意，由于用户不会被要求必须作出允许或者拒绝的选择，所以返回的<code>Promise</code>对象可能既不会触发<code>resolve</code>也不会触发 <code>reject</code>。</p>
<h2 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h2><p><img src="https://blog.zshipu.com/tlg/images/pasted-82.png" alt="知识铺-pasted-82.png"></p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>navigator.mediaDevices.getUserMedia(constraints)<br>.then(function(mediaStream) &#123; ... &#125;)<br>.catch(function(error) &#123; ... &#125;)</code> </p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>**<code>containers：</code>**指定请求的媒体类型，主要包含<code>video</code>和<code>audio</code>，必须至少一个类型或者两个同时可以被指定。如果浏览器无法找到指定的媒体类型或者无法满足相对应的参数要求，那么返回的<code>Promise</code>对象就会处于<code>rejected</code>［失败］状态，<code>NotFoundError</code>作为<code>rejected</code>［失败］回调的参数。</p>
<p><em>【例】同时请求不带任何参数的音频和视频：</em></p>
<p> <code>&#123; audio: true, video: true &#125;</code> </p>
<p><em>【例】使用1280x720的摄像头分辨率：</em></p>
<p><code>&#123;<br> audio: true,<br> video: &#123; width: 1280, height: 720 &#125;<br>&#125;</code> </p>
<p><em>【例】要求获取最低为1280x720的分辨率：</em></p>
<p><code>&#123;<br> audio: true,<br> video: &#123;<br> width: &#123; min: 1024, ideal: 1280, max: 1920 &#125;,<br> height: &#123; min: 776, ideal: 720, max: 1080 &#125;<br>  &#125;<br>&#125;</code> </p>
<p>当请求包含一个**<code>ideal</code>**（应用最理想的）值时，这个值有着更高的权重，意味着浏览器会先尝试找到最接近指定的理想值的设定或者摄像头（如果设备拥有不止一个摄像头）。</p>
<p><em>【例】优先使用前置摄像头（如果有的话）：</em></p>
<p><code>&#123; audio: true, video: &#123; facingMode: "user" &#125; &#125;</code> </p>
<p><em>【例】强制使用后置摄像头：</em></p>
<p><code>&#123; audio: true, video: &#123; facingMode: &#123; exact: "environment" &#125; &#125; &#125;</code> </p>
<hr>
<p>成功回调函数<code>seccessCallback</code>的参数**<code>stream</code>**：<code>stream</code>是<code>MediaStream</code>的对象，表示媒体内容的数据流，可以通过<code>URL.createObjectURL</code>转换后设置为<code>Video</code>或<code>Audio</code>元素的<code>src</code>属性来使用，部分较新的浏览器也可以直接设置为<code>srcObject</code>属性来使用。</p>
<hr>
<p>失败回调函数<code>errorCallback</code>的参数**<code>error</code>**，可能的异常有：</p>
<ul>
<li><code>AbortError</code>：硬件问题</li>
<li><code>NotAllowedError</code>：用户拒绝了当前的浏览器实例的访问请求；或者用户拒绝了当前会话的访问；或者用户在全局范围内拒绝了所有媒体访问请求。</li>
<li><code>NotFoundError</code>：找不到满足请求参数的媒体类型。</li>
<li><code>NotReadableError</code>：操作系统上某个硬件、浏览器或者网页层面发生的错误导致设备无法被访问。</li>
<li><code>OverConstrainedError</code>：指定的要求无法被设备满足。</li>
<li><code>SecurityError</code>：安全错误，在<code>getUserMedia()</code> 被调用的 <code>Document</code><br>上面，使用设备媒体被禁止。这个机制是否开启或者关闭取决于单个用户的偏好设置。</li>
<li><code>TypeError</code>：类型错误，<code>constraints</code>对象未设置［空］，或者都被设置为<code>false</code>。</li>
</ul>
<h2 id="示例：HTML-5调用媒体设备摄像头"><a href="#示例：HTML-5调用媒体设备摄像头" class="headerlink" title="示例：HTML 5调用媒体设备摄像头"></a>示例：HTML 5调用媒体设备摄像头</h2><p>这个例子中，请求访问用户硬件设备的摄像头，并把视频流通过Video元素显示出来。网页中提供一个”拍照”的按钮，通过Canvas将Video的画面截取并绘制，核心代码如下：</p>
<p><strong>HTML</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--video用于显示媒体设备的视频流，自动播放--&gt;</span><br><span class="line">&lt;video id&#x3D;&quot;video&quot; autoplay style&#x3D;&quot;width: 480px;height: 320px&quot;&gt;&lt;&#x2F;video&gt;</span><br><span class="line">&lt;!--拍照按钮--&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;button id&#x3D;&quot;capture&quot;&gt;拍照&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;!--描绘video截图--&gt;</span><br><span class="line">&lt;canvas id&#x3D;&quot;canvas&quot; width&#x3D;&quot;480&quot; height&#x3D;&quot;320&quot;&gt;&lt;&#x2F;canvas&gt;</span><br></pre></td></tr></table></figure>

<p><strong>JavaScript</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F;访问用户媒体设备的兼容方法</span><br><span class="line">function getUserMedia(constrains,success,error)&#123;</span><br><span class="line">    if(navigator.mediaDevices.getUserMedia)&#123;</span><br><span class="line">        &#x2F;&#x2F;最新标准API</span><br><span class="line">        navigator.mediaDevices.getUserMedia(constrains).then(success).catch(error);</span><br><span class="line">    &#125; else if (navigator.webkitGetUserMedia)&#123;</span><br><span class="line">        &#x2F;&#x2F;webkit内核浏览器</span><br><span class="line">        navigator.webkitGetUserMedia(constrains).then(success).catch(error);</span><br><span class="line">    &#125; else if (navigator.mozGetUserMedia)&#123;</span><br><span class="line">        &#x2F;&#x2F;Firefox浏览器</span><br><span class="line">        navagator.mozGetUserMedia(constrains).then(success).catch(error);</span><br><span class="line">    &#125; else if (navigator.getUserMedia)&#123;</span><br><span class="line">        &#x2F;&#x2F;旧版API</span><br><span class="line">        navigator.getUserMedia(constrains).then(success).catch(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var video &#x3D; document.getElementById(&quot;video&quot;);</span><br><span class="line">var canvas &#x3D; document.getElementById(&quot;canvas&quot;);</span><br><span class="line">var context &#x3D; canvas.getContext(&quot;2d&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;成功的回调函数</span><br><span class="line">function success(stream)&#123;</span><br><span class="line">    &#x2F;&#x2F;兼容webkit内核浏览器</span><br><span class="line">    var CompatibleURL &#x3D; window.URL || window.webkitURL;</span><br><span class="line">    &#x2F;&#x2F;将视频流设置为video元素的源</span><br><span class="line">    video.src &#x3D; CompatibleURL.createObjectURL(stream);</span><br><span class="line">    &#x2F;&#x2F;播放视频</span><br><span class="line">    video.play();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;异常的回调函数</span><br><span class="line">function error(error)&#123;</span><br><span class="line">    console.log(&quot;访问用户媒体设备失败：&quot;,error.name,error.message);</span><br><span class="line">&#125;</span><br><span class="line">if (navigator.mediaDevices.getUserMedia || navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia)&#123;</span><br><span class="line">    &#x2F;&#x2F;调用用户媒体设备，访问摄像头</span><br><span class="line">    getUserMedia(&#123;</span><br><span class="line">        video:&#123;width:480,height:320&#125;</span><br><span class="line">    &#125;,success,error);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&quot;你的浏览器不支持访问用户媒体设备&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册拍照按钮的单击事件</span><br><span class="line">document.getElementById(&quot;capture&quot;).addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line">    &#x2F;&#x2F;绘制画面</span><br><span class="line">    context.drawImage(video,0,0,480,320);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>对本示例进行功能加强，比如使用CSS 3 的滤镜实现模糊、黑白等效果。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-03-22T08:11:45.000Z" title="2020-03-22T08:11:45.000Z">2020-03-22</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.419Z" title="2020-09-08T14:03:00.419Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">44 分钟读完 (大约6612个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/03/22/WebRTC%E7%B3%BB%E5%88%97%EF%BC%9AWebRTC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%80/">WebRTC系列：WebRTC基础学习之一</a></h1><div class="content"><p><strong>1无插件的实时通讯</strong></p>
<p>想象一下，如果你的手机、电视、电脑都可以通过一个平台进行通信，想象一下，你可以在Web应用中轻松地加入视频聊天和p2p数据分享，这就是WebRTC的愿景。</p>
<p>想试一试吗？WebRTC现在已经被集成到Chrome、Opera和Firefox，在apprtc.appspot.com有个简单的视频聊天应用可供测试。</p>
<p>1.在Chrome、Opera或Firefox中打开apprtc.appspot.com。</p>
<p>2.点击允许按钮允许应用启用你的摄像头。</p>
<p>3.在新的选项卡中打开页面底部显示的URL，当然能在另外一台电脑上打开该URL会更好。</p>
<p>关于这个应用的具体教程详见“一个简单的视频聊天客户端”章节。</p>
<p><strong>2快速开始</strong></p>
<p>如果你没有时间阅读这篇文章，想直接编码，你可以这样：</p>
<p>1.看一看Gooogle关于WebRTC的幻灯片（here)。</p>
<p>2.你果你没有用过getUserMedia，要先学习一下它，教程：HTML5 Rocks article，例子：simpl.info/gum。</p>
<p>3.掌握RTCPeerConnection API，教程：本文的代码段，例子：simpl.info/pc，这个例子在一个单独的网页中实现了WebRTC。</p>
<p>4.了解一下WebRTC信令服务、防火墙和NAT转发，教程：apprtc.appspot.com。</p>
<p>5.实在等不及了，可以通过这20+ demos练习WebRTC的Java API。</p>
<p>6.如果有什么问题，可以试试问题帮助页面test.webrtc.org。</p>
<p>或者你可以直接跳到这一步：在WebRTC codelab上一步一步的学习如何构建一个完整的视频聊天应用程序，包括一个简单的信令服务器。</p>
<p><strong>3关于WebRTC的小故事无插件的实时通讯</strong></p>
<p>其实一个Web开发的终极挑战就是通过音频和视频进行实时通信，视频通信应该像文本通信一样自然，如果没有它，我们在用户交互方面的创新能力会受到限制。</p>
<p>在过去，实时通信都比较复杂，需要非常丰富的音频和视频技术才能进行开发。 完整的实现实时通信需要整合大量的数据和服务，在Web上实现尤其困难。</p>
<p>2008年，Gmail视频聊天火了。2011年谷歌发布了Hangouts，收购了GIPS，GIPS为RTC开发了许多组件，比如编码和回声消除技术。谷歌开源了GIPS的相关技术，并且与IETF和W3C等标准化组织达成了行业共识。2011年5月爱立信构建了第一个WebRTC应用。</p>
<p>WebRTC目前实现了实时、无插件的音频、视频和数据通信，我们迫切需要它，因为：</p>
<p>1.许多web service在使用RTC，但是需要下载原生app或者插件，比如Skype、Facebook和谷歌Hangouts。</p>
<p>2.下载、安装和升级插件非常繁琐，而且容易出错。</p>
<p>3.插件不容易发现问题，测试很困难，大部分都需要授权，开发成本太高。</p>
<p>WebRTC项目的宗旨是：API是开源、免费的、标准的、可内建于浏览器且比其他现存的技术更加高效。</p>
<p><strong>4WebRTC使用现状</strong></p>
<p>目前WhatsAPP、Facebook Messenger等应用都使用了WebRTC，不仅如此WebRTC还出现在其他平台中，比如TokBox。WebRTC可以被整合到WebKitGTK+或者Qt原生应用中。</p>
<p>WebRTC实现了下列三个API：</p>
<p>1.MediaStream (别名getUserMedia)</p>
<p>2.RTCPeerConnection</p>
<p>3.RTCDataChannel</p>
<p>getUserMedia可用于Chrome、Opera、Firefox和Edge。你可以看看这个跨浏览器的demo和Chris Wilson的amazing examples，这些例子使用getUserMedia作为音频的输入。</p>
<p>RTCPeerConnection可用于Chrome、Opera和Firefox。经过几次迭代之后</p>
<p>RTCPeerConnection被Chrome和Opera实现为webkitRTCPeerConnection，被Firefox实现为mozRTCPeerConnection。其他的实现已经被废弃。当标准化进程稳定之后，这两个实现名字的前缀会被移除。Chromium的一个超级简单的RTCPeerConnection实现在GitHub上，大量的视频聊天应用在apprtc.appspot.com。</p>
<p>RTCDataChannel可用于Chrome、Opera和Firefox。在GitHub上有关于数据通道的例子，可以去实践一下。</p>
<p><strong>5我的第一个WebRTC应用</strong></p>
<p>开发WebRTC应用需要做好下列准备：</p>
<p>1.获取音视频流或者其他数据</p>
<p>2.得到网络信息，如IP地址和端口，通过网络和其它WebRTC客户端交换数据，解决NATs/防火墙穿透问题。</p>
<p>3.协调信令通信来报告错误、启动或关闭会话。</p>
<p>4.交换媒体和客户端信息，比如分辨率和编解码参数。</p>
<p>5.传输音视频流或者其他数据。</p>
<p>为了实现数据流通信，WebRTC实现了下列API：</p>
<p>1.MediaStream：从设备获取数据流，比如说摄像头和麦克风。</p>
<p>2.RTCPeerConnection：音视频通话，包括设备加密和带宽管理。</p>
<p>3.RTCDataChannel：p2p通信。</p>
<p><strong>6MediaStream (别名getUserMedia)</strong></p>
<p>MediaStream API代表媒体流的同步。比如，从摄像头和麦克风获取的媒体流具有同步视频和音频轨道。不要将这里的MediaStream轨道和<track>元素混淆，它们是完全不同的概念。</p>
<p>理解MediaStream最简单的方法如下：</p>
<p>1.在Chrome或Opera中打开例子</p>
<p><a target="_blank" rel="noopener" href="https://webrtc.github.io/samples/src/content/getusermedia/gum">https://webrtc.github.io/samples/src/content/getusermedia/gum</a></p>
<p>2.打开控制台</p>
<p>3.检查stream变量，该变量是全局的。</p>
<p>每个MediaStream都有输入，即navigator.getUserMedia()；也有输出，被传递到video元素或RTCPeerConnection</p>
<p>getUserMedia()方法有三个参数：</p>
<p>1.一个约束对象。</p>
<p>2.一个成功的回调，如果成功会回传一个MediaStream。</p>
<p>3.一个失败的回调，如果失败会回传一个error对象。</p>
<p>每个MediaStream都有一个label，比如</p>
<p>‘Xk7EuLhsuHKbnjLWkW4yYGNJJ8ONsgwHBvLQ’,getAudioTradks()和</p>
<p>getAudioTracks()方法会回传一个MediaStreamTracks对象的数组。</p>
<p>在例子</p>
<p><a target="_blank" rel="noopener" href="https://webrtc.github.io/samples/src/content/getusermedia/gum">https://webrtc.github.io/samples/src/content/getusermedia/gum</a>   中,stream.getAudioTracks()回传了一个空数组（因为没有音频），假设摄像头正常工作并连接，stream.getVideoTracks()回传一个MediaStreamTracks对象的数组。数组中的每个MediaStreamTracks对象包含一种媒体（‘video’或‘audio’）和一个label（比如’FaceTime HD Camera (Built-in)’），而且还代表了一个或多个音视频的数据通道。在这个例子中，只有一个视频轨道，没有音频。当然，很容易就能扩展到其他情况。</p>
<p>在Chrome或Opera中, URL.createObjectURL()方法将MediaStream转换成Blob URL，该Blob URL可以设置为video元素的输入（在Firefox和Opera中，视频源可以通过数据流本身设置）。版本M25开始，基于Chromium的浏览器（Chrome和Opera）允许来自getUserMedia的音频数据传递到aduio或video元素。</p>
<p>getUserMedia还可用作Web Audio API的输入节点。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-54.png" alt="知识铺-pasted-54.png"></p>
<p>在manifest中添加audioCapture和videoCapture权限可以在加载的时候得到（仅一次）授权，毕竟加载之后用户不会再有对摄像头或麦克风的访问请求。</p>
<p>最终的目的是使MediaStream适用于任何数据源，不仅限于摄像头和麦克风，还包括来自磁盘或者传感器等输入设备二进制数据。</p>
<p>需要注意的是getUserMedia()必须在服务器上使用，而不是本地文件中，否则的话将会抛出权限的错误PERMISSION_DENIED。</p>
<p>getUserMedia()通常和其他的Java API及库一起使用:</p>
<p>Webcam Toy是一个photobooth应用，它使用WebGL来添加一些特效，让用户可以共享照片或是保存到本地。</p>
<p>FaceKat是一个人脸追踪的游戏，使用headtrackr.js。</p>
<p>ASCII Camera使用Canvas API来生成ASCII码的图片。</p>
<p><strong>7约束</strong></p>
<p>Constraints已经在Chrome、FireFox和Opera中实现了。通过约束可以设置getUserMedia()和RTCPeerConnection的addStream()获取视频的分辨率，约束的实现是为了通过applyConstraints()方法控制视频高度和宽度的比例、帧率、和正反摄像头模式等等……</p>
<p>这里有一个例子：</p>
<p><a target="_blank" rel="noopener" href="https://webrtc.github.io/samples/src/content/getusermedia/resolution/%E3%80%82">https://webrtc.github.io/samples/src/content/getusermedia/resolution/。</a></p>
<p>一个陷阱：getUserMedia约束设置在浏览器的一个标签中，会约束之后打开的所有标签。设置一个非法的值会提示以下错误：</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-55.png" alt="知识铺-pasted-55.png"><br><strong>8屏幕和标签捕获</strong></p>
<p>Chrome应用可以通过chrome.tabCapture和chrome.desktopCapture这两个API实时分享浏览器标签或者整个桌面。桌面捕获的例子：WebRTC samples GitHub repository。更多关于屏幕录制、编码的信息和有参考：Screensharing with WebRTC。</p>
<p>在Chrome中，可以将屏幕捕获当做MediaStream的数据源，此时使用的是实验性的chromeMediaSource约束，一个例子：this demo。需要注意的是屏幕捕获功能需要HTTPS支持，并且只用于开发中，通过一个命令行标志来启用。</p>
<p><strong>9信令：会话控制，网络和媒体信息</strong></p>
<p>WebRTC使用RTCPeerConnection在浏览器（别名peer）之间互通数据流，但是需要一种机制去协调通信或者发送控制消息，这个过程被称为信令。WebRTC没有指定信令方法和协议，信令不是RTCPeerConnection API的一部分。</p>
<p>因此，WebRTC应用的开发者可用选择其擅长的消息协议，比如SIP或XMPP，或者其他合适的双工通信协议。</p>
<p>apprtc.appspot.com这个例子使用XHR和Channel API作为信令机制。codelab是我们通过Socket.io构建，运行在Node server上的应用。</p>
<p>信令通常用于交互三类信息：</p>
<p>1.会话控制消息；初始化或者关闭通信，报告错误。</p>
<p>2.网络信息：对于外部而言，我的IP地址和端口是什么？</p>
<p>3.媒体信息：什么编码和分辨率浏览器可以处理，我的浏览器要和谁通信。</p>
<p>在p2p的流传输之前，必须通过信令成功的交换信息。</p>
<p>假如Alice想和Bob通信，这里有个简单的例子来自WebRTC W3C Working Draft，展示了实际的信令处理过程。例子中假设存在某种信令机制，该机制通过createSignalingChannel()方法创建。注意在Chrome和Opera中，RTCPeerConnection是带有前缀的。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-56.png" alt="知识铺-pasted-56.png"></p>
<p>首先，Alice和Bob交换网络信息，‘finding candidates’表示通过ICE framework查找网络接口和端口。</p>
<p>1.Alice创建一个RTCPeerConnection对象，该对象内置onicecandidate处理器。</p>
<p>2.这个处理器在网络candidate生效时开始运行。</p>
<p>3.Alice通过信令通道发送序列化的数据给Bob，信令通道可以是WebSocket或者其他机制。</p>
<p>4.当Bob收到Alice的candidate消息后，调用addIceCandidate将candidate添加到远端描述。</p>
<p>WebRTC客户端（别名peer，这里指Alice和Bob）需要明确并交换本地和远程音视频媒体信息，比如分辨率和编码格式。交换媒体信息的信令，是通过交换会话描述协议（SDP）来实现的。</p>
<p>1.Alice调用了RTCPeerConnection的createOffer()方法，它的回调参数传入的是RTCSessionDeion（Alice的本地会话描述）。</p>
<p>2.在回调中，Alice调用setLocalDeion()方法设置了本地会话描述，然后将该会话描述通过信令通道发送给Bob。注意，RTCPeerConnection并不会采集candidate直到setLocalDeion()被调用。</p>
<p>3.Bob使用setRemoteDeion()方法将Alice发送给他的会话描述设置为远程会话描述。</p>
<p>4.Bob调用了RTCPeerConnection的createAnswer()方法，并传入它从Alice接收到的远程会话描述，此时一个与Alice兼容的本地会话产生了。createAnswer()的回调参数传入的是RTCSessionDeion（Bob将它设置为本地会话描述并发送给Alice）。</p>
<p>5.当Alice收到Bob的会话描述，她使用setRemoteDeion()方法将其设置为远程会话描述。</p>
<p>6.Ping</p>
<p>RTCSessionDeion对象遵从SDP（Session Deion Protocol），一个SDP对象看起来如下所示：</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-57.png" alt="知识铺-pasted-57.png"></p>
<p>交换网络和媒体信息可以同时进行，但这两个过程必须在音视频流开始传输之前完成。</p>
<p>上述的offer/answer架构被称为JSEP（Java Session Establishment Protocol），JSEP架构如下所示：</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-58.png" alt="知识铺-pasted-58.png"></p>
<p>一旦信令过程成功，就可以直接进行Caller和callee之间p2p的数据流传输了。</p>
<p><strong>10RTCPeerConnection</strong></p>
<p>RTCPeerConnection是WebRTC的组件，用来稳定高效的处理端对端的数据流通信。</p>
<p>下图是WebRTC的架构图，标明了RTCPeerConnection扮演的角色。你可能注意到了，绿色部分是相当复杂的。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-59.png" alt="知识铺-pasted-59.png"></p>
<p>从Java的角度来看，理解这个图最重要的是理解RTCpeerConnection这一部分。WebRTC对编解码器和协议做了大量的工作，使实时通信成为可能，甚至在一些不可靠的网络中：</p>
<p>1.包补偿</p>
<p>2.回声消除</p>
<p>3.自适应带宽</p>
<p>4.视频抖动缓冲</p>
<p>5.自动增益控制</p>
<p>6.噪声抑制</p>
<p>7.图像清除</p>
<p>章节九中的例子从信令的角度进行了讲解，下面我们将学习两个WebRTC应用；一个简单的演示了RTCPeerConnection，另一个是功能齐全的视频聊天客户端。</p>
<p><strong>11无服务器的RTCPeerConnection</strong></p>
<p>下面的代码来自</p>
<p><a target="_blank" rel="noopener" href="https://webrtc.github.io/samples/src/content/peerconnection/pc1">https://webrtc.github.io/samples/src/content/peerconnection/pc1</a>    包含基于网页的本地和远程RTCPeerConnection。这个例子中caller和callee在同一个网页中，能更加清晰的展示RTCPeerConnection API的工作流程，因为RTCPeerConnection对象之间可以直接交换数据和消息，不需要通过中继信道机制。</p>
<p>一个陷阱：RTCPeerConnection()第二个约束类型的参数是可选的，它与getUserMedia()中使用的约束类型不同。</p>
<p>本例中pc1表示本地端（caller），pc2表示远程端（callee）</p>
<p><strong>caller</strong></p>
<p>1.创建一个RTCPeerConnection，并通过getUserMedia()添加数据流。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-60.png" alt="知识铺-pasted-60.png"></p>
<p>2.创建一个offer，并将它设置为pc1的本地会话描述，设置为pc2的远程会话描述。可以直接在代码中设置，不需要使用信令，因为caller和callee在同一个网页中。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-61.png" alt="知识铺-pasted-61.png"></p>
<p><strong>callee</strong></p>
<p>1.创建pc2，接收pc1的数据流，并显示到video元素中</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-62.png" alt="知识铺-pasted-62.png"></p>
<p><strong>12有服务器的RTCPeerConnection</strong></p>
<p>实际应用中，WebRTC需要服务器，无论多简单，下面四步是必须的：</p>
<p>1.用户通过交换名字之类的信息发现对方。</p>
<p>2.WebRTC客户端应用交换网络信息。</p>
<p>3.客户端交换媒体信息包括视频格式和分辨率。</p>
<p>4.WebRTC客户端穿透NAT网关和服务器。</p>
<p>换句话说，WebRTC需要四种类型的服务端功能。</p>
<p>1.用户发现和通信</p>
<p>2.信令</p>
<p>3.NAT/防火墙穿透</p>
<p>4.中继服务器，防止端到端的通信失败</p>
<p>以上这些不在本文讨论范围之内。可以说基于STUN和TURN协议的ICE框架，使得RTCPeerConnection处理NAT穿透和其他网络难题成为可能。</p>
<p>ICE框架用于端到端的连接，比如说两个视频聊天客户端。起初，ICE尝试通过UDP直接连接两端，这样可以保证低延迟。在这个过程中，STUN服务器有一个简单的任务：使NAT后边的端能找到它的公网地址和端口（谷歌有多个STUN服务器，其中一个用在了</p>
<p>apprtc.appspot.com例子）。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-63.png" alt="知识铺-pasted-63.png"><br>如果UDP传输失败，ICE会尝试TCP：首先是HTTP，然后才会选择 HTTPS。如果直接连接失败，通常因为企业的NAT穿透和防火墙，此时ICE使用中继（Relay）服务器。换句话说，ICE首先使用STUN和UDP直接连接两端，失败之后返回中继服务器。‘finding cadidates’就是寻找网络接口和端口的过程。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-64.png" alt="知识铺-pasted-64.png"><br>WebRTC工程师Justin Uberti在幻灯片2013 Google I/O WebRTC presentation中提供了许多关于ICE、STUN和TURN的信息。</p>
<p><strong>13一个简单的视频聊天客户端</strong></p>
<p>如果你觉得这个例子比较难，你也行会喜欢上我们的WebRTC codelab。那里一步步的介绍了如何建立一个完整的视频聊天应用，包括一个运行于Node server上基于Socket.io的信令服务器。</p>
<p>apprtc.appspot.com是一个测试WebRTC的好地方，里面有视频聊天的例子，它实现了信令和基于STUN服务器的NAT/防火墙穿透。这个例子使用adapter.js处理不同的RTCPeerConnection和getUserMedia()实现。</p>
<p>下面我们详细的过一遍代码。</p>
<p><strong>如何开始</strong></p>
<p>这个例子从initialize()函数开始运行。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-65.png" alt="知识铺-pasted-65.png"></p>
<p>需要注意的是，变量room和openChannel()参数的值都是由Google App Engine应用自身提供的。查看一下index.html template 就知道该赋什么值了。</p>
<p>这段代码初始化HTML video元素的相关变量，video元素播放来自本地摄像头（localVieo）和远程摄像头（remoteVideo）的视频流。resetStatus()设置了一条状态消息。</p>
<p>openChannel()函数建立了WebRTC客户端间的消息通道。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-66.png" alt="知识铺-pasted-66.png"><br>关于信令，本例使用的是Google App Engine Channel API，这使得JavaScritp客户端无需轮询就能实现消息传输。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-67.png" alt="知识铺-pasted-67.png"></p>
<p>使用Channel API建立通道的流程大致如下：</p>
<p>1.客户端A生成一个唯一ID。</p>
<p>2.客户端A向Google App Engine应用请求一个通道标识（即openChannel()的参数），并将它的ID传给Google App Engine应用。</p>
<p>3.Google App Engine应用会调用Channel API为客户端ID分配一个通道和一个通道标识。</p>
<p>4.Google App Engine应用将通道标识发给客户端A。</p>
<p>5.客户端A打开socket并监听服务器上建立的通道。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-68.png" alt="知识铺-pasted-68.png"></p>
<p>发送消息的流程大致如下：</p>
<p>1.客户端B给Google App Engine应用发送了一个POST请求，要求升级程序。</p>
<p>2.Google App Engine应用给通道发送一个请求消息。</p>
<p>3.消息经通道传递给客户端A</p>
<p>4.客户端A的onmessage回调函数被调用。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-69.png" alt="知识铺-pasted-69.png"></p>
<p>重申一次，信令传输机制是由开发者选择的。WebRTC并没有指定信令机制。本例的Channel API能被其他的方式取代，比如WebSocket。</p>
<p>initialize()调用完openChannel()之后，紧接着调用getUserMedia()，这个函数可以检测出浏览器是否支持getUserMedia API。如果一切顺利，onUserMediaSuccess会被调用。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-70.png" alt="知识铺-pasted-70.png"></p>
<p>这样一来，本地摄像头就能显示在localVideo元素中了。</p>
<p>此时，initiator被设置成1（直到caller的会话终止），maybeStart()被调用。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-71.png" alt="知识铺-pasted-71.png"><br>该函数使用了一种巧妙的结构，可以工作于多个异步回调：maybeStart()可能被任何函数调用，但是只有当localStream被定义、channelReady为true且通信还未开始的情况下，maybeStart()才会运行。因此，当连接还未建立，本地流已经可用，且信令通道已经准备好时，连接才会创建并加载本地视频流。接着started被设置为true。所以连接不会被创建多次 。</p>
<p><strong>RTCPeerConnection: 发起通话</strong></p>
<p>在</p>
<p>maybeStart()中被调用的createPeerConnection()，才是关键所在。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-72.png" alt="知识铺-pasted-72.png"></p>
<p>这段代码的目的是使用STUN服务器建立一个连接，并将onIceCandidate()作为回调函数。然后给RTCPeerConnection每个事件指定处理器（函数）：当会话连接或打开，当远程流被加载或移除。在本例中，这些处理器只是记录了状态消息——除了onRemoteStreamAdded()，它给remoteVideo元素设置了数据源。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-73.png" alt="知识铺-pasted-73.png"><br>一旦createPeerConnection()在maybeStart()中被调用，就会发起通话，创建Offer并发送消息给对端。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-74.png" alt="知识铺-pasted-74.png"></p>
<p>这里的offer创建过程类似于上面无信令的例子。但是，除此之外，一条消息被发送到了对端，详见setLocalAndSendMessage()：</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-75.png" alt="知识铺-pasted-75.png"></p>
<p><strong>用Channel API传输信令</strong></p>
<p>当RTCPeerConnection在createPeerConnection()中成功创建的时候，onIceCandidate()回调函数会触发，并发送关于candidate的信息。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-76.png" alt="知识铺-pasted-76.png"><br>从客户端到服务器的消息外传，是通过sendMessage()方法内的XHR请求实现的。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-77.png" alt="知识铺-pasted-77.png"></p>
<p>XHR多用于从客户端发送信令消息到服务端，但是某些机制需要用来实现服务端到客户端的消息传输：本例用的是Google App Engine Channel API。来自此API的消息会传递到</p>
<p>processSignalingMessage()：</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-78.png" alt="知识铺-pasted-78.png"></p>
<p>如果消息是来自对端的answer（offer的回应），RTCPeerConnection设置远程会话描述，通信开始。如果消息是offer（来自callee），RTCPeerConnection设置远程会话描述，发送answer给callee，然后调用RTCPeerConnection的startIce()方法发起连接。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-79.png" alt="知识铺-pasted-79.png"></p>
<p>于是乎，caller和callee都发现了对方并交换相关信息，会话被初始化，实时数据通信可以开始了。</p>
<p><strong>网络技术</strong></p>
<p>WebRTC目前只实现了一对一的通信，但是可用于更复杂的网络环境：比如，多个peer各自直接通信，即p2p；或者通过MCU（Multipoint Control Unit）服务器来实现流的转发、合成或音视频的录制。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-80.png" alt="知识铺-pasted-80.png"></p>
<p>许多WebRTC应用只演示了浏览器间的通信，但是通过网关服务器可以实现WebRTC与telephones（别名PSTN）和VOIP系统直接的通信。2012年5月，Doubango Telecom开源了sipml5 SIP client，该客户端基于WebRTC和WebSocket，能实现浏览器和IOS或Android应用之间的视频通话。</p>
<p><strong>14RTCDataChannel</strong></p>
<p>除了音频和视频，WebRTC支持其他类型数据的实时通信。</p>
<p>TCDataChannel API支持p2p低延迟和高吞吐量的二进制数据流交换，这里有个例子：<a target="_blank" rel="noopener" href="http://webrtc.github.io/samples/src/content/datachannel/datatransfer">http://webrtc.github.io/samples/src/content/datachannel/datatransfer</a></p>
<p>很多领域都潜在地使用到了这个API，比如：</p>
<p>1.游戏</p>
<p>2.远程桌面应用</p>
<p>3.实时文字聊天</p>
<p>4.文件传输</p>
<p>5.分散网络</p>
<p>充分利用了RTCPeerConnection的多个特性，能实现强大而灵活的p2p通信。</p>
<p>1.利用RTCPeerConnection进行会话设置。</p>
<p>2.通过优先级设置多个同步的channel。</p>
<p>3.可靠和非可靠的语义传递。</p>
<p>4.内建立安全的DTLS和拥塞控制。</p>
<p>5.能用于音视频或其他方面</p>
<p>TCDataChannel API语法与WebSocket类似，包括send()方法和message事件。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-81.png" alt="知识铺-pasted-81.png"><br>因为是浏览器间的直接通信，所以RTCDataChannel要比WebSocket快得多，即使通信用到了中继服务器。</p>
<p>RTCDataChannel可用于Chrome、Opera和Firefox。出色的Cube Slam游戏使用TCDataChannel API来交换游戏状态：是敌还是友！Sharefest演示了通过RTCDataChannel分享文件，peerCDN提供了WebRTC如何实现p2p内容分发的一种思路。</p>
<p>更多关于RTCDataChannel的信息，可以参考IETF的draft protocol spec。</p>
<p><strong>15安全</strong></p>
<p>实时通信应用或插件会在许多方面忽视了安全性：</p>
<p>1.浏览器之间、浏览器与服务器之间的音视频或其他数据没有加密。</p>
<p>2.应用在用户没有察觉的情况下录制和分发音视频。</p>
<p>3.恶意软件或病毒可能入侵了正常的插件或应用。</p>
<p>WebRTC的许多特性可以避免这些问题：</p>
<p>1.WebRTC采用类似DTLS和SRTP的安全协议。</p>
<p>2.所有的WebRTC组件强制加密，包括信令机制。</p>
<p>3.WebRTC不是插件：它的组件运行于浏览器沙盒，不是独立的一个进程，这些组件不需要单独安装，且随着浏览器更新。</p>
<p>4.摄像头和麦克风的访问必须经过明确准许，当摄像头和麦克风运行时，界面上会清楚的显示出来。</p>
<p>关于流媒体安全的讨论超出了本文的范畴。更多信息可参考IETF的WebRTC Security Architecture。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-03-22T07:49:58.000Z" title="2020-03-22T07:49:58.000Z">2020-03-22</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.417Z" title="2020-09-08T14:03:00.417Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">12 分钟读完 (大约1854个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/03/22/WebRTC%E7%B3%BB%E5%88%97%EF%BC%9AWebRTC-%E5%B0%86%E4%B8%80%E7%BB%9F%E5%AE%9E%E6%97%B6%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%A9%E4%B8%8B%EF%BC%9F/">WebRTC系列：WebRTC 将一统实时音视频天下？</a></h1><div class="content"><p>WebRTC 的前世</p>
<p>无论是在 PC 互联网时代、移动互联网时代，还是当下以云计算、人工智能、IoT 为主导的万物互联时代，WebRTC 的到来都是实时互联网技术标准演进过程中至关重要的一个节点。</p>
<p>回忆 Web 的早期发展，设备和 Web 服务器之间的通信非常有限。在访问网站时，只有当用户在地址栏中输入新地址或点击超链接时，浏览器才能与存储网站的网络服务器进行通信。而这就是静态网页需要运行的全部内容。</p>
<p>但是彼时的一些开发者意识到 Web 应该能以更具吸引力的方式实践应用。正因此，为了使各大网站更具动态性和响应性，诸如 Ajax 类似的框架最终在 90 年代后期被相继开发，从而浏览器也能够实时地与 Web 服务器通信、允许创建适当的 Web 应用程序或即时响应用户操作。不过，彼时的实时通信技术在 Web 浏览器和服务器之间仍存在很大的局限性。</p>
<p>具体而言，过去，两个不同用户的 Web 浏览器之间的通信速度很慢，因为其二者之间的所有流量都必须通过中间的服务器，这产生了明显的延迟。但是，我们也发现直接收发消息之类的延迟并不算是真正的问题。这是因为发送消息的一个用户和接收消息的另一个用户之间几秒钟的差异并没有真正影响到整体的传输效果。但是，服务器延迟导致了一系列的连接延迟，不过如果没有这种延迟则无法实现用户之间互相呼叫等实时视频的服务。</p>
<p>如今 WebRTC 的出现，可以完全实现桌面和基于移动的多人多媒体聊天应用程序。</p>
<p>WebRTC 的今生</p>
<p>那具体而言，到底何为 WebRTC？</p>
<p>WebRTC（Web Real-Time Communication，网页即时通信），是一个支持网页浏览器进行实时语音对话或视频对话的技术。它的起源，要从 2010 年 Google 以 6820 万美元收购 VoIP 软件开发商 Global IP Solutions 的 GIPS 引擎谈起，在经过收购之后没多久，Google 将该引擎改名为“WebRTC”，并宣布向开发者们开源了源代码。</p>
<p>2012 年，Google 将 WebRTC 集成到 Chrome 浏览器中。随后，在它的带动下，Mozilla、Opera、Ericsson 等 PC 浏览器以及手机浏览器均开始支持 WebRTC 技术。</p>
<p>2017 年，苹果在 WWDC17 上正式宣布其浏览器内核 WebKit 也正式支持 WebRTC。</p>
<p>如今，继去年微软宣布 Edge 将采用 Chromium 开源项目之后，就 WebRTC 技术应用而言，Bernard Aboba 表示，“基于 Chromium 的新版 Edge 现在可在预览版中使用。新版本的 Edge 提供了 WebRTC 开发者常用的许多功能，如支持数据通道、RTCPeerConnection 中的 Strem、VP9 编解码器和 MediaStream Recording。”</p>
<p>事实上，除了以上的浏览器以及文章伊始提及国内主流的应用程序之外，在 Discord、Google Hangouts 和 Facebook Messenger 等一些国内的多媒体网络应用中，也都需要 WebRTC 才能实现。</p>
<p>WebRTC 一统浏览器、移动端的实时音视频天下？</p>
<p>按照这样的发展趋势，WebRTC 能否一举成功夺下各层面的实时音频霸主之位？</p>
<p>其实，在 WebRTC 的全名——Web Real Time Communication 中，我们从 Web 一词就可以看出，最初这项技术是为浏览器量身打造用以实时音视频能力而准备的。而 WebRTC 项目一开始的初衷也是让 Web 开发者能够基于如 Chrome、Edge、Firefox 等浏览器平台轻易快捷开发出丰富的实时多媒体应用，而无需下载安装任何插件，Web 开发者也仅需关注多媒体的数字信号处理过程，只需编写简单的 JavaScript 程序即可实现。</p>
<p>不过，就浏览器应用而言，WebRTC 的发展还面临着诸多的挑战。对此，Bernard Aboba 表示：</p>
<p>浏览器面临的主要挑战是完成 WebRTC 1.0 API 的实现，以及消除实现差异。为了达到提议标准，WebRTC 工作组需要记录每个功能的两个实现，并通过 Web 平台测试（WPT）的结果展示互操作性。当下，W3C 在实现这一目标方面一直在稳步前进，但在 WebRTC 以及 WebRTC-Stats 等相关规范方面仍有许多工作要做。其次，就 WebRTC 自身的发展而言，WebRTC API 在其历史中经历了三次主要迭代，最后一次迭代是 addTransceiver API，这是 WebRTC 1.0 候选推荐中的首选 API。随着浏览器现在实施候选推荐标准并融合“Unified Plan”SDP，WebRTC 工作组正在为开发人员一直要求的互操作性方面而努力，并且 W3C 需要将规范推进到推荐的标准中。就需要改进的领域而言，W3C 仍然需要改进同步广播等高级功能的测试覆盖率，并将 WebRTC-Statistics 规范纳入候选推荐标准中。当前实时音视频通信领域，也并不只有 WebRTC 一种可供选择的技术。事实上，在 WebRTC 诞生之前，很多领域的公司都有自己自研的通信协议。而如何保证自研协议与 WebRTC 协议在 Windows、Mac 等平台上做到互通？Bernard Aboba 建议道，专有的自研协议和 WebRTC 的互操作性通常使用网关实现。使用 Janus 等工具，开发人员可以通过在已建立的框架内构建模块。但是，在各种情况下测试兼容性的任务仍然很困难。对此，Bernard Aboba 也表示，由 Cosmo Consulting 开发的测试框架（如 KITE）可能会有所帮助。然而，除此之外，WebRTC 在移动端的应用也一直被开发者所诟病。针对这一点，Bernard Aboba 坦言道，“对移动或嵌入式设备优化 WebRTC，是一项重大的挑战，尤其是在内存、应用程序大小，以及连接性和功耗等方面。”</p>
<p>不过当下，W3C 组织为了解决这些难题，该团队的开发者们经常需要创建自定义构建，其中包含了许多更改改进，举例说明，例如，Ortc Lib 创建了 OpenPeer Foundation 的 Robin Raymond，支持使用 ORTC API 在移动设备上进行开发，同时允许开发人员自定义库，以便仅包含所需的功能。 事实证明这种方法非常成功。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-12-06T12:17:24.000Z" title="2019-12-06T12:17:24.000Z">2019-12-06</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.301Z" title="2020-09-08T14:03:00.301Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">10 分钟读完 (大约1451个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/06/100%E5%A4%A9Spring%E9%9B%B6%E5%9F%BA%E7%A1%80%E8%B5%B7%E9%A3%9E-%E4%BA%8C/">100天Spring零基础起飞 二</a></h1><div class="content"><h2 id="Spring-体系结构"><a href="#Spring-体系结构" class="headerlink" title="Spring 体系结构"></a>Spring 体系结构</h2><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>Spring 有可能成为所有企业应用程序的一站式服务点，然而，Spring 是模块化的，允许你挑选和选择适用于你的模块，不必要把剩余部分也引入。下面的部分对在 Spring 框架中所有可用的模块给出了详细的介绍。</p>
<p>Spring 框架提供约 20 个模块，可以根据应用程序的要求来使用。</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-52.png" alt="知识铺-pasted-52.png"></p>
<h2 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h2><p>核心容器由<strong>spring-core，spring-beans，spring-context，spring-context-support和spring-expression</strong>（SpEL，Spring表达式语言，Spring Expression Language）等模块组成，它们的细节如下：</p>
<ul>
<li><p><strong>spring-core</strong>模块提供了框架的基本组成部分，包括 IoC 和依赖注入功能。</p>
</li>
<li><p><strong>spring-beans</strong> 模块提供 BeanFactory，工厂模式的微妙实现，它移除了编码式单例的需要，并且可以把配置和依赖从实际编码逻辑中解耦。</p>
</li>
<li><p><strong>context</strong>模块建立在由<strong>core</strong>和 <strong>beans</strong> 模块的基础上建立起来的，它以一种类似于JNDI注册的方式访问对象。Context模块继承自Bean模块，并且添加了国际化（比如，使用资源束）、事件传播、资源加载和透明地创建上下文（比如，通过Servelet容器）等功能。Context模块也支持Java EE的功能，比如EJB、JMX和远程调用等。<strong>ApplicationContext</strong>接口是Context模块的焦点。<strong>spring-context-support</strong>提供了对第三方库集成到Spring上下文的支持，比如缓存（EhCache, Guava, JCache）、邮件（JavaMail）、调度（CommonJ, Quartz）、模板引擎（FreeMarker, JasperReports, Velocity）等。</p>
</li>
<li><p><strong>spring-expression</strong>模块提供了强大的表达式语言，用于在运行时查询和操作对象图。它是JSP2.1规范中定义的统一表达式语言的扩展，支持set和get属性值、属性赋值、方法调用、访问数组集合及索引的内容、逻辑算术运算、命名变量、通过名字从Spring IoC容器检索对象，还支持列表的投影、选择以及聚合等。</p>
</li>
</ul>
<p>它们的完整依赖关系如下图所示：</p>
<p><img src="https://blog.zshipu.com/tlg/images/pasted-53.png" alt="知识铺-pasted-53.png"></p>
<h2 id="数据访问-集成"><a href="#数据访问-集成" class="headerlink" title="数据访问/集成"></a>数据访问/集成</h2><p>数据访问/集成层包括 JDBC，ORM，OXM，JMS 和事务处理模块，它们的细节如下：</p>
<p>（注：JDBC=Java Data Base Connectivity，ORM=Object Relational Mapping，OXM=Object XML Mapping，JMS=Java Message Service）</p>
<ul>
<li><p><strong>JDBC</strong> 模块提供了JDBC抽象层，它消除了冗长的JDBC编码和对数据库供应商特定错误代码的解析。</p>
</li>
<li><p><strong>ORM</strong> 模块提供了对流行的对象关系映射API的集成，包括JPA、JDO和Hibernate等。通过此模块可以让这些ORM框架和spring的其它功能整合，比如前面提及的事务管理。</p>
</li>
<li><p><strong>OXM</strong> 模块提供了对OXM实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等。</p>
</li>
<li><p><strong>JMS</strong> 模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了spring-messaging模块。。</p>
</li>
<li><p><strong>事务</strong>模块为实现特殊接口类及所有的 POJO 支持编程式和声明式事务管理。（注：编程式事务需要自己写beginTransaction()、commit()、rollback()等事务管理方法，声明式事务是通过注解或配置由spring自动处理，编程式事务粒度更细）</p>
</li>
</ul>
<h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><p>Web 层由 Web，Web-MVC，Web-Socket 和 Web-Portlet 组成，它们的细节如下：</p>
<ul>
<li><p><strong>Web</strong> 模块提供面向web的基本功能和面向web的应用上下文，比如多部分（multipart）文件上传功能、使用Servlet监听器初始化IoC容器等。它还包括HTTP客户端以及Spring远程调用中与web相关的部分。。</p>
</li>
<li><p><strong>Web-MVC</strong> 模块为web应用提供了模型视图控制（MVC）和REST Web服务的实现。Spring的MVC框架可以使领域模型代码和web表单完全地分离，且可以与Spring框架的其它所有功能进行集成。</p>
</li>
<li><p><strong>Web-Socket</strong> 模块为 WebSocket-based 提供了支持，而且在 web 应用程序中提供了客户端和服务器端之间通信的两种方式。</p>
</li>
<li><p><strong>Web-Portlet</strong> 模块提供了用于Portlet环境的MVC实现，并反映了spring-webmvc模块的功能。</p>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有其他一些重要的模块，像 AOP，Aspects，Instrumentation，Web 和测试模块，它们的细节如下：</p>
<ul>
<li><p><strong>AOP</strong> 模块提供了面向方面的编程实现，允许你定义方法拦截器和切入点对代码进行干净地解耦，从而使实现功能的代码彻底的解耦出来。使用源码级的元数据，可以用类似于.Net属性的方式合并行为信息到代码中。</p>
</li>
<li><p><strong>Aspects</strong> 模块提供了与 <strong>AspectJ</strong> 的集成，这是一个功能强大且成熟的面向切面编程（AOP）框架。</p>
</li>
<li><p><strong>Instrumentation</strong> 模块在一定的应用服务器中提供了类 instrumentation 的支持和类加载器的实现。</p>
</li>
<li><p><strong>Messaging</strong> 模块为 STOMP 提供了支持作为在应用程序中 WebSocket 子协议的使用。它也支持一个注解编程模型，它是为了选路和处理来自 WebSocket 客户端的 STOMP 信息。</p>
</li>
<li><p><strong>测试</strong>模块支持对具有 JUnit 或 TestNG 框架的 Spring 组件的测试。</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-12-06T12:15:37.000Z" title="2019-12-06T12:15:37.000Z">2019-12-06</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.299Z" title="2020-09-08T14:03:00.299Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">10 分钟读完 (大约1522个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/06/100%E5%A4%A9Spring%E9%9B%B6%E5%9F%BA%E7%A1%80%E8%B5%B7%E9%A3%9E-%E4%B8%80/">100天Spring零基础起飞 一</a></h1><div class="content"><h2 id="Spring-概述"><a href="#Spring-概述" class="headerlink" title="Spring 概述"></a>Spring 概述</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Spring 是最受欢迎的企业级 Java 应用程序开发框架，数以百万的来自世界各地的开发人员使用 Spring 框架来创建性能好、易于测试、可重用的代码。</p>
<p>Spring 框架是一个开源的 Java 平台，它最初是由 Rod Johnson 编写的，并且于 2003 年 6 月首次在 Apache 2.0 许可下发布。</p>
<p>Spring 是轻量级的框架，其基础版本只有 2 MB 左右的大小。</p>
<p>Spring 框架的核心特性是可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO 编程模型来促进良好的编程实践。</p>
<h2 id="使用-Spring-框架的好处"><a href="#使用-Spring-框架的好处" class="headerlink" title="使用 Spring 框架的好处"></a>使用 Spring 框架的好处</h2><p>下面列出的是使用 Spring 框架主要的好处：</p>
<ul>
<li><p>Spring 可以使开发人员使用 POJOs 开发企业级的应用程序。只使用 POJOs 的好处是你不需要一个 EJB 容器产品，比如一个应用程序服务器，但是你可以选择使用一个健壮的 servlet 容器，比如 Tomcat 或者一些商业产品。</p>
</li>
<li><p>Spring 在一个单元模式中是有组织的。即使包和类的数量非常大，你只要担心你需要的，而其它的就可以忽略了。</p>
</li>
<li><p>Spring 不会让你白费力气做重复工作，它真正的利用了一些现有的技术，像ORM 框架、日志框架、JEE、Quartz 和 JDK 计时器，其他视图技术。</p>
</li>
<li><p>测试一个用 Spring 编写的应用程序很容易，因为环境相关的代码被移动到这个框架中。此外，通过使用 JavaBean-style POJOs，它在使用依赖注入注入测试数据时变得更容易。</p>
</li>
<li><p>Spring 的 web 框架是一个设计良好的 web MVC 框架，它为比如 Structs 或者其他工程上的或者不怎么受欢迎的 web 框架提供了一个很好的供替代的选择。MVC模式导致应用程序的不同方面(输入逻辑，业务逻辑和UI逻辑)分离，同时提供这些元素之间的松散耦合。</p>
<ul>
<li>模型(Model)封装了应用程序数据，通常它们将由POJO类组成。</li>
<li>视图(View)负责渲染模型数据，一般来说它生成客户端浏览器可以解释HTML输出。</li>
<li>控制器(Controller)负责处理用户请求并构建适当的模型，并将其传递给视图进行渲染。</li>
</ul>
</li>
<li><p>Spring 对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。</p>
</li>
<li><p>轻量级的 IOC 容器往往是轻量级的，例如，特别是当与 EJB 容器相比的时候。这有利于在内存和 CPU 资源有限的计算机上开发和部署应用程序。</p>
</li>
<li><p>Spring提供了一致的事务管理接口，可向下扩展到（使用一个单一的数据库，例如）本地事务并扩展到全局事务（例如，使用 JTA）。</p>
</li>
</ul>
<h2 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h2><p>Spring 最认同的技术是控制反转的<strong>依赖注入（DI）</strong>模式。控制反转（IoC）是一个通用的概念，它可以用许多不同的方式去表达，依赖注入仅仅是控制反转的一个具体的例子。</p>
<p>当编写一个复杂的 Java 应用程序时，应用程序类应该尽可能的独立于其他的 Java 类来增加这些类可重用可能性，当进行单元测试时，可以使它们独立于其他类进行测试。依赖注入（或者有时被称为配线）有助于将这些类粘合在一起，并且在同一时间让它们保持独立。</p>
<p>到底什么是依赖注入？让我们将这两个词分开来看一看。这里将依赖关系部分转化为两个类之间的关联。例如，类 A 依赖于类 B。现在，让我们看一看第二部分，注入。所有这一切都意味着类 B 将通过 IoC 被注入到类 A 中。</p>
<p>依赖注入可以以向构造函数传递参数的方式发生，或者通过使用 setter 方法 post-construction。由于依赖注入是 Spring 框架的核心部分，所以我将在一个单独的章节中利用很好的例子去解释这一概念。</p>
<h2 id="面向方面的程序设计（AOP）："><a href="#面向方面的程序设计（AOP）：" class="headerlink" title="面向方面的程序设计（AOP）："></a>面向方面的程序设计（AOP）：</h2><p>Spring 框架的一个关键组件是<strong>面向方面的程序设计（AOP）</strong>框架。一个程序中跨越多个点的功能被称为<strong>横切关注点</strong>，这些横切关注点在概念上独立于应用程序的业务逻辑。有各种各样常见的很好的关于方面的例子，比如日志记录、声明性事务、安全性，和缓存等等。</p>
<p>在 OOP 中模块化的关键单元是类，而在 AOP 中模块化的关键单元是方面。AOP 帮助你将横切关注点从它们所影响的对象中分离出来，然而依赖注入帮助你将你的应用程序对象从彼此中分离出来。</p>
<p>Spring 框架的 AOP 模块提供了面向方面的程序设计实现，可以定义诸如方法拦截器和切入点等，从而使实现功能的代码彻底的解耦出来。使用源码级的元数据，可以用类似于.Net属性的方式合并行为信息到代码中。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-11-29T06:45:06.000Z" title="2019-11-29T06:45:06.000Z">2019-11-29</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.389Z" title="2020-09-08T14:03:00.389Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">1 小时读完 (大约13390个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/29/Next-js%E6%89%8B%E5%86%8C/">Next.js手册</a></h1><div class="content"><p>如果您对Next.js的知识从零到零，或者您过去曾经使用过React，并且希望进一步深入到React生态系统，尤其是服务器端渲染，这对您来说是理想的。</p>
<p>我发现Next.js是创建Web应用程序的绝佳工具，并且在本文结尾，我希望您能像我一样对它感到兴奋。我希望它能帮助您学习Next.js！</p>
<p><a target="_blank" rel="noopener" href="https://flaviocopes.com/page/nextjs-handbook/">注意：您可以下载本教程的PDF / ePub / Mobi版本，以便离线阅读</a>！</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>直到您意识到与在客户端呈现所有内容有关的几个问题之前，在由React驱动的现代JavaScript应用程序上进行工作非常出色。</p>
<p>首先，页面需要更长的时间才能被用户看到，因为在加载内容之前，必须加载所有JavaScript，并且您的应用程序需要运行才能确定在页面上显示的内容。</p>
<p>其次，如果您要建立一个公开可用的网站，则存在内容SEO问题。搜索引擎在运行和索引JavaScript应用方面越来越好，但是如果我们可以向他们发送内容而不是让他们弄清楚它，那就更好了。</p>
<p>解决这两个问题的方法是<strong>服务器渲染</strong>，也称为<strong>静态预渲染</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://nextjs.org/">Next.js</a>是一个React框架，可以通过一种非常简单的方式完成所有这些工作，但不仅限于此。它的创建者宣传它<strong>是React应用程序</strong>的<strong>零配置单命令工具链</strong>。</p>
<p>它提供了一种通用的结构，使您可以轻松构建前端React应用程序，并为您透明地处理服务器端渲染。</p>
<h2 id="Next-js提供的主要功能"><a href="#Next-js提供的主要功能" class="headerlink" title="Next.js提供的主要功能"></a>Next.js提供的主要功能</h2><p>这是Next.js主要功能的详尽列表：</p>
<h3 id="热门代码重装"><a href="#热门代码重装" class="headerlink" title="热门代码重装"></a>热门代码重装</h3><p>当Next.js检测到任何保存到磁盘的更改时，它将重新加载页面。</p>
<h3 id="自动路由"><a href="#自动路由" class="headerlink" title="自动路由"></a>自动路由</h3><p>任何URL都映射到文件系统，文件<code>pages</code>夹中的文件，并且您不需要任何配置（当然，您有自定义选项）。</p>
<h3 id="单个文件组件"><a href="#单个文件组件" class="headerlink" title="单个文件组件"></a>单个文件组件</h3><p>使用<code>styled-jsx</code>与同一团队完全集成的，可以轻松地将范围限定的样式添加到组件中。</p>
<h3 id="服务器渲染"><a href="#服务器渲染" class="headerlink" title="服务器渲染"></a>服务器渲染</h3><p>您可以在将HTML发送给客户端之前，在服务器端渲染React组件。</p>
<h3 id="生态系统兼容性"><a href="#生态系统兼容性" class="headerlink" title="生态系统兼容性"></a>生态系统兼容性</h3><p>Next.js在其余的JavaScript，Node和React生态系统中表现良好。</p>
<h3 id="自动代码分割"><a href="#自动代码分割" class="headerlink" title="自动代码分割"></a>自动代码分割</h3><p>页面仅使用它们所需的库和JavaScript呈现。Next.js会在几种不同的资源中自动将应用程序分解，而不是生成包含所有应用程序代码的单个JavaScript文件。</p>
<p>加载页面仅加载该特定页面所需的JavaScript。</p>
<p>Next.js通过分析导入的资源来做到这一点。</p>
<p>例如，如果只有一个页面导入Axios库，则该特定页面将在其捆绑包中包含该库。</p>
<p>这样可以确保您的第一个页面加载尽可能快，并且只有将来的页面加载（如果会被触发）才会将所需的JavaScript发送给客户端。</p>
<p>有一个值得注意的例外。如果至少在网站页面的一半中使用了常用导入，则这些导入将移入主要的JavaScript捆绑包中。</p>
<h3 id="预取"><a href="#预取" class="headerlink" title="预取"></a>预取</h3><p>该<code>Link</code>组件用于将不同的页面链接在一起，支持<code>prefetch</code>在后台自动预取页面资源（包括由于代码拆分而丢失的代码）的道具。</p>
<h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>您可以动态导入JavaScript模块和React组件。</p>
<h3 id="静态出口"><a href="#静态出口" class="headerlink" title="静态出口"></a>静态出口</h3><p>使用该<code>next export</code>命令，Next.js允许您从应用程序导出完全静态的网站。</p>
<h3 id="TypeScript支持"><a href="#TypeScript支持" class="headerlink" title="TypeScript支持"></a>TypeScript支持</h3><p>Next.js用TypeScript编写，因此具有出色的TypeScript支持。</p>
<h2 id="Next-js-vs盖茨比vs-create-react-app"><a href="#Next-js-vs盖茨比vs-create-react-app" class="headerlink" title="Next.js vs盖茨比vs create-react-app"></a>Next.js vs盖茨比vs <code>create-react-app</code></h2><p>Next.js，<a target="_blank" rel="noopener" href="https://flaviocopes.com/gatsby/">Gatsby</a>和<a target="_blank" rel="noopener" href="https://flaviocopes.com/react-create-react-app/"><code>create-react-app</code></a>它们是令人惊奇的工具，可用于增强应用程序的功能。</p>
<p>让我们先说说它们的共同点。他们全都拥有React在幕后，为整个开发经验提供动力。他们还抽象化了<a target="_blank" rel="noopener" href="https://flaviocopes.com/webpack/">webpack</a>以及我们过去在过去曾经手动配置的所有低级内容。</p>
<p><code>create-react-app</code>不能帮助您轻松生成服务器端渲染的应用。它附带的所有内容（SEO，速度…）仅由Next.js和Gatsby之类的工具提供。</p>
<p><strong>什么时候Next.js比Gatsby更好？</strong></p>
<p>它们都可以帮助<strong>服务器端呈现</strong>，但是有2种不同的方式。</p>
<p>使用Gatsby的最终结果是没有服务器的静态站点生成器。您生成站点，然后在Netlify或另一个静态托管站点上静态部署生成过程的结果。</p>
<p>Next.js提供了一个后端，服务器端可以呈现对请求的响应，从而允许您创建动态网站，这意味着您将其部署在可以运行Node.js的平台上。</p>
<p>Next.js _也可以_生成一个静态站点，但是我不会说这是其主要用例。</p>
<p>如果我的目标是建立一个静态站点，那么我将很难选择，也许盖茨比拥有一个更好的插件生态系统，其中包括许多特别用于博客的插件。</p>
<p>Gatsby很大程度上也基于<a target="_blank" rel="noopener" href="https://flaviocopes.com/graphql/">GraphQL</a>，根据您的意见和需求，您可能会真正喜欢或不喜欢它。</p>
<h2 id="如何安装Next-js？"><a href="#如何安装Next-js？" class="headerlink" title="如何安装Next.js？"></a>如何安装Next.js？</h2><p>要安装Next.js，您需要安装Node.js。</p>
<p>确保您具有最新版本的Node。检查<code>node -v</code>终端中的运行情况，并将其与<a target="_blank" rel="noopener" href="https://nodejs.org/">https://nodejs.org/上</a>列出的最新LTS版本进行比较。</p>
<p>安装Node.js之后，您将在<code>npm</code>命令行中使用该命令。</p>
<p>如果您在此阶段遇到任何麻烦，建议您为我编写以下教程：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://flaviocopes.com/node-installation/">如何安装Node.js</a></li>
<li><a target="_blank" rel="noopener" href="https://flaviocopes.com/how-to-update-node/">如何更新Node.js</a></li>
<li><a target="_blank" rel="noopener" href="https://flaviocopes.com/npm/">npm软件包管理器简介</a></li>
<li><a target="_blank" rel="noopener" href="https://flaviocopes.com/shells/">Unix Shell教程</a></li>
<li><a target="_blank" rel="noopener" href="https://flaviocopes.com/macos-terminal/">如何使用macOS终端</a></li>
<li><a target="_blank" rel="noopener" href="https://flaviocopes.com/bash/">重击壳</a></li>
</ul>
<p>现在，您已经拥有Node，已更新为最新版本，并且<code>npm</code>已经设置好了！</p>
<p>我们现在可以选择2条路线：使用<code>create-next-app</code>或经典方法，其中涉及手动安装和设置Next应用。</p>
<h3 id="使用create-next-app"><a href="#使用create-next-app" class="headerlink" title="使用create-next-app"></a>使用create-next-app</h3><p>如果您熟悉<a target="_blank" rel="noopener" href="https://flaviocopes.com/react-create-react-app/"><code>create-react-app</code></a>，<code>create-next-app</code>则是一样的-顾名思义，它创建的是Next应用而不是React应用。</p>
<p>我假设您已经安装了Node.js，该版本从5.2版（撰写本文时已经2年多）开始捆绑了<a target="_blank" rel="noopener" href="https://flaviocopes.com/npx/"><code>npx</code>命令</a>。这个方便的工具使我们能够下载并执行JavaScript命令，并且我们将像这样使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-next-app</span><br></pre></td></tr></table></figure>

<p>该命令要求应用程序名称（以及你使用该名称创建一个新的文件夹），然后下载它需要的所有包（<code>react</code>，<code>react-dom</code>，<code>next</code>），设置<code>package.json</code>到：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-14-at-16.46.47.png"></p>
<p>您可以通过运行<code>npm run dev</code>以下命令立即运行示例应用程序：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-14-at-16.46.32.png"></p>
<p>这是<a target="_blank" rel="noopener" href="http://localhost:3000/">http：// localhost：3000</a>上的结果：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-14-at-16.47.17.png"></p>
<p>这是启动Next.js应用程序的推荐方法，因为它为您提供了结构和示例代码。除了默认的示例应用程序之外，还有更多其他功能。您可以使用选项使用存储在<a target="_blank" rel="noopener" href="https://github.com/zeit/next.js/tree/canary/examples">https://github.com/zeit/next.js/tree/canary/examples</a>中的任何示例<code>--example</code>。例如，尝试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-next-app --example blog-starter</span><br></pre></td></tr></table></figure>
<p>这也为您提供了一个立即可用的博客实例，并且语法突出显示了：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-14-at-17.13.29.png"></p>
<h3 id="手动创建Next-js应用"><a href="#手动创建Next-js应用" class="headerlink" title="手动创建Next.js应用"></a>手动创建Next.js应用</h3><p><code>create-next-app</code>如果您想从头开始创建Next应用程序，则可以避免。方法如下：在您喜欢的任何位置（例如在主文件夹中）创建一个空文件夹，然后进入该文件夹：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir nextjs</span><br><span class="line">cd nextjs</span><br></pre></td></tr></table></figure>

<p>并创建您的第一个Next项目目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir firstproject</span><br><span class="line">cd firstproject</span><br></pre></td></tr></table></figure>

<p>现在使用<code>npm</code>命令将其初始化为Node项目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>

<p>该<code>-y</code>选项告诉<code>npm</code>您使用项目的默认设置，并填充示例<code>package.json</code>文件。</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-16.59.21.png"></p>
<p>现在安装Next和React：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install next react react-dom</span><br></pre></td></tr></table></figure>

<p>您的项目文件夹现在应具有2个文件：</p>
<ul>
<li><code>package.json</code>（<a target="_blank" rel="noopener" href="https://flaviocopes.com/package-json/">参见我的教程</a>）</li>
<li><code>package-lock.json</code>（<a target="_blank" rel="noopener" href="https://flaviocopes.com/package-lock-json/">请参阅我关于package-lock的教程</a>）</li>
</ul>
<p>和<code>node_modules</code>文件夹。</p>
<p>使用您喜欢的编辑器打开项目文件夹。我最喜欢的编辑器是<a target="_blank" rel="noopener" href="https://flaviocopes.com/vscode/">VS Code</a>。如果您有安装，可以运行<code>code .</code>在终端打开编辑器中的当前文件夹（如果该命令不为你工作，看到<a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/setup/mac#_launching-from-the-command-line">这个</a>）</p>
<p>Open <code>package.json</code>，现在具有以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;firstproject&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;dependencies&quot;:  &#123;</span><br><span class="line">    &quot;next&quot;: &quot;^9.1.2&quot;,</span><br><span class="line">    &quot;react&quot;: &quot;^16.11.0&quot;,</span><br><span class="line">    &quot;react-dom&quot;: &quot;^16.11.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并将该<code>scripts</code>部分替换为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;dev&quot;: &quot;next&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;next build&quot;,</span><br><span class="line">  &quot;start&quot;: &quot;next start&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加Next.js构建命令，我们将很快使用它。</p>
<p>提示：用于<code>&quot;dev&quot;: &quot;next -p 3001&quot;,</code>更改端口并在此示例中在端口3001上运行。</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-17.01.03.png"></p>
<p>现在创建一个<code>pages</code>文件夹，并添加一个<code>index.js</code>文件。</p>
<p>在这个文件中，让我们创建第一个React组件。</p>
<p>我们将使用它作为默认导出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const Index &#x3D; () &#x3D;&gt; (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Home page&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export default Index</span><br></pre></td></tr></table></figure>

<p>现在使用终端，运行<code>npm run dev</code>以启动Next开发服务器。</p>
<p>这将使该应用程序在本地主机上的端口3000上可用。</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-11.24.02.png"></p>
<p>在浏览器中打开<a target="_blank" rel="noopener" href="http://localhost:3000/">http：// localhost：3000</a>进行查看。</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-11.24.23.png"></p>
<h2 id="查看源代码以确认SSR是否正常运行"><a href="#查看源代码以确认SSR是否正常运行" class="headerlink" title="查看源代码以确认SSR是否正常运行"></a>查看源代码以确认SSR是否正常运行</h2><p>现在，让我们检查应用程序是否正常运行。这是一个Next.js应用程序，因此应该在<strong>服务器端呈现</strong>。</p>
<p>这是Next.js的主要卖点之一：如果我们使用Next.js创建一个网站，则该网站页面将呈现在服务器上，该服务器会将HTML传递给浏览器。</p>
<p>这具有3个主要优点：</p>
<ul>
<li>客户端不需要实例化React来渲染，这使网站对您的用户更快。</li>
<li>搜索引擎将为页面编制索引，而无需运行客户端JavaScript。Google开始做的事情，但公开承认这是一个较慢的过程（如果您想获得良好的排名，则应该尽可能地帮助Google）。</li>
<li>您可以拥有社交媒体元标记，可用于添加预览图像，自定义在Facebook，Twitter等上共享的任何页面的标题和描述。</li>
</ul>
<p>让我们查看应用程序的源代码。<br>使用Chrome浏览器，您可以右键单击页面中的任意位置，然后按<strong>查看页面源</strong>。</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-11.33.10.png"></p>
<p>如果您查看页面的源代码，您将<code>&lt;div&gt;&lt;h1&gt;Home page&lt;/h1&gt;&lt;/div&gt;</code>在HTML中看到该代码段<code>body</code>以及一堆JavaScript文件-该应用程序捆绑包。</p>
<p>我们不需要进行任何设置，SSR（服务器端渲染）已经在为我们工作。</p>
<p>React应用程序将在客户端上启动，并且将成为使用客户端渲染推动交互（例如单击链接）的一种方式。但是重新加载页面会从服务器重新加载页面。使用Next.js，浏览器内部的结果应该没有差异-服务器呈现的页面应该看起来完全像客户端呈现的页面。</p>
<h2 id="该应用程序捆绑"><a href="#该应用程序捆绑" class="headerlink" title="该应用程序捆绑"></a>该应用程序捆绑</h2><p>当查看页面源代码时，我们看到一堆JavaScript文件正在加载：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-11.34.41.png"></p>
<p>让我们开始将代码放入<a target="_blank" rel="noopener" href="https://htmlformatter.com/">HTML格式化程序中，</a>以使其格式更好，以便我们人类可以更好地了解它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charSet&#x3D;&quot;utf-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,m_inimum-scale&#x3D;1,initial-scale&#x3D;1&quot; &#x2F;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;next-head-count&quot; content&#x3D;&quot;2&quot; &#x2F;&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;preload&quot; href&#x3D;&quot;&#x2F;_next&#x2F;static&#x2F;development&#x2F;pages&#x2F;index.js?ts&#x3D;1572863116051&quot; as&#x3D;&quot;script&quot; &#x2F;&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;preload&quot; href&#x3D;&quot;&#x2F;_next&#x2F;static&#x2F;development&#x2F;pages&#x2F;_app.js?ts&#x3D;1572863116051&quot; as&#x3D;&quot;script&quot; &#x2F;&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;preload&quot; href&#x3D;&quot;&#x2F;_next&#x2F;static&#x2F;runtime&#x2F;webpack.js?ts&#x3D;1572863116051&quot; as&#x3D;&quot;script&quot; &#x2F;&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;preload&quot; href&#x3D;&quot;&#x2F;_next&#x2F;static&#x2F;runtime&#x2F;main.js?ts&#x3D;1572863116051&quot; as&#x3D;&quot;script&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;__next&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;Home page&lt;&#x2F;h1&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;_next&#x2F;static&#x2F;development&#x2F;dll&#x2F;dll_01ec57fc9b90d43b98a8.js?ts&#x3D;1572863116051&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script id&#x3D;&quot;__NEXT_DATA__&quot; type&#x3D;&quot;application&#x2F;json&quot;&gt;&#123;&quot;dataManager&quot;:&quot;[]&quot;,&quot;props&quot;:&#123;&quot;pageProps&quot;:&#123;&#125;&#125;,&quot;page&quot;:&quot;&#x2F;&quot;,&quot;query&quot;:&#123;&#125;,&quot;buildId&quot;:&quot;development&quot;,&quot;nextExport&quot;:true,&quot;autoExport&quot;:true&#125;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script async&#x3D;&quot;&quot; data-next-page&#x3D;&quot;&#x2F;&quot; src&#x3D;&quot;&#x2F;_next&#x2F;static&#x2F;development&#x2F;pages&#x2F;index.js?ts&#x3D;1572863116051&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script async&#x3D;&quot;&quot; data-next-page&#x3D;&quot;&#x2F;_app&quot; src&#x3D;&quot;&#x2F;_next&#x2F;static&#x2F;development&#x2F;pages&#x2F;_app.js?ts&#x3D;1572863116051&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;_next&#x2F;static&#x2F;runtime&#x2F;webpack.js?ts&#x3D;1572863116051&quot; async&#x3D;&quot;&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;_next&#x2F;static&#x2F;runtime&#x2F;main.js?ts&#x3D;1572863116051&quot; async&#x3D;&quot;&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>我们有4个JavaScript文件被声明为预加载到中<code>head</code>，使用<code>rel=&quot;preload&quot; as=&quot;script&quot;</code>：</p>
<ul>
<li><code>/_next/static/development/pages/index.js</code> （96个本地代码）</li>
<li><code>/_next/static/development/pages/_app.js</code> （5900 LOC）</li>
<li><code>/_next/static/runtime/webpack.js</code> （LOC 939）</li>
<li><code>/_next/static/runtime/main.js</code> （LOC为12k）</li>
</ul>
<p>这告诉浏览器在正常渲染流程开始之前尽快开始加载这些文件。没有这些脚本，脚本将被额外加载，这将提高页面加载性能。</p>
<p>然后，将这4个文件<code>body</code>与<code>/_next/static/development/dll/dll_01ec57fc9b90d43b98a8.js</code>（31k LOC）和一个JSON代码段一起加载到的末尾，该JSON代码段为页面数据设置了一些默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id&#x3D;&quot;__NEXT_DATA__&quot; type&#x3D;&quot;application&#x2F;json&quot;&gt;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;dataManager&quot;: &quot;[]&quot;,</span><br><span class="line">  &quot;props&quot;: &#123;</span><br><span class="line">    &quot;pageProps&quot;:  &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;page&quot;: &quot;&#x2F;&quot;,</span><br><span class="line">  &quot;query&quot;: &#123;&#125;,</span><br><span class="line">  &quot;buildId&quot;: &quot;development&quot;,</span><br><span class="line">  &quot;nextExport&quot;: true,</span><br><span class="line">  &quot;autoExport&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>加载的4个捆绑包文件已经实现了一项称为代码拆分的功能。该<code>index.js</code>文件提供了为路线<code>index</code>提供服务的组件所需的代码<code>/</code>，如果我们有更多的页面，我们将为每个页面提供更多的包，然后仅在需要时才进行加载-为页面提供更高性能的加载时间。</p>
<h2 id="右下角的图标是什么？"><a href="#右下角的图标是什么？" class="headerlink" title="右下角的图标是什么？"></a>右下角的图标是什么？</h2><p>您是否在页面右下方看到了一个小图标，看起来像闪电？</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-13.21.42.png"></p>
<p>如果将其悬停，它将显示“ Prerendered Page”：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-13.21.46.png"></p>
<p>该图标（_仅在开发模式下才可见）_告诉您该页面符合自动静态优化的条件，这基本上意味着该页面不依赖于在调用时需要获取的数据，并且可以按以下方式进行预渲染和构建：在构建时（当我们运行时<code>npm run build</code>）的静态HTML文件。</p>
<p>接下来可以通过缺少<code>getInitialProps()</code>附加到页面组件的方法来确定这一点。</p>
<p>在这种情况下，我们的页面甚至可以更快，因为它将作为HTML文件静态提供，而不是通过生成HTML输出的Node.js服务器提供。</p>
<p>可能会出现在它旁边的另一个有用图标，或者代替它在未呈现页面上显示的是一个动画三角形：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-14-at-14.56.21.png"></p>
<p>这是一个编译指示符，当您保存页面并且Next.js正在编译应用程序之前，此提示会在热代码重新加载开始之前自动显示在应用程序中。</p>
<p>这是一种非常好的方法，可以立即确定应用程序是否已经编译，您可以测试正在处理的应用程序的一部分。</p>
<h2 id="安装React-Developer-Tools"><a href="#安装React-Developer-Tools" class="headerlink" title="安装React Developer Tools"></a>安装React Developer Tools</h2><p>Next.js基于React，所以我们绝对需要安装（如果您尚未安装）一个非常有用的工具是React Developer Tools。</p>
<p>React Developer Tools是可用于<a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en">Chrome</a>和<a target="_blank" rel="noopener" href="https://addons.mozilla.org/en-US/firefox/addon/react-devtools/">Firefox</a>的基本工具，可用于检查React应用程序。</p>
<p>现在，React开发人员工具并不特定于Next.js，但是我想介绍它们，因为您可能不是100％熟悉React提供的所有工具。最好花一点时间来调试工具，而不要假设您已经了解它们。</p>
<p>他们提供了一个检查器，该检查器揭示了构建页面的React组件树，对于每个组件，您都可以检查道具，状态，钩子等等。</p>
<p>一旦安装了React Developer Tools，就可以打开常规的浏览器devtools（在Chrome中，右键单击页面，然后单击<code>Inspect</code>），您会发现2个新面板：<strong>Components</strong>和<strong>Profiler</strong>。</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-14.26.12.png"></p>
<p>如果将鼠标移到组件上，则会在页面中看到，浏览器将选择该组件渲染的部分。</p>
<p>如果您在树中选择任何组件，则右侧面板将显示<strong>对父组件</strong>的引用以及传递给它的道具：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-14.27.05.png"></p>
<p>您可以通过单击组件名称来轻松导航。</p>
<p>您可以单击“开发人员工具”工具栏中的眼睛图标来检查DOM元素，如果您使用的是第一个图标（带有鼠标图标（通常位于类似的常规DevTools图标下）），则可以将元素悬停在浏览器用户界面以直接选择呈现它的React组件。</p>
<p>您可以使用该<code>bug</code>图标将组件数据记录到控制台。</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-14.31.25.png"></p>
<p>这非常棒，因为一旦在其中打印了数据，就可以右键单击任何元素，然后按“存储为全局变量”。例如，在这里，我使用<code>url</code>prop进行操作，并且可以使用分配给它的临时变量在控制台中对其进行检查<code>temp1</code>：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-14.40.22.png"></p>
<p>使用由Next.js在开发模式下自动加载的<strong>Source Maps</strong>，从Components面板中单击<code>&lt;&gt;</code>代码，然后DevTools将切换到Source面板，向我们显示组件源代码：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-14.41.33.png"></p>
<p>如果可能的话，“ <strong>探查器”</strong>选项卡更加出色。它使我们能够在应用程序中<strong>记录交互</strong>，并观察发生了什么。我无法显示一个示例，因为它至少需要2个组件才能创建交互，而现在只有一个。稍后再说。</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-14.42.24.png"></p>
<p>我使用Chrome显示了所有屏幕截图，但是React Developer Tools在Firefox中的工作方式相同：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-14.45.20.png"></p>
<h2 id="您可以使用的其他调试技术"><a href="#您可以使用的其他调试技术" class="headerlink" title="您可以使用的其他调试技术"></a>您可以使用的其他调试技术</h2><p>除了对构建Next.js应用程序必不可少的React Developer Tools之外，我还要强调两种调试Next.js应用程序的方法。</p>
<p>首先显然是<code>console.log()</code>所有<a target="_blank" rel="noopener" href="https://flaviocopes.com/console-api/">其他控制台API</a>工具。Next应用程序的工作方式将使日志语句在浏览器控制台中或在您使用Next启动Next的终端中运行<code>npm run dev</code>。</p>
<p>特别是，如果页面是从服务器加载的，则将URL指向服务器时，或者单击刷新按钮/ cmd / ctrl-R，则任何控制台日志记录都会在终端中发生。</p>
<p>通过单击鼠标进行的后续页面转换将使所有控制台记录都发生在浏览器内部。</p>
<p>请记住，如果您对丢失日志感到惊讶。</p>
<p>另一个必不可少的工具就是<code>debugger</code>声明。将此语句添加到组件将使浏览器暂停呈现页面：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-15.10.32.png"></p>
<p>真棒，因为现在您可以使用浏览器调试器检查值并一次一行运行您的应用程序。</p>
<p>您还可以使用VS Code调试器来调试服务器端代码。我提到了这项技术和<a target="_blank" rel="noopener" href="https://github.com/Microsoft/vscode-recipes/tree/master/Next-js">本教程</a>来进行设置。</p>
<h2 id="在网站上添加第二页"><a href="#在网站上添加第二页" class="headerlink" title="在网站上添加第二页"></a>在网站上添加第二页</h2><p>现在我们已经掌握了可用于帮助开发Next.js应用程序的工具，让我们从剩下的第一个应用程序继续：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-13.21.42-1.png"></p>
<p>我想在此网站上添加第二页，即博客。它会送入<code>/blog</code>，并且暂时将只包含一个简单的静态页面，就像我们的第一个<code>index.js</code>组件一样：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-15.39.40.png"></p>
<p>保存新文件后，<code>npm run dev</code>已经运行的进程已经能够呈现页面，而无需重新启动它。</p>
<p>当我们点击URL <a target="_blank" rel="noopener" href="http://localhost:3000/blog">http：// localhost：3000 / blog时，</a>我们将打开新页面：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-15.41.39.png"></p>
<p>这是终端告诉我们的内容：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-15.41.03.png"></p>
<p>现在，URL仅<code>/blog</code>取决于文件名及其在<code>pages</code>文件夹下的位置。</p>
<p>您可以创建一个<code>pages/hey/ho</code>页面，该页面将显示在URL <a target="_blank" rel="noopener" href="http://localhost:3000/hey/ho">http：// localhost：3000 / hey / ho上</a>。</p>
<p>对于URL而言，无所谓的是文件内的组件名称。</p>
<p>尝试浏览页面的源代码，当从服务器加载页面时，它将<code>/_next/static/development/pages/blog.js</code>作为加载的包之一列出，而<code>/_next/static/development/pages/index.js</code>不像主页中那样。这是因为通过自动代码拆分，我们不需要提供主页的捆绑包。只是用于博客页面的捆绑软件。</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-16.24.53.png"></p>
<p>我们也可以只从导出一个匿名函数<code>blog.js</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default () &#x3D;&gt; (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Blog&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>或者，如果您更喜欢非箭头函数语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default function() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Blog&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链接两个页面"><a href="#链接两个页面" class="headerlink" title="链接两个页面"></a>链接两个页面</h2><p>现在我们有2个页面，分别由<code>index.js</code>和定义<code>blog.js</code>，我们可以介绍链接。</p>
<p>页面内的普通HTML链接是使用<code>a</code>标记完成的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;&#x2F;blog&quot;&gt;Blog&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>我们无法在Next.js中做到这一点。</p>
<p>为什么？我们在技术上_可以_，当然，因为这是Web和_在网络上的事情从来没有突破_（这就是为什么我们仍然可以使用<code>&lt;marquee&gt;</code>标签，但使用接下来的主要好处之一是，一旦页面加载，转换到其他页面借助客户端渲染，速度非常快。</p>
<p>如果使用普通<code>a</code>链接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Index &#x3D; () &#x3D;&gt; (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Home page&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;a href&#x3D;&#39;&#x2F;blog&#39;&gt;Blog&lt;&#x2F;a&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export default Index</span><br></pre></td></tr></table></figure>

<p>现在打开<strong>DevTools</strong>，尤其是“ <strong>网络”面板</strong>。第一次加载时，<code>http://localhost:3000/</code>我们会加载所有页面包：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-16.26.00.png"></p>
<p>现在，如果您单击“保留日志”按钮（以避免清除“网络”面板），然后单击“博客”链接，将发生以下情况：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-16.27.16.png"></p>
<p>我们再次从服务器获得了所有JavaScript！但是..如果我们已经有了JavaScript，就不需要所有的JavaScript。我们只需要<code>blog.js</code>页面捆绑包，这是页面上唯一的新捆绑包。</p>
<p>要解决此问题，我们使用Next提供的名为Link的组件。</p>
<p>我们导入它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Link from &#39;next&#x2F;link&#39;</span><br></pre></td></tr></table></figure>

<p>然后我们用它来包装我们的链接，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import Link from &#39;next&#x2F;link&#39;</span><br><span class="line"></span><br><span class="line">const Index &#x3D; () &#x3D;&gt; (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Home page&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;Link href&#x3D;&#39;&#x2F;blog&#39;&gt;</span><br><span class="line">      &lt;a&gt;Blog&lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;Link&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export default Index</span><br></pre></td></tr></table></figure>

<p>现在，如果您重试我们以前做过的事情，<code>blog.js</code>当我们移至博客页面时，您将能够看到仅加载了捆绑软件：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-04-at-16.35.18.png"></p>
<p>而且页面加载的速度比以前快，该标签上的浏览器常规微调框甚至都没有出现。如您所见，URL发生了变化。这与浏览器的<a target="_blank" rel="noopener" href="https://flaviocopes.com/history-api/">History API</a>无缝配合。</p>
<p>这是实际的客户端渲染。</p>
<p>如果现在按下返回按钮怎么办？什么都没有加载，因为浏览器仍然具有旧的<code>index.js</code>捆绑软件，可以加载<code>/index</code>路由。都是自动的！</p>
<h2 id="路由器的动态内容"><a href="#路由器的动态内容" class="headerlink" title="路由器的动态内容"></a>路由器的动态内容</h2><p>在上一章中，我们看到了如何将主页链接到博客页面。</p>
<p>博客是Next.js的一个很好的用例，我们将在本章中通过添加<strong>博客文章</strong>继续进行探讨。</p>
<p>博客文章具有动态URL。例如，标题为“ Hello World”的帖子可能具有URL <code>/blog/hello-world</code>。标题为“我的第二条帖子”的帖子可能具有URL <code>/blog/my-second-post</code>。</p>
<p>此内容是动态的，可以从数据库，降价文件或更多内容中获取。</p>
<p>Next.js可以基于<strong>动态URL</strong>提供动态内容。</p>
<p>我们通过使用<code>[]</code>语法创建动态页面来创建动态URL 。</p>
<p>怎么样？我们添加一个<code>pages/blog/[id].js</code>文件。该文件将处理下的所有动态URL <code>/blog/</code>路径，就像那些我们上面提到的：<code>/blog/hello-world</code>，<code>/blog/my-second-post</code>等等。</p>
<p>在文件名中，<code>[id]</code>内部的任何的动态将在内部把方括号方式<code>id</code>的参数<strong>查询属性</strong>的的<strong>路由器</strong>。</p>
<p>好的，一次太多了。</p>
<p>什么是<strong>路由器</strong>？</p>
<p>路由器是Next.js提供的库。</p>
<p>我们从导入<code>next/router</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useRouter &#125; from &#39;next&#x2F;router&#39;</span><br></pre></td></tr></table></figure>

<p>一旦有了<code>useRouter</code>，我们将使用以下方法实例化路由器对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; useRouter()</span><br></pre></td></tr></table></figure>

<p>一旦有了该路由器对象，就可以从中提取信息。</p>
<p>具体来说，我们可以<code>[id].js</code>通过访问来获取文件中URL的动态部分<code>router.query.id</code>。</p>
<p>动态部分也可以只是URL的一部分，例如<code>post-[id].js</code>。</p>
<p>因此，让我们继续将所有这些内容应用到实践中。</p>
<p>创建文件<code>pages/blog/[id].js</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useRouter &#125; from &#39;next&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">export default () &#x3D;&gt; &#123;</span><br><span class="line">  const router &#x3D; useRouter()</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;Blog post&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;p&gt;Post id: &#123;router.query.id&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，如果您转到<code>http://localhost:3000/blog/test</code>路由器，应该会看到以下内容：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-05-at-16.41.32.png"></p>
<p>我们可以使用此<code>id</code>参数从帖子列表中收集帖子。例如，来自数据库。为了简单起见，我们将<code>posts.json</code>在项目根文件夹中添加一个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;test&quot;: &#123;</span><br><span class="line">    &quot;title&quot;: &quot;test post&quot;,</span><br><span class="line">    &quot;content&quot;: &quot;Hey some post content&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;second&quot;: &#123;</span><br><span class="line">    &quot;title&quot;: &quot;second post&quot;,</span><br><span class="line">    &quot;content&quot;: &quot;Hey this is the second post content&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以导入它并从<code>id</code>键中查找帖子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useRouter &#125; from &#39;next&#x2F;router&#39;</span><br><span class="line">import posts from &#39;..&#x2F;..&#x2F;posts.json&#39;</span><br><span class="line"></span><br><span class="line">export default () &#x3D;&gt; &#123;</span><br><span class="line">  const router &#x3D; useRouter()</span><br><span class="line"></span><br><span class="line">  const post &#x3D; posts[router.query.id]</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;post.title&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;p&gt;&#123;post.content&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新加载页面应向我们显示以下结果：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-05-at-16.44.07.png"></p>
<p>但这不是！相反，我们在控制台中出现错误，在浏览器中也出现错误：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-05-at-18.18.17.png"></p>
<p>为什么？因为在渲染过程中初始化组件时，数据还不存在。在下一课中，我们将了解如何使用getInitialProps将数据提供给组件。</p>
<p>现在，<code>if (!post) return &lt;p&gt;&lt;/p&gt;</code>在返回JSX之前添加一点检查：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useRouter &#125; from &#39;next&#x2F;router&#39;</span><br><span class="line">import posts from &#39;..&#x2F;..&#x2F;posts.json&#39;</span><br><span class="line"></span><br><span class="line">export default () &#x3D;&gt; &#123;</span><br><span class="line">  const router &#x3D; useRouter()</span><br><span class="line"></span><br><span class="line">  const post &#x3D; posts[router.query.id]</span><br><span class="line">  if (!post) return &lt;p&gt;&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;post.title&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;p&gt;&#123;post.content&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在一切正常。最初，在没有动态<code>router.query.id</code>信息的情况下渲染组件。呈现后，Next.js会使用查询值触发更新，并且页面显示正确的信息。</p>
<p>而且，如果您查看源<code>&lt;p&gt;</code>代码，则HTML中有一个空标记：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-05-at-18.20.58.png"></p>
<p>我们将尽快解决无法实施SSR的问题，这将损害我们的用户，SEO和社交共享的加载时间，正如我们已经讨论的那样。</p>
<p>我们可以通过列出以下帖子中的内容来完善博客示例<code>pages/blog.js</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import posts from &#39;..&#x2F;posts.json&#39;</span><br><span class="line"></span><br><span class="line">const Blog &#x3D; () &#x3D;&gt; (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Blog&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;Object.entries(posts).map((value, index) &#x3D;&gt; &#123;</span><br><span class="line">        return &lt;li key&#x3D;&#123;index&#125;&gt;&#123;value[1].title&#125;&lt;&#x2F;li&gt;</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export default Blog</span><br></pre></td></tr></table></figure>

<p>我们可以将它们链接到个人页面后，通过导入<code>Link</code>从<code>next/link</code>使用它的职位循环内：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import Link from &#39;next&#x2F;link&#39;</span><br><span class="line">import posts from &#39;..&#x2F;posts.json&#39;</span><br><span class="line"></span><br><span class="line">const Blog &#x3D; () &#x3D;&gt; (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Blog&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;Object.entries(posts).map((value, index) &#x3D;&gt; &#123;</span><br><span class="line">        return (</span><br><span class="line">          &lt;li key&#x3D;&#123;index&#125;&gt;</span><br><span class="line">            &lt;Link href&#x3D;&#39;&#x2F;blog&#x2F;[id]&#39; as&#x3D;&#123;&#39;&#x2F;blog&#x2F;&#39; + value[0]&#125;&gt;</span><br><span class="line">              &lt;a&gt;&#123;value[1].title&#125;&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;&#x2F;Link&gt;</span><br><span class="line">          &lt;&#x2F;li&gt;</span><br><span class="line">        )</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export default Blog</span><br></pre></td></tr></table></figure>
<h2 id="预取-1"><a href="#预取-1" class="headerlink" title="预取"></a>预取</h2><p>前面我曾提到过如何使用<code>Link</code>Next.js组件在两个页面之间创建链接，当您使用它时，Next.js <strong>透明地</strong>为我们<strong>处理前端路由</strong>，因此当用户单击链接时，前端会负责显示新页面。网页，而不会触发新的客户端/服务器请求和响应周期，这通常在网页中会发生。</p>
<p>使用时，Next.js还会为您做另一件事<code>Link</code>。</p>
<p>只要包含在<code>&lt;Link&gt;</code>其中的元素出现在视口中（这意味着它对网站用户可见），只要它是本地链接（在您的网站上），Next.js就会预取它指向的URL，从而使应用程序变得超快给观看者。</p>
<p>此行为仅在<strong>生产模式下</strong>触发（我们将在稍后进行深入讨论），这意味着如果使用来运行该应用程序，则必须停止该应用程序<code>npm run dev</code>，使用来编译生产捆绑包，<code>npm run build</code>然后使用<code>npm run start</code>来运行它   。</p>
<p>使用DevTools中的网络检查器，您会注意到页面加载时折叠上方的所有链接在页面<code>load</code>上触发事件后立即开始预提取（在页面完全加载时触发，并在<code>DOMContentLoaded</code>事件发生后触发））。</p>
<p><code>Link</code>用户滚动并滚动时，将预取视口中没有的其他任何标签</p>
<p>高速连接（Wifi和3g +连接）上的自动预取是自动的，除非浏览器发送<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Save-Data"><code>Save-Data</code>HTTP Header</a>。</p>
<p>您可以<code>Link</code>通过将<code>prefetch</code>prop 设置为来退出预取单个实例<code>false</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link href&#x3D;&quot;&#x2F;a-link&quot; prefetch&#x3D;&#123;false&#125;&gt;</span><br><span class="line">  &lt;a&gt;A link&lt;&#x2F;a&gt;</span><br><span class="line">&lt;&#x2F;Link&gt;</span><br></pre></td></tr></table></figure>
<h2 id="使用路由器检测活动链接"><a href="#使用路由器检测活动链接" class="headerlink" title="使用路由器检测活动链接"></a>使用路由器检测活动链接</h2><p>使用链接时，一个非常重要的功能是确定当前URL，尤其是为活动链接分配一个类，因此我们可以将其样式设置为与其他URL不同。</p>
<p>例如，这在您的网站标题中特别有用。</p>
<p>提供的Next.js默认<code>Link</code>组件<code>next/link</code>不会自动为我们执行此操作。</p>
<p>我们可以自己创建一个Link组件，然后将其存储<code>Link.js</code>在Components文件夹中的文件中，然后导入它而不是default <code>next/link</code>。</p>
<p>在此组件中，我们将首先导入React from <code>react</code>，Link from <code>next/link</code>和<code>useRouter</code>钩子from <code>next/router</code>。</p>
<p>在组件内部，我们确定当前路径名是否与<code>href</code>组件的prop 相匹配，如果是，则将<code>selected</code>类附加到子级。</p>
<p>我们最终使用以下方法通过更新后的类返回此子级<code>React.cloneElement()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;</span><br><span class="line">import Link from &#39;next&#x2F;link&#39;</span><br><span class="line">import &#123; useRouter &#125; from &#39;next&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">export default (&#123; href, children &#125;) &#x3D;&gt; &#123;</span><br><span class="line">  const router &#x3D; useRouter()</span><br><span class="line"></span><br><span class="line">  let className &#x3D; children.props.className || &#39;&#39;</span><br><span class="line">  if (router.pathname &#x3D;&#x3D;&#x3D; href) &#123;</span><br><span class="line">    className &#x3D; &#96;$&#123;className&#125; selected&#96;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &lt;Link href&#x3D;&#123;href&#125;&gt;&#123;React.cloneElement(children, &#123; className &#125;)&#125;&lt;&#x2F;Link&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-next-router"><a href="#使用-next-router" class="headerlink" title="使用 next/router"></a>使用 <code>next/router</code></h2><p>我们已经了解了如何使用Link组件在Next.js应用程序中声明性地处理路由。</p>
<p>在JSX中管理路由确实非常方便，但是有时您需要以编程方式触发路由更改。</p>
<p>在这种情况下，您可以直接访问<code>next/router</code>软件包中提供的Next.js路由器，并调用其<code>push()</code>方法。</p>
<p>这是访问路由器的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useRouter &#125; from &#39;next&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">export default () &#x3D;&gt; &#123;</span><br><span class="line">  const router &#x3D; useRouter()</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦通过调用获得了路由器对象<code>useRouter()</code>，就可以使用其方法。</p>
<p>这是客户端路由器，因此方法仅应在面向前端的代码中使用。确保这一点的最简单方法是将调用包装在<code>useEffect()</code>React钩子中，或包装<code>componentDidMount()</code>在React有状态组件中。</p>
<p>您可能最常使用的是<code>push()</code>和<code>prefetch()</code>。</p>
<p><code>push()</code> 允许我们在前端以编程方式触发URL更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.push(&#39;&#x2F;login&#39;)</span><br></pre></td></tr></table></figure>

<p><code>prefetch()</code>允许我们以编程方式预取URL，当我们没有<code>Link</code>自动为我们处理预取代码的标记时，此功能非常有用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.prefetch(&#39;&#x2F;login&#39;)</span><br></pre></td></tr></table></figure>

<p>完整示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useRouter &#125; from &#39;next&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">export default () &#x3D;&gt; &#123;</span><br><span class="line">  const router &#x3D; useRouter()</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    router.prefetch(&#39;&#x2F;login&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您也可以使用路由器侦听<a target="_blank" rel="noopener" href="https://nextjs.org/docs#router-events">路由更改事件</a>。</p>
<h2 id="使用getInitialProps将数据馈送到组件"><a href="#使用getInitialProps将数据馈送到组件" class="headerlink" title="使用getInitialProps将数据馈送到组件"></a>使用getInitialProps将数据馈送到组件</h2><p>在上一章中，动态生成帖子页面存在一个问题，因为该组件需要预先提供一些数据，并且当我们尝试从JSON文件获取数据时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useRouter &#125; from &#39;next&#x2F;router&#39;</span><br><span class="line">import posts from &#39;..&#x2F;..&#x2F;posts.json&#39;</span><br><span class="line"></span><br><span class="line">export default () &#x3D;&gt; &#123;</span><br><span class="line">  const router &#x3D; useRouter()</span><br><span class="line"></span><br><span class="line">  const post &#x3D; posts[router.query.id]</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;post.title&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;p&gt;&#123;post.content&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们收到此错误：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-05-at-18.18.17-1.png"></p>
<p>我们该如何解决？以及如何使SSR用于动态路由？</p>
<p>我们必须使用一个<code>getInitialProps()</code>附加到组件的特殊功能为组件提供道具。</p>
<p>为此，首先我们将组件命名为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Post &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Post</span><br></pre></td></tr></table></figure>

<p>然后我们添加功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const Post &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Post.getInitialProps &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Post</span><br></pre></td></tr></table></figure>

<p>此函数将一个对象作为其参数，其中包含多个属性。特别是，我们现在感兴趣的是获取<code>query</code>对象，这是我们之前用于获取帖子ID的对象。</p>
<p>因此，我们可以使用_对象分解_语法来获取它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Post.getInitialProps &#x3D; (&#123; query &#125;) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以从该函数返回帖子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Post.getInitialProps &#x3D; (&#123; query &#125;) &#x3D;&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    post: posts[query.id]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以删除的导入<code>useRouter</code>，然后从<code>props</code>传递给<code>Post</code>组件的属性中获取发布：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import posts from &#39;..&#x2F;..&#x2F;posts.json&#39;</span><br><span class="line"></span><br><span class="line">const Post &#x3D; props &#x3D;&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;&#123;props.post.title&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;p&gt;&#123;props.post.content&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Post.getInitialProps &#x3D; (&#123; query &#125;) &#x3D;&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    post: posts[query.id]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Post</span><br></pre></td></tr></table></figure>

<p>现在将没有错误，并且SSR将按预期工作，如您所见，查看视图源：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-05-at-18.53.02.png"></p>
<p><code>getInitialProps</code>当我们<code>Link</code>像以前一样使用组件导航到新页面时，该功能将在服务器端和客户端执行。</p>
<p>重要的是要注意，<code>getInitialProps</code>除了<code>query</code>对象之外，它还接收其他上下文属性：</p>
<ul>
<li><code>pathname</code>：<code>path</code>URL部分</li>
<li><code>asPath</code> -实际路径（包括查询）的字符串显示在浏览器中</li>
</ul>
<p>在调用的情况下<code>http://localhost:3000/blog/test</code>将分别导致：</p>
<ul>
<li><code>/blog/[id]</code></li>
<li><code>/blog/test</code></li>
</ul>
<p>对于服务器端渲染，它还将收到：</p>
<ul>
<li><code>req</code>：HTTP请求对象</li>
<li><code>res</code>：HTTP响应对象</li>
<li><code>err</code>：错误对象</li>
</ul>
<p><code>req``res</code>如果您已完成任何Node.js编码，将会很熟悉。</p>
<h2 id="的CSS"><a href="#的CSS" class="headerlink" title="的CSS"></a>的CSS</h2><p>我们如何在Next.js中设置React组件的样式？</p>
<p>我们有很多自由，因为我们可以使用我们喜欢的任何库。</p>
<p>但是Next.js是<a target="_blank" rel="noopener" href="https://github.com/zeit/styled-jsx"><code>styled-jsx</code></a>内置的，因为那是由从事Next.js的同一个人构建的库。</p>
<p>这是一个非常酷的库，为我们提供了范围内的CSS，这对于可维护性非常有用，因为CSS仅会影响所应用的组件。</p>
<p>我认为这是编写CSS的好方法，无需应用其他会增加复杂性的库或预处理器。</p>
<p>要将CSS添加到Next.js中的React组件中，我们将其插入JSX的一个片段中，该片段以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style jsx&gt;&#123;&#96;</span><br></pre></td></tr></table></figure>

<p>并以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#125;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>在这个怪异的块中，我们编写普通的CSS，就像在<code>.css</code>文件中一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style jsx&gt;&#123;&#96;</span><br><span class="line">  h1 &#123;</span><br><span class="line">    font-size: 3rem;</span><br><span class="line">  &#125;</span><br><span class="line">&#96;&#125;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>您可以在JSX内编写它，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Index &#x3D; () &#x3D;&gt; (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">		&lt;h1&gt;Home page&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">		&lt;style jsx&gt;&#123;&#96;</span><br><span class="line">		  h1 &#123;</span><br><span class="line">		    font-size: 3rem;</span><br><span class="line">		  &#125;</span><br><span class="line">		&#96;&#125;&lt;&#x2F;style&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export default Index</span><br></pre></td></tr></table></figure>

<p>在块内部，我们可以使用插值来动态更改值。例如，在这里我们假设一个<code>size</code>prop被父组件传递，并在<code>styled-jsx</code>块中使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const Index &#x3D; props &#x3D;&gt; (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">		&lt;h1&gt;Home page&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">		&lt;style jsx&gt;&#123;&#96;</span><br><span class="line">		  h1 &#123;</span><br><span class="line">		    font-size: $&#123;props.size&#125;rem;</span><br><span class="line">		  &#125;</span><br><span class="line">		&#96;&#125;&lt;&#x2F;style&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果要全局应用某些CSS，而不是将其范围限制在组件上，则将<code>global</code>关键字添加到<code>style</code>标签中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style jsx global&gt;&#123;&#96;</span><br><span class="line">body &#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#125;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>如果要在Next.js组件中导入外部CSS文件，则必须先安装<code>@zeit/next-css</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @zeit&#x2F;next-css</span><br></pre></td></tr></table></figure>

<p>然后在项目的根目录中创建一个名为的配置文件，<code>next.config.js</code>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const withCSS &#x3D; require(&#39;@zeit&#x2F;next-css&#39;)</span><br><span class="line">module.exports &#x3D; withCSS()</span><br></pre></td></tr></table></figure>

<p>重新启动Next应用程序后，您现在可以像通常使用JavaScript库或组件一样导入CSS：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#39;..&#x2F;style.css&#39;</span><br></pre></td></tr></table></figure>

<p>您也可以直接使用<a target="_blank" rel="noopener" href="https://github.com/zeit/next-plugins/tree/master/packages/next-sass"><code>@zeit/next-sass</code></a>库导入SASS文件。</p>
<h2 id="用自定义标签填充head标签"><a href="#用自定义标签填充head标签" class="headerlink" title="用自定义标签填充head标签"></a>用自定义标签填充head标签</h2><p>您可以从任何Next.js页面组件向页面标题添加信息。</p>
<p>在以下情况下方便使用：</p>
<ul>
<li>您要自定义页面标题</li>
<li>您想更改一个元标记</li>
</ul>
<p>你该怎么做？</p>
<p>您可以在每个组件内部导入<code>Head</code>组件，<code>next/head</code>并将其包含在组件JSX输出中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import Head from &#39;next&#x2F;head&#39;</span><br><span class="line"></span><br><span class="line">const House &#x3D; props &#x3D;&gt; (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Head&gt;</span><br><span class="line">      &lt;title&gt;The page title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;Head&gt;</span><br><span class="line">    &#123;&#x2F;* the rest of the JSX *&#x2F;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export default House</span><br></pre></td></tr></table></figure>

<p>您可以添加任何想要显示在<code>&lt;head&gt;</code>页面部分的HTML标记。</p>
<p>安装组件时，Next.js将确保将内部标签<code>Head</code>添加到页面标题。与卸载组件相同，Next.js将负责删除这些标记。</p>
<h2 id="添加包装器组件"><a href="#添加包装器组件" class="headerlink" title="添加包装器组件"></a>添加包装器组件</h2><p>您网站上的所有页面看起来大致相同。有一个chrome窗口，一个公共基础层，您只想更改其中的内容。</p>
<p>有一个导航栏，一个边栏，然后是实际内容。</p>
<p>您如何在Next.js中构建这样的系统？</p>
<p>有两种方法。一种是通过创建<a target="_blank" rel="noopener" href="https://flaviocopes.com/react-higher-order-components/">组件</a>来使用<a target="_blank" rel="noopener" href="https://flaviocopes.com/react-higher-order-components/">高阶组件</a><code>components/Layout.js</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default Page &#x3D;&gt; &#123;</span><br><span class="line">  return () &#x3D;&gt; (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;nav&gt;</span><br><span class="line">        &lt;ul&gt;....&lt;&#x2F;ul&gt;</span><br><span class="line">      &lt;&#x2F;hav&gt;</span><br><span class="line">      &lt;main&gt;</span><br><span class="line">        &lt;Page &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;main&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们可以为标题和/或边栏导入单独的组件，还可以添加所需的所有CSS。</p>
<p>您可以在每个页面中使用它，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import withLayout from &#39;..&#x2F;components&#x2F;Layout.js&#39;</span><br><span class="line"></span><br><span class="line">const Page &#x3D; () &#x3D;&gt; &lt;p&gt;Here&#39;s a page!&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">export default withLayout(Page)</span><br></pre></td></tr></table></figure>

<p>但是我发现这仅适用于不需要调用<code>getInitialProps()</code>页面的简单情况。</p>
<p>为什么？</p>
<p>因为<code>getInitialProps()</code>仅在页面组件上被调用。但是，如果我们从页面导出withLayout（）的高阶组件，<code>Page.getInitialProps()</code>则不会被调用。<code>withLayout.getInitialProps()</code>将。</p>
<p>为了避免不必要地使我们的代码库复杂化，替代方法是使用props：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default props &#x3D;&gt; (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;nav&gt;</span><br><span class="line">      &lt;ul&gt;....&lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;hav&gt;</span><br><span class="line">    &lt;main&gt;</span><br><span class="line">      &#123;props.content&#125;</span><br><span class="line">    &lt;&#x2F;main&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>现在在我们的页面中，我们可以这样使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import Layout from &#39;..&#x2F;components&#x2F;Layout.js&#39;</span><br><span class="line"></span><br><span class="line">const Page &#x3D; () &#x3D;&gt; (</span><br><span class="line">  &lt;Layout content&#x3D;&#123;(</span><br><span class="line">    &lt;p&gt;Here&#39;s a page!&lt;&#x2F;p&gt;</span><br><span class="line">  )&#125; &#x2F;&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这种方法使我们可以<code>getInitialProps()</code>在页面组件内使用，而唯一的缺点是必须在<code>content</code>prop 内部编写组件JSX ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import Layout from &#39;..&#x2F;components&#x2F;Layout.js&#39;</span><br><span class="line"></span><br><span class="line">const Page &#x3D; () &#x3D;&gt; (</span><br><span class="line">  &lt;Layout content&#x3D;&#123;(</span><br><span class="line">    &lt;p&gt;Here&#39;s a page!&lt;&#x2F;p&gt;</span><br><span class="line">  )&#125; &#x2F;&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Page.getInitialProps &#x3D; (&#123; query &#125;) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="API路由"><a href="#API路由" class="headerlink" title="API路由"></a>API路由</h2><p>除了创建<strong>页面路由</strong>（这意味着将页面作为网页提供给浏览器）之外，Next.js还可创建<strong>API路由</strong>。</p>
<p>这是一个非常有趣的功能，因为这意味着Next.js可用于为Next.js本身存储和检索的数据创建前端，并通过提取请求传输JSON。</p>
<p>API路由位于该<code>/pages/api/</code>文件夹下，并映射到<code>/api</code>端点。</p>
<p>创建应用程序时，此功能_非常_有用。</p>
<p>在这些路由中，我们编写了Node.js代码（而不是React代码）。这是一个范式转换，您可以从前端移动到后端，但是非常无缝。</p>
<p>假设您有一个<code>/pages/api/comments.js</code>文件，其目标是以JSON格式返回博客文章的评论。</p>
<p>假设您有一个存储在<code>comments.json</code>文件中的注释列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;comment&quot;: &quot;First&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;comment&quot;: &quot;Nice post&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这是一个示例代码，它将注释列表返回给客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import comments from &#39;.&#x2F;comments.json&#39;</span><br><span class="line"></span><br><span class="line">export default (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  res.status(200).json(comments)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它将在<code>/api/comments</code>URL 上侦听GET请求，您可以尝试使用浏览器调用它：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-07-at-11.14.42.png"></p>
<p>API路由也可以像页面一样使用<strong>动态路由</strong>，使用<code>[]</code>语法来创建动态API路由，例如<code>/pages/api/comments/[id].js</code>它将检索特定于帖子ID的注释。</p>
<p>在内部，<code>[id].js</code>您可以<code>id</code>通过在<code>req.query</code>对象内部查找来获取值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import comments from &#39;..&#x2F;comments.json&#39;</span><br><span class="line"></span><br><span class="line">export default (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  res.status(200).json(&#123; post: req.query.id, comments &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里您可以看到上面的代码正在运行：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-07-at-11.59.53.png"></p>
<p>在动态网页，你需要导入<code>useRouter</code>从<code>next/router</code>，然后利用获取路由器对象<code>const router = useRouter()</code>，然后我们就可以得到<code>id</code>利用价值<code>router.query.id</code>。</p>
<p>在服务器端，这很容易，因为查询已附加到请求对象上。</p>
<p>如果您执行POST请求，则所有请求均以相同的方式工作-所有操作均通过该默认导出进行。</p>
<p>要将POST与GET和其他HTTP方法（PUT，DELETE）分开，请查找<code>req.method</code>值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export default (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  switch (req.method) &#123;</span><br><span class="line">    case &#39;GET&#39;:</span><br><span class="line">      &#x2F;&#x2F;...</span><br><span class="line">      break</span><br><span class="line">    case &#39;POST&#39;:</span><br><span class="line">      &#x2F;&#x2F;...</span><br><span class="line">      break</span><br><span class="line">    default:</span><br><span class="line">      res.status(405).end() &#x2F;&#x2F;Method Not Allowed</span><br><span class="line">      break</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了<code>req.query</code>和<code>req.method</code>我们已经看到，我们已经通过引用访问饼干<code>req.cookies</code>，在请求主体<code>req.body</code>。</p>
<p>在幕后，这些全部由<a target="_blank" rel="noopener" href="https://github.com/zeit/micro">Micro</a>提供支持，<a target="_blank" rel="noopener" href="https://github.com/zeit/micro">Micro</a>是一个支持异步HTTP微服务的库，该库由构建Next.js的同一团队制作。</p>
<p>您可以在我们的API路由中使用任何Micro中间件来添加更多功能。</p>
<h2 id="仅在服务器端或客户端运行代码"><a href="#仅在服务器端或客户端运行代码" class="headerlink" title="仅在服务器端或客户端运行代码"></a>仅在服务器端或客户端运行代码</h2><p>在页面组件中，通过检查<code>window</code>属性，您只能在服务器端或客户端执行代码。</p>
<p>此属性仅存在于浏览器内部，因此您可以检查</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (typeof window &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并在该块中添加服务器端代码。</p>
<p>同样，您只能通过检查执行客户端代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (typeof window !&#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JS技巧：我们在<code>typeof</code>这里使用运算符是因为我们无法通过其他方式检测到未定义的值。我们不能这样做，<code>if (window === undefined)</code>因为会出现“未定义窗口”运行时错误</p>
<p>Next.js作为构建时的优化，也从捆绑软件中删除了使用这些检查的代码。客户端捆绑包将不包含包装在<code>if (typeof window === &#39;undefined&#39;) &#123;&#125;</code>块中的内容。</p>
<h2 id="部署生产版本"><a href="#部署生产版本" class="headerlink" title="部署生产版本"></a>部署生产版本</h2><p>部署应用程序始终是教程中的最后内容。</p>
<p>在这里，我想尽早介绍它，因为部署Next.js应用程序非常容易，我们现在就可以深入研究它，然后再转到其他更复杂的主题。</p>
<p>请记住，在“如何安装Next.js”一章中，我告诉您将这3行添加到该<code>package.json</code> <code>script</code>部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;dev&quot;: &quot;next&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;next build&quot;,</span><br><span class="line">  &quot;start&quot;: &quot;next start&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>npm run dev</code>到目前为止，我们一直使用来调用<code>next</code>本地安装的命令<code>node_modules/next/dist/bin/next</code>。这启动了开发服务器，该服务器向我们提供了<strong>源映射</strong>和<strong>热代码重载</strong>，这是调试时的两个非常有用的功能。</p>
<p><code>build</code>通过运行，可以调用相同的命令来构建传递标记的网站<code>npm run build</code>。然后，<code>start</code>通过运行，可以使用相同的命令通过该标志来启动生产应用<code>npm run start</code>。</p>
<p>这两个命令是我们必须调用以成功在本地部署站点的生产版本的命令。生产版本经过高度优化，并且不附带源地图和诸如热代码重载之类的其他东西，这些东西对我们的最终用户无益。</p>
<p>因此，让我们创建应用程序的生产部署。使用以下命令进行构建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-06-at-13.46.31.png"></p>
<p>该命令的输出告诉我们某些路由（<code>/</code>并且<code>/blog</code>现在已预先<code>/blog/[id]</code>呈现为静态HTML，而Node.js后端将提供这些路由）。</p>
<p>然后，您可以运行<code>npm run start</code>以在本地启动生产服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-06-at-13.47.01.png"></p>
<p>访问<a target="_blank" rel="noopener" href="http://localhost:3000/">http：// localhost：3000</a>将向我们展示该应用程序的生产版本。</p>
<h2 id="立即部署"><a href="#立即部署" class="headerlink" title="立即部署"></a>立即部署</h2><p>在上一章中，我们在本地部署了Next.js应用程序。</p>
<p>我们如何将其部署到真实的Web服务器上，以便其他人可以访问它？</p>
<p>部署Next应用程序最简单的方法之一就是通过<a target="_blank" rel="noopener" href="https://zeit.co/">Zeit</a>创建的<strong>Now</strong>平台，该平台创建了开源项目Next.js。您可以使用Now来部署Node.js应用程序，静态网站等。</p>
<p>现在，使应用程序的部署和分发步骤变得非常，非常简单和快速，并且除了Node.js应用程序外，它们还支持部署Go，PHP，Python和其他语言。</p>
<p>您可以将其视为“云”，因为您并不真正知道应用程序的部署位置，但是您知道将拥有一个可以访问它的URL。</p>
<p>现在可以免费开始使用了免费的免费计划，该计划目前包括100GB托管，每天1000次<a target="_blank" rel="noopener" href="https://www.freecodecamp.org/serverless/">无服务器</a>功能调用，每月1000次构建，每月100GB带宽以及一个<a target="_blank" rel="noopener" href="https://www.freecodecamp.org/cdn/">CDN</a>位置。该<a target="_blank" rel="noopener" href="https://zeit.co/pricing">定价页面</a>帮助，如果你需要更多的获得成本的想法。</p>
<p>开始使用Now的最佳方法是使用官方的Now CLI：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g now</span><br></pre></td></tr></table></figure>

<p>命令可用后，运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">now login</span><br></pre></td></tr></table></figure>

<p>然后该应用会询问您的电子邮件。</p>
<p>如果尚未注册，<a target="_blank" rel="noopener" href="https://zeit.co/signup">请</a>在继续之前在<a target="_blank" rel="noopener" href="https://zeit.co/signup">https://zeit.co/signup</a>上创建一个帐户，然后将电子邮件添加到CLI客户端。</p>
<p>完成此操作后，从Next.js项目根文件夹运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">now</span><br></pre></td></tr></table></figure>

<p>并且该应用将立即部署到Now云中，并且会为您提供唯一的应用URL：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-06-at-14.21.09.png"></p>
<p>运行该<code>now</code>程序后，该应用程序将部署到<code>now.sh</code>域下的随机URL 。</p>
<p>我们在图像中给出的输出中可以看到3个不同的URL：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://firstproject-2pv7khwwr.now.sh/">https://firstproject-2pv7khwwr.now.sh</a></li>
<li><a target="_blank" rel="noopener" href="https://firstproject-sepia-ten.now.sh/">https://firstproject-sepia-ten.now.sh</a></li>
<li><a target="_blank" rel="noopener" href="https://firstproject.flaviocopes.now.sh/">https://firstproject.flaviocopes.now.sh</a></li>
</ul>
<p>为什么那么多？</p>
<p>第一个是标识部署的URL。每次我们部署应用程序时，此URL都会更改。</p>
<p>您可以通过更改项目代码中的某些内容并<code>now</code>再次运行来立即进行测试：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-06-at-15.08.11.png"></p>
<p>其他2个URL不会更改。第一个是随机的，第二个是您的项目名称（默认为当前项目文件夹，然后是您的帐户名<code>now.sh</code>。</p>
<p>如果您访问该URL，您将看到该应用程序已部署到生产环境。</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-06-at-14.21.43.png"></p>
<p>您可以配置“现在”以将网站提供给您自己的自定义域或子域，但是我现在不会对此进行介绍。</p>
<p>该<code>now.sh</code>子域是足以让我们的测试目的。</p>
<h2 id="分析应用捆绑"><a href="#分析应用捆绑" class="headerlink" title="分析应用捆绑"></a>分析应用捆绑</h2><p>Next为我们提供了一种分析生成的代码束的方法。</p>
<p>打开应用程序的package.json文件，然后在脚本部分中添加这3个新命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;analyze&quot;: &quot;cross-env ANALYZE&#x3D;true next build&quot;,</span><br><span class="line">&quot;analyze:server&quot;: &quot;cross-env BUNDLE_ANALYZE&#x3D;server next build&quot;,</span><br><span class="line">&quot;analyze:browser&quot;: &quot;cross-env BUNDLE_ANALYZE&#x3D;browser next build&quot;</span><br></pre></td></tr></table></figure>

<p>像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;firstproject&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;next&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;next build&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;next start&quot;,</span><br><span class="line">    &quot;analyze&quot;: &quot;cross-env ANALYZE&#x3D;true next build&quot;,</span><br><span class="line">    &quot;analyze:server&quot;: &quot;cross-env BUNDLE_ANALYZE&#x3D;server next build&quot;,</span><br><span class="line">    &quot;analyze:browser&quot;: &quot;cross-env BUNDLE_ANALYZE&#x3D;browser next build&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;next&quot;: &quot;^9.1.2&quot;,</span><br><span class="line">    &quot;react&quot;: &quot;^16.11.0&quot;,</span><br><span class="line">    &quot;react-dom&quot;: &quot;^16.11.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后安装这两个软件包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --dev cross-env @next&#x2F;bundle-analyzer</span><br></pre></td></tr></table></figure>

<p><code>next.config.js</code>在项目根目录中创建一个文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const withBundleAnalyzer &#x3D; require(&#39;@next&#x2F;bundle-analyzer&#39;)(&#123;</span><br><span class="line">  enabled: process.env.ANALYZE &#x3D;&#x3D;&#x3D; &#39;true&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; withBundleAnalyzer(&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>现在运行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run analyze</span><br></pre></td></tr></table></figure>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-06-at-16.12.40.png"></p>
<p>这应该在浏览器中打开2个页面。一种用于客户端捆绑，另一种用于服务器捆绑：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-06-at-16.11.14.png"><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-06-at-16.11.23.png"></p>
<p>这是非常有用的。您可以检查束中占用最多空间的空间，还可以使用边栏排除束，以更轻松地可视化较小的束：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-06-at-16.14.12.png"></p>
<h2 id="延迟加载模块"><a href="#延迟加载模块" class="headerlink" title="延迟加载模块"></a>延迟加载模块</h2><p>能够以可视方式分析捆绑软件非常有用，因为我们可以非常轻松地优化应用程序。</p>
<p>假设我们需要在博客文章中加载Moment库。跑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install moment</span><br></pre></td></tr></table></figure>

<p>将其包括在项目中。</p>
<p>现在，让我们模拟一个事实，即我们在两条不同的路线上都需要它：<code>/blog</code>和<code>/blog/[id]</code>。</p>
<p>我们将其导入<code>pages/blog/[id].js</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import moment from &#39;moment&#39;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">const Post &#x3D; props &#x3D;&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;&#123;props.post.title&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;p&gt;Published on &#123;moment().format(&#39;dddd D MMMM YYYY&#39;)&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p&gt;&#123;props.post.content&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我仅以今天的日期为例。</p>
<p>您可以通过运行<code>npm run analyze</code>以下命令在博客文章页面捆绑包中包含Moment.js ：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-06-at-17.56.14.png"></p>
<p>看到我们现在在中有一个红色条目<code>/blog/[id]</code>，这是我们添加Moment.js的路线！</p>
<p>它从〜1kB变为350kB，相当大的一笔。这是因为Moment.js库本身为349kB。</p>
<p>现在，客户端捆绑包可视化向我们显示，更大的捆绑包是第一页，以前很少。其代码的99％是Moment.js。</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-06-at-17.55.50.png"></p>
<p>每次加载博客文章时，我们都会将所有这些代码转移到客户端。这不理想。</p>
<p>一种解决方法是寻找一个较小的库，因为Moment.js并不以其轻量级而著称（尤其是开箱即用，包括所有语言环境），但为示例起见，我们必须使用它。</p>
<p>相反，我们可以做的是将所有Moment代码<strong>分成</strong>一个<strong>单独的捆绑包</strong>。</p>
<p>怎么样？而不是在组件级别导入Moment，而是在内部执行异步导入<code>getInitialProps</code>，然后计算要发送到组件的值。<br>请记住，我们不能在返回的对象内返回复杂的<code>getInitialProps()</code>对象，因此我们要计算其中的日期：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import posts from &#39;..&#x2F;..&#x2F;posts.json&#39;</span><br><span class="line"></span><br><span class="line">const Post &#x3D; props &#x3D;&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;&#123;props.post.title&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;p&gt;Published on &#123;props.date&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p&gt;&#123;props.post.content&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Post.getInitialProps &#x3D; async (&#123; query &#125;) &#x3D;&gt; &#123;</span><br><span class="line">  const moment &#x3D; (await import(&#39;moment&#39;)).default()</span><br><span class="line">  return &#123;</span><br><span class="line">    date: moment.format(&#39;dddd D MMMM YYYY&#39;),</span><br><span class="line">    post: posts[query.id]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Post</span><br></pre></td></tr></table></figure>

<p>看到<code>.default()</code>之后的特别电话<code>await import</code>吗？需要在动态导入中引用默认导出（请参阅<a target="_blank" rel="noopener" href="https://v8.dev/features/dynamic-import">https://v8.dev/features/dynamic-import</a>）</p>
<p>现在，如果<code>npm run analyze</code>再次运行，我们可以看到：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2019/11/Screen-Shot-2019-11-06-at-18.00.22.png"></p>
<p>我们的<code>/blog/[id]</code>包又很小，因为Moment已移至其自己的包文件，并由浏览器单独加载。</p>
<h2 id="从这往哪儿走"><a href="#从这往哪儿走" class="headerlink" title="从这往哪儿走"></a>从这往哪儿走</h2><p>关于Next.js，还有更多的知识。我没有谈论使用登录，无服务器，管理数据库等等来管理用户会话。</p>
<p>本手册的目的不是要教您所有内容，而是要逐步向您介绍Next.js的所有功能。</p>
<p>我建议的下一步是<a target="_blank" rel="noopener" href="https://nextjs.org/docs">仔细</a>阅读<a target="_blank" rel="noopener" href="https://nextjs.org/docs">Next.js官方文档，</a>以查找有关我没有谈论的所有功能的更多信息，并查看<a target="_blank" rel="noopener" href="https://github.com/zeit/next-plugins">Next.js插件</a>引入的所有其他功能。，其中一些非常了不起。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-11-29T05:34:21.000Z" title="2019-11-29T05:34:21.000Z">2019-11-29</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.414Z" title="2020-09-08T14:03:00.414Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">2 小时读完 (大约21751个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/29/Vue%E6%89%8B%E5%86%8C%EF%BC%9AVue-js%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%8B%E7%BB%8D/">Vue手册：Vue.js的完整介绍</a></h1><div class="content"><p>Vue是一种非常流行的JavaScript前端框架，正在经历巨大的增长。</p>
<p>它很简单，很小（〜24KB），并且性能很高。感觉与所有其他JavaScript前端框架和视图库不同。让我们找出原因。</p>
<h3 id="首先，什么是JavaScript前端框架？"><a href="#首先，什么是JavaScript前端框架？" class="headerlink" title="首先，什么是JavaScript前端框架？"></a>首先，什么是JavaScript前端框架？</h3><p>如果不确定什么是JavaScript框架，那么Vue是一个完美的初体验。</p>
<p>JavaScript框架可帮助我们创建现代应用程序。现代JavaScript应用程序主要在Web上使用，但也为许多桌面和移动应用程序提供支持。</p>
<p>直到2000年代初，浏览器才拥有现在所没有的功能。它们的功能要弱得多，并且在它们内部构建复杂的应用程序在性能上并不可行。人们甚至都没有想到过这种工具。</p>
<p>当Google推出浏览器中运行的两个应用程序<a target="_blank" rel="noopener" href="https://www.google.com/maps">Google Maps</a>和<a target="_blank" rel="noopener" href="https://www.google.com/gmail">GMail时</a>，一切都发生了变化。<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started">Ajax</a>使异步网络请求成为可能。随着时间的流逝，开发人员开始在Web平台之上进行构建，而工程师在该平台本身上进行工作-浏览器，Web标准，浏览器API和JavaScript语言。</p>
<p>像<a target="_blank" rel="noopener" href="https://jquery.com/">jQuery</a>和<a target="_blank" rel="noopener" href="https://mootools.net/">Mootools</a>这样的库是第一个基于JavaScript的大型项目，并在一段时间内大受欢迎。他们基本上提供了一个更好的API与浏览器进行交互，并提供了各种浏览器之间的错误和不一致的解决方法。</p>
<p>诸如<a target="_blank" rel="noopener" href="http://backbonejs.org/">Backbone</a>，<a target="_blank" rel="noopener" href="https://www.emberjs.com/">Ember</a>，<a target="_blank" rel="noopener" href="http://knockoutjs.com/">Knockout</a>和<a target="_blank" rel="noopener" href="https://angularjs.org/">AngularJS之</a>类的框架是现代JavaScript框架的第一波潮流。</p>
<p>第二波是当前波，其主要参与者是<a target="_blank" rel="noopener" href="https://reactjs.org/">React</a>，<a target="_blank" rel="noopener" href="https://angular.io/">Angular</a>和<a target="_blank" rel="noopener" href="https://vuejs.org/">Vue</a>。</p>
<p>请注意，jQuery，Ember和我提到的其他项目仍在大量使用，积极维护和数百万个网站依赖它们。</p>
<p>也就是说，技术和工具不断发展，作为JavaScript开发人员，您现在可能需要了解React，Angular或Vue，而不是那些较旧的框架。</p>
<p>框架抽象了与浏览器和DOM的交互。我们不是在DOM中通过引用元素来操作元素，而是在更高的级别上以<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Declarative_programming">声明方式</a>定义它们并与之交互。</p>
<p>使用框架就像使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/C_(programming_language)">C编程语言</a>而不是使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Assembly_language">汇编语言</a>编写系统程序一样。就像使用计算机来编写文档而不是使用打字机一样。这就像拥有自动驾驶汽车，而不是自己驾驶汽车。</p>
<p>好吧，不是很远，但是您知道了。您不必使用由浏览器提供的低级API来操纵元素，而是使用非常聪明的人构建的工具来使我们的生活更轻松，这些工具可以构建非常复杂的系统来编写应用程序。</p>
<h3 id="Vue的受欢迎程度"><a href="#Vue的受欢迎程度" class="headerlink" title="Vue的受欢迎程度"></a>Vue的受欢迎程度</h3><p>Vue.js的受欢迎程度如何？</p>
<p>Vue有：</p>
<ul>
<li>2016年在GitHub上获得7,600星</li>
<li>2017年在GitHub上有36,700星</li>
</ul>
<p>截至2018年6月，它在GitHub上拥有超过100,000个星星。</p>
<p>它的<a target="_blank" rel="noopener" href="https://www.npmjs.com/">npm</a>下载数量每天都在增长，现在每周大约有350,000次下载。</p>
<p>鉴于这些数字，我会说Vue非常受欢迎。</p>
<p>相对而言，它的GitHub星星数量与几年前诞生的React大致相同。</p>
<p>当然，数字并不是万能的。我对Vue的印象是开发人员<strong>喜欢</strong>它。</p>
<p>Vue兴起的关键时刻是在Laravel生态系统中的采用，Laravel生态系统是一种非常流行的PHP Web应用程序框架。但是从那以后，它已经在许多其他开发社区中广泛传播。</p>
<h4 id="为什么开发人员喜欢Vue"><a href="#为什么开发人员喜欢Vue" class="headerlink" title="为什么开发人员喜欢Vue"></a>为什么开发人员喜欢Vue</h4><p>首先，Vue被称为渐进框架。</p>
<p>这意味着它可以适应开发人员的需求。其他框架则需要开发人员或团队的全面支持，并且由于它们需要某些特定的约定集，因此常常希望您重写现有的应用程序。Vue从一个简单的<code>script</code>标签开始就很高兴地落在您的应用程序内部，它可以随着您的需求而增长，从3行扩展到管理整个视图层。</p>
<p>您不需要了解<a target="_blank" rel="noopener" href="https://webpack.js.org/">webpack</a>，<a target="_blank" rel="noopener" href="https://babeljs.io/">Babel</a>，npm或任何有关Vue入门的知识。但是，当您准备就绪时，Vue使您可以轻松依赖它们。</p>
<p>这是一个很大的卖点，尤其是在当前的JavaScript前端框架和库生态系统中，这些生态系统倾向于疏远新手和经验丰富的开发人员，他们迷失在可能性和选择的海洋中。</p>
<p>Vue.js可能是最容易接近的前端框架。有人称Vue为<strong>新的jQuery</strong>，因为它很容易通过script标签进入应用程序，并从那里逐渐获得空间。自从jQuery在过去几年中统治了Web以来，它一直是一种赞美，现在它仍然在大量站点上发挥作用。</p>
<p>Vue的构建是通过选择Angular，React和Knockout等框架的最佳思想，并挑选这些框架的最佳选择来完成的。通过排除一些不太出色的产品，它开始成为“最佳”产品，并从那里发展起来。</p>
<h4 id="Vue-js在框架环境中的什么位置？"><a href="#Vue-js在框架环境中的什么位置？" class="headerlink" title="Vue.js在框架环境中的什么位置？"></a>Vue.js在框架环境中的什么位置？</h4><p>在谈论Web开发时，会议室中的两个大象是React和Angular。Vue如何相对于这两个流行的大型框架定位自己？</p>
<p>Vue由Evan You在Google上使用AngularJS（Angular 1.0）应用程序创建时创建。它是出于创建更多高性能应用程序的需要而诞生的。Vue选择了一些Angular模板语法，但删除了Angular所需的，自以为是的复杂堆栈，并使其表现出色。</p>
<p>新的Angular（Angular 2.0）也解决了许多AngularJS问题，但是方式却截然不同。它还需要<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/">TypeScript的支持</a>，并非所有开发人员都喜欢使用（或想学习）。</p>
<p>那React呢？Vue从React获得了很多好主意，最重要的是虚拟DOM。但是Vue通过某种自动依赖管理来实现它。这跟踪状态更改影响哪些组件，以便在状态属性更改时仅重新呈现那些组件。</p>
<p>另一方面，在React中，当影响组件的一部分状态发生变化时，组件将被重新渲染。默认情况下，其所有子级也会重新渲染。为避免这种情况，您需要使用<code>shouldComponentUpdate</code>每个组件的方法并确定是否应重新渲染该组件。在易用性和开箱即用的性能方面，这给Vue带来了一些优势。</p>
<p>与React的一大不同是<a target="_blank" rel="noopener" href="https://reactjs.org/docs/introducing-jsx.html">JSX</a>。尽管您可以在Vue中使用JSX，但它不是一种流行的方法，而是使用了<a target="_blank" rel="noopener" href="https://vuejs.org/v2/guide/syntax.html">模板系统</a>。任何HTML文件都是有效的Vue模板。JSX与HTML截然不同，它为团队中的人员提供了学习曲线，他们可能只需要使用应用程序的HTML部分，例如设计师。</p>
<p>Vue模板与<a target="_blank" rel="noopener" href="http://mustache.github.io/">Moustache</a>和<a target="_blank" rel="noopener" href="https://handlebarsjs.com/">Handlebars</a>非常相似（尽管它们在灵活性方面有所不同）。因此，对于已经使用Angular和Ember等框架的开发人员来说，它们更加熟悉。</p>
<p>官方状态管理库<a target="_blank" rel="noopener" href="https://vuex.vuejs.org/">Vuex</a>遵循Flux架构，其概念在某种程度上类似于<a target="_blank" rel="noopener" href="https://redux.js.org/">Redux</a>。再次，这是关于Vue的积极事情的一部分，Vue在React中看到了这种良好模式，并将其借用于其生态系统。尽管可以将Redux与Vue结合使用，但Vuex是专门为Vue及其内部功能量身定制的。</p>
<p>Vue非常灵活，但是核心团队维护着两个对任何Web应用都非常重要的软件包（例如路由和状态管理），这一事实使得它比React更加零碎。例如：<code>vue-router</code>和<code>vuex</code>是Vue成功的关键。</p>
<p>您无需选择或担心您将来选择的库是否将要维护，并会跟上框架更新的步伐。由于它们是官方的，因此它们是其利基市场的规范性去库（但您当然可以选择使用喜欢的库）。</p>
<p>与React和Angular相比，使Vue处于不同的类别的一件事是，Vue是一个<strong>独立</strong>项目：它没有像Facebook或Google这样的大型公司的支持。</p>
<p>相反，它得到了社区的完全支持，该社区通过捐赠和赞助者促进发展。这可以确保Vue的路线图不受单个公司议程的驱动。</p>
<h3 id="您的第一个Vue应用"><a href="#您的第一个Vue应用" class="headerlink" title="您的第一个Vue应用"></a>您的第一个Vue应用</h3><p>如果您从未创建过Vue.js应用程序，那么我将指导您完成创建应用程序的任务，以便您了解其工作方式。</p>
<h4 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h4><p>首先，我将介绍使用Vue的最基本示例。</p>
<p>您创建一个HTML文件，其中包含：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">      &lt;p&gt;&#123;.&#123; hello &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            el: &#39;#example&#39;,</span><br><span class="line">            data: &#123; hello: &#39;Hello World!&#39; &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>然后在浏览器中打开它。这是您的第一个Vue应用！该页面应显示“ Hello World！”消息。</p>
<p>我将脚本标签放在正文的末尾，以便在加载DOM之后按顺序执行它们。</p>
<p>该代码的作用是实例化一个新的Vue应用程序，该应用程序链接到该<code>#example</code>元素作为其模板。通常是使用CSS选择器定义的，但您也可以传入<code>HTMLElement</code>。</p>
<p>然后，它将模板与<code>data</code>对象相关联。这是一个特殊的对象，用于承载我们希望Vue呈现的数据。</p>
<p>在模板中，特殊<code>&#123;.&#123; &#125;&#125;</code>标记表示这是动态模板的一部分，应在Vue应用程序数据中查找其内容。</p>
<p>您可以在<a target="_blank" rel="noopener" href="https://codepen.io/flaviocopes/pen/YLoLOp">CodePen</a>上看到此示例。</p>
<p>CodePen与使用纯HTML文件有点不同，您需要对其进行配置以指向Pen设置中的Vue库位置：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/Qa8s2ayB3DhhE3dRKv4SFowGd8xHDvEeSlL4"></p>
<h4 id="第二个示例：Vue-CLI默认应用"><a href="#第二个示例：Vue-CLI默认应用" class="headerlink" title="第二个示例：Vue CLI默认应用"></a>第二个示例：Vue CLI默认应用</h4><p>让我们稍微升级一下游戏。我们将要构建的下一个应用程序已经完成，它是Vue CLI的默认应用程序。</p>
<p>什么是Vue CLI？它是一个命令行实用程序，通过安装适当的示例应用程序来为您架设一个应用程序框架，从而有助于加快开发速度。</p>
<p>有两种方法可以获取此应用程序：</p>
<p><strong>在本地使用Vue CLI</strong></p>
<p>首先是在计算机上安装Vue CLI并运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create &lt;enter the app name&gt;</span><br></pre></td></tr></table></figure>

<p><strong>使用CodeSandbox</strong></p>
<p>一个简单的方法（无需安装任何软件）是转到<a target="_blank" rel="noopener" href="https://codesandbox.io/s/vue">CodeSandbox</a>。该链接将打开Vue CLI默认应用程序。</p>
<p>CodeSandbox是一个很棒的代码编辑器，可让您在云中构建应用程序。您可以使用任何npm软件包，并且可以轻松地与<a target="_blank" rel="noopener" href="https://zeit.co/now">Zeit Now</a>集成以实现轻松部署，并可以与<a target="_blank" rel="noopener" href="https://github.com/">GitHub</a>集成以管理版本控制。</p>
<p>无论您是选择在本地使用Vue CLI还是通过CodeSandbox，我们都将详细检查该Vue应用程序。</p>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>在旁边<code>package.json</code>，其中包含配置，这些是初始项目结构中包含的文件：</p>
<ul>
<li><code>index.html</code></li>
<li><code>src/App.vue</code></li>
<li><code>src/main.js</code></li>
<li><code>src/assets/logo.png</code></li>
<li><code>src/components/HelloWorld.vue</code></li>
</ul>
<h4 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a><code>index.html</code></h4><p>该<code>index.html</code>文件是主应用程序文件。</p>
<p>在主体中，它仅包含一个简单元素：<code>&lt;div id=&quot;app&quot;&gt;</code>&lt;/ div&gt;。这是我们将用于附加到DOM的Vue应用程序的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;CodeSandbox Vue&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;!-- built files will be auto injected --&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="src-main-js"><a href="#src-main-js" class="headerlink" title="src/main.js"></a><code>src/main.js</code></h4><p>这是驱动我们的应用程序的主要JavaScript文件。</p>
<p>我们首先从中导入Vue库和App组件<code>App.vue</code>。</p>
<p>我们设置<code>productionTip</code>为<code>false</code>，以避免Vue在控制台中输出“您处于开发模式”提示。</p>
<p>接下来，我们通过将Vue实例分配给在中<code>#app</code>定义的标识的DOM元素来创建Vue实例，<code>index.html</code>并告诉它使用App组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable no-new *&#x2F;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="src-App-vue"><a href="#src-App-vue" class="headerlink" title="src/App.vue"></a><code>src/App.vue</code></h4><p><code>App.vue</code>是单个文件组件。它包含三个代码块：HTML，CSS和JavaScript。</p>
<p>乍一看似乎很奇怪，但是“单个文件组件”是一种创建独立组件的好方法，这些组件可以在单个文件中包含所有需要的组件。</p>
<p>我们具有标记，将要与之交互的JavaScript以及应用于该标记的样式，可以对其范围进行限制。在这种情况下，它没有作用域，只是输出了像常规CSS一样应用到页面的CSS。</p>
<p>有趣的部分在于<code>script</code>标签。</p>
<p>我们从<code>components/HelloWorld.vue</code>文件中导入一个组件，我们将在后面描述。</p>
<p>该组件将在我们的组件中引用。这是一个依赖关系。我们将输出此代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;img width&#x3D;&quot;25%&quot; src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;</span><br><span class="line">  &lt;HelloWorld&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>从该组件中，您将看到该<code>HelloWorld</code>组件。Vue会自动将该组件插入此占位符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;img width&#x3D;&quot;25%&quot; src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;</span><br><span class="line">    &lt;HelloWorld&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import HelloWorld from &#39;.&#x2F;components&#x2F;HelloWorld&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &#39;Avenir&#39;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<h4 id="src-components-HelloWorld-vue"><a href="#src-components-HelloWorld-vue" class="headerlink" title="src/components/HelloWorld.vue"></a><code>src/components/HelloWorld.vue</code></h4><p>这是<code>HelloWorld</code>组件，它包含在App组件中。</p>
<p>该组件输出一组链接以及一条消息。</p>
<p>还记得上面我们讨论过App.vue中的CSS，但没有作用域吗？该<code>HelloWorld</code>组件的作用域为CSS。</p>
<p>您可以通过查看<code>style</code>标签轻松地确定它。如果具有<code>scoped</code>属性，则其作用域为：<code>&lt;style scop</code>ed&gt;</p>
<p>这意味着生成的CSS将通过Vue透明应用的类来唯一地定位组件。您无需为此担心，并且知道CSS不会<strong>泄漏</strong>到页面的其他部分。</p>
<p>组件输出的消息存储在<code>data</code>Vue实例的属性中，并在模板中输出<code>&#123;.&#123; msg &#125;&#125;</code>。</p>
<p><code>data</code>可以使用自己的名称直接在模板中访问存储在其中的任何内容。我们不必说<code>data.msg</code>了<code>msg</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h1&gt;&#123;.&#123; msg &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h2&gt;Essential Links&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href&#x3D;&quot;https:&#x2F;&#x2F;vuejs.org&quot;</span><br><span class="line">          target&#x3D;&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          Core Docs</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href&#x3D;&quot;https:&#x2F;&#x2F;forum.vuejs.org&quot;</span><br><span class="line">          target&#x3D;&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          Forum</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href&#x3D;&quot;https:&#x2F;&#x2F;chat.vuejs.org&quot;</span><br><span class="line">          target&#x3D;&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          Community Chat</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href&#x3D;&quot;https:&#x2F;&#x2F;twitter.com&#x2F;vuejs&quot;</span><br><span class="line">          target&#x3D;&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          Twitter</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">      &lt;br&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href&#x3D;&quot;http:&#x2F;&#x2F;vuejs-templates.github.io&#x2F;webpack&#x2F;&quot;</span><br><span class="line">          target&#x3D;&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          Docs for This Template</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;h2&gt;Ecosystem&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href&#x3D;&quot;http:&#x2F;&#x2F;router.vuejs.org&#x2F;&quot;</span><br><span class="line">          target&#x3D;&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          vue-router</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href&#x3D;&quot;http:&#x2F;&#x2F;vuex.vuejs.org&#x2F;&quot;</span><br><span class="line">          target&#x3D;&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          vuex</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href&#x3D;&quot;http:&#x2F;&#x2F;vue-loader.vuejs.org&#x2F;&quot;</span><br><span class="line">          target&#x3D;&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          vue-loader</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;vuejs&#x2F;awesome-vue&quot;</span><br><span class="line">          target&#x3D;&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          awesome-vue</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;HelloWorld&#39;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#39;Welcome to Your Vue.js App&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">h1,</span><br><span class="line">h2 &#123;</span><br><span class="line">  font-weight: normal;</span><br><span class="line">&#125;</span><br><span class="line">ul &#123;</span><br><span class="line">  list-style-type: none;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">li &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  margin: 0 10px;</span><br><span class="line">&#125;</span><br><span class="line">a &#123;</span><br><span class="line">  color: #42b983;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<h4 id="运行应用"><a href="#运行应用" class="headerlink" title="运行应用"></a>运行应用</h4><p>CodeSandbox具有很酷的预览功能。您可以运行该应用程序并编辑源代码中的任何内容，以使其立即反映在预览中。</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/ZWfaVoQWEm4HzD0RNcS2osp8NpIPz-G5Vq5P"></p>
<h3 id="Vue-CLI"><a href="#Vue-CLI" class="headerlink" title="Vue CLI"></a>Vue CLI</h3><p>CodeSandbox非常适合在线编码和工作，而无需在本地设置Vue。在本地工作的一种好方法是设置Vue CLI（命令行界面）。让我们进一步了解它。</p>
<p>在上一个示例中，我介绍了一个基于Vue CLI的示例项目。Vue CLI到底是什么，它如何适合Vue生态系统？另外，我们如何在本地设置基于Vue CLI的项目？让我们找出答案！</p>
<p><strong>注意：</strong>从版本2到版本3，现在正在对CLI进行大量修改。虽然尚不稳定，但我将介绍版本3，因为它是对版本2的巨大改进，并且有很大的不同。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>Vue CLI是一个命令行实用程序，您可以使用npm在全球范围内安装它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue&#x2F;cli</span><br></pre></td></tr></table></figure>

<p>或使用纱线：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add @vue&#x2F;cli</span><br></pre></td></tr></table></figure>

<p>完成后，您可以调用该<code>vue</code>命令。</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/F1uuQW81iw1WZNOiUn0xnLOagFi637vPDUfd"></p>
<h4 id="Vue-CLI提供了什么？"><a href="#Vue-CLI提供了什么？" class="headerlink" title="Vue CLI提供了什么？"></a>Vue CLI提供了什么？</h4><p>CLI对于快速Vue.js开发至关重要。</p>
<p>它的主要目标是确保所需的所有工具都可以正常工作，执行所需的工作，并抽象出单独使用每种工具所需的所有细节。</p>
<p>它可以执行初始项目设置和脚手架。</p>
<p>这是一个灵活的工具。使用CLI创建项目后，您可以进行配置调整，而不必<strong>退出</strong>应用程序（就像使用一样<code>create-react-app</code>）。</p>
<p>从中弹出时，<code>create-react-app</code>可以更新和调整所需的内容，但不能依赖所提供的出色功能<code>create-react-app</code>。</p>
<p>您可以配置任何内容，但仍然可以轻松升级。</p>
<p>创建和配置应用程序后，它充当基于Webpack的运行时依赖工具。</p>
<p>与CLI的第一次接触是在创建新的Vue项目时。</p>
<h4 id="如何使用CLI创建新的Vue项目"><a href="#如何使用CLI创建新的Vue项目" class="headerlink" title="如何使用CLI创建新的Vue项目"></a>如何使用CLI创建新的Vue项目</h4><p>使用CLI要做的第一件事是创建一个Vue应用程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create example</span><br></pre></td></tr></table></figure>

<p>最酷的是，这是一个交互式过程。您需要选择一个预设。默认情况下，有一个预设可提供Babel和<a target="_blank" rel="noopener" href="https://eslint.org/">ESLint</a>集成：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/FL4mTLZqzhKkAYL2FB507Tx1Hkdtnl0y5cgu"></p>
<p>我将按向下箭头⬇️并手动选择所需的功能：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/mkF3jMMCGluqmQ3hX3bGbCxhfXcwvWVNjWLi"></p>
<p>按<code>space</code>启用您需要的其中一项，然后按<code>enter</code>继续。由于选择<code>Linter / Formatter</code>，因此Vue CLI会提示我进行配置。我选择了，<code>ESLint + Prettier</code>因为这是我最喜欢的设置：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/bYwN2mfgTuJNxiiHBSNjnJQADZQvFR0TErhK"></p>
<p>接下来的事情是选择如何应用棉绒。我选择<code>Lint on save</code>。</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/dcQmjoykCaJG7pevG5Yc-6A43eVYUkCbTxn7"></p>
<p>接下来：测试。Vue CLI让我在两种最受欢迎​​的单元测试解决方案之间进行选择：<a target="_blank" rel="noopener" href="https://mochajs.org/">Mocha + Chai</a>和<a target="_blank" rel="noopener" href="https://jestjs.io/">Jest</a>。</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/lIdwYkOgcllnAJRVZOoKIxZ49ikNFoQjYtSV"></p>
<p>Vue CLI询问我将所有配置放在何处：在<code>package.json</code>文件或专用配置文件中，每个工具一个。我选择了后者。</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/dN4W4ZALKh7Xz1D8ac7ebXpGdTPVGpzdujcc"></p>
<p>接下来，Vue CLI询问我是否要保存这些预设，并允许我下次使用Vue CLI创建新应用时选择它们。这是一个非常方便的功能，因为根据我的喜好进行快速设置可以减轻复杂性：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/X6rbmBloyRnQbdwrFQwtYeChdqxzQRpOJYfl"></p>
<p>然后，Vue CLI询问我是否更喜欢使用<a target="_blank" rel="noopener" href="https://yarnpkg.com/lang/en/">Yarn</a>或NPM：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/vbEmq0oYaGFjDtjL9D2QaUZ6t5omf0fjZTJM"></p>
<p>这是它问我的最后一件事，然后继续下载依赖项并创建Vue应用程序：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/Q52LD-RGQm9dHXMyWikiI5fMyESB7vRJqe1h"></p>
<h4 id="如何启动新创建的Vue-CLI应用程序"><a href="#如何启动新创建的Vue-CLI应用程序" class="headerlink" title="如何启动新创建的Vue CLI应用程序"></a>如何启动新创建的Vue CLI应用程序</h4><p>Vue CLI已为我们创建了该应用程序，我们可以进入该<code>example</code>文件夹并运行<code>yarn serve</code>以在开发模式下启动我们的第一个应用程序：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/iegqNiWWJaunJi-KFTV93EKuODc4njdfLRuf"></p>
<p>入门示例应用程序源包含一些文件，包括<code>package.json</code>：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/FuI7nmJ2NAtesloTZrh3eJL-aa0ceCCr68wQ"></p>
<p>这是定义所有CLI命令的地方，其中包括<code>yarn serve</code>我们刚才使用的。其他命令是</p>
<ul>
<li><code>yarn build</code>，开始生产构建</li>
<li><code>yarn lint</code>，运行lint</li>
<li><code>yarn test:unit</code>，运行单元测试</li>
</ul>
<p>我将在单独的教程中描述由Vue CLI生成的示例应用程序。</p>
<h4 id="Git仓库"><a href="#Git仓库" class="headerlink" title="Git仓库"></a>Git仓库</h4><p>注意<code>master</code>VS Code左下角的单词吗？这是因为Vue CLI自动创建存储库并进行第一次提交。这样我们就可以跳进去，进行更改，然后我们知道更改了什么：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/4IHrGo6U-xkz4aeVXf3S06AYzIk0lAZJ6t6y"></p>
<p>这很酷。您投入了多少次并进行了更改，才意识到，当您要提交结果时，您没有提交初始状态？</p>
<h4 id="从命令行使用预设"><a href="#从命令行使用预设" class="headerlink" title="从命令行使用预设"></a>从命令行使用预设</h4><p>您可以跳过交互式面板，并指示Vue CLI使用特定的预设：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create -p favourite example-2</span><br></pre></td></tr></table></figure>
<h4 id="预设存储在哪里"><a href="#预设存储在哪里" class="headerlink" title="预设存储在哪里"></a>预设存储在哪里</h4><p>预设存储在<code>.vuejs</code>主目录中的文件中。创建第一个“收藏夹”预设后，这是我的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;useTaobaoRegistry&quot;: false,</span><br><span class="line">  &quot;packageManager&quot;: &quot;yarn&quot;,</span><br><span class="line">  &quot;presets&quot;: &#123;</span><br><span class="line">    &quot;favourite&quot;: &#123;</span><br><span class="line">      &quot;useConfigFiles&quot;: true,</span><br><span class="line">      &quot;plugins&quot;: &#123;</span><br><span class="line">        &quot;@vue&#x2F;cli-plugin-babel&quot;: &#123;&#125;,</span><br><span class="line">        &quot;@vue&#x2F;cli-plugin-eslint&quot;: &#123;</span><br><span class="line">          &quot;config&quot;: &quot;prettier&quot;,</span><br><span class="line">          &quot;lintOn&quot;: [</span><br><span class="line">            &quot;save&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;@vue&#x2F;cli-plugin-unit-jest&quot;: &#123;&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;router&quot;: true,</span><br><span class="line">      &quot;vuex&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="外挂程式"><a href="#外挂程式" class="headerlink" title="外挂程式"></a>外挂程式</h4><p>从阅读配置可以看到，预设基本上是插件的集合，带有一些可选配置。</p>
<p>创建项目后，您可以使用来添加更多插件<code>vue add</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue add @vue&#x2F;cli-plugin-babel</span><br></pre></td></tr></table></figure>

<p>所有这些插件均以可用的最新版本使用。您可以通过传递version属性来强制Vue CLI使用特定版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;@vue&#x2F;cli-plugin-eslint&quot;: &#123;</span><br><span class="line">  &quot;version&quot;: &quot;^3.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果新版本具有重大更改或错误，并且您需要稍等片刻才能使用它，这将很有用。</p>
<h4 id="远程存储预设"><a href="#远程存储预设" class="headerlink" title="远程存储预设"></a>远程存储预设</h4><p>通过创建包含<code>preset.json</code>文件的存储库，可以将预设存储在GitHub（或其他服务）中，该文件包含单个预设配置。</p>
<p>从以上摘录中，我制作了一个包含以下配置的示例<a target="_blank" rel="noopener" href="https://github.com/flaviocopes/vue-cli-preset/blob/master/preset.json">预设</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  &quot;useConfigFiles&quot;: true,  &quot;plugins&quot;: &#123;    &quot;@vue&#x2F;cli-plugin-babel&quot;: &#123;&#125;,    &quot;@vue&#x2F;cli-plugin-eslint&quot;: &#123;      &quot;config&quot;: &quot;prettier&quot;,      &quot;lintOn&quot;: [        &quot;save&quot;      ]    &#125;,    &quot;@vue&#x2F;cli-plugin-unit-jest&quot;: &#123;&#125;  &#125;,  &quot;router&quot;: true,  &quot;vuex&quot;: true&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用以下命令来引导新应用程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create --preset flaviocopes&#x2F;vue-cli-preset example3</span><br></pre></td></tr></table></figure>
<h3 id="Vue-CLI的另一种用法：快速原型制作"><a href="#Vue-CLI的另一种用法：快速原型制作" class="headerlink" title="Vue CLI的另一种用法：快速原型制作"></a>Vue CLI的另一种用法：快速原型制作</h3><p>到现在为止，我已经解释了如何使用Vue CLI从头开始创建所有项目。但是对于真正快速的原型制作，您可以创建一个非常简单的Vue应用程序（甚至是一个包含在单个.vue文件中的应用程序）并提供该服务，而不必下载<code>node_modules</code>文件夹中的所有依赖项。</p>
<p>怎么样？首先安装<code>cli-service-global</code>全局软件包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue&#x2F;cli-service-global</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;or</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add @vue&#x2F;cli-service-global</span><br></pre></td></tr></table></figure>

<p>创建一个app.vue文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;    &lt;div&gt;        &lt;h2&gt;Hello world!&lt;&#x2F;h2&gt;        &lt;marquee&gt;Heyyy&lt;&#x2F;marquee&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>然后运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue serve app.vue</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn-media-1.freecodecamp.org/images/pp3QTRAMwLtOnkhazBRgRrjYKnMEbnm1CbWL">独立应用</p>
<p>您还可以提供由JavaScript和HTML文件组成的更有条理的项目。默认情况下，Vue CLI使用Vue CLI <code>main.js / index.js </code>作为其入口点，并且您可以<code>package.json</code>设置和任何工具配置。<code>vue serve</code>会捡起来。</p>
<p>由于这使用了全局依赖关系，因此除了演示或快速测试之外，它不是最佳方法。</p>
<p>运行<code>vue build</code>将准备在中部署项目<code>dist/</code>，并将生成所有相应的代码（也用于供应商依赖性）。</p>
<h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><p>在内部，Vue CLI使用Webpack，但是配置是抽象的，我们甚至在文件夹中都看不到配置文件。您仍然可以通过以下方式访问它<code>vue inspect</code>：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/dGT6I8Uq75505tD1Xj8wR-h7rO9ZvRby80cH"></p>
<h3 id="Vue开发工具"><a href="#Vue开发工具" class="headerlink" title="Vue开发工具"></a>Vue开发工具</h3><p>首次尝试使用Vue时，如果打开浏览器开发人员工具，则会发现以下消息：“下载Vue Devtools扩展以获得更好的开发体验：<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-devtools">https</a> : <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-devtools">//github.com/vuejs/vue-devtools</a> ”</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/J-LJE-u3DphYF8pOpMnkCX9KoNz3fGp4OPea">提示安装Vue devtools</p>
<p>这是一个友好的提醒，请安装Vue Devtools Extension。那是什么？任何流行的框架都有其自己的devtools扩展名，该扩展名通常会向浏览器开发人员工具添加一个新面板，该面板比浏览器默认提供的工具更加专业。在这种情况下，面板将使我们检查Vue应用程序并与之交互。</p>
<p>构建Vue应用程序时，此工具将为您提供惊人的帮助。开发人员工具只能在处于开发模式时检查Vue应用程序。这样可以确保没有人可以使用它们与您的生产应用程序进行交互，并且可以使Vue的性能更高，因为它不必关心开发工具。</p>
<p>让我们安装它！</p>
<p>有3种安装Vue Dev Tools的方法：</p>
<ul>
<li>在Chrome上</li>
<li>在Firefox上</li>
<li>作为独立的应用程序</li>
</ul>
<p>自定义扩展不支持Safari，Edge和其他浏览器，但是使用独立应用程序，您可以调试在任何浏览器中运行的Vue.js应用程序。</p>
<h4 id="在Chrome上安装"><a href="#在Chrome上安装" class="headerlink" title="在Chrome上安装"></a>在Chrome上安装</h4><p>转到Google Chrome <a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd">商店中的</a>此页面，然后单击<code>**Add to Chrome**</code>。</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/uh0CFZPRsdnKFOY-OWWvQCN3UVcnh-0KXpfh"></p>
<p>完成安装过程：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/hAQZpBESrlkCeLeLJpzeiPdJs12mmFHLRq9s"></p>
<p>Vue.js devtools图标显示在工具栏中。如果页面没有正在运行的Vue.js实例，则该页面显示为灰色。</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/TaZntVatyBmsqqKsMjbGKn5nIuJikKLOJJyt"></p>
<p>如果检测到Vue.js，则图标具有Vue徽标的颜色。</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/xPbOBNuLCdCE28QiFevAcqFb06Oqk8tB31Zy"></p>
<p>图标什么也不做只是告诉我们，有<strong>是</strong>一个Vue.js实例。要使用devtools，我们必须使用“查看→开发人员→开发人员工具”打开“开发人员工具”面板，或者<code>Cmd-Alt-i</code></p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/td1gw01JZxVxAkHLGg9FKzIHz8UFhMhvr3gG"></p>
<h4 id="在Firefox上安装"><a href="#在Firefox上安装" class="headerlink" title="在Firefox上安装"></a>在Firefox上安装</h4><p>您可以在Mozilla附加组件<a target="_blank" rel="noopener" href="https://addons.mozilla.org/en-US/firefox/addon/vue-js-devtools/">商店中</a>找到Firefox开发工具扩展。</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/y-G2Zcw62ZrkjMOe6ottwLy-z6onBxnZzOXm"></p>
<p>单击“添加到Firefox”，将安装扩展名。与Chrome一样，工具栏中会显示灰色图标</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/LQCCB8c2g0OsUmJZ20fYJBPbampJudlIPocv"></p>
<p>当您访问正在运行Vue实例的站点时，它将变为绿色，并且当我们打开开发工具时，我们将看到一个“ Vue”面板：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/jFYMTGNEhrkxzzC6Grdb7zgXrnHrwuR-0AiI"></p>
<h4 id="安装独立应用"><a href="#安装独立应用" class="headerlink" title="安装独立应用"></a>安装独立应用</h4><p>或者，您可以使用DevTools独立应用程序。</p>
<p>只需使用以下命令安装它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue&#x2F;devtools</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;or</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add @vue&#x2F;devtools</span><br></pre></td></tr></table></figure>

<p>并通过调用来运行它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue-devtools</span><br></pre></td></tr></table></figure>

<p>这将打开独立的基于电子的应用程序。</p>
<p>现在，粘贴显示给您的脚本标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;localhost:8098&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>在项目<code>index.html</code>文件中，然后等待应用程序重新加载。它将自动连接到应用程序。</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/ANnfWmlscUkP0RN9Pn-hSABLCOxzMJYvtuqw"></p>
<h4 id="如何使用开发人员工具"><a href="#如何使用开发人员工具" class="headerlink" title="如何使用开发人员工具"></a>如何使用开发人员工具</h4><p>如前所述，可以通过在浏览器中打开开发人员工具并移至Vue面板来激活Vue DevTools。</p>
<p>另一个选项是右键单击页面中的任何元素，然后选择“检查Vue组件”：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/r4URIzj-Mm92WTnnl9iXMK18f8cIwmyICQ0m"></p>
<p>打开Vue DevTools面板后，我们可以导航组件树。当我们从左侧的列表中选择一个组件时，右侧面板将显示其持有的道具和数据：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/h55RK1azzd7gjON36Da9HdY-tpu8cuVMBs-3"></p>
<p>在顶部有四个按钮：</p>
<ul>
<li><strong>组件</strong>（当前面板），其中列出了当前页面中运行的所有组件实例。Vue可以同时运行多个实例。例如，它可以使用单独的轻型应用程序管理购物车小部件和幻灯片。</li>
<li><strong>在Vuex</strong>中，您可以检查通过Vuex管理的状态。</li>
<li><strong>事件</strong>显示所有发出的事件。</li>
<li><strong>刷新将</strong>重新加载devtools面板。</li>
</ul>
<p>注意<code>= $vm0</code>组件旁边的小文本吗？这是使用控制台检查组件的便捷方法。按下“ esc”键将在devtools底部显示控制台，您可以键入<code>$vm0</code>以访问Vue组件：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/9fi396qPj8ajABDLnAoB77AkjDtLEJu-2okG"></p>
<p>检查组件并与之交互非常酷，而不必在代码中将它们分配给全局变量。</p>
<h4 id="过滤组件"><a href="#过滤组件" class="headerlink" title="过滤组件"></a>过滤组件</h4><p>开始输入组件名称，组件树将过滤出不匹配的组件。</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/IdqSWwFMpvHVN125f7uIxue0Xp0ic-HJmBzX"></p>
<h4 id="在页面中选择一个组件"><a href="#在页面中选择一个组件" class="headerlink" title="在页面中选择一个组件"></a>在页面中选择一个组件</h4><p>点击<code>**Select component in the page**</code>按钮。</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/RE969Y8eHdDn1rqHvj2OGfnEqthwHMVy37A-">在页面中选择组件</p>
<p>您可以用鼠标悬停在页面上的任何组件上，单击它，然后它将在devtools中打开。</p>
<h4 id="格式化组件名称"><a href="#格式化组件名称" class="headerlink" title="格式化组件名称"></a>格式化组件名称</h4><p>您可以选择在camelCase中显示组件或使用破折号。</p>
<h4 id="筛选检查的数据"><a href="#筛选检查的数据" class="headerlink" title="筛选检查的数据"></a>筛选检查的数据</h4><p>在右侧面板上，您可以输入任何单词来过滤与之不匹配的属性。</p>
<h4 id="检查DOM"><a href="#检查DOM" class="headerlink" title="检查DOM"></a>检查DOM</h4><p>单击“检查DOM”按钮，将其带到DevTools Elements检查器中，该DOM元素由组件生成：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/YKTlyULN-MDOAg3R1KPA3tI27IqX5Q9ckIH4">检查DOM</p>
<h4 id="在编辑器中打开"><a href="#在编辑器中打开" class="headerlink" title="在编辑器中打开"></a>在编辑器中打开</h4><p>任何用户组件（不是框架级组件）都有一个按钮，可在默认编辑器中将其打开。非常便利。</p>
<h3 id="设置VS-Code以与Vue一起使用"><a href="#设置VS-Code以与Vue一起使用" class="headerlink" title="设置VS Code以与Vue一起使用"></a>设置VS Code以与Vue一起使用</h3><p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/">Visual Studio Code</a>是目前世界上最常用的代码编辑器之一。像许多软件产品一样，编辑器有一个循环。一旦<a target="_blank" rel="noopener" href="https://macromates.com/">TextMate</a>成为开发人员的最爱，那么它就是<a target="_blank" rel="noopener" href="https://www.sublimetext.com/">Sublime Text</a>，现在是VS Code。</p>
<p>受欢迎的有趣之处在于，人们花了很多时间来为他们可以想象的一切构建插件。</p>
<p>一个这样的插件是一个很棒的工具，可以帮助我们Vue.js开发人员。</p>
<h4 id="威图"><a href="#威图" class="headerlink" title="威图"></a>威图</h4><p>它叫做Vetur，非常受欢迎（下载量超过300万），您可以<a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=octref.vetur">在Visual Studio Marketplace上</a>找到它。</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/OOfHNunbiMBxokJsrmdrvWixSoDmaDdPRzxK"></p>
<h4 id="安装Vetur"><a href="#安装Vetur" class="headerlink" title="安装Vetur"></a>安装Vetur</h4><p>单击“安装”按钮将在VS Code中触发安装面板：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/hskNZD-byUAunDSOjCdPXPMIb9v3rBPSlOvf"></p>
<p>您也可以简单地在VS Code中打开扩展，然后搜索“ vetur”：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/xbOVISLaIuAgHHvD4gKVFb0Lg9R1f5R5Jowk"></p>
<p>此扩展程序提供什么？</p>
<h4 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h4><p>Vetur为所有Vue源代码文件提供语法高亮显示。</p>
<p>如果没有Vetur，<code>.vue</code>VS Code将以这种方式显示文件：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/JTZ9KScP0WTtr-4cCvjvQJKkGwlA4EW9KIf3"></p>
<p>安装了Vetur时：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/c5wC-aTwknyXUSjqq9gbr-EqFbSDXSewix-N"></p>
<p>VS Code能够从其扩展名识别文件中包含的代码类型。</p>
<p>使用单个文件组件，您可以在同一文件中混合使用不同类型的代码，从CSS到JavaScript到HTML。</p>
<p>默认情况下，VS Code无法识别这种情况，而Vetur为您使用的每种代码提供语法高亮显示。</p>
<p>Vetur支持以下方面的支持：</p>
<ul>
<li>HTML</li>
<li>CSS</li>
<li>JavaScript</li>
<li>Pug</li>
<li>Haml</li>
<li>SCSS</li>
<li>PostCSS</li>
<li>Sass</li>
<li>Stylus</li>
<li>TypeScript</li>
</ul>
<h4 id="片段"><a href="#片段" class="headerlink" title="片段"></a>片段</h4><p>与语法突出显示一样，由于VS Code无法确定<code>.vue</code>文件一部分中包含的代码种类，因此无法提供我们都喜欢的代码段。代码片段是我们可以添加到文件中的代码片段，由专用插件提供。</p>
<p>Vetur使VS Code能够在单个文件组件中使用您喜欢的代码段。</p>
<h4 id="智能感知"><a href="#智能感知" class="headerlink" title="智能感知"></a>智能感知</h4><p>Vetur还为每种不同的语言启用了<a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/intellisense">IntelliSense</a>，并具有自动完成功能：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/3KtNeQR4W8HVg-JVT0kmu33sL79xlWIT0KtY"></p>
<h4 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h4><p>除了启用自定义片段外，Vetur还提供了自己的片段集。每个人都使用自己的语言创建一个特定的标签（模板，脚本或样式）：</p>
<ul>
<li><code>scaffold</code></li>
<li><code>template with html</code></li>
<li><code>template with pug</code></li>
<li><code>script with JavaScript</code></li>
<li><code>script with TypeScript</code></li>
<li><code>style with CSS</code></li>
<li><code>style with CSS (scoped)</code></li>
<li><code>style with scss</code></li>
<li><code>style with scss (scoped)</code></li>
<li><code>style with less</code></li>
<li><code>style with less (scoped)</code></li>
<li><code>style with sass</code></li>
<li><code>style with sass (scoped)</code></li>
<li><code>style with postcss</code></li>
<li><code>style with postcss (scoped)</code></li>
<li><code>style with stylus</code></li>
<li><code>style with stylus (scoped)</code></li>
</ul>
<p>如果输入<code>scaffold</code>，您将获得单个文件组件的入门包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>其他的是特定的，并创建单个代码块。</p>
<p><strong>注意：</strong>上面列表中的（作用域）意味着它仅适用于当前组件。</p>
<h4 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a>Emmet</h4><p>默认情况下，<a target="_blank" rel="noopener" href="https://emmet.io/">Emmet</a>是流行的HTML / CSS缩写引擎。您可以键入Emmet的缩写之一，然后按<code>tab</code>VS Code将自动将其扩展为等效的HTML：</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/R7Q4k9hsI0yzBe-xaVIMxdBMukjQWzzIw-FG"></p>
<h4 id="整理和错误检查"><a href="#整理和错误检查" class="headerlink" title="整理和错误检查"></a>整理和错误检查</h4><p>Vetur通过<a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">VS Code ESLint插件</a>与ESLint集成。</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/j1mnYvPYhNPWM00V0lDdxCwb5ZidBzG0Djtn"><img src="https://cdn-media-1.freecodecamp.org/images/5Z2hR9l8ARVe3uucCT4iPzTsDZRuEh0gZSs8"></p>
<h4 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a>代码格式化</h4><p>Vetur与<code>&quot;editor.formatOnSave&quot;</code>VS Code设置结合使用，为代码格式化提供自动支持，以在保存时格式化整个文件。</p>
<p>您可以通过在VS Code设置中将设置为<code>vetur.format.defaultFormatter.XXXXX</code>来选择禁用某些特定语言的自动格式<code>none</code>设置。要更改这些设置之一，只需开始搜索字符串，然后在右侧面板的用户设置中覆盖所需的内容即可。</p>
<p>支持的大多数语言都使用<a target="_blank" rel="noopener" href="https://prettier.io/">Prettier</a>进行自动格式化，该工具已成为行业标准。它使用您的Prettier配置来确定您的首选项。</p>
<h3 id="介绍Vue组件"><a href="#介绍Vue组件" class="headerlink" title="介绍Vue组件"></a>介绍Vue组件</h3><p>组件是接口的单个​​独立单元。他们可以具有自己的状态，标记和样式。</p>
<h4 id="如何使用组件"><a href="#如何使用组件" class="headerlink" title="如何使用组件"></a>如何使用组件</h4><p>Vue组件可以通过四种主要方式进行定义。让我们谈谈代码。</p>
<p>第一个是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;  &#x2F;* options *&#x2F;&#125;)</span><br></pre></td></tr></table></figure>

<p>第二个是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#39;component-name&#39;, &#123;  &#x2F;* options *&#x2F;&#125;)</span><br></pre></td></tr></table></figure>

<p>第三是通过使用本地组件。这些是只能由特定组件访问的组件，而在其他地方则不可用（非常适合封装）。</p>
<p>第四个在<code>.vue</code>文件中，也称为“单个文件组件”。</p>
<p>让我们详细介绍前三种方式。</p>
<p>在构建不是单页应用程序（SPA）的应用程序时，使用<code>new Vue()</code>或是<code>Vue.component()</code>使用Vue的标准方法。相反，当您仅在某些页面中使用Vue.js（例如在联系表单或购物车中）时，就使用此方法。也许在所有页面中都使用了Vue，但是服务器正在渲染布局，然后您将HTML提供给客户端，然后客户端将加载您构建的Vue应用程序。</p>
<p>在SPA中，是由Vue构建HTML的，使用单文件组件更为方便，因此更为常见。</p>
<p>您可以通过将Vue安装在DOM元素上来实例化Vue。如果您有<code>&lt;div id=&quot;app&quot;&gt;</code>&lt;/ div&gt;标签，则将使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123; el: &#39;#app&#39; &#125;)</span><br></pre></td></tr></table></figure>

<p>使用初始化的组件<code>new Vue</code>没有相应的标签名称，因此通常是主要的容器组件。</p>
<p>使用初始化应用程序中使用的其他组件<code>Vue.component()</code>。这样的组件允许您定义一个标记-您可以使用该标记在应用程序中多次嵌入该组件-并在<code>template</code>属性中指定该组件的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;  &lt;user-name name&#x3D;&quot;Flavio&quot;&gt;&lt;&#x2F;user-name&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#39;user-name&#39;, &#123;  props: [&#39;name&#39;],  template: &#39;&lt;p&gt;Hi &#123;.&#123; name &#125;&#125;&lt;&#x2F;p&gt;&#39;&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;  el: &#39;#app&#39;&#125;)</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://jsfiddle.net/flaviocopes/nvgedhq4/">在JSFiddle上查看</a></p>
<p>我们在做什么？我们正在上初始化一个Vue根组件<code>#app</code>，在其中，我们使用Vue组件<code>user-name</code>，它向用户抽象了问候语。</p>
<p>该组件接受一个prop，这是我们用来将数据向下传递给子组件的属性。</p>
<p>在<code>Vue.component()</code>调用中，我们将其<code>user-name</code>作为第一个参数传递。这为组件命名。您可以在此处以两种方式输入名称。第一个是我们使用的那个，叫做kebab-case。第二个称为PascalCase，类似于camelCase，但首字母大写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#39;UserName&#39;, &#123;  &#x2F;* ... *&#x2F;&#125;)</span><br></pre></td></tr></table></figure>

<p>Vue的自动创建从内部的别名<code>user-name</code>来<code>UserName</code>，反之亦然，所以你可以使用任何你喜欢的。通常最好<code>UserName</code>在JavaScript和<code>user-name</code>模板中使用。</p>
<h4 id="本地组件"><a href="#本地组件" class="headerlink" title="本地组件"></a>本地组件</h4><p>使用创建的任何组件<code>Vue.component()</code>都是全局注册的。您无需将其分配给变量或将其传递以在模板中重复使用。</p>
<p>您可以通过将定义组件对象的对象分配给变量来在本地封装组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Sidebar &#x3D; &#123;  template: &#39;&lt;aside&gt;Sidebar&lt;&#x2F;aside&gt;&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用该<code>components</code>属性使其在另一个组件内可用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;  el: &#39;#app&#39;,  components: &#123;    Sidebar  &#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>您可以在同一文件中编写组件，但是一种很好的方法是使用JavaScript模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Sidebar from &#39;.&#x2F;Sidebar&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;  el: &#39;#app&#39;,  components: &#123;    Sidebar  &#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重用组件"><a href="#重用组件" class="headerlink" title="重用组件"></a>重用组件</h4><p>子组件可以添加多次。每个单独的实例都独立于其他实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;  &lt;user-name name&#x3D;&quot;Flavio&quot;&gt;&lt;&#x2F;user-name&gt;  &lt;user-name name&#x3D;&quot;Roger&quot;&gt;&lt;&#x2F;user-name&gt;  &lt;user-name name&#x3D;&quot;Syd&quot;&gt;&lt;&#x2F;user-name&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#39;user-name&#39;, &#123;  props: [&#39;name&#39;],  template: &#39;&lt;p&gt;Hi &#123;.&#123; name &#125;&#125;&lt;&#x2F;p&gt;&#39;&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;  el: &#39;#app&#39;&#125;)</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://jsfiddle.net/flaviocopes/3kebv908/">在JSFiddle上查看</a></p>
<h4 id="组件的组成部分"><a href="#组件的组成部分" class="headerlink" title="组件的组成部分"></a>组件的组成部分</h4><p>到目前为止，我们已经看到了一个组件如何接受<code>el</code>，<code>props</code>并且<code>template</code>性能。</p>
<ul>
<li><code>el</code>仅在使用初始化的根组件中使用<code>new Vue(&#123;&#125;)</code>，并标识组件将安装在其上的DOM元素。</li>
<li><code>props</code> 列出了我们可以传递给子组件的所有属性</li>
<li><code>template</code> 我们可以在其中设置组件模板，该模板将负责定义组件生成的输出。</li>
</ul>
<p>组件接受其他属性：</p>
<ul>
<li><code>data</code> 组件本地状态</li>
<li><code>methods</code>：组成方法</li>
<li><code>computed</code>：与组件关联的计算属性</li>
<li><code>watch</code>：组件观察者</li>
</ul>
<h3 id="单个文件组件"><a href="#单个文件组件" class="headerlink" title="单个文件组件"></a>单个文件组件</h3><p>可以在JavaScript文件（<code>.js</code>）中声明Vue组件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#39;component-name&#39;, &#123;  &#x2F;* options *&#x2F;&#125;)</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;  &#x2F;* options *&#x2F;&#125;)</span><br></pre></td></tr></table></figure>

<p>或者可以在<code>.vue</code>文件中指定。</p>
<p>该<code>.vue</code>文件非常酷，因为它允许您定义：</p>
<ul>
<li>JavaScript logic</li>
<li>HTML code template</li>
<li>CSS styling</li>
</ul>
<p>全部都在一个文件中。因此，它的名称为“单个文件组件”。</p>
<p>这是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p&gt;&#123;.&#123; hello &#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      hello: &#39;Hello World!&#39;    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;  p &#123;    color: blue;  &#125;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>由于使用了Webpack，所有这些都是可能的。Vue CLI使得此操作非常容易，并且开箱即用。<code>.vue</code>如果没有Webpack设置，则无法使用这些文件，因此，它们非常不适合仅在页面上使用Vue而又不是完整的单页面应用程序（SPA）的应用程序。</p>
<p>由于单个文件组件依赖Webpack，因此我们免费获得了使用现代Web功能的功能。</p>
<p>您可以使用SCSS或Stylus定义CSS，可以使用Pug构建模板，而要做的就是向Vue声明要使用哪种语言预处理器。</p>
<p>支持的预处理器列表包括</p>
<ul>
<li>TypeScript</li>
<li>SCSS</li>
<li>Sass</li>
<li>Less</li>
<li>PostCSS</li>
<li>Pug</li>
</ul>
<p>无论使用Babel集成的目标浏览器是什么，我们都可以使用现代JavaScript（ES6-7-8），并且ES模块也是如此，因此我们可以使用<code>import/export</code>语句。</p>
<p>我们可以使用CSS模块来定义CSS范围。</p>
<p>说到对CSS进行范围界定，通过使用ed&gt;标签，单个文件组件使编写不会<strong>泄漏</strong>到其他组件的CSS绝对容易<code>&lt;style scop</code>。</p>
<p>如果省略<code>scoped</code>，则定义的CSS将是全局的。但是添加<code>scoped</code>标签后，Vue会自动向组件添加特定于您的应用程序的特定类，因此可以确保CSS不会泄漏到其他组件。</p>
<p>也许您的JavaScript非常庞大，因为您需要注意一些逻辑。如果要为JavaScript使用单独的文件怎么办？</p>
<p>您可以使用<code>src</code>属性将其外部化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p&gt;&#123;.&#123; hello &#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;&lt;script src&#x3D;&quot;.&#x2F;hello.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>这也适用于您的CSS：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p&gt;&#123;.&#123; hello &#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;&lt;script src&#x3D;&quot;.&#x2F;hello.js&quot;&gt;&lt;&#x2F;script&gt;&lt;style src&#x3D;&quot;.&#x2F;hello.css&quot;&gt;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>注意我如何使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;  data() &#123;    return &#123;      hello: &#39;Hello World!&#39;    &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>在组件的JavaScript中设置数据。</p>
<p>您将看到的其他常见方式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;  data: function() &#123;    return &#123;      name: &#39;Flavio&#39;    &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>以上等同于我们之前所做的工作。</p>
<p>要么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;  data: () &#x3D;&gt; &#123;    return &#123;      name: &#39;Flavio&#39;    &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这是不同的，因为它使用箭头功能。箭头函数很好，直到我们需要访问组件方法为止。如果我们需要使用，这是一个问题<code>this</code>，并且使用箭头功能未将此类属性绑定到组件。因此，必须使用<strong>常规</strong>函数而不是箭头函数。</p>
<p>您可能还会看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;  data: () &#x3D;&gt; &#123;    return &#123;      name: &#39;Flavio&#39;    &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这使用<a target="_blank" rel="noopener" href="http://requirejs.org/docs/commonjs.html">CommonJS</a>语法，并且也可以正常工作。但是我建议使用ES模块语法，因为这是JavaScript标准。</p>
<h3 id="Vue模板"><a href="#Vue模板" class="headerlink" title="Vue模板"></a>Vue模板</h3><p>Vue.js使用的模板语言是HTML的超集。</p>
<p>任何HTML都是有效的Vue.js模板。除此之外，Vue.js还提供了两个强大的功能：插值和指令。</p>
<p>这是有效的Vue.js模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;Hello!&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>

<p>可以将该模板放入显式声明的Vue组件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;  template: &#39;&lt;span&gt;Hello!&lt;&#x2F;span&gt;&#39;&#125;)</span><br></pre></td></tr></table></figure>

<p>或者可以将其放入单个文件组件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;span&gt;Hello!&lt;&#x2F;span&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>第一个示例非常基础。下一步是使其输出部分组件状态，例如名称。</p>
<p>这可以使用插值来完成。首先，我们向组件添加一些数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;  </span><br><span class="line">  data: &#123;    </span><br><span class="line">    name: &#39;Flavio&#39;  </span><br><span class="line">  &#125;,  </span><br><span class="line">  template: &#39;&lt;span&gt;Hello!&lt;&#x2F;span&gt;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后我们可以使用双括号语法将其添加到模板中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;  data: &#123;    name: &#39;Flavio&#39;  &#125;,  template: &#39;&lt;span&gt;Hello &#123;.&#123;name&#125;&#125;!&lt;&#x2F;span&gt;&#39;&#125;)</span><br></pre></td></tr></table></figure>

<p>这里一件有趣的事。看看我们是怎么<code>name</code>代替的<code>this.data.name</code>？</p>
<p>这是因为Vue.js进行了一些内部绑定，并允许模板像使用本地属性一样使用该属性。很方便。</p>
<p>在单个文件组件中，将是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;span&gt;Hello &#123;.&#123;name&#125;&#125;!&lt;&#x2F;span&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      name: &#39;Flavio&#39;    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>我在导出中使用了常规函数。为什么不使用箭头功能？</p>
<p>这是因为在这种情况下，<code>data</code>我们可能需要访问组件实例中的方法，并且如果<code>this</code>未绑定到组件，则无法执行该操作，因此无法使用箭头功能。</p>
<p>请注意，我们可以使用箭头功能，但是如果我使用，则需要记住切换到常规功能<code>this</code>。我认为最好安全一点。</p>
<p>现在，回到插值。</p>
<p><code>&#123;.&#123; name &#125;&#125;</code> 应该使您想起Mustache / Handlebars模板插值，但这只是视觉上的提醒。</p>
<p>尽管在那些模板引擎中它们是“哑巴”，但在Vue中，您可以做更多的事情，并且更加灵活。</p>
<p>您可以在插值中使用任何JavaScript表达式，但仅限于一个表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;.&#123; name.reverse() &#125;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;.&#123; name &#x3D;&#x3D;&#x3D; &#39;Flavio&#39; ? &#39;Flavio&#39; : &#39;stranger&#39; &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>Vue提供对模板中某些全局对象的访问，包括Math和Date，因此您可以使用它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;.&#123; Math.sqrt(16) * Math.random() &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>最好避免向模板添加复杂的逻辑，但是Vue允许这样做的事实为我们提供了更大的灵活性，尤其是在尝试时。</p>
<p>我们可以先尝试将表达式放入模板中，然后再将其移动到计算的属性或方法中。</p>
<p>任何插值中包含的值将在其依赖的任何数据属性发生更改时进行更新。</p>
<p>您可以通过使用<code>v-once</code>指令来避免这种反应。</p>
<p>结果总是转义的，因此输出中不能包含HTML。</p>
<p>如果需要HTML片段，则需要使用<code>v-html</code>指令。</p>
<h3 id="使用CSS样式化组件"><a href="#使用CSS样式化组件" class="headerlink" title="使用CSS样式化组件"></a>使用CSS样式化组件</h3><p>将CSS添加到Vue.js组件的最简单选择是使用<code>style</code>标签，就像在HTML中一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p style&#x3D;&quot;text-decoration: underline&quot;&gt;Hi!&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      decoration: &#39;underline&#39;    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>这是尽可能静态的。如果要<code>underline</code>在组件数据中定义怎么办？您可以按照以下方法进行操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p :style&#x3D;&quot;&#123;&#39;text-decoration&#39;: decoration&#125;&quot;&gt;Hi!&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      decoration: &#39;underline&#39;    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><code>:style</code>是的简写<code>v-bind:style</code>。在本教程中，我将使用此速记。</p>
<p>注意我们必须如何<code>text-decoration</code>用引号引起来。这是因为破折号不是有效的JavaScript标识符的一部分。</p>
<p>您可以使用Vue.js启用的特殊camelCase语法并将其重写为<code>textDecoration</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p :style&#x3D;&quot;&#123;textDecoration: decoration&#125;&quot;&gt;Hi!&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>除了<code>style</code>可以将对象绑定到之外，您还可以引用计算属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p :style&#x3D;&quot;styling&quot;&gt;Hi!&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      textDecoration: &#39;underline&#39;,      textWeight: &#39;bold&#39;    &#125;  &#125;,  computed: &#123;    styling: function() &#123;      return &#123;        textDecoration: this.textDecoration,        textWeight: this.textWeight      &#125;    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>Vue组件生成纯HTML，因此您可以选择向每个元素添加一个类，并添加具有样式设置其属性的相应CSS选择器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p class&#x3D;&quot;underline&quot;&gt;Hi!&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;.underline &#123; text-decoration: underline; &#125;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>您可以像这样使用SCSS：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p class&#x3D;&quot;underline&quot;&gt;Hi!&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang&#x3D;&quot;scss&quot;&gt;body &#123;  .underline &#123; text-decoration: underline; &#125;&#125;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>您可以像上面的示例一样对类进行硬编码。或者，您可以将类绑定到组件属性，以使其具有动态性，并且仅在data属性为true时才应用于该类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p :class&#x3D;&quot;&#123;underline: isUnderlined&#125;&quot;&gt;Hi!&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      isUnderlined: true    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;.underline &#123; text-decoration: underline; &#125;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;p :class=&quot;&#123;text: isText&#125;&quot;&gt;H</code>您可以直接绑定一个字符串，而不是像我们对i！那样将对象绑定到类！&lt;/ p&gt;，它将引用一个数据属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p :class&#x3D;&quot;paragraphClass&quot;&gt;Hi!&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      paragraphClass: &#39;underline&#39;    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;.underline &#123; text-decoration: underline; &#125;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>您可以分配多个类，<code>paragraphClass</code>在这种情况下，可以添加两个类，也可以使用数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p :class&#x3D;&quot;[decoration, weight]&quot;&gt;Hi!&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      decoration: &#39;underline&#39;,      weight: &#39;weight&#39;,    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;.underline &#123; text-decoration: underline; &#125;.weight &#123; font-weight: bold; &#125;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>使用类绑定中内联的对象可以完成相同的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p :class&#x3D;&quot;&#123;underline: isUnderlined, weight: isBold&#125;&quot;&gt;Hi!&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      isUnderlined: true,      isBold: true    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;.underline &#123; text-decoration: underline; &#125;.weight &#123; font-weight: bold; &#125;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>您可以结合以下两个语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p :class&#x3D;&quot;[decoration, &#123;weight: isBold&#125;]&quot;&gt;Hi!&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      decoration: &#39;underline&#39;,      isBold: true    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;.underline &#123; text-decoration: underline; &#125;.weight &#123; font-weight: bold; &#125;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>您还可以使用返回对象的计算属性，当您将多个CSS类添加到同一元素时，该属性最有效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p :class&#x3D;&quot;paragraphClasses&quot;&gt;Hi!&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      isUnderlined: true,      isBold: true    &#125;  &#125;,  computed: &#123;    paragraphClasses: function() &#123;      return &#123;        underlined: this.isUnderlined,        bold: this.isBold      &#125;    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;.underlined &#123; text-decoration: underline; &#125;.bold &#123; font-weight: bold; &#125;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>请注意，在计算属性中，您需要使用来引用组件数据<code>this.[propertyName]</code>，而在模板数据中，属性可以方便地放置为第一级属性。</p>
<p>Vue将处理任何未像第一个示例中那样进行硬编码的CSS，Vue会为我们自动为CSS加上前缀。这使我们可以编写干净的CSS，同时仍可以针对较旧的浏览器（这仍然意味着Vue支持的浏览器，因此是IE9 +）。</p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>我们在Vue.js模板和插值中看到了如何将数据嵌入Vue模板。</p>
<p>本节说明Vue.js在模板中提供的另一种技术：指令。</p>
<p>指令基本上类似于添加在模板内部的HTML属性。它们都以开头<code>v-</code>，以表示这是Vue的特殊属性。</p>
<p>让我们详细了解每个Vue指令。</p>
<h4 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a><code>v-text</code></h4><p>代替使用插值，可以使用<code>v-text</code>指令。它执行相同的工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-text&#x3D;&quot;name&quot;&gt;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>
<h4 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a><code>v-once</code></h4><p>您知道如何<code>&#123;.&#123; name &#125;&#125;</code>绑定到<code>name</code>组件数据的属性。</p>
<p>每当<code>name</code>您的组件数据发生更改时，Vue都会更新浏览器中表示的值。</p>
<p>除非使用<code>v-once</code>伪指令，否则伪指令基本上类似于HTML属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-once&gt;&#123;.&#123; name &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>
<h4 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a><code>v-html</code></h4><p>使用插值打印数据属性时，将转义HTML。这是Vue自动防御XSS攻击的一种好方法。</p>
<p>但是，在某些情况下，您想输出HTML并让浏览器解释它。您可以使用<code>v-html</code>指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-html&#x3D;&quot;someHtml&quot;&gt;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>
<h4 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a><code>v-bind</code></h4><p>插值仅适用于标签内容。您不能在属性上使用它。</p>
<p>属性必须使用<code>v-bind</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;&#123;.&#123; linkText &#125;&#125;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p><code>v-bind</code> 非常普遍，以至于它有一个简写语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;&#123;.&#123; linkText &#125;&#125;&lt;&#x2F;a&gt;&lt;a :href&#x3D;&quot;url&quot;&gt;&#123;.&#123; linkText &#125;&#125;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<h4 id="双向绑定使用-v-model"><a href="#双向绑定使用-v-model" class="headerlink" title="双向绑定使用 v-model"></a>双向绑定使用 <code>v-model</code></h4><p>例如 <code>v-model</code> ，让我们绑定一个表单输入元素，并在用户更改字段内容时使它更改Vue数据属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model&#x3D;&quot;message&quot; placeholder&#x3D;&quot;Enter a message&quot;&gt;&lt;p&gt;Message is: &#123;.&#123; message &#125;&#125;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;select v-model&#x3D;&quot;selected&quot;&gt;  &lt;option disabled value&#x3D;&quot;&quot;&gt;Choose a fruit&lt;&#x2F;option&gt;  &lt;option&gt;Apple&lt;&#x2F;option&gt;  &lt;option&gt;Banana&lt;&#x2F;option&gt;  &lt;option&gt;Strawberry&lt;&#x2F;option&gt;&lt;&#x2F;select&gt;&lt;span&gt;Fruit chosen: &#123;.&#123; selected &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>
<h4 id="使用表达式"><a href="#使用表达式" class="headerlink" title="使用表达式"></a>使用表达式</h4><p>您可以在指令内使用任何JavaScript表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-text&#x3D;&quot;&#39;Hi, &#39; + name + &#39;!&#39;&quot;&gt;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-bind:href&#x3D;&quot;&#39;https:&#x2F;&#x2F;&#39; + domain + path&quot;&gt;&#123;.&#123; linkText &#125;&#125;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>指令中使用的任何变量都引用相应的data属性。</p>
<h4 id="有条件的"><a href="#有条件的" class="headerlink" title="有条件的"></a>有条件的</h4><p>在指令内部，您可以使用三元运算符执行条件检查，因为这是一个表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-text&#x3D;&quot;name &#x3D;&#x3D; Flavio ? &#39;Hi Flavio!&#39; : &#39;Hi&#39; + name + &#39;!&#39;&quot;&gt;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>

<p>有专门的指令，让您执行更为有组织的条件句：<code>v-if</code>，<code>v-else</code>和<code>v-else-if</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-if&#x3D;&quot;shouldShowThis&quot;&gt;Hey!&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<p><code>shouldShowThis</code> 是包含在组件数据中的布尔值。</p>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p><code>v-for</code>允许您呈现项目列表。结合使用<code>v-bind</code>可以设置列表中每个项目的属性。</p>
<p>您可以迭代一个简单的值数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;ul&gt;    &lt;li v-for&#x3D;&quot;item in items&quot;&gt;&#123;.&#123; item &#125;&#125;&lt;&#x2F;li&gt;  &lt;&#x2F;ul&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      items: [&#39;car&#39;, &#39;bike&#39;, &#39;dog&#39;]    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>或在一组对象上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;div&gt;    &lt;!-- using interpolation --&gt;    &lt;ul&gt;      &lt;li v-for&#x3D;&quot;todo in todos&quot;&gt;&#123;.&#123; todo.title &#125;&#125;&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;    &lt;!-- using v-text --&gt;    &lt;ul&gt;      &lt;li v-for&#x3D;&quot;todo in todos&quot; v-text&#x3D;&quot;todo.title&quot;&gt;&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      todos: [        &#123; id: 1, title: &#39;Do something&#39; &#125;,        &#123; id: 2, title: &#39;Do something else&#39; &#125;      ]    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><code>v-for</code> 可以使用以下方式为您提供索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for&#x3D;&quot;(todo, index) in todos&quot;&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>
<h4 id="大事记"><a href="#大事记" class="headerlink" title="大事记"></a>大事记</h4><p><code>v-on</code>允许您侦听DOM事件，并在事件发生时触发方法。在这里，我们监听点击事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;a v-on:click&#x3D;&quot;handleClick&quot;&gt;Click me!&lt;&#x2F;a&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  methods: &#123;    handleClick: function() &#123;      alert(&#39;test&#39;)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>您可以将参数传递给任何事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;a v-on:click&#x3D;&quot;handleClick(&#39;test&#39;)&quot;&gt;Click me!&lt;&#x2F;a&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  methods: &#123;    handleClick: function(value) &#123;      alert(value)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>少量的JavaScript（单个表达式）可以直接放入模板中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;a v-on:click&#x3D;&quot;counter &#x3D; counter + 1&quot;&gt;&#123;.&#123;counter&#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data: function() &#123;    return &#123;      counter: 0    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><code>click</code>只是一种事件。一个常见的事件是<code>submit</code>，您可以使用绑定该事件<code>v-on:submit</code>。</p>
<p><code>v-on</code>非常普遍，以至于它有一个简写语法<code>@</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-on:click&#x3D;&quot;handleClick&quot;&gt;Click me!&lt;&#x2F;a&gt;&lt;a @click&#x3D;&quot;handleClick&quot;&gt;Click me!&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<h4 id="显示或隐藏"><a href="#显示或隐藏" class="headerlink" title="显示或隐藏"></a>显示或隐藏</h4><p>如果Vue实例的特定属性评估为true，则可以选择仅在DOM中显示元素，方法是<code>v-show</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-show&#x3D;&quot;isTrue&quot;&gt;Something&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<p>元素仍插入DOM中，但<code>display: none</code>如果不满足条件则设置为。</p>
<h4 id="事件指令修饰符"><a href="#事件指令修饰符" class="headerlink" title="事件指令修饰符"></a>事件指令修饰符</h4><p>Vue提供了一些可选的事件修饰符，您可以将它们与结合使用<code>v-on</code>，这些修饰符会自动使事件执行某些操作，而无需在事件处理程序中对其进行显式编码。</p>
<p>一个很好的例子是<code>.prevent</code>，它会自动调用<code>preventDefault()</code>该事件。</p>
<p>在这种情况下，该表单不会导致页面被重新加载，这是默认行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form v-on:submit.prevent&#x3D;&quot;formSubmitted&quot;&gt;&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>其它调节剂包括<code>.stop</code>，<code>.capture</code>，<code>.self</code>，<code>.once</code>，<code>.passive</code>和他们<a target="_blank" rel="noopener" href="https://vuejs.org/v2/guide/events.html#Event-Modifiers">详细的官方文档描述</a>。</p>
<h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><p>Vue默认指令已经可以完成很多工作，但是如果需要，您可以随时添加新的自定义指令。</p>
<p>如果您有兴趣了解更多信息，请阅读<a target="_blank" rel="noopener" href="https://vuejs.org/v2/guide/custom-directive.html">此处</a>。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="什么是Vue-js方法？"><a href="#什么是Vue-js方法？" class="headerlink" title="什么是Vue.js方法？"></a>什么是Vue.js方法？</h4><p>Vue方法是与Vue实例关联的函数。</p>
<p>方法在<code>methods</code>属性内定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;  methods: &#123;    handleClick: function() &#123;      alert(&#39;test&#39;)    &#125;  &#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>或对于单个文件组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  methods: &#123;    handleClick: function() &#123;      alert(&#39;test&#39;)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>当您需要执行操作并将<code>v-on</code>指令附加到元素上以处理事件时，方法特别有用。像这样，<code>handleClick</code>当元素被点击时调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;a @click&#x3D;&quot;handleClick&quot;&gt;Click me!&lt;&#x2F;a&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<h4 id="将参数传递给Vue-js方法"><a href="#将参数传递给Vue-js方法" class="headerlink" title="将参数传递给Vue.js方法"></a>将参数传递给Vue.js方法</h4><p>方法可以接受参数。</p>
<p>在这种情况下，您只需在模板中传递参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;a @click&#x3D;&quot;handleClick(&#39;something&#39;)&quot;&gt;Click me!&lt;&#x2F;a&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;  methods: &#123;    handleClick: function(text) &#123;      alert(text)    &#125;  &#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>或对于单个文件组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  methods: &#123;    handleClick: function(text) &#123;      alert(text)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="如何从方法访问数据"><a href="#如何从方法访问数据" class="headerlink" title="如何从方法访问数据"></a>如何从方法访问数据</h4><p>您可以使用以下命令访问Vue组件的任何数据属性<code>this.propertyName</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;a @click&#x3D;&quot;handleClick()&quot;&gt;Click me!&lt;&#x2F;a&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      name: &#39;Flavio&#39;    &#125;  &#125;,  methods: &#123;    handleClick: function() &#123;      console.log(this.name)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>我们不必使用<code>this.data.name</code>，只是<code>this.name</code>。Vue确实为我们提供了透明的绑定。使用<code>this.data.name</code>将引发错误。</p>
<p>如您在<strong>事件</strong>描述中之前所看到的，方法与事件紧密关联，因为它们被用作事件处理程序。每次事件发生时，都会调用该方法。</p>
<h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><p>监视程序是Vue.js的一项特殊功能，它使您可以监视组件状态的一个属性，并在该属性值更改时运行一个函数。</p>
<p>这是一个例子。我们有一个显示名称的组件，并允许您通过单击按钮进行更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p&gt;My name is &#123;.&#123;name&#125;&#125;&lt;&#x2F;p&gt;  &lt;button @click&#x3D;&quot;changeName()&quot;&gt;Change my name!&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      name: &#39;Flavio&#39;    &#125;  &#125;,  methods: &#123;    changeName: function() &#123;      this.name &#x3D; &#39;Flavius&#39;    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>名称更改后，我们想做一些事情，例如打印控制台日志。</p>
<p>我们可以通过在<code>watch</code>对象上添加一个名为data属性的属性来实现此目的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      name: &#39;Flavio&#39;    &#125;  &#125;,  methods: &#123;    changeName: function() &#123;      this.name &#x3D; &#39;Flavius&#39;    &#125;  &#125;,  watch: &#123;    name: function() &#123;      console.log(this.name)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>分配给的功能<code>watch.name</code>可以选择接受2个参数。首先是新的属性值。第二个是旧的属性值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  &#x2F;* ... *&#x2F;  watch: &#123;    name: function(newValue, oldValue) &#123;      console.log(newValue, oldValue)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>无法像使用计算属性一样从模板中查找观察者。</p>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><h4 id="什么是计算属性"><a href="#什么是计算属性" class="headerlink" title="什么是计算属性"></a>什么是计算属性</h4><p>在Vue.js中，您可以使用括号输出任何数据值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p&gt;&#123;.&#123; count &#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      count: 1    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>此属性可以托管一些小的计算。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &#123;.&#123; count * 10 &#125;&#125;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>但是您只能使用一个JavaScript <strong>表达式</strong>。</p>
<p>除此技术限制外，您还需要考虑模板应仅与向用户显示数据有关，而不应执行逻辑计算。</p>
<p>若要执行多个操作而不是单个表达式，并具有更多的声明性模板，请使用计算属性。</p>
<p>计算属性是在<code>computed</code>Vue组件的属性中定义的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  computed: &#123;</span><br><span class="line">&#96;&#96;&#96; &#96;&#96;&#96;</span><br><span class="line">&#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="计算属性的示例"><a href="#计算属性的示例" class="headerlink" title="计算属性的示例"></a>计算属性的示例</h4><p>这是一个使用计算属性<code>count</code>计算输出的示例。</p>
<p>注意：</p>
<ol>
<li>我不必打电话<code>&#123;.&#123; count() &#125;&#125;</code>。Vue.js自动调用该函数</li>
<li>我使用常规函数（而不是箭头函数）来定义<code>count</code>计算所得的属性，因为我需要能够通过来访问组件实例<code>this</code>。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p&gt;&#123;.&#123; count &#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      items: [1, 2, 3]    &#125;  &#125;,  computed: &#123;    count: function() &#123;      return &#39;The count is &#39; + this.items.length * 10    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="计算属性与方法"><a href="#计算属性与方法" class="headerlink" title="计算属性与方法"></a>计算属性与方法</h4><p>如果您已经了解Vue方法，您可能会想知道有什么区别。</p>
<p>首先，必须调用方法，而不仅仅是引用方法，因此您需要执行以下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p&gt;&#123;.&#123; count() &#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      items: [1, 2, 3]    &#125;  &#125;,  methods: &#123;    count: function() &#123;      return &#39;The count is &#39; + this.items.length * 10    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>但是主要区别在于，已计算的属性已缓存。</p>
<p><code>count</code>计算属性的结果在内部缓存，直到<code>items</code>数据属性更改。</p>
<p><strong>重要：</strong>仅当反应性源更新时，才会更新计算属性。常规JavaScript方法不是被动的，因此一个常见的示例是使用<code>Date.now()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p&gt;&#123;.&#123; now &#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  computed: &#123;    now: function () &#123;      return Date.now()    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>它只会渲染一次，即使重新渲染组件也不会更新。当Vue组件退出并重新初始化时，它仅在页面刷新时更新。</p>
<p>在这种情况下，一种方法更适合您的需求。</p>
<h3 id="方法与观察者与计算属性"><a href="#方法与观察者与计算属性" class="headerlink" title="方法与观察者与计算属性"></a>方法与观察者与计算属性</h3><p>既然您知道方法，观察者和计算属性，那么您可能想知道什么时候应该使用一种方法。</p>
<p>这是这个问题的细分。</p>
<h4 id="何时使用方法"><a href="#何时使用方法" class="headerlink" title="何时使用方法"></a>何时使用方法</h4><ul>
<li>对DOM中发生的某些事件做出反应</li>
<li>当组件中发生某些事情时调用函数。<br>您可以从计算的属性或观察程序中调用方法。</li>
</ul>
<h4 id="何时使用计算属性"><a href="#何时使用计算属性" class="headerlink" title="何时使用计算属性"></a>何时使用计算属性</h4><ul>
<li>您需要从现有数据源中组合新数据</li>
<li>您有一个在模板中使用的变量，该变量是根据一个或多个数据属性构建的</li>
<li>您希望将复杂的嵌套属性名称简化为更易读和易于使用的名称（但是在原始属性更改时进行更新）</li>
<li>您需要从模板中引用一个值。在这种情况下，最好创建一个计算属性，因为它已缓存。</li>
<li>您需要聆听多个数据属性的更改</li>
</ul>
<h4 id="何时使用观察者"><a href="#何时使用观察者" class="headerlink" title="何时使用观察者"></a>何时使用观察者</h4><ul>
<li>您想在数据属性更改时进行监听，并执行一些操作</li>
<li>您想听听道具价值的变化</li>
<li>您只需要听一个特定的属性（您不能同时观看多个属性）</li>
<li>您要监视一个数据属性，直到达到某个特定值，然后再执行某些操作</li>
</ul>
<h3 id="道具：将数据传递给子组件"><a href="#道具：将数据传递给子组件" class="headerlink" title="道具：将数据传递给子组件"></a>道具：将数据传递给子组件</h3><p>道具是组件可以从包含它们的组件（父组件）接受数据的方式。</p>
<p>当组件需要一个或多个道具时，必须在其<code>props</code>属性中定义它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#39;user-name&#39;, &#123;  props: [&#39;name&#39;],  template: &#39;&lt;p&gt;Hi &#123;.&#123; name &#125;&#125;&lt;&#x2F;p&gt;&#39;&#125;)</span><br></pre></td></tr></table></figure>

<p>或者，在Vue单个文件组件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p&gt;&#123;.&#123; name &#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  props: [&#39;name&#39;]&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="接受多个道具"><a href="#接受多个道具" class="headerlink" title="接受多个道具"></a>接受多个道具</h4><p>您可以通过简单地将它们附加到数组来获得多个props：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#39;user-name&#39;, &#123;  props: [&#39;firstName&#39;, &#39;lastName&#39;],  template: &#39;&lt;p&gt;Hi &#123;.&#123; firstName &#125;&#125; &#123;.&#123; lastName &#125;&#125;&lt;&#x2F;p&gt;&#39;&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="设置道具类型"><a href="#设置道具类型" class="headerlink" title="设置道具类型"></a>设置道具类型</h4><p>您可以使用对象而不是数组，使用属性名称作为每个属性的键，并使用类型作为值来非常简单地指定道具的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#39;user-name&#39;, &#123;  props: &#123;    firstName: String,    lastName: String  &#125;,  template: &#39;&lt;p&gt;Hi &#123;.&#123; firstName &#125;&#125; &#123;.&#123; lastName &#125;&#125;&lt;&#x2F;p&gt;&#39;&#125;)</span><br></pre></td></tr></table></figure>

<p>您可以使用的有效类型是：</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Array</li>
<li>Object</li>
<li>Date</li>
<li>Function</li>
<li>Symbol</li>
</ul>
<p>当类型不匹配时，Vue会在控制台中以警告方式警告您（处于开发模式）。</p>
<p>道具类型可以更清晰地表达。</p>
<p>您可以允许多种不同的值类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;  firstName: [String, Number]&#125;</span><br></pre></td></tr></table></figure>
<h4 id="将道具设置为强制性"><a href="#将道具设置为强制性" class="headerlink" title="将道具设置为强制性"></a>将道具设置为强制性</h4><p>您可以要求道具是强制性的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;  firstName: &#123;    type: String,    required: true  &#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="设置道具的默认值"><a href="#设置道具的默认值" class="headerlink" title="设置道具的默认值"></a>设置道具的默认值</h4><p>您可以指定一个默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;  firstName: &#123;    type: String,    default: &#39;Unknown person&#39;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>对于对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;  name: &#123;    type: Object,    default: &#123;      firstName: &#39;Unknown&#39;,      lastName: &#39;&#39;    &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><code>default</code> 也可以是返回适当值的函数，而不是实际值。</p>
<p>您甚至可以构建一个自定义验证器，该验证器对复杂数据很酷：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;  name: &#123;    validator: name &#x3D;&gt; &#123;      return name &#x3D;&#x3D;&#x3D; &#39;Flavio&#39;     &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="将道具传递到组件"><a href="#将道具传递到组件" class="headerlink" title="将道具传递到组件"></a>将道具传递到组件</h4><p>您使用语法将prop传递给组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ComponentName color&#x3D;&quot;white&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>如果您传递的是静态值。</p>
<p>如果它是数据属性，则使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;ComponentName :color&#x3D;color &#x2F;&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;...export default &#123;  &#x2F;&#x2F;...  data: function() &#123;    return &#123;      color: &#39;white&#39;    &#125;  &#125;,  &#x2F;&#x2F;...&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>您可以在prop值内使用三元运算符来检查真实条件并传递依赖于该条件的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;ComponentName :colored&#x3D;&quot;color &#x3D;&#x3D; &#39;white&#39; ? true : false&quot; &#x2F;&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;...export default &#123;  &#x2F;&#x2F;...  data: function() &#123;    return &#123;      color: &#39;white&#39;    &#125;  &#125;,  &#x2F;&#x2F;...&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="在Vue中处理事件"><a href="#在Vue中处理事件" class="headerlink" title="在Vue中处理事件"></a>在Vue中处理事件</h3><h4 id="什么是Vue-js事件？"><a href="#什么是Vue-js事件？" class="headerlink" title="什么是Vue.js事件？"></a>什么是Vue.js事件？</h4><p>Vue.js允许我们通过使用<code>v-on</code>元素上的指令来拦截任何DOM事件。</p>
<p>如果我们想在此元素中发生点击事件时采取措施：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;a&gt;Click me!&lt;&#x2F;a&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>我们添加一条<code>v-on</code>指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;a v-on:click&#x3D;&quot;handleClick&quot;&gt;Click me!&lt;&#x2F;a&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>Vue还为此提供了一种非常方便的替代语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;a @click&#x3D;&quot;handleClick&quot;&gt;Click me!&lt;&#x2F;a&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>您可以选择是否使用括号。<code>@click=&quot;handleClick&quot;</code>等同于<code>@click=&quot;handleClick()&quot;</code>。</p>
<p><code>handleClick</code> 是附加到组件的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  methods: &#123;    handleClick: function(event) &#123;      console.log(event)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>您需要在这里知道的是，您可以通过事件传递参数：<code>@click=&quot;handleClick(param)&quot;</code>它们将在方法内部接收。</p>
<h4 id="访问原始事件对象"><a href="#访问原始事件对象" class="headerlink" title="访问原始事件对象"></a>访问原始事件对象</h4><p>在许多情况下，您将要对事件对象执行操作或在其中查找某些属性。您如何访问它？</p>
<p>使用特殊<code>$event</code>指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;a @click&#x3D;&quot;handleClick($event)&quot;&gt;Click me!&lt;&#x2F;a&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  methods: &#123;    handleClick: function(event) &#123;      console.log(event)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>并且如果您已经传递了变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;a @click&#x3D;&quot;handleClick(&#39;something&#39;, $event)&quot;&gt;Click me!&lt;&#x2F;a&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  methods: &#123;    handleClick: function(text, event) &#123;      console.log(text)      console.log(event)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>从那里可以调用<code>event.preventDefault()</code>，但是有一个更好的方法：事件修饰符。</p>
<h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><p>告诉Vue为您处理事情，而不是弄乱方法中的DOM“事物”：</p>
<ul>
<li><code>@click.prevent</code> 呼叫 <code>event.preventDefault()</code></li>
<li><code>@click.stop</code> 呼叫 <code>event.stopPropagation()</code></li>
<li><code>@click.passive</code>利用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters">addEventListener</a>的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters">被动选项</a></li>
<li><code>@click.capture</code> 使用事件捕获而不是事件冒泡</li>
<li><code>@click.self</code> 确保click事件没有从子事件中冒出，而是直接发生在该元素上</li>
<li><code>@click.once</code> 事件只会被触发一次</li>
</ul>
<p>所有这些选项可以通过在一个修饰符之后附加一个修饰符来组合。</p>
<p>有关传播，冒泡和捕获的更多信息，请参阅我的<a target="_blank" rel="noopener" href="https://flaviocopes.com/javascript-events">JavaScript事件指南</a>。</p>
<h3 id="使用广告位注入内容"><a href="#使用广告位注入内容" class="headerlink" title="使用广告位注入内容"></a>使用广告位注入内容</h3><p>组件可以选择完全定义其内容，例如在这种情况下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#39;user-name&#39;, &#123;  props: [&#39;name&#39;],  template: &#39;&lt;p&gt;Hi &#123;.&#123; name &#125;&#125;&lt;&#x2F;p&gt;&#39;&#125;)</span><br></pre></td></tr></table></figure>

<p>或者，它也可以让父组件通过使用插槽将任何种类的内容注入其中。</p>
<p>什么是插槽？</p>
<p>您可以通过将<code>&lt;slot&gt;&amp;</code>lt; / slot&gt;放在组件模板中来定义它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#39;user-information&#39;, &#123;  template: &#39;&lt;div class&#x3D;&quot;user-information&quot;&gt;&lt;slot&gt;&lt;&#x2F;slot&gt;&lt;&#x2F;div&gt;&#39;&#125;)</span><br></pre></td></tr></table></figure>

<p>使用此组件时，在开始和结束标记之间添加的所有内容都将添加到广告位占位符内：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;user-information&gt;  &lt;h2&gt;Hi!&lt;&#x2F;h2&gt;  &lt;user-name name&#x3D;&quot;Flavio&quot;&gt;&lt;&#x2F;user-information&gt;</span><br></pre></td></tr></table></figure>

<p>如果将任何内容放在<code>&lt;slot&gt;&amp;</code>lt; / slot&gt;标记旁边，这将作为默认内容，以防万一。</p>
<p>复杂的组件布局可能需要更好的方式来组织内容。</p>
<p>输入<strong>命名的插槽</strong>。</p>
<p>使用命名插槽，可以将插槽的各个部分分配到组件模板布局中的特定位置，并且可以<code>slot</code>对任何标签使用属性，以将内容分配给该插槽。</p>
<p>模板标签之外的所有内容都会添加到main中<code>slot</code>。</p>
<p>为了方便起见，<code>page</code>在此示例中，我使用单个文件组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;div&gt;    &lt;main&gt;      &lt;slot&gt;&lt;&#x2F;slot&gt;    &lt;&#x2F;main&gt;    &lt;sidebar&gt;      &lt;slot name&#x3D;&quot;sidebar&quot;&gt;&lt;&#x2F;slot&gt;    &lt;&#x2F;sidebar&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;page&gt;  &lt;ul slot&#x3D;&quot;sidebar&quot;&gt;    &lt;li&gt;Home&lt;&#x2F;li&gt;    &lt;li&gt;Contact&lt;&#x2F;li&gt;  &lt;&#x2F;ul&gt;</span><br><span class="line">&#96;&#96;&#96; &#96;&#96;&#96;</span><br><span class="line">&lt;h2&gt;Page title&lt;&#x2F;h2&gt;  &lt;p&gt;Page content&lt;&#x2F;p&gt;&lt;&#x2F;page&gt;</span><br></pre></td></tr></table></figure>
<h3 id="筛选器，模板的帮手"><a href="#筛选器，模板的帮手" class="headerlink" title="筛选器，模板的帮手"></a>筛选器，模板的帮手</h3><p>过滤器是Vue组件提供的功能，可让您将格式设置和转换应用于模板动态数据的任何部分。</p>
<p>它们不会更改组件的数据或其他任何内容，而只会影响输出。</p>
<p>假设您正在打印名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p&gt;Hi &#123;.&#123; name &#125;&#125;!&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      name: &#39;Flavio&#39;    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>如果要检查<code>name</code>实际上是否包含一个值，如果不打印，则该怎么办，以便我们的模板将打印“嗨，那里！”？</p>
<p>输入过滤器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p&gt;Hi &#123;.&#123; name | fallback &#125;&#125;!&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      name: &#39;Flavio&#39;    &#125;  &#125;,  filters: &#123;    fallback: function(name) &#123;      return name ? name : &#39;there&#39;    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>请注意，应用过滤器的语法为<code>| filterName</code>。如果您熟悉Unix，那就是Unix管道运算符，用于将操作的输出作为输入传递给下一个操作。</p>
<p><code>filters</code>组件的属性是一个对象。单个过滤器是一个接受一个值并返回另一个值的函数。</p>
<p>返回的值是Vue.js模板中实际打印的值。</p>
<p>过滤器当然可以访问组件数据和方法。</p>
<p>过滤器的好用例是什么？</p>
<ul>
<li>转换字符串，例如大写或将其小写</li>
<li>格式化价格</li>
</ul>
<p>在上方，您看到了一个简单的过滤器示例：<code>&#123;.&#123; name | fallback &#125;&#125;</code>。</p>
<p>通过重复管道语法，可以链接过滤器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;.&#123; name | fallback | capitalize &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>首先应用<code>fallback</code>过滤器，然后应用过滤<code>capitalize</code>器（我们没有定义，但尝试创建一个！）。</p>
<p>高级过滤器还可以使用常规函数参数语法接受参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;p&gt;Hello &#123;.&#123; name | prepend(&#39;Dr.&#39;) &#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  data() &#123;    return &#123;      name: &#39;House&#39;    &#125;  &#125;,  filters: &#123;    prepend: (name, prefix) &#x3D;&gt; &#123;      return &#96;$&#123;prefix&#125; $&#123;name&#125;&#96;    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>如果将参数传递给过滤器，则传递给过滤器函数的第一个参数始终是模板插值中的项（<code>name</code>在这种情况下），然后是传递的显式参数。</p>
<p>您可以通过使用逗号分隔多个参数来使用它们。</p>
<p>注意，我使用了箭头功能。通常，我们避免在方法和计算属性中使用箭头函数，因为它们几乎总是引用<code>this</code>来访问组件数据。但是在这种情况下，过滤器不需要访问，<code>this</code>而是通过参数接收它需要的所有数据，并且我们可以安全地使用更简单的箭头函数语法。</p>
<p><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/vue2-filters">这个包</a>有很多预先制成的过滤器，为您的模板，其中包括直接使用<code>capitalize</code>，<code>uppercase</code>，<code>lowercase</code>，<code>placeholder</code>，<code>truncate</code>，<code>currency</code>，<code>pluralize</code>等等。</p>
<h3 id="组件之间的通讯"><a href="#组件之间的通讯" class="headerlink" title="组件之间的通讯"></a>组件之间的通讯</h3><p>Vue中的组件可以通过各种方式进行通信。</p>
<h4 id="使用道具"><a href="#使用道具" class="headerlink" title="使用道具"></a>使用道具</h4><p>第一种方法是使用道具。</p>
<p>父级通过在组件声明中添加参数来“传递”数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;div&gt;    &lt;Car color&#x3D;&quot;green&quot; &#x2F;&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;import Car from &#39;.&#x2F;components&#x2F;Car&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;  name: &#39;App&#39;,  components: &#123;    Car  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>道具是单向的：从父母到孩子。每当父母更改道具时，新值就会发送给孩子并重新渲染。</p>
<p>反之则不成立，您永远都不应在子组件内部变异道具。</p>
<h4 id="使用事件从孩子与父母沟通"><a href="#使用事件从孩子与父母沟通" class="headerlink" title="使用事件从孩子与父母沟通"></a>使用事件从孩子与父母沟通</h4><p>通过事件，您可以从孩子到父母进行交流：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  name: &#39;Car&#39;,  methods: &#123;    handleClick: function() &#123;      this.$emit(&#39;clickedSomething&#39;)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><code>v-on</code>当组件在其模板中包含组件时，父级可以使用指令截获此消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;div&gt;    &lt;Car v-on:clickedSomething&#x3D;&quot;handleClickInParent&quot; &#x2F;&gt;    &lt;!-- or --&gt;    &lt;Car @clickedSomething&#x3D;&quot;handleClickInParent&quot; &#x2F;&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  name: &#39;App&#39;,  methods: &#123;    handleClickInParent: function() &#123;      &#x2F;&#x2F;...    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>您当然可以传递参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  name: &#39;Car&#39;,  methods: &#123;    handleClick: function() &#123;      this.$emit(&#39;clickedSomething&#39;, param1, param2)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>并从父级检索它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;div&gt;    &lt;Car v-on:clickedSomething&#x3D;&quot;handleClickInParent&quot; &#x2F;&gt;    &lt;!-- or --&gt;    &lt;Car @clickedSomething&#x3D;&quot;handleClickInParent&quot; &#x2F;&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  name: &#39;App&#39;,  methods: &#123;    handleClickInParent: function(param1, param2) &#123;      &#x2F;&#x2F;...    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="使用事件总线在任何组件之间进行通信"><a href="#使用事件总线在任何组件之间进行通信" class="headerlink" title="使用事件总线在任何组件之间进行通信"></a>使用事件总线在任何组件之间进行通信</h4><p>使用事件，您不仅限于儿童与父母之间的关系。您可以使用所谓的事件总线。</p>
<p>上面我们曾经<code>this.$emit</code>在组件实例上发出一个事件。</p>
<p>相反，我们可以做的是在更易于访问的组件上发出事件。</p>
<p><code>this.$root</code>根组件，通常用于此目的。</p>
<p>您还可以创建专用于此作业的Vue组件，然后将其导入所需的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  name: &#39;Car&#39;,  methods: &#123;    handleClick: function() &#123;      this.$root.$emit(&#39;clickedSomething&#39;)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>任何其他组件都可以侦听此事件。您可以在<code>mounted</code>回调中执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  name: &#39;App&#39;,  mounted() &#123;    this.$root.$on(&#39;clickedSomething&#39;, () &#x3D;&gt; &#123;      &#x2F;&#x2F;...    &#125;)  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>这就是Vue开箱即用的功能。</p>
<p>当您超出此范围时，可以查看Vuex或其他第三部分库。</p>
<h3 id="使用Vuex管理状态"><a href="#使用Vuex管理状态" class="headerlink" title="使用Vuex管理状态"></a>使用Vuex管理状态</h3><p>Vuex是Vue.js的官方状态管理库。</p>
<p>它的工作是在应用程序的各个组件之间共享数据。</p>
<p>开箱即用的Vue.js中的组件可以使用</p>
<ul>
<li>道具，将状态从父级传递到子级组件</li>
<li>事件，以从子级更改父组件的状态，或将根组件用作事件总线</li>
</ul>
<p>有时候事情变得比这些简单的选项所允许的更为复杂。</p>
<p>在这种情况下，一个好的选择是将状态集中在一个存储中。这就是Vuex所做的。</p>
<h4 id="为什么要使用Vuex？"><a href="#为什么要使用Vuex？" class="headerlink" title="为什么要使用Vuex？"></a>为什么要使用Vuex？</h4><p>Vuex不是您可以在Vue中使用的唯一状态管理选项（您也可以使用<a target="_blank" rel="noopener" href="https://medium.com/@quincylarson/17a99705b8e1">Redux</a>），但是它的主要优点是它是官方的，并且与Vue.js的集成才使它发光。</p>
<p>使用React，您将不得不选择众多可用库中的一种，因为该生态系统庞大且没有实际标准。最近，Redux是最受欢迎的选择，<a target="_blank" rel="noopener" href="https://mobx.js.org/getting-started.html">MobX</a>在人气方面<a target="_blank" rel="noopener" href="https://mobx.js.org/getting-started.html">紧随</a>其后。有了Vue，我想说的就是，除了Vuex之外，您无需四处寻找其他东西，尤其是在入门时。</p>
<p>Vuex从React生态系统中借鉴了许多想法，因为这是Redux流行的Flux模式。</p>
<p>如果您已经了解Flux或Redux，那么Vuex将非常熟悉。如果您不这样做，那就没问题-我将彻底解释每个概念。</p>
<p>Vue应用程序中的组件可以具有自己的状态。例如，一个输入框将在本地存储输入到其中的数据。这非常好，即使使用Vuex，组件也可以具有局部状态。</p>
<p>您知道开始进行大量工作来传递状态时需要Vuex之类的东西。</p>
<p>在这种情况下，Vuex为状态提供了一个中央存储库，您可以通过请求状态来对状态进行更改。</p>
<p>依赖于状态的特定部分的每个组件都将使用商店中的getter来访问它，以确保在状态发生变化时立即对其进行更新。</p>
<p>使用Vuex会给应用程序带来一些复杂性，因为需要以某种方式进行设置才能正常工作。但是，如果这有助于解决过于复杂的杂乱无章的道具传递和事件系统（如果变得过于复杂，则可能会变成意大利面条），那么这是一个不错的选择。</p>
<h4 id="开始吧"><a href="#开始吧" class="headerlink" title="开始吧"></a>开始吧</h4><p>在此示例中，我从Vue CLI应用程序开始。通过直接将Vuex加载到脚本标签中，也可以使用它。但是，由于Vuex更适合大型应用程序，因此您很有可能会在结构化的应用程序上使用它，例如可以通过Vue CLI快速启动的应用程序。</p>
<p>我使用的示例将放在CodeSandbox中，它是一项很棒的服务，具有准备就绪的Vue CLI <a target="_blank" rel="noopener" href="https://codesandbox.io/s/vue">示例</a>。我建议使用它来玩耍。</p>
<p><img src="https://cdn-media-1.freecodecamp.org/images/hoB1Mu8Q1Py50t5Es5EKze26BsJOApMhEWVh"></p>
<p>到达之后，单击“添加依赖项”按钮，输入“ vuex”，然后单击它。</p>
<p>现在，Vuex将列在项目依赖项中。</p>
<p>要在本地安装Vuex，您可以简单地运行<code>npm install vuex</code>或<code>yarn add vuex</code>在项目文件夹中。</p>
<h4 id="创建Vuex商店"><a href="#创建Vuex商店" class="headerlink" title="创建Vuex商店"></a>创建Vuex商店</h4><p>现在，我们准备创建Vuex商店。</p>
<p>该文件可以放在任何地方。通常建议将其放入<code>src/store/store.js</code>文件中，因此我们将这样做。</p>
<p>在此文件中，我们初始化Vuex并告诉Vue使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;</span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Vue.use(Vuex)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>export const store = new Vuex.Store({})</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">![](https:&#x2F;&#x2F;cdn-media-1.freecodecamp.org&#x2F;images&#x2F;p2kPCCKdhaHsHfXd4Nti975YVgvKMnbHbMRd)</span><br><span class="line"></span><br><span class="line">我们导出使用&#96;Vuex.Store()&#96;API 创建的Vuex存储对象。</span><br><span class="line"></span><br><span class="line">#### 商店的用例</span><br><span class="line"></span><br><span class="line">现在我们有了一个框架，让我们提出一个关于Vuex的好用例的想法，以便我介绍它的概念。</span><br><span class="line"></span><br><span class="line">例如，我有两个同级组件，一个带有一个输入字段，另一个打印该输入字段的内容。</span><br><span class="line"></span><br><span class="line">当输入字段更改时，我还要更改第二个组件中的内容。非常简单，但这将为我们完成工作。</span><br><span class="line"></span><br><span class="line">#### 介绍我们需要的新组件</span><br><span class="line"></span><br><span class="line">我删除HelloWorld组件，并添加一个Form组件和一个Display组件。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><template>  <div>    <label for="flavor">Favorite ice cream flavor?</label>    <input name="flavor">  </div></template></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;You chose ???&lt;&#x2F;p&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<h4 id="将这些组件添加到应用程序"><a href="#将这些组件添加到应用程序" class="headerlink" title="将这些组件添加到应用程序"></a>将这些组件添加到应用程序</h4><p>我们将它们添加到<code>App.vue</code>代码中，而不是HelloWorld组件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;div id&#x3D;&quot;app&quot;&gt;    &lt;Form&#x2F;&gt;    &lt;Display&#x2F;&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;import Form from &#39;.&#x2F;components&#x2F;Form&#39;import Display from &#39;.&#x2F;components&#x2F;Display&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;  name: &#39;App&#39;,  components: &#123;    Form,    Display  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="将状态添加到商店"><a href="#将状态添加到商店" class="headerlink" title="将状态添加到商店"></a>将状态添加到商店</h4><p>因此，有了这个，我们回到store.js文件。我们向名为的商店添加了一个属性，该属性<code>state</code>是一个包含该<code>flavor</code>属性的对象。最初是一个空字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const store &#x3D; new Vuex.Store(&#123;  state: &#123;    flavor: &#39;&#39;  &#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>当用户在输入字段中键入内容时，我们将对其进行更新。</p>
<h4 id="添加突变"><a href="#添加突变" class="headerlink" title="添加突变"></a>添加突变</h4><p>除非使用突变，否则无法操纵状态。我们设置了一个突变，该突变将在<code>Form</code>组件内部用于通知商店状态应该更改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const store &#x3D; new Vuex.Store(&#123;  state: &#123;    flavor: &#39;&#39;  &#125;,  mutations: &#123;    change(state, flavor) &#123;      state.flavor &#x3D; flavor    &#125;  &#125;&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="添加获取器以引用状态属性"><a href="#添加获取器以引用状态属性" class="headerlink" title="添加获取器以引用状态属性"></a>添加获取器以引用状态属性</h4><p>设置好之后，我们需要添加一种查看状态的方法。我们使用吸气剂。我们为该<code>flavor</code>属性设置了一个吸气剂：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const store &#x3D; new Vuex.Store(&#123;  state: &#123;    flavor: &#39;&#39;  &#125;,  mutations: &#123;    change(state, flavor) &#123;      state.flavor &#x3D; flavor    &#125;  &#125;,  getters: &#123;    flavor: state &#x3D;&gt; state.flavor  &#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>注意<code>getters</code>对象如何。<code>flavor</code>是此对象的属性，该对象接受状态作为参数，并返回<code>flavor</code>状态的属性。</p>
<h4 id="将Vuex商店添加到应用程序"><a href="#将Vuex商店添加到应用程序" class="headerlink" title="将Vuex商店添加到应用程序"></a>将Vuex商店添加到应用程序</h4><p>现在该商店已准备就绪，可以使用。我们回到应用程序代码，在main.js文件中，我们需要导入状态并将其在我们的Vue应用程序中可用。</p>
<p>我们增加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; store &#125; from &#39;.&#x2F;store&#x2F;store&#39;</span><br></pre></td></tr></table></figure>

<p>并将其添加到Vue应用程序中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;  el: &#39;#app&#39;,  store,  components: &#123; App &#125;,  template: &#39;&lt;App&#x2F;&gt;&#39;&#125;)</span><br></pre></td></tr></table></figure>

<p>一旦添加它，由于这是主要的Vue组件，因此<code>store</code>每个Vue组件中的变量都将指向Vuex存储。</p>
<h4 id="使用提交更新用户操作的状态"><a href="#使用提交更新用户操作的状态" class="headerlink" title="使用提交更新用户操作的状态"></a>使用提交更新用户操作的状态</h4><p>让我们在用户键入内容时更新状态。</p>
<p>我们通过使用<code>store.commit()</code>API来实现。</p>
<p>但是首先，让我们创建一个在输入内容更改时调用的方法。我们使用<code>@input</code>而不是<code>@change</code>因为后者仅在焦点移离输入框时触发，而<code>@input</code>每次按键时都会调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;div&gt;    &lt;label for&#x3D;&quot;flavor&quot;&gt;Favorite ice cream flavor?&lt;&#x2F;label&gt;    &lt;input @input&#x3D;&quot;changed&quot; name&#x3D;&quot;flavor&quot;&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  methods: &#123;    changed: function(event) &#123;      alert(event.target.value)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>现在我们有了风味的价值，我们使用Vuex API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;export default &#123;  methods: &#123;    changed: function(event) &#123;      this.$store.commit(&#39;change&#39;, event.target.value)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>看看我们如何使用来引用商店<code>this.$store</code>？这是由于<code>store</code>在主Vue组件初始化中包含了该对象。</p>
<p>该<code>commit()</code>方法接受一个突变名称（我们<code>change</code>在Vuex存储中使用了）和一个有效负载，这些负载将作为其回调函数的第二个参数传递给该突变。</p>
<h4 id="使用吸气剂打印状态值"><a href="#使用吸气剂打印状态值" class="headerlink" title="使用吸气剂打印状态值"></a>使用吸气剂打印状态值</h4><p>现在，我们需要通过使用在Display模板中引用此值的getter <code>$store.getters.flavor</code>。<code>this</code>可以删除，因为我们在模板中，并且<code>this</code>是隐式的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;div&gt;    &lt;p&gt;You chose &#123;.&#123; $store.getters.flavor &#125;&#125;&lt;&#x2F;p&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>完整的有效源代码可<a target="_blank" rel="noopener" href="https://codesandbox.io/s/zq7k7nkzkm">在此处获得</a>。</p>
<p>这个难题中仍然缺少许多概念：</p>
<ul>
<li>行动</li>
<li>模组</li>
<li>帮手</li>
<li>外挂程式</li>
</ul>
<p>但是现在您有了基本知识，可以在官方文档中阅读它们。</p>
<h3 id="使用Vue路由器处理URL"><a href="#使用Vue路由器处理URL" class="headerlink" title="使用Vue路由器处理URL"></a>使用Vue路由器处理URL</h3><p>在JavaScript Web应用程序中，路由器是将当前显示的视图与浏览器地址栏内容同步的部分。</p>
<p>换句话说，这是使您在单击页面中的某些内容时更改URL的部分，并有助于在您单击特定的URL时显示正确的视图。</p>
<p>传统上，Web是围绕URL构建的。当您点击某个URL时，将显示一个特定页面。</p>
<p>随着在浏览器中运行的应用程序的引入并改变了用户的外观，许多应用程序中断了这种交互，因此您必须使用浏览器的History API手动更新URL。</p>
<p>当您需要将URL同步到应用程序中的视图时，需要一个路由器。这是非常普遍的需求，现在所有主要的现代框架都允许您管理路由。</p>
<p>Vue路由器库是用于Vue.js应用程序的方式。Vue不强制使用此库。您可以使用任何所需的通用路由库，也可以创建自己的History API集成，但是使用Vue Router的好处是它是官方的。</p>
<p>这意味着它由维护Vue的同一个人维护，因此您将在框架中获得更一致的集成，并保证无论将来如何，它始终是兼容的。</p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>Vue Router可以通过名为npm的软件包通过npm获得<code>vue-router</code>。</p>
<p>如果通过脚本标签使用Vue，则可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue-router&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://unpkg.com/#/">UNPKG</a>是一个非常方便的工具，它可以通过简单的链接在浏览器中提供每个npm软件包。</p>
<p>如果使用Vue CLI，请使用以下命令进行安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router</span><br></pre></td></tr></table></figure>

<p><code>vue-router</code>使用脚本标签或通过Vue CLI 安装并使其可用后，现在可以将其导入应用程序中。</p>
<p>您在之后导入它<code>vue</code>，然后调用<code>Vue.use(VueRouter)</code>将其<strong>安装</strong>在应用程序中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;import VueRouter from &#39;vue-router&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure>

<p>调用<code>Vue.use()</code>传递路由器对象后，在应用程序的任何组件中您都可以访问以下对象：</p>
<ul>
<li><code>this.$router</code> 是路由器对象</li>
<li><code>this.$route</code> 是当前路线对象</li>
</ul>
<h4 id="路由器对象"><a href="#路由器对象" class="headerlink" title="路由器对象"></a>路由器对象</h4><p><code>this.$router</code>当Vue路由器安装在根Vue组件中时，可以使用任何组件访问该路由器对象，这些对象具有许多不错的功能。</p>
<p>我们可以使用以下方法使应用导航到新路线</p>
<ul>
<li><code>this.$router.push()</code></li>
<li><code>this.$router.replace()</code></li>
<li><code>this.$router.go()</code></li>
</ul>
<p>这类似于<code>pushState</code>，<code>replaceState</code>和<code>go</code>历史API的方法。</p>
<ul>
<li><code>push()</code> 用于转到新路线，将新项目添加到浏览器历史记录中</li>
<li><code>replace()</code> 是相同的，只是它不会将新状态推向历史记录</li>
</ul>
<p>用法样本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#39;about&#39;) &#x2F;&#x2F;named route, see laterthis.$router.push(&#123; path: &#39;about&#39; &#125;)this.$router.push(&#123; path: &#39;post&#39;, query: &#123; post_slug: &#39;hello-world&#39; &#125; &#125;) &#x2F;&#x2F;using query parameters (post?post_slug&#x3D;hello-world)this.$router.replace(&#123; path: &#39;about&#39; &#125;)</span><br></pre></td></tr></table></figure>

<p><code>go()</code> 来回移动，接受可以在历史记录中返回的正数或负数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$router.go(-1) &#x2F;&#x2F;go back 1 stepthis.$router.go(1) &#x2F;&#x2F;go forward 1 step</span><br></pre></td></tr></table></figure>
<h4 id="定义路线"><a href="#定义路线" class="headerlink" title="定义路线"></a>定义路线</h4><p>在此示例中，我正在使用Vue单个文件组件。</p>
<p>在模板中，我使用了一个<code>nav</code>标签，该标签包含三个<code>router-link</code>组件，分别具有标签Home，Login和About。URL通过<code>to</code>属性分配。</p>
<p><code>router-view</code>Vue路由器将在该组件中放置与当前URL匹配的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;div id&#x3D;&quot;app&quot;&gt;    &lt;nav&gt;      &lt;router-link to&#x3D;&quot;&#x2F;&quot;&gt;Home&lt;&#x2F;router-link&gt;      &lt;router-link to&#x3D;&quot;&#x2F;login&quot;&gt;Login&lt;&#x2F;router-link&gt;      &lt;router-link to&#x3D;&quot;&#x2F;about&quot;&gt;About&lt;&#x2F;router-link&gt;    &lt;&#x2F;nav&gt;    &lt;router-view&gt;&lt;&#x2F;router-view&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>一个<code>router-link</code>组件显示的<code>a</code>默认标签（你可以改变）。每次更改路线时，通过单击链接或更改URL，都会将一个<code>router-link-active</code>类添加到引用活动路线的元素中，以设置其样式。</p>
<p>在JavaScript部分，我们首先包括并安装路由器，然后定义三个路由组件。</p>
<p>我们将它们传递给<code>router</code>对象的初始化，然后将此对象传递给Vue根实例。</p>
<p>这是代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;import Vue from &#39;vue&#39;import VueRouter from &#39;vue-router&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Router)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Home  &#x3D; &#123;  template: &#39;&lt;div&gt;Home&lt;&#x2F;div&gt;&#39;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Login &#x3D; &#123;  template: &#39;&lt;div&gt;Login&lt;&#x2F;div&gt;&#39;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const About &#x3D; &#123;  template: &#39;&lt;div&gt;About&lt;&#x2F;div&gt;&#39;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;  routes: [    &#123; path: &#39;&#x2F;&#39;, component: Home &#125;,    &#123; path: &#39;&#x2F;login&#39;, component: Login &#125;,    &#123; path: &#39;&#x2F;about&#39;, component: About &#125;  ]&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;  router&#125;).$mount(&#39;#app&#39;)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>通常，在Vue应用程序中，您可以使用以下方法实例化并挂载根应用程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;  render: h &#x3D;&gt; h(App)&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

<p>使用Vue路由器时，您不会传递<code>render</code>属性，而是使用<code>router</code>。</p>
<p>上例中使用的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;  router&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

<p>是以下内容的简写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;  router: router&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

<p>在示例中看到，我们将<code>routes</code>数组传递给<code>VueRouter</code>构造函数。此数组中的每个路由都有<code>path</code>和<code>component</code>参数。</p>
<p>如果您也通过了<code>name</code>参数，那么您将具有命名路线。</p>
<h4 id="使用命名的路由将参数传递到路由器的推入和替换方法"><a href="#使用命名的路由将参数传递到路由器的推入和替换方法" class="headerlink" title="使用命名的路由将参数传递到路由器的推入和替换方法"></a>使用命名的路由将参数传递到路由器的推入和替换方法</h4><p>还记得我们以前如何使用Router对象推送新状态吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123; path: &#39;about&#39; &#125;)</span><br></pre></td></tr></table></figure>

<p>使用命名路由，我们可以将参数传递给新路由：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123; name: &#39;post&#39;, params: &#123; post_slug: &#39;hello-world&#39; &#125; &#125;)</span><br></pre></td></tr></table></figure>

<p>同样适用于<code>replace()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$router.replace(&#123; name: &#39;post&#39;, params: &#123; post_slug: &#39;hello-world&#39; &#125; &#125;)</span><br></pre></td></tr></table></figure>
<h4 id="当用户点击一个-router-link"><a href="#当用户点击一个-router-link" class="headerlink" title="当用户点击一个 router-link?"></a>当用户点击一个 <code>router-link?</code></h4><p>该应用程序将呈现与传递给链接的URL匹配的路由组件。</p>
<p>实例化处理URL的新路由组件，并调用其防护措施，旧的路由组件将被销毁。</p>
<h4 id="路线守卫"><a href="#路线守卫" class="headerlink" title="路线守卫"></a>路线守卫</h4><p>既然我们提到了守卫，让我们对其进行介绍。</p>
<p>您可以将它们视为生命周期挂钩或中间件。这些是在应用程序执行期间的特定时间调用的函数。您可以加入并更改路由的执行，重定向或简单地取消请求。</p>
<p>您可以通过向路由器的<code>beforeEach()</code>and <code>afterEach()</code>属性添加回调来获得全局保护。</p>
<ul>
<li><code>beforeEach()</code> 在确认导航之前调用</li>
<li><code>beforeResolve()</code>在<code>beforeEach()</code>执行并调用所有组件<code>beforeRouterEnter</code>和<code>beforeRouteUpdate</code>防护时但在确认导航之前调用。最后检查。</li>
<li><code>afterEach()</code> 导航确认后调用</li>
</ul>
<p>“导航已确认”是什么意思？我们将在一秒钟内看到它。同时，将其视为“应用程序可以走那条路”。</p>
<p>用法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$router.beforeEach((to, from, next) &#x3D;&gt; &#123;  &#x2F;&#x2F; ...&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$router.afterEach((to, from) &#x3D;&gt; &#123;  &#x2F;&#x2F; ...&#125;)</span><br></pre></td></tr></table></figure>

<p><code>to</code>并<code>from</code>代表我们往返的路线对象。</p>
<p><code>beforeEach</code>有一个附加参数<code>next</code>，如果我们调用<code>false</code>作为参数，它将阻止导航并导致其不确定。</p>
<p>就像在Node中间件中一样，如果您熟悉的话，<code>next()</code>应始终调用它，否则执行将被卡住。</p>
<p>单路径组件还具有防护装置：</p>
<ul>
<li><code>beforeRouteEnter(from, to, next)</code> 在确认当前路线之前调用</li>
<li><code>beforeRouteUpdate(from, to, next)</code>当路由更改但管理它的组件仍然相同时调用（使用动态路由，请参见<code>next</code>）</li>
<li><code>beforeRouteLeave(from, to, next)</code> 当我们离开这里时被称为</li>
</ul>
<p>我们提到了导航。要确定是否确认导航到路线，Vue Router会执行一些检查：</p>
<ul>
<li>它会<code>beforeRouteLeave</code>在当前组件中发出警戒</li>
<li>它称呼路由器<code>beforeEach()</code>守卫</li>
<li>它调用<code>beforeRouteUpdate()</code>需要重用的任何组件（如果存在）</li>
<li>它<code>beforeEnter()</code>在路由对象上调用了守卫（我没有提到它，但是您可以<a target="_blank" rel="noopener" href="https://router.vuejs.org/guide/advanced/navigation-guards.html#per-route-guard">在这里查看</a>）</li>
<li>它调用了<code>beforeRouterEnter()</code>我们应该输入的组件</li>
<li>它称呼路由器<code>beforeResolve()</code>守卫</li>
<li>如果一切正常，导航已确认！</li>
<li>它称呼路由器<code>afterEach()</code>守卫</li>
</ul>
<p>您可以使用路由的具体卫士（<code>beforeRouteEnter</code>和<code>beforeRouteUpdate</code>动态路由的情况下）的生命周期挂钩，这样你就可以开始进行数据抓取，例如请求。</p>
<h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><p>以上示出了例如基于该URL不同的看法，处理<code>/</code>，<code>/login</code>和<code>/about</code>路由。</p>
<p>一个非常普遍的需求是处理动态路由，例如将所有帖子都放在之下<code>/post/</code>，每个帖子都带有一个名字。</p>
<ul>
<li><code>/post/first</code></li>
<li><code>/post/another-post</code></li>
<li><code>/post/hello-world</code></li>
</ul>
<p>您可以使用动态细分来实现。</p>
<p>这些是静态段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;  routes: [    &#123; path: &#39;&#x2F;&#39;, component: Home &#125;,    &#123; path: &#39;&#x2F;login&#39;, component: Login &#125;,    &#123; path: &#39;&#x2F;about&#39;, component: About &#125;  ]&#125;)</span><br></pre></td></tr></table></figure>

<p>我们添加了一个动态细分来处理博客文章：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;  routes: [    &#123; path: &#39;&#x2F;&#39;, component: Home &#125;,    &#123; path: &#39;&#x2F;post&#x2F;:post_slug&#39;, component: Post &#125;,    &#123; path: &#39;&#x2F;login&#39;, component: Login &#125;,    &#123; path: &#39;&#x2F;about&#39;, component: About &#125;  ]&#125;)</span><br></pre></td></tr></table></figure>

<p>注意<code>:post_slug</code>语法。这意味着您可以使用任何字符串，并将其映射到<code>post_slug</code>占位符。</p>
<p>您不仅限于这种语法。Vue依靠<a target="_blank" rel="noopener" href="https://github.com/pillarjs/path-to-regexp">此库</a>来解析动态路由，并且您可以使用正则表达式疯狂。</p>
<p>现在，在“发布路线”组件内部，我们可以使用引用该路线<code>$route</code>，并使用<code>$route.params.post_slug</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Post &#x3D; &#123;  template: &#39;&lt;div&gt;Post: &#123;.&#123; $route.params.post_slug &#125;&#125;&lt;&#x2F;div&gt;&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用此参数从后端加载内容。</p>
<p>在相同的URL中，您可以具有任意数量的动态细分：</p>
<p><code>/post/:author/:post_slug</code></p>
<p>还记得我们谈论用户导航到新路线时会发生什么情况吗？</p>
<p>在动态路线的情况下，发生的情况有些不同。</p>
<p>为了提高Vue的效率，它可以重用当前实例，而不是销毁当前路由组件并重新实例化它。</p>
<p>发生这种情况时，Vue会调用<code>beforeRouteUpdate</code>生命周期事件。</p>
<p>在那里您可以执行所需的任何操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Post &#x3D; &#123;  template: &#39;&lt;div&gt;Post: &#123;.&#123; $route.params.post_slug &#125;&#125;&lt;&#x2F;div&gt;&#39;  beforeRouteUpdate(to, from, next) &#123;    console.log(&#96;Updating slug from $&#123;from&#125; to $&#123;to&#125;&#96;)    next() &#x2F;&#x2F;make sure you always call next()  &#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用道具-1"><a href="#使用道具-1" class="headerlink" title="使用道具"></a>使用道具</h4><p>在示例中，我曾经<code>$route.params.*</code>访问过路线数​​据。组件不应与路由器紧密耦合，而可以使用道具：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Post &#x3D; &#123;  props: [&#39;post_slug&#39;],  template: &#39;&lt;div&gt;Post: &#123;.&#123; post_slug &#125;&#125;&lt;&#x2F;div&gt;&#39;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;  routes: [    &#123; path: &#39;&#x2F;post&#x2F;:post_slug&#39;, component: Post, props: true &#125;  ]&#125;)</span><br></pre></td></tr></table></figure>

<p>请注意<code>props: true</code>传递给route对象以启用此功能。</p>
<h4 id="嵌套路线"><a href="#嵌套路线" class="headerlink" title="嵌套路线"></a>嵌套路线</h4><p>在我提到之前，您可以在同一URL中具有任意数量的动态细分，例如：</p>
<p><code>/post/:author/:post_slug</code></p>
<p>因此，假设我们有一个Author组件负责第一个动态段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;div id&#x3D;&quot;app&quot;&gt;    &lt;router-view&gt;&lt;&#x2F;router-view&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;import Vue from &#39;vue&#39;import VueRouter from &#39;vue-router&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Router)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Author  &#x3D; &#123;  template: &#39;&lt;div&gt;Author: &#123;.&#123; $route.params.author&#125;&#125;&lt;&#x2F;div&gt;&#39;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;  routes: [    &#123; path: &#39;&#x2F;post&#x2F;:author&#39;, component: Author &#125;  ]&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;  router&#125;).$mount(&#39;#app&#39;)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以<code>router-view</code>在Author模板中插入另一个组件实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Author  &#x3D; &#123;  template: &#39;&lt;div&gt;Author: &#123;.&#123; $route.params.author&#125;&#125;&lt;router-view&gt;&lt;&#x2F;router-view&gt;&lt;&#x2F;div&gt;&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>我们添加Post组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Post &#x3D; &#123;  template: &#39;&lt;div&gt;Post: &#123;.&#123; $route.params.post_slug &#125;&#125;&lt;&#x2F;div&gt;&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们将内部动态路由注入<code>VueRouter</code>配置中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;  routes: [&#123;    path: &#39;&#x2F;post&#x2F;:author&#39;,    component: Author,    children: [      path: &#39;:post_slug&#39;,      component: Post    ]  &#125;]&#125;)</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-11-27T03:33:22.000Z" title="2019-11-27T03:33:22.000Z">2019-11-27</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.333Z" title="2020-09-08T14:03:00.333Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">几秒读完 (大约47个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/27/Dos%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80/">Dos批量修改文件后缀</a></h1><div class="content"><h3 id="Dos批量修改文件后缀"><a href="#Dos批量修改文件后缀" class="headerlink" title="Dos批量修改文件后缀"></a>Dos批量修改文件后缀</h3><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">for &#x2F;f &quot;tokens&#x3D;* delims&#x3D;&quot; %%i in (&#39;dir &#x2F;b&#x2F;s *.txt&#39;) do (</span><br><span class="line">rename &quot;%%i&quot; &quot;*.dxh&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<p><img src="https://blog.zshipu.com/tlg/images/pasted-51.png" alt="知识铺-pasted-51.png"></p>
<h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ren *.txt *.dxh</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-11-22T07:53:38.000Z" title="2019-11-22T07:53:38.000Z">2019-11-22</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.391Z" title="2020-09-08T14:03:00.391Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">4 分钟读完 (大约530个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/22/PHP%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/">PHP编码规范</a></h1><div class="content"><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>阅读本规范需结合<a target="_blank" rel="noopener" href="https://blog.zshipu.com/tlg/2019/11/22/%E9%80%9A%E7%94%A8%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/">通用编码规范</a>，里面讲到的规范这里不再赘述，此外，PHP代码里面出现的HTML编码需遵守<a target="_blank" rel="noopener" href="https://blog.zshipu.com/tlg/2019/11/22/HTML%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%833/">HTML 编码规范</a>。</p>
<h2 id="2-代码风格"><a href="#2-代码风格" class="headerlink" title="2 代码风格"></a>2 代码风格</h2><h3 id="2-1-文件"><a href="#2-1-文件" class="headerlink" title="2.1 文件"></a>2.1 文件</h3><h5 id="强制-对于只含有-php-代码的文件，文件结尾处忽略掉-gt"><a href="#强制-对于只含有-php-代码的文件，文件结尾处忽略掉-gt" class="headerlink" title="[强制] 对于只含有 php 代码的文件，文件结尾处忽略掉 ?&gt;"></a>[强制] 对于只含有 php 代码的文件，文件结尾处忽略掉 <code>?&gt;</code></h5><p>防止多余的空格或者其它字符影响到代码。</p>
<h5 id="强制-不使用-php-短标签"><a href="#强制-不使用-php-短标签" class="headerlink" title="[强制] 不使用 php 短标签"></a>[强制] 不使用 php 短标签</h5><p>php 标签采用完整的形式 <code>&lt;?php … ?&gt;</code>，不使用短标签 <code>&lt;? … ?&gt;</code>，且保证在关闭标签后不要有任何空格。</p>
<h3 id="2-2-结构"><a href="#2-2-结构" class="headerlink" title="2.2 结构"></a>2.2 结构</h3><h3 id="2-3-命名"><a href="#2-3-命名" class="headerlink" title="2.3 命名"></a>2.3 命名</h3><h5 id="强制-大小写不敏感的标识符，当做大小写敏感来使用"><a href="#强制-大小写不敏感的标识符，当做大小写敏感来使用" class="headerlink" title="[强制] 大小写不敏感的标识符，当做大小写敏感来使用"></a>[强制] 大小写不敏感的标识符，当做大小写敏感来使用</h5><p>所有标识符都当做是大小写敏感的，严格按照通用编程规范来定义，使用时使用与定义相同的名字。</p>
<h5 id="强制-常量默认大小写敏感，按照规范，禁止开启大小写不敏感"><a href="#强制-常量默认大小写敏感，按照规范，禁止开启大小写不敏感" class="headerlink" title="[强制] 常量默认大小写敏感，按照规范，禁止开启大小写不敏感"></a>[强制] 常量默认大小写敏感，按照规范，禁止开启大小写不敏感</h5><p>常量默认大小写敏感，也可以定义成不敏感，但不允许这么做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">##### [强制] 魔术常量统一大写</span><br><span class="line"></span><br><span class="line">包括：__LINE__、__FILE__、__DIR__、__FUNCTION__、__CLASS__、__METHOD__、__NAMESPACE__。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// good<br>echo <strong>LINE</strong>;</p>
<p>// bad<br>echo <strong>line</strong>;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### [强制] null、true、false 统一小写</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// good<br>$foo = null;<br>$foo = true;<br>$foo = false;</p>
<p>// nad<br>$foo = NULL;<br>$foo = TRUE;<br>$foo = FALSE;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### [强制] 类型强制转换统一小写</span><br><span class="line"></span><br><span class="line">包括：</span><br><span class="line"></span><br><span class="line">* (int)，(integer) – 转换成整型</span><br><span class="line">* (bool)，(boolean) – 转换成布尔型</span><br><span class="line">* (float)，(double)，(real) – 转换成浮点型</span><br><span class="line">* (string) – 转换成字符串</span><br><span class="line">* (array) – 转换成数组</span><br><span class="line">* (object) – 转换成对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// good<br>$foo = (string) 1;</p>
<p>// bad<br>$foo = (STRING) 1;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.4 注释</span><br><span class="line"></span><br><span class="line">## 3 语言特性</span><br><span class="line"></span><br><span class="line">### 3.1 字符串</span><br><span class="line"></span><br><span class="line">##### [强制] 字符串使用单引号</span><br><span class="line"></span><br><span class="line">除非字符串里面有变量或者其他特殊情况不能使用单引号，否则使用单引号</span><br><span class="line"></span><br><span class="line">为了统一和效率。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// good<br>$name = ‘MyName’;</p>
<p>// bad<br>$name = “MyName”;</p>
<pre><code>
### 3.2 条件

##### [建议] 使用 `else...if` 而不是 `elseif`

没为什么，仅仅是为了统一而已。

</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-11-22T07:36:20.000Z" title="2019-11-22T07:36:20.000Z">2019-11-22</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.362Z" title="2020-09-08T14:03:00.362Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">17 分钟读完 (大约2542个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/22/HTML%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%833/">HTML编码规范3</a></h1><div class="content"><p><a href="#user-content-1-%E5%89%8D%E8%A8%80">1 前言</a></p>
<p><a href="#user-content-2-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC">2 代码风格</a></p>
<p>　　<a href="#user-content-21-%E6%96%87%E4%BB%B6">2.1 文件</a></p>
<p>　　<a href="#user-content-22-%E7%BB%93%E6%9E%84">2.2 结构</a></p>
<p>　　　　<a href="#user-content-221-%E7%BC%A9%E8%BF%9B">2.2.1 缩进</a></p>
<p>　　　　<a href="#user-content-222-%E7%A9%BA%E6%A0%BC">2.2.2 空格</a></p>
<p>　　　　<a href="#user-content-223-%E6%8D%A2%E8%A1%8C">2.2.3 换行</a></p>
<p>　　<a href="#user-content-23-%E5%91%BD%E5%90%8D">2.3 命名</a></p>
<p>　　<a href="#user-content-24-%E6%B3%A8%E9%87%8A">2.4 注释</a></p>
<p><a href="#user-content-3-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7">3 语言特性</a></p>
<p>　　<a href="#user-content-31-DOCTYPE">3.1 DOCTYPE</a></p>
<p>　　<a href="#user-content-32-%E5%85%83%E7%B4%A0">3.2 元素</a></p>
<p>　　<a href="#user-content-33-%E5%B1%9E%E6%80%A7">3.3 属性</a></p>
<p><a href="#user-content-4-%E5%B8%B8%E8%A7%81%E5%85%83%E7%B4%A0">4 常见元素</a></p>
<p>　　<a href="#user-content-41-html">4.1 html</a></p>
<p>　　<a href="#user-content-42-head">4.2 head</a></p>
<p>　　<a href="#user-content-43-title">4.3 title</a></p>
<p>　　<a href="#user-content-44-meta">4.4 meta</a></p>
<p>　　<a href="#user-content-45-link">4.5 link</a></p>
<p>　　<a href="#user-content-46-script">4.6 script</a></p>
<p>　　<a href="#user-content-47-img">4.7 img</a></p>
<p>　　<a href="#user-content-48-table">4.8 table</a></p>
<p><a href="#user-content-5-%E5%85%B6%E4%BB%96">5 其他</a></p>
<p>　　<a href="#user-content-51-%E4%BB%A3%E7%A0%81%E6%9C%89%E6%95%88%E6%80%A7">5.1 代码有效性</a></p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>无</p>
<h2 id="2-代码风格"><a href="#2-代码风格" class="headerlink" title="2 代码风格"></a>2 代码风格</h2><h3 id="2-1-文件"><a href="#2-1-文件" class="headerlink" title="2.1 文件"></a>2.1 文件</h3><h5 id="建议-用不带-BOM-头的-UTF-8-编码"><a href="#建议-用不带-BOM-头的-UTF-8-编码" class="headerlink" title="[建议] 用不带 BOM 头的 UTF-8 编码"></a>[建议] 用不带 BOM 头的 UTF-8 编码</h5><p>用没有字节顺序标记的UTF-8编码格式进行编写。</p>
<p>在HTML模板和文件中指定编码 <code>&lt;meta charset=&quot;utf-8&quot;&gt; </code>. 不需要制定样式表的编码，它默认为UTF-8.</p>
<h3 id="2-2-结构"><a href="#2-2-结构" class="headerlink" title="2.2 结构"></a>2.2 结构</h3><h4 id="2-2-1-缩进"><a href="#2-2-1-缩进" class="headerlink" title="2.2.1 缩进"></a>2.2.1 缩进</h4><h5 id="强制-每次缩进-4-个空格，不允许使用-2-个空格过-tab-字符"><a href="#强制-每次缩进-4-个空格，不允许使用-2-个空格过-tab-字符" class="headerlink" title="[强制] 每次缩进 4 个空格，不允许使用 2 个空格过 tab 字符"></a>[强制] 每次缩进 4 个空格，不允许使用 2 个空格过 tab 字符</h5><h5 id="强制-每个块元素、列表元素或表格元素都独占一行，每个子元素都相对于父元素进行缩进"><a href="#强制-每个块元素、列表元素或表格元素都独占一行，每个子元素都相对于父元素进行缩进" class="headerlink" title="[强制] 每个块元素、列表元素或表格元素都独占一行，每个子元素都相对于父元素进行缩进"></a>[强制] 每个块元素、列表元素或表格元素都独占一行，每个子元素都相对于父元素进行缩进</h5><p>将块元素、列表元素或表格元素都放在新行。</p>
<p>另外，需要缩进块元素、列表元素或表格元素的子元素。</p>
<p>（如果出现了列表项左右空文本节点问题，可以试着将所有的 li 元素都放在一行。 )</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>Space<span class="tag">&lt;/<span class="name">em</span>&gt;</span>, the final frontier.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">td</span>&gt;</span>16<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="强制-html、head、body-以及-head-和-body-的直接子元素不缩进"><a href="#强制-html、head、body-以及-head-和-body-的直接子元素不缩进" class="headerlink" title="[强制] html、head、body 以及 head 和 body 的直接子元素不缩进"></a>[强制] html、head、body 以及 head 和 body 的直接子元素不缩进</h5><h4 id="2-2-2-空格"><a href="#2-2-2-空格" class="headerlink" title="2.2.2 空格"></a>2.2.2 空格</h4><h5 id="强制-元素属性中的-左右不能出现空格"><a href="#强制-元素属性中的-左右不能出现空格" class="headerlink" title="[强制] 元素属性中的 = 左右不能出现空格"></a>[强制] 元素属性中的 <code>=</code> 左右不能出现空格</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- good --&gt;</span><br><span class="line">&lt;p class&#x3D;&quot;foo&quot;&gt;...&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- bad --&gt;</span><br><span class="line">&lt;p class &#x3D;&quot;foo&quot;&gt;...&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p class&#x3D; &quot;foo&quot;&gt;...&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p class &#x3D; &quot;foo&quot;&gt;...&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-换行"><a href="#2-2-3-换行" class="headerlink" title="2.2.3 换行"></a>2.2.3 换行</h4><h5 id="建议-每行代码不超过-120-个字符"><a href="#建议-每行代码不超过-120-个字符" class="headerlink" title="[建议] 每行代码不超过 120 个字符"></a>[建议] 每行代码不超过 120 个字符</h5><p>考虑到 html 的特殊性，不作强制要求。</p>
<h3 id="2-3-注释"><a href="#2-3-注释" class="headerlink" title="2.3  注释"></a>2.3  注释</h3><h5 id="建议-在模块的开始和结束位置添加模块开始-结束注释"><a href="#建议-在模块的开始和结束位置添加模块开始-结束注释" class="headerlink" title="[建议] 在模块的开始和结束位置添加模块开始/结束注释"></a>[建议] 在模块的开始和结束位置添加模块开始/结束注释</h5><p>这样做是很有必要的，可以使代码结构更加清晰，便于维护，尤其是模块代码很多行的时候。</p>
<ul>
<li>开始注释：<code>&lt;!-- 模块名 --&gt;</code>。</li>
<li>结束注释：<code>&lt;!-- /模块名 --&gt;</code>。</li>
<li>模块代码比较少的时候允许只有开始注释！</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 头部 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- logo --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;logo&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>logo<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /logo --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导航 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;menu&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>nav1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>nav2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /导航 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- /头部 --&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-语言特性"><a href="#3-语言特性" class="headerlink" title="3 语言特性"></a>3 语言特性</h2><h3 id="3-1-DOCTYPE"><a href="#3-1-DOCTYPE" class="headerlink" title="3.1 DOCTYPE"></a>3.1 DOCTYPE</h3><h5 id="强制-使用HTML5标准，且DOCTYPE大写"><a href="#强制-使用HTML5标准，且DOCTYPE大写" class="headerlink" title="[强制] 使用HTML5标准，且DOCTYPE大写"></a>[强制] 使用HTML5标准，且DOCTYPE大写</h5><p>DOCTYPE 不可省略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-元素"><a href="#3-2-元素" class="headerlink" title="3.2 元素"></a>3.2 元素</h3><h5 id="强制-元素名必须小写"><a href="#强制-元素名必须小写" class="headerlink" title="[强制] 元素名必须小写"></a>[强制] 元素名必须小写</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- good --&gt;</span><br><span class="line">&lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- bad --&gt;</span><br><span class="line">&lt;DIV&gt;&lt;&#x2F;DIV&gt;</span><br></pre></td></tr></table></figure>

<h5 id="强制-不要省略可选的结束标签（closing-tag）"><a href="#强制-不要省略可选的结束标签（closing-tag）" class="headerlink" title="[强制] 不要省略可选的结束标签（closing tag）"></a>[强制] 不要省略可选的结束标签（closing tag）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- good --&gt;</span><br><span class="line">&lt;p&gt;这是一段文本&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- bad --&gt;</span><br><span class="line">&lt;p&gt;这是一段文本</span><br></pre></td></tr></table></figure>

<h5 id="强制-不要在自闭合元素（Void-elements）尾部添加斜线"><a href="#强制-不要在自闭合元素（Void-elements）尾部添加斜线" class="headerlink" title="[强制] 不要在自闭合元素（Void elements）尾部添加斜线"></a>[强制] 不要在自闭合元素（Void elements）尾部添加斜线</h5><p>常见的自闭合元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</span><br></pre></td></tr></table></figure>
<p>不太常见的无内容元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt;</span><br><span class="line">&lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- good --&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;xxx.jpg&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- bad --&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;xxx.jpg&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h5 id="强制-标签必须合理地嵌套"><a href="#强制-标签必须合理地嵌套" class="headerlink" title="[强制] 标签必须合理地嵌套"></a>[强制] 标签必须合理地嵌套</h5><ul>
<li>块元素可以包含内联元素或块元素。</li>
<li>内联元素不能包含块元素。</li>
<li>几个特殊的块元素只能包含内联元素，不能包含块元素：h1-h6、p、dt、caption、hr。</li>
<li>其他规则，如 tbody 必须置于 table 中。</li>
</ul>
<h5 id="建议-合理使用语义化标签"><a href="#建议-合理使用语义化标签" class="headerlink" title="[建议] 合理使用语义化标签"></a>[建议] 合理使用语义化标签</h5><p>合理使用，不滥用。</p>
<p>原因：SEO优化。</p>
<h5 id="建议-不使用样式有关的元素"><a href="#建议-不使用样式有关的元素" class="headerlink" title="[建议] 不使用样式有关的元素"></a>[建议] 不使用样式有关的元素</h5><p>如center、u 等等。</p>
<h5 id="建议-减少不必要的嵌套"><a href="#建议-减少不必要的嵌套" class="headerlink" title="[建议] 减少不必要的嵌套"></a>[建议] 减少不必要的嵌套</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- good --&gt;</span><br><span class="line">&lt;img class&#x3D;&quot;foo&quot; src&#x3D;&quot;xxx.jpg&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- bad --&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;foo&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;xxx.jpg&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-属性"><a href="#3-3-属性" class="headerlink" title="3.3 属性"></a>3.3 属性</h3><h5 id="强制-属性必须小写"><a href="#强制-属性必须小写" class="headerlink" title="[强制] 属性必须小写"></a>[强制] 属性必须小写</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- good --&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;xxx.jpg&quot;&gt;</span><br><span class="line">&lt;div onclick&#x3D;&quot;foo()&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- bad --&gt;</span><br><span class="line">&lt;img SRC&#x3D;&quot;xxx.jpg&quot;&gt;</span><br><span class="line">&lt;div onClick&#x3D;&quot;foo()&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h5 id="建议-自定义属性以-data-开头"><a href="#建议-自定义属性以-data-开头" class="headerlink" title="[建议] 自定义属性以 data- 开头"></a>[建议] 自定义属性以 <code>data-</code> 开头</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- good --&gt;</span><br><span class="line">&lt;img class&#x3D;&quot;post-image&quot; src&#x3D;&quot;default.jpg&quot; data-original&#x3D;&quot;foo.png&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- bad --&gt;</span><br><span class="line">&lt;img class&#x3D;&quot;post-image&quot; src&#x3D;&quot;default.jpg&quot; original-image&#x3D;&quot;foo.png&quot;&gt;</span><br></pre></td></tr></table></figure>

<h5 id="强制-属性值必须用双引号包围"><a href="#强制-属性值必须用双引号包围" class="headerlink" title="[强制] 属性值必须用双引号包围"></a>[强制] 属性值必须用双引号包围</h5><p>不允许使用单引号，不允许不加引号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- good --&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;xxx.jpg&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- bad --&gt;</span><br><span class="line">&lt;img src&#x3D;&#39;xxx.jpg&#39;&gt;</span><br><span class="line">&lt;img src&#x3D;&#39;xxx.jpg&gt;</span><br></pre></td></tr></table></figure>


<h5 id="建议-属性值必须小写（除了文本和-CDATA-）"><a href="#建议-属性值必须小写（除了文本和-CDATA-）" class="headerlink" title="[建议] 属性值必须小写（除了文本和 CDATA ）"></a>[建议] 属性值必须小写（除了文本和 CDATA ）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- good --&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;&quot; target&#x3D;&quot;_blank&quot;&gt;百度一下&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- bad --&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;&quot; target&#x3D;&quot;_BLANK&quot;&gt;百度一下&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<h5 id="建议-布尔类型的属性不添加属性值"><a href="#建议-布尔类型的属性不添加属性值" class="headerlink" title="[建议] 布尔类型的属性不添加属性值"></a>[建议] 布尔类型的属性不添加属性值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- good --&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; disabled&gt;</span><br><span class="line"> </span><br><span class="line">&lt;input type&#x3D;&quot;checkbox&quot; checked&gt;</span><br><span class="line"> </span><br><span class="line">&lt;select&gt;</span><br><span class="line">	&lt;option selected&gt;1&lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- bad --&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; disabled&#x3D;&quot;true&quot;&gt;</span><br></pre></td></tr></table></figure>

<h5 id="建议-属性应当按照以下给出的顺序依次排列"><a href="#建议-属性应当按照以下给出的顺序依次排列" class="headerlink" title="[建议] 属性应当按照以下给出的顺序依次排列"></a>[建议] 属性应当按照以下给出的顺序依次排列</h5><ol>
<li>class</li>
<li>id, name</li>
<li>data-*</li>
<li>src, for, type, href</li>
<li>title, alt</li>
<li>aria-*, role</li>
</ol>
<p>依据属性的重要程度来书写。<br>必须属性写在非必须属性前面。</p>
<p>class 用于标识组件，相当于一个元素的名称，因此应该排在首位。</p>
<p>id 用于标识具体组件，排在第二位。</p>
<h2 id="4-常见元素"><a href="#4-常见元素" class="headerlink" title="4 常见元素"></a>4 常见元素</h2><h3 id="4-1-html"><a href="#4-1-html" class="headerlink" title="4.1 html"></a>4.1 html</h3><h5 id="建议-为-html-元素添加-lang-属性"><a href="#建议-为-html-元素添加-lang-属性" class="headerlink" title="[建议] 为 html 元素添加 lang 属性"></a>[建议] 为 html 元素添加 lang 属性</h5><p>为文档设置正确的语言。</p>
<p>这将有助于语音合成工具确定其所应该采用的发音，有助于翻译工具自动翻译等等。</p>
<p>如果是中文，lang 属性值为 <code>zh-CN</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang&#x3D;&quot;zh-CN&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-head"><a href="#4-2-head" class="headerlink" title="4.2 head"></a>4.2 head</h3><h5 id="建议-head-元素各子元素按顺序编写"><a href="#建议-head-元素各子元素按顺序编写" class="headerlink" title="[建议] head 元素各子元素按顺序编写"></a>[建议] head 元素各子元素按顺序编写</h5><ol>
<li>meta</li>
<li>title</li>
<li>link</li>
<li>script</li>
<li>style</li>
</ol>
<h3 id="4-3-title"><a href="#4-3-title" class="headerlink" title="4.3 title"></a>4.3 title</h3><h5 id="强制-title-元素必不可少"><a href="#强制-title-元素必不可少" class="headerlink" title="[强制] title 元素必不可少"></a>[强制] title 元素必不可少</h5><p>标题不可为空。</p>
<h3 id="4-4-meta"><a href="#4-4-meta" class="headerlink" title="4.4 meta"></a>4.4 meta</h3><h5 id="强制-使用-lt-meta-charset-quot-quot-gt-来定义页面编码"><a href="#强制-使用-lt-meta-charset-quot-quot-gt-来定义页面编码" class="headerlink" title="[强制] 使用 &lt;meta charset=&quot;&quot;&gt; 来定义页面编码"></a>[强制] 使用 <code>&lt;meta charset=&quot;&quot;&gt;</code> 来定义页面编码</h5><p>页面必须指定编码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br></pre></td></tr></table></figure>

<h5 id="建议-启用-IE-兼容模式"><a href="#建议-启用-IE-兼容模式" class="headerlink" title="[建议] 启用 IE 兼容模式"></a>[建议] 启用 IE 兼容模式</h5><p>IE 支持通过特定的 <meta> 标签来确定绘制当前页面所应该采用的 IE 版本。除非有强烈的特殊需求，否则最好是设置为 edge mode，从而通知 IE 采用其所支持的最新的模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;Edge&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-link"><a href="#4-5-link" class="headerlink" title="4.5 link"></a>4.5 link</h3><h5 id="强制-使用-link-引用外部-css-文件时，必须加-rel-quot-stylesheet-quot"><a href="#强制-使用-link-引用外部-css-文件时，必须加-rel-quot-stylesheet-quot" class="headerlink" title="[强制] 使用 link 引用外部 css 文件时，必须加 rel=&quot;stylesheet&quot;"></a>[强制] 使用 link 引用外部 css 文件时，必须加 <code>rel=&quot;stylesheet&quot;</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- good --&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;foo.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- bad --&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;foo.css&quot;&gt;</span><br></pre></td></tr></table></figure>

<h5 id="强制-使用-link-引用外部-css-文件时，不允许加-type-quot-text-css-quot"><a href="#强制-使用-link-引用外部-css-文件时，不允许加-type-quot-text-css-quot" class="headerlink" title="[强制] 使用 link 引用外部 css 文件时，不允许加 type=&quot;text/css&quot;"></a>[强制] 使用 link 引用外部 css 文件时，不允许加 <code>type=&quot;text/css&quot;</code></h5><p>HTML5 默认 type 为 <code>text/css</code>，所以没必要指定。即便是老浏览器也是支持的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- good --&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;foo.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- bad --&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;foo.css&quot;&gt;</span><br></pre></td></tr></table></figure>

<h5 id="建议-使用-link-引用外部-css-文件时，rel-quot-stylesheet-quot-写在-href-属性前面"><a href="#建议-使用-link-引用外部-css-文件时，rel-quot-stylesheet-quot-写在-href-属性前面" class="headerlink" title="[建议] 使用 link 引用外部 css 文件时，rel=&quot;stylesheet&quot; 写在 href 属性前面"></a>[建议] 使用 link 引用外部 css 文件时，<code>rel=&quot;stylesheet&quot;</code> 写在 href 属性前面</h5><p>仅仅是为了对齐，看起来美观而已。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- good --&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;foo.css&quot;&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;long-path&#x2F;foo.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- bad --&gt;</span><br><span class="line">&lt;link href&#x3D;&quot;foo.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;link href&#x3D;&quot;long-path&#x2F;foo.css&quot; rel&#x3D;&quot;stylesheet&quot; &gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-script"><a href="#4-6-script" class="headerlink" title="4.6 script"></a>4.6 script</h3><h5 id="强制-使用script元素引用外部-javascript-文件时，不允许加-type-quot-text-javascript-quot"><a href="#强制-使用script元素引用外部-javascript-文件时，不允许加-type-quot-text-javascript-quot" class="headerlink" title="[强制] 使用script元素引用外部 javascript 文件时，不允许加 type=&quot;text/javascript&quot;"></a>[强制] 使用script元素引用外部 javascript 文件时，不允许加 <code>type=&quot;text/javascript&quot;</code></h5><p>HTML5默认 script 元素的 type 为 <code>text/javascript</code> 类型，所以没必要指定。即便是老浏览器也是支持的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- good --&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;foo.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- bad --&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;foo.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-7-img"><a href="#4-7-img" class="headerlink" title="4.7 img"></a>4.7 img</h3><h3 id="4-8-table"><a href="#4-8-table" class="headerlink" title="4.8 table"></a>4.8 table</h3><h5 id="强制-除非必要，否则不要使用-table-元素来布局"><a href="#强制-除非必要，否则不要使用-table-元素来布局" class="headerlink" title="[强制] 除非必要，否则不要使用 table 元素来布局"></a>[强制] 除非必要，否则不要使用 <code>table</code> 元素来布局</h5><p>除了显示表格数据外，尽可能避免使用表格来布局。</p>
<h5 id="强制-table-元素必须包含-thead-和-tbody-元素"><a href="#强制-table-元素必须包含-thead-和-tbody-元素" class="headerlink" title="[强制] table 元素必须包含 thead 和 tbody 元素"></a>[强制] table 元素必须包含 thead 和 tbody 元素</h5><p>如果不需要标题，thead 可以不写。</p>
<h3 id="语义化元素"><a href="#语义化元素" class="headerlink" title="语义化元素"></a>语义化元素</h3><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>“网页”或“section”的页眉。也就是说header的直接父元素不是body就是section。通常显示网站标题，副标题，logo等信息。</p>
<h4 id="footer"><a href="#footer" class="headerlink" title="footer"></a>footer</h4><p>“网页”或“section”的页脚。也就是说header的直接父元素不是body就是section。显示版权等信息。</p>
<h4 id="nav"><a href="#nav" class="headerlink" title="nav"></a>nav</h4><p>导航栏，网站的导航</p>
<h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5 其他"></a>5 其他</h2><h3 id="5-1-代码有效性"><a href="#5-1-代码有效性" class="headerlink" title="5.1 代码有效性"></a>5.1 代码有效性</h3><h3 id="HTML代码有效性"><a href="#HTML代码有效性" class="headerlink" title="HTML代码有效性"></a>HTML代码有效性</h3><h5 id="建议-尽量使用有效的HTML代码"><a href="#建议-尽量使用有效的HTML代码" class="headerlink" title="[建议] 尽量使用有效的HTML代码"></a>[建议] 尽量使用有效的HTML代码</h5><p>比如元素的闭合、必要的元素等等。</p>
<p>编写有效的HTML代码，否则很难达到性能上的提升。</p>
<p>用类似 <a target="_blank" rel="noopener" href="http://validator.w3.org/">W3C HTML validator</a>  这样的工具来进行测试。</p>
<p>HTML代码有效性是重要的质量衡量标准，并可确保HTML代码可以正确使用。</p>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>大胆地使用 html5 语义标签，兼容性问题用 <a target="_blank" rel="noopener" href="https://github.com/aFarkas/html5shiv">html5shiv</a> 解决</p>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><h5 id="建议-用-TODO-标记代办事项和正活动的条目"><a href="#建议-用-TODO-标记代办事项和正活动的条目" class="headerlink" title="[建议] 用 TODO 标记代办事项和正活动的条目"></a>[建议] 用 TODO 标记代办事项和正活动的条目</h5><p>说明：<br>只用 TODO 来强调代办事项， 不要用其他的常见格式，例如 @@ 。</p>
<p>附加联系人（用户名或电子邮件列表），用括号括起来，例如 TODO(contact) 。</p>
<p>可在冒号之后附加活动条目说明等，例如 TODO: 活动条目说明 。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;# TODO(cha.jn): 重新置中 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- <span class="doctag">TODO:</span> 删除可选元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Apples<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Oranges<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="多媒体后备方案"><a href="#多媒体后备方案" class="headerlink" title="多媒体后备方案"></a>多媒体后备方案</h3><h5 id="建议-为多媒体提供备选内容"><a href="#建议-为多媒体提供备选内容" class="headerlink" title="[建议] 为多媒体提供备选内容"></a>[建议] 为多媒体提供备选内容</h5><p>对于多媒体，如图像，视频，通过 canvas 读取的动画元素，确保提供备选方案。 对于图像使用有意义的备选文案（ alt ） 对于视频和音频使用有效的副本和文案说明。</p>
<p>提供备选内容是很重要的，原因：给盲人用户以一些提示性的文字，用 @alt 告诉他这图像是关于什么的，给可能没理解视频或音频的内容的用户以提示。</p>
<p>（图像的 alt 属性会产生冗余，如果使用图像只是为了不能立即用CSS而装饰的 ，就不需要用备选文案了，可以写 alt=”” 。）</p>
<h3 id="关注点分离"><a href="#关注点分离" class="headerlink" title="关注点分离"></a>关注点分离</h3><h5 id="建议-尽可能保持结构（html）、表现（css）和行为（Javascript）分离。"><a href="#建议-尽可能保持结构（html）、表现（css）和行为（Javascript）分离。" class="headerlink" title="[建议] 尽可能保持结构（html）、表现（css）和行为（Javascript）分离。"></a>[建议] 尽可能保持结构（html）、表现（css）和行为（Javascript）分离。</h5><p>确保文档和模板只包含HTML结构， 把所有表现都放到样式表里，把所有行为都放到脚本里。</p>
<p>此外，尽量使脚本和样式表在文档与模板中有最小接触面积，即减少外链。</p>
<p>具体见后面几条规范。</p>
<h5 id="建议-尽量避免写在-HTML-标签中写-style-属性"><a href="#建议-尽量避免写在-HTML-标签中写-style-属性" class="headerlink" title="[建议] 尽量避免写在 HTML 标签中写 style 属性"></a>[建议] 尽量避免写在 HTML 标签中写 style 属性</h5><h5 id="建议-尽量避免-JavaScript-生成标签"><a href="#建议-尽量避免-JavaScript-生成标签" class="headerlink" title="[建议] 尽量避免 JavaScript 生成标签"></a>[建议] 尽量避免 JavaScript 生成标签</h5><p>通过 JavaScript 生成的标签让内容变得不易查找、编辑，并且降低性能。</p>
<h5 id="建议-避免内联到-HTML-的-Javascript-代码"><a href="#建议-避免内联到-HTML-的-Javascript-代码" class="headerlink" title="[建议] 避免内联到 HTML 的 Javascript 代码"></a>[建议] 避免内联到 HTML 的 Javascript 代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- good --&gt;</span><br><span class="line">&lt;a id&#x3D;&quot;myId&quot; href&#x3D;&quot;javascript:;&quot;&gt;foo&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">$(&quot;#myId&quot;).on(&quot;click&quot;, handler);</span><br><span class="line"></span><br><span class="line">&lt;!-- bad --&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;javascript:;&quot; onclick&#x3D;&quot;handler();&quot;&gt;foo&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><h5 id="建议-嵌入式资源书写省略协议头"><a href="#建议-嵌入式资源书写省略协议头" class="headerlink" title="[建议] 嵌入式资源书写省略协议头"></a>[建议] 嵌入式资源书写省略协议头</h5><p>省略图像、媒体文件、样式表和脚本等URL协议头部声明 ( http: , https: )。如果不是这两个声明的URL则不省略。</p>
<p>省略协议声明，使URL成相对地址，防止内容混淆问题和导致小文件重复下载。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不推荐 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://www.google.com/js/gweb/analytics/autotrack.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 推荐 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//www.google.com/js/gweb/analytics/autotrack.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">/* 不推荐 */</span><br><span class="line">.example &#123;</span><br><span class="line">  background: url(http://www.google.com/images/example);</span><br><span class="line">&#125;</span><br><span class="line">/* 推荐 */</span><br><span class="line">.example &#123;</span><br><span class="line">  background: url(//www.google.com/images/example);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="实体引用"><a href="#实体引用" class="headerlink" title="实体引用"></a>实体引用</h3><p>不要用实体引用。<br>不需要使用类似 &mdash; 、 &rdquo; 和 &#x263a; 等的实体引用, 假定团队之间所用的文件和编辑器是同一编码（UTF-8）。</p>
<p>在HTML文档中具有特殊含义的字符（例如 &lt; 和 &amp; )为例外， 噢对了，还有 “不可见” 字符 （例如no-break空格）。</p>
<!-- 不推荐 -->
<p>欧元货币符号是 <code>&amp;ldquo;&amp;eur;&amp;rdquo;</code>。</p>
<!-- 推荐 -->
<p>欧元货币符号是 “€”。</p>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/16/">上一页</a></div><div class="pagination-next"><a href="/page/18/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/16/">16</a></li><li><a class="pagination-link is-current" href="/page/17/">17</a></li><li><a class="pagination-link" href="/page/18/">18</a></li><li><a class="pagination-link" href="/page/19/">19</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://www.gravatar.com/avatar/2396bdfe5aadb513e676094004dde830?s=128" alt="edwin"></figure><p class="title is-size-4 is-block line-height-inherit">edwin</p><p class="is-size-6 is-block">知识铺</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国 杭州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">189</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">2</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/liliang8858" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/liliang8858"><i class="Github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="社区"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="设计"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/go/"><span class="level-start"><span class="level-item">go</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T10:43:02.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/Spring%20Cloud%20Gateway+Nacos%EF%BC%8Cyml+properties%E4%B8%A4%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BA%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1/">Spring Cloud Gateway+Nacos，yml+properties两种配置文件方式搭建网关服务</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T10:39:59.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/Spring%20Cloud+nacos+Feign%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/">Spring Cloud+nacos+Feign，实现注册中心及配置中心</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T10:32:26.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/Nacos%E4%BD%9C%E4%B8%BA%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%97%B6%EF%BC%8C%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AAdataId%E7%9A%84%E9%85%8D%E7%BD%AE/">Nacos作为配置中心时，多个服务共用一个dataId的配置</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T09:34:29.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/SpringCloudAlibaba(%E4%B8%89)%EF%BC%9A%E4%BD%BF%E7%94%A8Nacos%E4%BD%9C%E4%B8%BA%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/">SpringCloudAlibaba(三)：使用Nacos作为配置中心</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T09:31:53.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/Nacos%20%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/">Nacos 集群部署</a></p><p class="is-uppercase"></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">37</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">62</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web/"><span class="tag">web</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">广告</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="2183476622" data-ad-slot="pub-2874221941555456" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="知识铺" height="28"></a><p class="size-small"><span>&copy; 2020 edwin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://zshipu.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>