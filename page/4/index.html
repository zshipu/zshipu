<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>知识铺</title><meta property="og:type" content="blog"><meta property="og:title" content="知识铺"><meta property="og:url" content="https://zshipu.com/"><meta property="og:site_name" content="知识铺"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zshipu.com/img/og_image.png"><meta property="article:author" content="edwin"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zshipu.com"},"headline":"知识铺","image":["https://zshipu.com/img/og_image.png"],"author":{"@type":"Person","name":"edwin"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script data-ad-client="2183476622" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="generator" content="Hexo 5.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="知识铺" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-06-21T03:27:01.000Z" title="2020-06-21T03:27:01.000Z">2020-06-21</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.393Z" title="2020-09-08T14:03:00.393Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">17 分钟读完 (大约2553个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/21/Python%20%E4%B8%AD%E6%94%AF%E6%8C%81%E7%9F%A2%E9%87%8F%E6%9C%BA%20-%20%E5%88%86%E6%AD%A5%E6%8C%87%E5%8D%97/">Python 中支持矢量机 - 分步指南</a></h1><div class="content"><p>支持向量机 （SVM） 是世界上最受欢迎的机器学习问题之一。</p>
<p>SVM 可用于分类问题或回归问题，这使得它们非常通用。</p>
<p>在本教程中，您将学习如何使用 附带的乳腺癌数据集从头开始构建第一个 Python 支持向量机模型。<code>scikit-learn</code></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>您可以使用下面的目录跳到此 Python 机器学习教程的特定部分：</p>
<ul>
<li><a href="https://zshipu.com/t?url=#the-python-libraries-we-will-need-in-this-tutorial">本教程中我们需要的 Python 库</a></li>
<li><a href="https://zshipu.com/t?url=#the-data-set-we-will-use-in-this-tutorial">我们将在本教程中使用数据集</a></li>
<li><a href="https://zshipu.com/t?url=#splitting-the-data-set-into-training-data-and-test-data">将数据集拆分为训练数据和测试数据</a></li>
<li><a href="https://zshipu.com/t?url=#training-the-support-vector-machines-model">训练支持向量机模型</a></li>
<li><a href="https://zshipu.com/t?url=#making-predictions-with-our-support-vector-machines-model">使用我们的支持矢量机模型进行预测</a></li>
<li><a href="https://zshipu.com/t?url=#assessing-the-performance-of-our-support-vector-machines-model">评估我们支持向量机模型的性能</a></li>
<li><a href="https://zshipu.com/t?url=#the-full-code-for-this-tutorial">本教程的完整代码</a></li>
<li><a href="https://zshipu.com/t?url=#final-thoughts">最后的想法</a></li>
</ul>
<h2 id="本教程中我们需要的-Python-库"><a href="#本教程中我们需要的-Python-库" class="headerlink" title="本教程中我们需要的 Python 库"></a>本教程中我们需要的 Python 库</h2><p>在本教程中，您将使用许多开源 Python 库，包括<a href="https://zshipu.com/t?url=https://nickmccullum.com/advanced-python/numpy/">NumPy、</a><a href="https://zshipu.com/t?url=https://nickmccullum.com/advanced-python/pandas/">熊猫</a>和 matplotlib。以下是在开始之前需要运行的一些导入：</p>
<p>  <code>import pandas as pd</p>
<p>import numpy as np</p>
<p>import matplotlib.pyplot as plt</p>
<p>%matplotlib inline</p>
<p>import seaborn as sns</code> </p>
<p>接下来，您将导入我们将在整个本教程中使用的数据集。</p>
<h2 id="我们将在本教程中使用数据集"><a href="#我们将在本教程中使用数据集" class="headerlink" title="我们将在本教程中使用数据集"></a>我们将在本教程中使用数据集</h2><p>本教程使用 附带的乳腺癌数据集。因此，我们现在会将该数据集导入到 Python 脚本中。<code>scikit-learn</code></p>
<p>首先，使用以下命令从 模块导入 函数：<code>load_breast_cancer``````datasets``````scikit-learn</code></p>
<p>  <code>from sklearn.datasets import load_breast_cancer</code> </p>
<p>接下来，您需要创建乳腺癌数据集的实例。以下语句应执行以下操作：</p>
<p>  <code>cancer_data = load_breast_cancer()</code> </p>
<p>此变量不仅包括乳腺癌数据集。例如，我们很快就会看到此数据结构中包含一个有用的描述。<code>cancer_data``````raw_data</code></p>
<p>因此，在导入数据集时，我们需要执行的最后一步是将数据存储在它自己的数据帧中。下面是执行此操作的代码：<code>raw_data</code></p>
<p>  <code>raw_data = pd.DataFrame(cancer_data['data'], columns = cancer_data['feature_names'])</code> </p>
<p>让我们来调查此数据集中实际包含的内容。</p>
<p>中包含的每个数据集都附带一个描述字段，可帮助您了解数据集描述的内容。<code>scikit-learn</code></p>
<p>让我们打印此说明。以下语句应执行以下操作：</p>
<p>  <code>print(raw_data['DESCR'])</code> </p>
<p>这将生成：</p>
<p> <code>.. _breast_cancer_dataset:</p>
<h2 id="Breast-cancer-wisconsin-diagnostic-dataset"><a href="#Breast-cancer-wisconsin-diagnostic-dataset" class="headerlink" title="Breast cancer wisconsin (diagnostic) dataset"></a>Breast cancer wisconsin (diagnostic) dataset</h2><p><strong>Data Set Characteristics:</strong></p>
<pre><code>:Number of Instances: 569

:Number of Attributes: 30 numeric, predictive attributes and the class

:Attribute Information:
    - radius (mean of distances from center to points on the perimeter)
    - texture (standard deviation of gray-scale values)
    - perimeter
    - area
    - smoothness (local variation in radius lengths)
    - compactness (perimeter^2 / area - 1.0)
    - concavity (severity of concave portions of the contour)
    - concave points (number of concave portions of the contour)
    - symmetry
    - fractal dimension (&quot;coastline approximation&quot; - 1)

    The mean, standard error, and &quot;worst&quot; or largest (mean of the three
    worst/largest values) of these features were computed for each image,
    resulting in 30 features.  For instance, field 0 is Mean Radius, field
    10 is Radius SE, field 20 is Worst Radius.

    - class:
            - WDBC-Malignant
            - WDBC-Benign

:Summary Statistics:

===================================== ====== ======
                                       Min    Max
===================================== ====== ======
radius (mean):                        6.981  28.11
texture (mean):                       9.71   39.28
perimeter (mean):                     43.79  188.5
area (mean):                          143.5  2501.0
smoothness (mean):                    0.053  0.163
compactness (mean):                   0.019  0.345
concavity (mean):                     0.0    0.427
concave points (mean):                0.0    0.201
symmetry (mean):                      0.106  0.304
fractal dimension (mean):             0.05   0.097
radius (standard error):              0.112  2.873
texture (standard error):             0.36   4.885
perimeter (standard error):           0.757  21.98
area (standard error):                6.802  542.2
smoothness (standard error):          0.002  0.031
compactness (standard error):         0.002  0.135
concavity (standard error):           0.0    0.396
concave points (standard error):      0.0    0.053
symmetry (standard error):            0.008  0.079
fractal dimension (standard error):   0.001  0.03
radius (worst):                       7.93   36.04
texture (worst):                      12.02  49.54
perimeter (worst):                    50.41  251.2
area (worst):                         185.2  4254.0
smoothness (worst):                   0.071  0.223
compactness (worst):                  0.027  1.058
concavity (worst):                    0.0    1.252
concave points (worst):               0.0    0.291
symmetry (worst):                     0.156  0.664
fractal dimension (worst):            0.055  0.208
===================================== ====== ======

:Missing Attribute Values: None

:Class Distribution: 212 - Malignant, 357 - Benign

:Creator:  Dr. William H. Wolberg, W. Nick Street, Olvi L. Mangasarian

:Donor: Nick Street

:Date: November, 1995</code></pre>
<p>This is a copy of UCI ML Breast Cancer Wisconsin (Diagnostic) datasets.<br><a target="_blank" rel="noopener" href="https://goo.gl/U2Uwz2">https://goo.gl/U2Uwz2</a></p>
<p>Features are computed from a digitized image of a fine needle<br>aspirate (FNA) of a breast mass.  They describe<br>characteristics of the cell nuclei present in the image.</p>
<p>Separating plane described above was obtained using<br>Multisurface Method-Tree (MSM-T) [K. P. Bennett, “Decision Tree<br>Construction Via Linear Programming.” Proceedings of the 4th<br>Midwest Artificial Intelligence and Cognitive Science Society,<br>pp. 97-101, 1992], a classification method which uses linear<br>programming to construct a decision tree.  Relevant features<br>were selected using an exhaustive search in the space of 1-4<br>features and 1-3 separating planes.</p>
<p>The actual linear program used to obtain the separating plane<br>in the 3-dimensional space is that described in:<br>[K. P. Bennett and O. L. Mangasarian: “Robust Linear<br>Programming Discrimination of Two Linearly Inseparable Sets”,<br>Optimization Methods and Software 1, 1992, 23-34].</p>
<p>This database is also available through the UW CS ftp server:</p>
<p>ftp ftp.cs.wisc.edu<br>cd math-prog/cpo-dataset/machine-learn/WDBC/</p>
<p>.. topic:: References</p>
<ul>
<li>W.N. Street, W.H. Wolberg and O.L. Mangasarian. Nuclear feature extraction<br>for breast tumor diagnosis. IS&amp;T/SPIE 1993 International Symposium on<br>Electronic Imaging: Science and Technology, volume 1905, pages 861-870,<br>San Jose, CA, 1993.</li>
<li>O.L. Mangasarian, W.N. Street and W.H. Wolberg. Breast cancer diagnosis and<br>prognosis via linear programming. Operations Research, 43(4), pages 570-577,<br>July-August 1995.</li>
<li>W.H. Wolberg, W.N. Street, and O.L. Mangasarian. Machine learning techniques<br>to diagnose breast cancer from fine-needle aspirates. Cancer Letters 77 (1994)<br>163-171.</code> </li>
</ul>
<p>此数据集描述中最重要的要点是：</p>
<ul>
<li>数据集中有 569 个观测值</li>
<li>每个观察点有 30 个数字属性</li>
</ul>
<p>现在，我们已经了解了数据集的结构，让我们继续将数据集拆分为训练数据和测试数据。</p>
<h2 id="将数据集拆分为训练数据和测试数据"><a href="#将数据集拆分为训练数据和测试数据" class="headerlink" title="将数据集拆分为训练数据和测试数据"></a>将数据集拆分为训练数据和测试数据</h2><p>要将数据集拆分为训练数据和测试数据，我们需要做的第一件事是指定我们和变量。<code>x``````y</code></p>
<p>我们的变量将是我们之前创建的<a href="https://zshipu.com/t?url=https://nickmccullum.com/advanced-python/pandas-dataframes/">熊猫数据帧</a>。我们的变量需要从我们之前创建的原始对象进行分析，其中存储在键下。<code>x``````raw_data``````y``````cancer_data``````target</code></p>
<p>更具体地说，下面是创建我们和变量的代码：<code>x``````y</code></p>
<p>  <code>x = raw_data</p>
<p>y = cancer_data[‘target’]</code> </p>
<p>我们将使用’s 函数与列表解包相结合，将数据集拆分为训练数据和测试数据（就像我们在<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-machine-learning/logistic-regression-python/">本课程前面</a><a href="https://zshipu.com/t?url=https://nickmccullum.com/python-machine-learning/linear-regression-python/">之前所做的那样）。</a><code>scikit-learn``````train_test_split</code></p>
<p>首先，您需要使用以下语句导入函数：</p>
<p>  <code>from sklearn.model_selection import train_test_split</code> </p>
<p>现在，您可以使用以下语句沿 和 轴创建训练数据和测试数据：<code>x``````y</code></p>
<p>  <code>x_training_data, x_test_data, y_training_data, y_test_data = train_test_split(x, y, test_size = 0.3)</code> </p>
<p>这将拆分数据，以便测试数据是原始数据集的 30%（由 参数指示）。<code>test_size = 0.3</code></p>
<p>现在，我们的数据被拆分了，让我们继续训练我们的第一个支持向量机模型。</p>
<h2 id="训练支持向量机模型"><a href="#训练支持向量机模型" class="headerlink" title="训练支持向量机模型"></a>训练支持向量机模型</h2><p>在训练第一个支持向量机模型之前，需要从 导入模型类。<code>scikit-learn</code></p>
<p>类住在模块内。下面是用于导入它的语句：<code>SVC``````scikit-learn``````svm</code></p>
<p>  <code>from sklearn.svm import SVC</code> </p>
<p>现在，让我们创建一个此类的实例并将其分配给变量：<code>model</code></p>
<p>  <code>model = SVC()</code> </p>
<p>现在，我们可以使用与<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-machine-learning/k-nearest-neighbors-python/">k 最近邻域模型</a>和<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-machine-learning/decision-trees-random-forests-python/">随机林模型</a>相同的方法训练 SVM 模型：通过调用该方法，并传入 和 。<code>fit``````x_training_data``````y_training_data</code></p>
<p>下面是执行此操作的代码：</p>
<p>  <code>model.fit(x_training_data, y_training_data)</code> </p>
<p>我们的模型现在已经接受培训。让我们在本教程的下一节中继续使用模型进行预测。</p>
<h2 id="使用我们的支持矢量机模型进行预测"><a href="#使用我们的支持矢量机模型进行预测" class="headerlink" title="使用我们的支持矢量机模型进行预测"></a>使用我们的支持矢量机模型进行预测</h2><p>使用创建的任何机器学习模型都可用于生成预测，只需调用方法并传入要从中生成预测的值数组。<code>scikit-learn``````predict</code></p>
<p>在这种情况下，下面是 Python 语句，用于存储来自 名为 的变量中的预测：<code>x_test_data``````predictions</code></p>
<p>  <code>predictions = model.predict(x_test_data)</code> </p>
<p>接下来我们将评估模型的性能。</p>
<h2 id="评估我们支持向量机模型的性能"><a href="#评估我们支持向量机模型的性能" class="headerlink" title="评估我们支持向量机模型的性能"></a>评估我们支持向量机模型的性能</h2><p>我们将使用与本课程中构建的其他分类模型相同的支持向量机器模型的性能测量技术：a 和 。<code>classification_report``````confusion_matrix</code></p>
<p>首先，让我们从 导入这些函数：<code>scikit-learn</code></p>
<p>  <code>from sklearn.metrics import classification_report</p>
<p>from sklearn.metrics import confusion_matrix</code> </p>
<p>首先，让我们生成我们的classification_report：</p>
<p>  <code>print(classification_report(y_test_data, predictions))</code> </p>
<p>这将生成：</p>
<p>  <code>precision    recall  f1-score   support</p>
<pre><code>       0       1.00      0.84      0.91        67

       1       0.90      1.00      0.95       104

accuracy                           0.94       171</code></pre>
<p>   macro avg       0.95      0.92      0.93       171</p>
<p>weighted avg       0.94      0.94      0.93       171</code> </p>
<p>接下来，让我们生成我们的混淆矩阵：</p>
<p>  <code>print(confusion_matrix(y_test_data, predictions))</code> </p>
<p>这将生成：</p>
<p>  <code>[[ 56  11]</p>
<p> [  0 104]]</code> </p>
<h2 id="本教程的完整代码"><a href="#本教程的完整代码" class="headerlink" title="本教程的完整代码"></a>本教程的完整代码</h2><p>您可以在<a href="https://zshipu.com/t?url=https://github.com/nicholasmccullum/python-machine-learning">此 GitHub 存储库</a>中查看本教程的完整代码。下面还粘贴如下，供参考：</p>
<p>  <code>#Data imports<br>import pandas as pd</p>
<p>import numpy as np</p>
<p>#Visualization imports<br>import matplotlib.pyplot as plt</p>
<p>%matplotlib inline</p>
<p>import seaborn as sns</p>
<p>#Import the data set from scikit-learn<br>from sklearn.datasets import load_breast_cancer</p>
<p>cancer_data = load_breast_cancer()</p>
<p>raw_data = pd.DataFrame(cancer_data[‘data’], columns = cancer_data[‘feature_names’])</p>
<h1 id="print-cancer-data-‘DESCR’"><a href="#print-cancer-data-‘DESCR’" class="headerlink" title="print(cancer_data[‘DESCR’])"></a>print(cancer_data[‘DESCR’])</h1><p>#Split the data set into training data and test data<br>x = raw_data</p>
<p>y = cancer_data[‘target’]</p>
<p>from sklearn.model_selection import train_test_split</p>
<p>x_training_data, x_test_data, y_training_data, y_test_data = train_test_split(x, y, test_size = 0.3)</p>
<p>#Train the SVM model<br>from sklearn.svm import SVC</p>
<p>model = SVC()</p>
<p>model.fit(x_training_data, y_training_data)</p>
<p>#Make predictions with the model<br>predictions = model.predict(x_test_data)</p>
<p>#Measure the performance of our model<br>from sklearn.metrics import classification_report</p>
<p>from sklearn.metrics import confusion_matrix</p>
<p>print(classification_report(y_test_data, predictions))</p>
<p>print(confusion_matrix(y_test_data, predictions))</code> </p>
<h2 id="最后的想法"><a href="#最后的想法" class="headerlink" title="最后的想法"></a>最后的想法</h2><p>在本教程中，您学习了如何构建 Python 支持向量计算机模型。</p>
<p>以下是本教程中讨论的简要摘要：</p>
<ul>
<li>如何导入和加载内置乳腺癌数据集<code>scikit-learn</code></li>
<li>如何打印包含的内置数据集的说明。<code>scikit-learn</code></li>
<li>如何使用如何将数据组拆分为训练数据和测试数据<code>scikit-learn</code></li>
<li>如何从模块导入模型<code>SVC``````scikit-learn``````svm</code></li>
<li>如何训练SVM模型</li>
<li>如何使用 Python 中的支持向量机模型进行预测</li>
<li>如何使用 和 函数测量支持向量机模型的性能<code>classification_report``````confusion_matrix</code></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-06-21T03:25:57.000Z" title="2020-06-21T03:25:57.000Z">2020-06-21</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.396Z" title="2020-09-08T14:03:00.396Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">22 分钟读完 (大约3246个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/21/Python%20%E4%B8%AD%E7%9A%84%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%9E%97/">Python 中的决策树和随机林</a></h1><div class="content"><p>随机林是一种机器学习分类算法，由众多决策树组成。</p>
<p>随机林中的每个决策树都包含对数据集要素的随机采样。此外，在构建每个树时，算法使用数据点的随机采样来训练模型。</p>
<p>在本教程中，您将学习如何在 Python 中构建第一个随机林。如果想在完成后了解有关机器学习的更多信息，本文包括真实数据集、完整代码库以及进一步说明。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>您可以使用下面的目录跳到此 Python 随机林教程的特定部分：</p>
<ul>
<li><a href="https://zshipu.com/t?url=#the-data-set-we-will-need-for-this-tutorial">本教程所需的数据集</a></li>
<li><a href="https://zshipu.com/t?url=#the-imports-we-will-need-for-this-tutorial">本教程所需的导入</a></li>
<li><a href="https://zshipu.com/t?url=#importing-the-data-set-into-our-python-script">将数据集导入到我们的 Python 脚本中</a></li>
<li><a href="https://zshipu.com/t?url=#exploratory-data-analysis">探索性数据分析</a><ul>
<li><a href="https://zshipu.com/t?url=#determining-the-size-of-the-data-set">确定数据集的大小</a></li>
<li><a href="https://zshipu.com/t?url=#visualizing-the-data">可视化数据</a></li>
</ul>
</li>
<li><a href="https://zshipu.com/t?url=#building-and-training-our-decision-tree-model">构建和培训我们的决策树模型</a></li>
<li><a href="https://zshipu.com/t?url=#making-predictions-using-our-decision-tree-model">使用我们的决策树模型进行预测</a></li>
<li><a href="https://zshipu.com/t?url=#measuring-the-performance-of-our-decision-tree-model">衡量我们决策树模型的性能</a></li>
<li><a href="https://zshipu.com/t?url=#building-and-training-our-random-forests-model">构建和培训我们的随机林模型</a></li>
<li><a href="https://zshipu.com/t?url=#making-predictions-using-our-random-forest-model">使用随机林模型进行预测</a></li>
<li><a href="https://zshipu.com/t?url=#measuring-the-performance-of-our-decision-tree-model-1">衡量我们决策树模型的性能</a></li>
<li><a href="https://zshipu.com/t?url=#the-full-code-for-this-tutorial">本教程的完整代码</a></li>
<li><a href="https://zshipu.com/t?url=#final-thoughts">最后的想法</a></li>
</ul>
<h2 id="本教程所需的数据集"><a href="#本教程所需的数据集" class="headerlink" title="本教程所需的数据集"></a>本教程所需的数据集</h2><p>在本教程中，我们将使用一组基福症患者，并构建一个随机林算法来预测患者是否患有这种疾病。</p>
<p>您需要下载数据集，然后才能继续。我已经上传了数据集到我的网站，使这很容易为你。只需<a href="https://zshipu.com/t?url=https://nickmccullum.com/files/kyphosis-data.csv">单击此处</a>即可下载文件。下载后，将文件移动到相应的目录，然后打开<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-course/jupyter-notebook-basics/">Jupyter 笔记本</a>。</p>
<h2 id="本教程所需的导入"><a href="#本教程所需的导入" class="headerlink" title="本教程所需的导入"></a>本教程所需的导入</h2><p>我们将依靠一些开源软件库来构建我们的随机森林模型，包括<a href="https://zshipu.com/t?url=https://nickmccullum.com/advanced-python/numpy/">NumPy，</a><a href="https://zshipu.com/t?url=https://nickmccullum.com/advanced-python/pandas/">熊猫</a>和<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-visualization/how-to-import-matplotlib/">matplotlib。</a>让我们首先导入具有以下代码的这些库：</p>
<p>  <code>#Numerical computing libraries<br>import pandas as pd</p>
<p>import numpy as np</p>
<p>#Visalization libraries<br>import matplotlib.pyplot as plt</p>
<p>import seaborn as sns</p>
<p>%matplotlib inline</code> </p>
<p>现在，我们的导入已执行，我们已准备好将数据集导入到 Python 脚本中。</p>
<h2 id="将数据集导入到我们的-Python-脚本中"><a href="#将数据集导入到我们的-Python-脚本中" class="headerlink" title="将数据集导入到我们的 Python 脚本中"></a>将数据集导入到我们的 Python 脚本中</h2><p>您可以使用熊猫的方法将 kyphosis 数据集导入到 Python 脚本中，如下所示：<code>read_csv</code></p>
<p>  <code>raw_data = pd.read_csv('kyphosis-data.csv')</code> </p>
<p>让我们来看看此数据集中包含的功能：</p>
<p>  <code>Raw_data.columns</code> </p>
<p>这将返回：</p>
<p>  <code>Index(['Kyphosis', 'Age', 'Number', 'Start'], dtype='object')</code> </p>
<p>此数据集表示以前患有基福症的一组患者，然后在背部手术后再次进行测试。</p>
<p>该列包含或取决于他们是否患有 kyphosis 的值，而该列包含患者的年龄（以月为月）。该列指示操作中涉及的椎骨数。该列描述操作的顶级椎骨。<code>Kyphosis``````present``````absent``````Age``````Number``````Start</code></p>
<p>现在我们已经导入了数据集，让我们继续执行一些探索性数据分析。</p>
<h2 id="探索性数据分析"><a href="#探索性数据分析" class="headerlink" title="探索性数据分析"></a>探索性数据分析</h2><p>探索性数据分析是在使用数据集构建机器学习模型之前了解有关数据集的更多知识的过程。它通常涉及计算聚合数据或构建可视化效果。</p>
<p>在构建和培训机器学习模型之前，让我们深入了解一些简短的探索性数据分析。</p>
<h3 id="确定数据集的大小"><a href="#确定数据集的大小" class="headerlink" title="确定数据集的大小"></a>确定数据集的大小</h3><p>机器学习工程师在构建模型之前应始终了解的一个特征是其数据集的大小。</p>
<p><code>pandas</code>使这很容易确定。只需调用<a href="https://zshipu.com/t?url=https://nickmccullum.com/advanced-python/pandas-dataframes/">熊猫数据帧</a>上的方法，如下所示：<code>info</code></p>
<p>  <code>raw_data.info()</code> </p>
<p>这将生成：</p>
<p>  <code>RangeIndex: 81 entries, 0 to 80</p>
<p>Data columns (total 4 columns):</p>
<p>Kyphosis    81 non-null object</p>
<p>Age         81 non-null int64</p>
<p>Number      81 non-null int64</p>
<p>Start       81 non-null int64</p>
<p>dtypes: int64(3), object(1)</p>
<p>memory usage: 2.7+ KB</code> </p>
<p>如您所见，此数据集中有 81 个观测值。这是一个相对较小的数据集，用于执行机器学习预测，但由于这只是一个教育教程，我们还是可以继续。</p>
<h3 id="可视化数据"><a href="#可视化数据" class="headerlink" title="可视化数据"></a>可视化数据</h3><p>由于数据集相当小，我们可以使用库轻松可视化每个功能发生的情况。<code>seaborn</code></p>
<p>下面是执行此操作的命令：</p>
<p>  <code>sns.pairplot(raw_data, hue = 'Kyphosis')</code> </p>
<p>下面是此命令生成的绘图：<code>seaborn</code></p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/random-forests/seaborn-pairplot.png" alt="A seaborn pairplot of our Kyphosis data set"></p>
<p>现在，我们已经了解数据集的结构，让我们将数据集划分为训练数据和测试数据。</p>
<p>将数据集拆分为训练数据和测试数据</p>
<p>我们将使用’的功能与列表解包相结合，以创建我们的训练数据和测试数据。具体来说，我们将使用 30% 的测试大小。<code>scikit-learn``````train_test_split</code></p>
<p>首先，让我们从 导入 函数：<code>train_test_split``````scikit-learn</code></p>
<p>  <code>from sklearn.model_selection import train_test_split</code> </p>
<p>接下来，我们需要指定数据集中的 和 数据。数据将是除列之外的所有数据，而数据本身将是列。<code>x``````y``````x``````Kyphosis``````y``````Kyphosis</code></p>
<p>下面是在数据集中创建此除法的 Python 语句：</p>
<p>  <code>x = raw_data.drop('Kyphosis', axis = 1)</p>
<p>y = raw_data[‘Kyphosis’]</code> </p>
<p>最后，下面是创建训练测试拆分的命令：</p>
<p>  <code>x_training_data, x_test_data, y_training_data, y_test_data = train_test_split(x, y, test_size = 0.3)</code> </p>
<p>我们成功地将数据集划分为训练数据和测试数据。</p>
<p>接下来，我们将通过构建并训练此数据的决策树算法来继续本教程。</p>
<p>稍后，我们还将在相同的训练数据和测试数据上构建一个随机林模型，并查看其结果与更基本的决策树模型的比较情况。</p>
<h2 id="构建和培训我们的决策树模型"><a href="#构建和培训我们的决策树模型" class="headerlink" title="构建和培训我们的决策树模型"></a>构建和培训我们的决策树模型</h2><p>我们需要做的第一件事是从 模块导入类。运行以下命令以执行此操作：<code>DecisionTreeClassifier``````tree``````scikit-learn</code></p>
<p>  <code>from sklearn.tree import DecisionTreeClassifier</code> </p>
<p>现在我们需要创建此类的实例并将其分配给变量：<code>model</code></p>
<p>  <code>model = DecisionTreeClassifier()</code> </p>
<p>我们的模型已经创建。现在我们需要使用我们的培训数据来训练它。</p>
<p>这样做的方式与本课程前面线性<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-machine-learning/linear-regression-python/">回归</a>、<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-machine-learning/logistic-regression-python/">逻辑回归</a>和<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-machine-learning/k-nearest-neighbors-python/">K 最近邻域</a>模型相同：通过使用 方法。<code>fit</code></p>
<p>调用对象上的方法并传递 和 ，如下所示：<code>fit``````model``````x_training_data``````y_training_data</code></p>
<p>  <code>model.fit(x_training_data, y_training_data)</code> </p>
<p>我们的基福西模型已经过培训。让我们使用此模型进行一些预测。</p>
<h2 id="使用我们的决策树模型进行预测"><a href="#使用我们的决策树模型进行预测" class="headerlink" title="使用我们的决策树模型进行预测"></a>使用我们的决策树模型进行预测</h2><p>要使用对象进行预测，只需调用它上的方法并传递变量即可。您可以将这些预测分配给名为 的变量。<code>model``````predict``````x_test_data``````predictions</code></p>
<p>更具体地说，下面是执行此操作的代码：</p>
<p>  <code>predictions = model.predict(x_test_data)</code> </p>
<p>现在，我们已经进行了预测，让我们使用一些内置功能来评估模型的准确性。<code>scikit-learn</code></p>
<h2 id="衡量我们决策树模型的性能"><a href="#衡量我们决策树模型的性能" class="headerlink" title="衡量我们决策树模型的性能"></a>衡量我们决策树模型的性能</h2><p>我们将使用’’的内置函数，并评估我们决策树机器学习模型的性能。<code>scikit-learn``````classification_report``````confusion_matrix</code></p>
<p>首先，让我们导入这些函数：</p>
<p>  <code>from sklearn.metrics import classification_report</p>
<p>from sklearn.metrics import confusion_matrix</code> </p>
<p>接下来，让我们生成一个 ：<code>classification_report</code></p>
<p>  <code>print(classification_report(y_test_data, predictions))</code> </p>
<p>这将生成：</p>
<p>  <code>precision    recall  f1-score   support</p>
<pre><code>  absent       0.85      0.89      0.87        19

 present       0.60      0.50      0.55         6

accuracy                           0.80        25</code></pre>
<p>   macro avg       0.72      0.70      0.71        25</p>
<p>weighted avg       0.79      0.80      0.79        25</code> </p>
<p>我们可以以类似的方式生成：<code>confusion_matrix</code></p>
<p>  <code>print(confusion_matrix(y_test_data, predictions))</code> </p>
<p>这将生成：</p>
<p>  <code>[[17  2]</p>
<p> [ 3  3]]</code> </p>
<p>总体而言，我们的模型似乎对测试数据进行预测方面做得相当不错。它只对 5 个数据点（2 个误报和 3 个假负数）进行不正确的预测，这一点如 所示。<code>confusion_matrix</code></p>
<p>在下一节中，我们将开始构建一个随机林模型，在本教程的后面部分，我们将将其性能与对象进行比较。<code>model</code></p>
<h2 id="构建和培训我们的随机林模型"><a href="#构建和培训我们的随机林模型" class="headerlink" title="构建和培训我们的随机林模型"></a>构建和培训我们的随机林模型</h2><p>要构建随机林模型，我们首先需要从 导入模型。下面是执行此操作的命令：<code>scikit-learn</code></p>
<p>  <code>from sklearn.ensemble import RandomForestClassifier</code> </p>
<p>接下来，我们需要创建随机林模型。</p>
<p>由于我们不想覆盖我们之前创建的变量，我们不会命名它。相反，让我们命名它：<code>model``````model``````random_forest_model</code></p>
<p>  <code>random_forest_model = RandomForestClassifier()</code> </p>
<p>请注意，类具有一个名为 的参数，该参数指定林中的树数。其默认值为 ，但如果需要，可以更改此值。我们将在本教程中使用 的默认值。<code>RandomForestClassifier``````n_estimators``````100``````100</code></p>
<p>注意训练随机林模型的时间。为此，我们使用 的方法，就像以前一样：<code>fit</code></p>
<p>  <code>random_forest_model.fit(x_training_data, y_training_data)</code> </p>
<p>我们的随机森林模型已经过训练。让我们继续用这个新的合奏模型做一些预测。</p>
<h2 id="使用随机林模型进行预测"><a href="#使用随机林模型进行预测" class="headerlink" title="使用随机林模型进行预测"></a>使用随机林模型进行预测</h2><p>让我们使用 方法使用对象计算一些预测，并将它们分配给名为 的变量：<code>predict``````random_forest_model``````random_forest_predictions</code></p>
<p>  <code>random_forest_predictions = random_forest_model.predict(x_test_data)</code> </p>
<p>接下来我们将评估这些预测的准确性。</p>
<h2 id="衡量我们决策树模型的性能-1"><a href="#衡量我们决策树模型的性能-1" class="headerlink" title="衡量我们决策树模型的性能"></a>衡量我们决策树模型的性能</h2><p>正如我们使用基本决策树模型时所做的那样，让我们生成 和 。<code>classification_report``````confusion_matrix</code></p>
<p>让我们从 开始：<code>classification_report</code></p>
<p>  <code>print(classification_report(y_test_data, random_forest_predictions))</code> </p>
<p>以下是此报告的输出：</p>
<p>  <code>precision    recall  f1-score   support</p>
<pre><code>  absent       0.82      0.95      0.88        19

 present       0.67      0.33      0.44         6

accuracy                           0.80        25</code></pre>
<p>   macro avg       0.74      0.64      0.66        25</p>
<p>weighted avg       0.78      0.80      0.77        25</code> </p>
<p>现在，让我们生成一个混淆矩阵：</p>
<p>  <code>print(confusion_matrix(y_test_data, random_forest_predictions))</code> </p>
<p>下面是此混淆矩阵的输出：</p>
<p>  <code>[[18  1]</p>
<p> [ 4  2]]</code> </p>
<p>在这种情况下，我们的随机林的表现没有明显优于我们的决策树模型。</p>
<p>这主要是因为我们的数据集很小。在几乎所有情况下，随机林的性能都会优于基本决策树，尤其是在您用于进行预测的数据集变得越来越大时。</p>
<h2 id="本教程的完整代码"><a href="#本教程的完整代码" class="headerlink" title="本教程的完整代码"></a>本教程的完整代码</h2><p>您可以在<a href="https://zshipu.com/t?url=https://github.com/nicholasmccullum/python-machine-learning">此 GitHub 存储库</a>中查看本教程的完整代码。下面还粘贴如下，供参考：</p>
<p>  <code>#Numerical computing libraries<br>import pandas as pd</p>
<p>import numpy as np</p>
<p>#Visalization libraries<br>import matplotlib.pyplot as plt</p>
<p>import seaborn as sns</p>
<p>%matplotlib inline</p>
<p>raw_data = pd.read_csv(‘kyphosis-data.csv’)</p>
<p>raw_data.columns</p>
<p>#Exploratory data analysis<br>raw_data.info()</p>
<p>sns.pairplot(raw_data, hue = ‘Kyphosis’)</p>
<p>#Split the data set into training data and test data<br>from sklearn.model_selection import train_test_split</p>
<p>x = raw_data.drop(‘Kyphosis’, axis = 1)</p>
<p>y = raw_data[‘Kyphosis’]</p>
<p>x_training_data, x_test_data, y_training_data, y_test_data = train_test_split(x, y, test_size = 0.3)</p>
<p>#Train the decision tree model<br>from sklearn.tree import DecisionTreeClassifier</p>
<p>model = DecisionTreeClassifier()</p>
<p>model.fit(x_training_data, y_training_data)</p>
<p>predictions = model.predict(x_test_data)</p>
<p>#Measure the performance of the decision tree model<br>from sklearn.metrics import classification_report</p>
<p>from sklearn.metrics import confusion_matrix</p>
<p>print(classification_report(y_test_data, predictions))</p>
<p>print(confusion_matrix(y_test_data, predictions))</p>
<p>#Train the random forests model<br>from sklearn.ensemble import RandomForestClassifier</p>
<p>random_forest_model = RandomForestClassifier()</p>
<p>random_forest_model.fit(x_training_data, y_training_data)</p>
<p>random_forest_predictions = random_forest_model.predict(x_test_data)</p>
<p>#Measure the performance of the random forest model<br>print(classification_report(y_test_data, random_forest_predictions))</p>
<p>print(confusion_matrix(y_test_data, random_forest_predictions))</code> </p>
<h2 id="最后的想法"><a href="#最后的想法" class="headerlink" title="最后的想法"></a>最后的想法</h2><p>在本教程中，您了解了如何在 Python 中构建决策树和随机林。</p>
<p>以下是您在本文中学到的内容的简要摘要：</p>
<ul>
<li>如何使用构建决策树模型<code>scikit-learn</code></li>
<li>如何使用随机林模型<code>scikit-learn</code></li>
<li>随机林通常比决策树更善于预测 ， 尤其是对于大型数据集</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-06-21T03:24:52.000Z" title="2020-06-21T03:24:52.000Z">2020-06-21</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.394Z" title="2020-09-08T14:03:00.394Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">22 分钟读完 (大约3324个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/21/Python%20%E4%B8%AD%E7%9A%84%20K%20%E6%9C%80%E8%BF%91%E9%82%BB%E5%B1%85%20-%20%E5%88%86%E6%AD%A5%E6%8C%87%E5%8D%97/">Python 中的 K 最近邻居 - 分步指南</a></h1><div class="content"><p>K 近邻算法是世界上最流行的机器学习模型之一，用于解决分类问题。</p>
<p>对于探索机器学习的学生来说，一个常见的练习是将 K 近邻算法应用于数据集，无论这些类别是否为不知道。如果需要使用机器学习对一组机密政府信息进行预测，那么这方面的一个真实示例就是。</p>
<p>在本教程中，您将学习在 Python 中编写第一个 K 近邻机器学习算法。我们将使用类似于上述情况的匿名数据集。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>您可以使用下面的目录跳到此 K 最接近邻居教程的特定部分：</p>
<ul>
<li><a href="https://zshipu.com/t?url=#the-data-set-you-will-need-in-this-tutorial">本教程中所需的数据集</a></li>
<li><a href="https://zshipu.com/t?url=#the-libraries-you-will-need-in-this-tutorial">本教程中所需的库</a></li>
<li><a href="https://zshipu.com/t?url=#importing-the-data-set-into-our-python-script">将数据集导入我们的 Python 脚本</a></li>
<li><a href="https://zshipu.com/t?url=#standardizing-the-data-set">标准化数据集</a></li>
<li><a href="https://zshipu.com/t?url=#splitting-the-data-set-into-training-data-and-test-data">将数据集拆分为训练数据和测试数据</a></li>
<li><a href="https://zshipu.com/t?url=#training-a-k-nearest-neighbors-model">训练 K 最近邻居模型</a></li>
<li><a href="https://zshipu.com/t?url=#making-predictions-with-our-k-nearest-neighbors-algorithm">使用我们的 K 近邻算法进行预测</a></li>
<li><a href="https://zshipu.com/t?url=#measuring-the-accuracy-of-our-model">测量我们模型的准确性</a></li>
<li><a href="https://zshipu.com/t?url=#choosing-an-optimal-k-value-using-the-elbow-method">使用弯头方法选择最佳<code>K</code>值</a></li>
<li><a href="https://zshipu.com/t?url=#the-full-code-for-this-tutorial">本教程的完整代码</a></li>
<li><a href="https://zshipu.com/t?url=#final-thoughts">最后的想法</a></li>
</ul>
<h2 id="本教程中所需的数据集"><a href="#本教程中所需的数据集" class="headerlink" title="本教程中所需的数据集"></a>本教程中所需的数据集</h2><p>您需要做的第一件事是下载我们将在本教程中使用的数据集。我已经上传文件到这个网站。您可以通过<a href="https://zshipu.com/t?url=https://nickmccullum.com/files/k-nearest-neighbors/classified_data.csv">单击此处访问</a>它。</p>
<p>下载数据集后，需要将文件移动到要处理的目录。之后，打开一个<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-course/jupyter-notebook-basics/">犹太笔记本</a>，我们可以开始编写Python代码！</p>
<h2 id="本教程中所需的库"><a href="#本教程中所需的库" class="headerlink" title="本教程中所需的库"></a>本教程中所需的库</h2><p>为了编写一个K近邻算法，我们将利用许多开源Python库，包括<a href="https://zshipu.com/t?url=https://nickmccullum.com/advanced-python/numpy/">NumPy，</a><a href="https://zshipu.com/t?url=https://nickmccullum.com/advanced-python/pandas-dataframes/">熊猫</a>，和<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-machine-learning/introduction-scikit-learn/">scikit-学习</a>。</p>
<p>通过编写以下导入语句来开始 Python 脚本：</p>
<p>  <code>import numpy as np</p>
<p>import pandas as pd</p>
<p>import matplotlib.pyplot as plt</p>
<p>import seaborn as sns</p>
<p>%matplotlib inline</code> </p>
<h2 id="将数据集导入我们的-Python-脚本"><a href="#将数据集导入我们的-Python-脚本" class="headerlink" title="将数据集导入我们的 Python 脚本"></a>将数据集导入我们的 Python 脚本</h2><p>我们的下一步是将文件导入到我们的 Python 脚本中。熊猫图书馆使<a href="https://zshipu.com/t?url=https://nickmccullum.com/advanced-python/pandas-data-input-output/">将数据导入熊猫数据框架</a>变得容易。<code>classified_data.csv</code></p>
<p>由于数据集存储在文件中，我们将使用 方法执行此操作：<code>csv``````read_csv</code></p>
<p>  <code>raw_data = pd.read_csv('classified_data.csv')</code> </p>
<p>在 Jupyter 笔记本中打印此 DataFrame 将让您了解数据的外观：</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/k-nearest-neighbors/pandas-dataframe.png" alt="A pandas DataFrame"></p>
<p>您会注意到，DataFrame 以一个未命名的列开头，该列的值等于 DataFrame 的索引。我们可以通过对将数据集导入到 Python 脚本的命令进行细微调整来解决此问题：</p>
<p>  <code>raw_data = pd.read_csv('classified_data.csv', index_col = 0)</code> </p>
<p>接下来，让我们看一下此数据集中包含的实际功能。您可以使用以下语句打印数据集的列名称列表：</p>
<p>  <code>print(raw_data.columns)</code> </p>
<p>这将返回：</p>
<p>  <code>Index(['WTT', 'PTI', 'EQW', 'SBI', 'LQE', 'QWG', 'FDJ', 'PJF', 'HQE', 'NXJ',</p>
<pre><code>   &#39;TARGET CLASS&#39;],

  dtype=&#39;object&#39;)&lt;/code&gt; </code></pre>
<p>由于这是一个分类数据集，我们不知道这些列中的任何一个意味着什么。就目前而言，它足以识别每个列都是数值的，因此非常适合使用机器学习技术进行建模。</p>
<h2 id="标准化数据集"><a href="#标准化数据集" class="headerlink" title="标准化数据集"></a>标准化数据集</h2><p>由于 K 最近的邻域算法通过使用最接近数据的观测值对数据点进行预测，因此数据集中要素的比例很重要。</p>
<p>因此，机器学习从业者通常采用数据集，这意味着调整每个值，使其大致处于相同的规模。<code>standardize``````x</code></p>
<p>幸运的是，包括一些优秀的功能，这样做很少头痛。<code>scikit-learn</code></p>
<p>首先，我们需要从 导入 类。向 Python 脚本添加以下命令以执行此操作：<code>StandardScaler``````scikit-learn</code></p>
<p>  <code>from sklearn.preprocessing import StandardScaler</code> </p>
<p>此函数的作用与本课程前面使用的 和 类类似。我们将要创建此类的实例，然后将该类的实例适合我们的数据集。<code>LinearRegression``````LogisticRegression</code></p>
<p>首先，让我们创建一个用以下语句命名的类的实例：<code>StandardScaler``````scaler</code></p>
<p>  <code>scaler = StandardScaler()</code> </p>
<p>现在，我们可以使用 方法在数据集上训练此实例：<code>fit</code></p>
<p>  <code>scaler.fit(raw_data.drop('TARGET CLASS', axis=1))</code> </p>
<p>现在，我们可以使用 该方法来标准化数据集中的所有要素，以便它们大致相同的比例。我们将这些缩放的要素分配给名为 ： 的变量：<code>transform``````scaled_featuers</code></p>
<p>  <code>scaled_features = scaler.transform(raw_data.drop('TARGET CLASS', axis=1))</code> </p>
<p>这实际上创建了一个<a href="https://zshipu.com/t?url=https://nickmccullum.com/advanced-python/numpy-arrays/">NumPy数组</a>的所有功能在数据集中，我们希望它是<a href="https://zshipu.com/t?url=https://nickmccullum.com/advanced-python/pandas-dataframes/">熊猫数据帧</a>。相反。</p>
<p>幸运的是，这是一个简单的解决方法。我们只需将变量包装在方法中，并将此 DataFrame 分配给一个使用适当参数调用的新变量来指定列名称：<code>scaled_features``````pd.DataFrame``````scaled_data</code></p>
<p>  <code>scaled_data = pd.DataFrame(scaled_features, columns = raw_data.drop('TARGET CLASS', axis=1).columns)</code> </p>
<p>现在，我们已经导入了数据集并标准化了数据集的功能，我们准备将数据集拆分为训练数据和测试数据。</p>
<h2 id="将数据集拆分为训练数据和测试数据"><a href="#将数据集拆分为训练数据和测试数据" class="headerlink" title="将数据集拆分为训练数据和测试数据"></a>将数据集拆分为训练数据和测试数据</h2><p>我们将使用与列表解包相结合的函数从机密数据集创建训练数据和测试数据。<code>train_test_split``````scikit-learn</code></p>
<p>首先，您需要从 以下语句的模块导入：<code>train_test_split``````model_validation``````scikit-learn</code></p>
<p>  <code>from sklearn.model_selection import train_test_split</code> </p>
<p>接下来，我们需要指定将传递到此函数的 和 值。<code>x``````y``````train_test_split</code></p>
<p>这些值将是我们以前创建的 DataFrame。这些值将是原始数据帧的列。<code>x``````scaled_data``````y``````TARGET CLASS``````raw_data</code></p>
<p>您可以使用以下语句创建这些变量：</p>
<p>  <code>x = scaled_data</p>
<p>y = raw_data[‘TARGET CLASS’]</code> </p>
<p>接下来，您需要使用这两个参数和一个合理的 运行函数。我们将使用 30% 的 参数，为函数提供以下参数：<code>train_test_split``````test_size``````test_size</code></p>
<p>  <code>x_training_data, x_test_data, y_training_data, y_test_data = train_test_split(x, y, test_size = 0.3)</code> </p>
<p>现在，我们的数据集已拆分为训练数据和测试数据，我们已准备好开始训练我们的模型！</p>
<h2 id="训练-K-最近邻居模型"><a href="#训练-K-最近邻居模型" class="headerlink" title="训练 K 最近邻居模型"></a>训练 K 最近邻居模型</h2><p>让我们从 导入 开始：<code>KNeighborsClassifier``````scikit-learn</code></p>
<p>  <code>from sklearn.neighbors import KNeighborsClassifier</code> </p>
<p>接下来，让我们创建类的实例并将其分配给名为<code>KNeighborsClassifier``````model</code></p>
<p>此类需要名为 的参数，该参数等于要构建的 K 最近邻域算法的值。首先，让我们指定 ：<code>n_neighbors``````K``````n_neighbors = 1</code></p>
<p>  <code>model = KNeighborsClassifier(n_neighbors = 1)</code> </p>
<p>现在，我们可以使用 该方法和我们的 和 变量训练我们的 K 最接近邻域模型：<code>fit``````x_training_data``````y_training_data</code></p>
<p>  <code>model.fit(x_training_data, y_training_data)</code> </p>
<p>现在，让我们用我们新训练的K近邻算法进行一些预测！</p>
<h2 id="使用我们的-K-近邻算法进行预测"><a href="#使用我们的-K-近邻算法进行预测" class="headerlink" title="使用我们的 K 近邻算法进行预测"></a>使用我们的 K 近邻算法进行预测</h2><p>我们可以用我们的K近邻算法进行预测，就像我们在本课程前面使用<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-machine-learning/linear-regression-python/">线性回归</a>和<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-machine-learning/logistic-regression-python/">逻辑回归</a>模型一样：通过使用该方法并传入我们的变量。<code>predict``````x_test_data</code></p>
<p>更具体地说，下面介绍如何进行预测并将其分配给一个变量，称为 ：<code>predictions</code></p>
<p>  <code>predictions = model.predict(x_test_data)</code> </p>
<p>让我们在本教程的下一节中探讨我们的准确程度。<code>predictions</code></p>
<h2 id="测量我们模型的准确性"><a href="#测量我们模型的准确性" class="headerlink" title="测量我们模型的准确性"></a>测量我们模型的准确性</h2><p>我们在逻辑回归教程中看到了内置功能，便于测量机器学习分类模型的性能。<code>scikit-learn</code></p>
<p>现在，让我们将其中两个函数 （ 和 ） 导入到我们的报告中：<code>classification_report``````confuson_matrix</code></p>
<p>  <code>from sklearn.metrics import classification_report</p>
<p>from sklearn.metrics import confusion_matrix</code> </p>
<p>让我们逐个完成这些工作，从 开始。您可以使用以下语句生成报表：<code>classfication_report</code></p>
<p>  <code>print(classification_report(y_test_data, predictions))</code> </p>
<p>这将生成：</p>
<p>  <code>precision    recall  f1-score   support</p>
<pre><code>       0       0.94      0.85      0.89       150

       1       0.86      0.95      0.90       150

accuracy                           0.90       300</code></pre>
<p>   macro avg       0.90      0.90      0.90       300</p>
<p>weighted avg       0.90      0.90      0.90       300</code> </p>
<p>同样，您可以使用以下语句生成混淆矩阵：</p>
<p>  <code>print(confusion_matrix(y_test_data, predictions))</code> </p>
<p>这将生成：</p>
<p>  <code>[[141  12]</p>
<p> [ 18 129]]</code> </p>
<p>查看这些性能指标，我们的模型看起来已经相当高性能。它仍然可以改进。</p>
<p>在下一节中，我们将了解如何通过为 选择更好的值来提高 K 最接近邻域模型的性能。<code>K</code></p>
<h2 id="使用弯头方法选择最佳值K"><a href="#使用弯头方法选择最佳值K" class="headerlink" title="使用弯头方法选择最佳值K"></a>使用弯头方法选择最佳值<code>K</code></h2><p>在本节中，我们将使用弯头方法为 K 最近的邻域算法选择 的优值。<code>K</code></p>
<p>弯头方法涉及遍历不同的 K 值，并在应用于测试数据时选择误差率最低的值。</p>
<p>首先，让我们创建一个名为 的空<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-course/lists/">列表</a>。我们将循环遍历不同的值，并将其错误率追加到此列表中。<code>error_rates``````K</code></p>
<p>  <code>error_rates = []</code> </p>
<p>接下来，我们需要创建一个 Python 循环，循环遍历我们想要在每次迭代中测试和执行以下功能的不同值：<code>K</code></p>
<ul>
<li>从<code>KNeighborsClassifier``````scikit-learn</code></li>
<li>使用我们的培训数据训练新模型</li>
<li>对我们的测试数据进行预测</li>
<li>计算每个错误预测的平均值差（这个预测越低，我们的模型越准确）</li>
</ul>
<p>下面是对 和 之间的值执行此操作的代码：<code>K``````1``````100</code></p>
<p>  <code>for i in np.arange(1, 101):</p>
<pre><code>new_model = KNeighborsClassifier(n_neighbors = i)

new_model.fit(x_training_data, y_training_data)

new_predictions = new_model.predict(x_test_data)

error_rates.append(np.mean(new_predictions != y_test_data))&lt;/code&gt; </code></pre>
<p>让我们使用快速 matplotlib 可视化来可视化错误率如何以不同值变化：<code>K</code></p>
<p>  <code>plt.plot(error_rates)</code> </p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/k-nearest-neighbors/error-rates.png" alt="A plot of our error rates"></p>
<p>如您所见，我们的错误率往往最小化，值约为 50。这意味着，这是一个合适的选择，在简单性和预测能力之间取得平衡。<code>K``````50``````K</code></p>
<h2 id="本教程的完整代码"><a href="#本教程的完整代码" class="headerlink" title="本教程的完整代码"></a>本教程的完整代码</h2><p>您可以在<a href="https://zshipu.com/t?url=https://github.com/nicholasmccullum/python-machine-learning">此 GitHub 存储库</a>中查看本教程的完整代码。下面还粘贴如下，供参考：</p>
<p>  <code>#Common imports<br>import numpy as np</p>
<p>import pandas as pd</p>
<p>import matplotlib.pyplot as plt</p>
<p>import seaborn as sns</p>
<p>%matplotlib inline</p>
<p>#Import the data set<br>raw_data = pd.read_csv(‘classified_data.csv’, index_col = 0)</p>
<p>#Import standardization functions from scikit-learn<br>from sklearn.preprocessing import StandardScaler</p>
<p>#Standardize the data set<br>scaler = StandardScaler()</p>
<p>scaler.fit(raw_data.drop(‘TARGET CLASS’, axis=1))</p>
<p>scaled_features = scaler.transform(raw_data.drop(‘TARGET CLASS’, axis=1))</p>
<p>scaled_data = pd.DataFrame(scaled_features, columns = raw_data.drop(‘TARGET CLASS’, axis=1).columns)</p>
<p>#Split the data set into training data and test data<br>from sklearn.model_selection import train_test_split</p>
<p>x = scaled_data</p>
<p>y = raw_data[‘TARGET CLASS’]</p>
<p>x_training_data, x_test_data, y_training_data, y_test_data = train_test_split(x, y, test_size = 0.3)</p>
<p>#Train the model and make predictions<br>from sklearn.neighbors import KNeighborsClassifier</p>
<p>model = KNeighborsClassifier(n_neighbors = 1)</p>
<p>model.fit(x_training_data, y_training_data)</p>
<p>predictions = model.predict(x_test_data)</p>
<p>#Performance measurement<br>from sklearn.metrics import classification_report</p>
<p>from sklearn.metrics import confusion_matrix</p>
<p>print(classification_report(y_test_data, predictions))</p>
<p>print(confusion_matrix(y_test_data, predictions))</p>
<p>#Selecting an optimal K value<br>error_rates = []</p>
<p>for i in np.arange(1, 101):</p>
<pre><code>new_model = KNeighborsClassifier(n_neighbors = i)

new_model.fit(x_training_data, y_training_data)

new_predictions = new_model.predict(x_test_data)

error_rates.append(np.mean(new_predictions != y_test_data))</code></pre>
<p>plt.figure(figsize=(16,12))</p>
<p>plt.plot(error_rates)</code> </p>
<h2 id="最后的想法"><a href="#最后的想法" class="headerlink" title="最后的想法"></a>最后的想法</h2><p>在本教程中，您学习了如何在 Python 中构建第一个 K 最接近邻居的机器学习模型。</p>
<p>以下是您在本教程中学到的内容的简要摘要：</p>
<ul>
<li>分类数据如何是一种常见的工具，用于教学生如何解决他们的第一个K近邻问题</li>
<li>为什么在构建 K 近邻模型时标准化数据集很重要</li>
<li>如何使用 函数将数据组拆分为训练数据和测试数据<code>train_test_split</code></li>
<li>如何训练你的第一个K最近的邻居模型，并与它作出预测</li>
<li>如何测量 K 近邻模型的性能</li>
<li>如何使用弯头方法在 K 最近邻域模型中选择 K 的最佳值</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-06-21T03:23:42.000Z" title="2020-06-21T03:23:42.000Z">2020-06-21</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.398Z" title="2020-09-08T14:03:00.398Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">39 分钟读完 (大约5861个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/21/Python%20%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%20-%20%E5%88%86%E6%AD%A5%E6%8C%87%E5%8D%97/">Python 中的逻辑回归 - 分步指南</a></h1><div class="content"><p>在上一篇文章中，我们了解了逻辑回归的理论基础，以及如何使用它来解决机器学习分类问题。</p>
<p>本教程将教您如何在 Python 中构建逻辑回归模型，从而教您有关逻辑回归机器学习技术的更多信息。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>您可以使用下面的目录跳到此 Python 逻辑回归教程的特定部分：</p>
<ul>
<li><a href="https://zshipu.com/t?url=#the-data-set-we-will-be-using-in-this-tutorial">我们将在本教程中使用数据集</a></li>
<li><a href="https://zshipu.com/t?url=#the-imports-we-will-be-using-in-this-tutorial">我们将在本教程中使用导入</a></li>
<li><a href="https://zshipu.com/t?url=#importing-the-data-set-into-our-python-script">将数据集导入到我们的 Python 脚本中</a></li>
<li><a href="https://zshipu.com/t?url=#learning-about-our-data-set-with-exploratory-data-analysis">通过探索性数据分析了解我们的数据集</a><ul>
<li><a href="https://zshipu.com/t?url=#the-prevalence-of-each-classification-category">每个分类类别的流行程度</a></li>
<li><a href="https://zshipu.com/t?url=#survival-rates-between-genders">性别之间的生存率</a></li>
<li><a href="https://zshipu.com/t?url=#survival-rates-between-passenger-classes">乘客舱位之间的生存率</a></li>
<li><a href="https://zshipu.com/t?url=#the-age-distribution-of-titanic-passengers">泰坦尼克号乘客的年龄分布</a></li>
<li><a href="https://zshipu.com/t?url=#the-ticket-price-distribution-of-titanic-passengers">泰坦尼克号乘客的票价分配</a></li>
</ul>
</li>
<li><a href="https://zshipu.com/t?url=#removing-null-data-from-our-data-set">从我们的数据集中删除空数据</a></li>
<li><a href="https://zshipu.com/t?url=#building-a-logistic-regression-model">构建逻辑回归模型</a></li>
<li><a href="https://zshipu.com/t?url=#removing-columns-with-too-much-missing-data">删除缺少过多数据的列</a></li>
<li><a href="https://zshipu.com/t?url=#handling-categorical-data-with-dummy-variables">使用虚拟变量处理分类数据</a></li>
<li><a href="https://zshipu.com/t?url=#adding-dummy-variables-to-the-pandas-dataframe">向<code>熊猫</code>数据帧添加虚拟变量</a></li>
<li><a href="https://zshipu.com/t?url=#removing-unnecessary-columns-from-the-data-set">从数据集中删除不必要的列</a></li>
<li><a href="https://zshipu.com/t?url=#creating-training-data-and-test-data">创建训练数据和测试数据</a></li>
<li><a href="https://zshipu.com/t?url=#training-the-logistic-regression-model">训练逻辑回归模型</a></li>
<li><a href="https://zshipu.com/t?url=#making-predictions-with-our-logistic-regression-model">使用我们的逻辑回归模型进行预测</a></li>
<li><a href="https://zshipu.com/t?url=#measuring-the-performance-of-a-logistic-regression-machine-learning-model">衡量逻辑回归机器学习模型的性能</a></li>
<li><a href="https://zshipu.com/t?url=#the-full-code-for-this-tutorial">本教程的完整代码</a></li>
<li><a href="https://zshipu.com/t?url=#final-thoughts">最后的想法</a></li>
</ul>
<h2 id="我们将在本教程中使用数据集"><a href="#我们将在本教程中使用数据集" class="headerlink" title="我们将在本教程中使用数据集"></a>我们将在本教程中使用数据集</h2><p>泰坦尼克号数据集是一个非常著名的数据集，包含泰坦尼克号上乘客的特征。它通常用作逻辑回归问题的介绍性数据集。</p>
<p>在本教程中，我们将使用泰坦尼克号数据集与 Python 逻辑回归模型相结合，以预测乘客是否在泰坦尼克号失事中幸存下来。</p>
<p><a href="https://zshipu.com/t?url=https://www.kaggle.com/c/titanic">原始的泰坦尼克号数据集</a>在Kaggle.com上公开提供，这是一个托管数据集和数据科学竞赛的网站。</p>
<p>为了让您在本课程中轻松学习，我们将使用半清洁版本的泰坦尼克号数据集，这将节省您在数据清理和操作方面的时间。</p>
<p>清理过的泰坦尼克号数据集实际上已经可供你使用。您可以通过单击以下链接下载数据文件：</p>
<ul>
<li><a href="https://zshipu.com/t?url=https://nickmccullum.com/files/logistic-regression/titanic_train.csv">泰坦尼克号数据</a></li>
</ul>
<p>下载此文件后，在同一工作目录中打开<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-course/jupyter-notebook-basics/">Jupyter 笔记本</a>，我们可以开始构建<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-machine-learning/introduction-logistic-regression/">逻辑回归模型。</a></p>
<h2 id="我们将在本教程中使用导入"><a href="#我们将在本教程中使用导入" class="headerlink" title="我们将在本教程中使用导入"></a>我们将在本教程中使用导入</h2><p>与之前一样，我们将在本教程中使用多个开源软件库。以下是在通过 Python 逻辑回归模型编写代码时需要运行的导入：</p>
<p>  <code>import pandas as pd</p>
<p>import numpy as np</p>
<p>import matplotlib.pyplot as plt</p>
<p>%matplotlib inline</p>
<p>import seaborn as sns</code> </p>
<p>接下来，我们需要将泰坦尼克号数据集导入到 Python 脚本中。</p>
<h2 id="将数据集导入到我们的-Python-脚本中"><a href="#将数据集导入到我们的-Python-脚本中" class="headerlink" title="将数据集导入到我们的 Python 脚本中"></a>将数据集导入到我们的 Python 脚本中</h2><p>我们将使用熊猫的方法将我们的文件导入<a href="https://zshipu.com/t?url=https://nickmccullum.com/advanced-python/pandas-dataframes/">到熊猫数据帧</a>中。<code>read_csv``````csv``````titanic_data</code></p>
<p>下面是执行此操作的代码：</p>
<p>  <code>titanic_data = pd.read_csv('titanic_train.csv')</code> </p>
<p>接下来，让我们调查泰坦尼克号数据集中实际包含的数据。有两种主要方法可以执行此操作（具体使用数据帧）：<code>titanic_data</code></p>
<ul>
<li>该方法将打印 DataFrame 的前 5 行。你可以用任何你想的号码来代替。<code>titanic_data.head(5)``````5</code></li>
<li>您还可以打印 ，这将显示名为的列。<code>titanic_data.columns</code></li>
</ul>
<p>运行第二个命令 （） 生成以下输出：<code>titanic_data.columns</code></p>
<p>  <code>Index(['PassengerId', 'Survived', 'Pclass', 'Name', 'Sex', 'Age', 'SibSp',</p>
<pre><code>   &#39;Parch&#39;, &#39;Ticket&#39;, &#39;Fare&#39;, &#39;Cabin&#39;, &#39;Embarked&#39;],

  dtype=&#39;object&#39;&lt;/code&gt; </code></pre>
<p>这些是数据框架中列的名称。以下是每个数据点的简要说明：</p>
<ul>
<li><code>PassengerId</code>：泰坦尼克号上每位乘客的数字标识符。</li>
<li><code>Survived</code>：一个二进制标识符，指示乘客是否在泰坦尼克号失事中幸存下来。此变量将保存的值，如果他们存活下来，如果他们没有生存。<code>1``````0</code></li>
<li><code>Pclass</code>：乘客的舱位。这可以容纳 值 ， 或 ， 取决于乘客在船舶中的位置。<code>1``````2``````3</code></li>
<li><code>Name</code>：乘客的名字。</li>
<li><code>Sex</code>：男性或女性。</li>
<li><code>Age</code>：乘客的年龄（以年数表示）。</li>
<li><code>SibSp</code>：船上兄弟姐妹和配偶人数。</li>
<li><code>Parch</code>：船上的父母和孩子的数量。</li>
<li><code>Ticket</code>：乘客的票号。</li>
<li><code>Fare</code>：乘客在泰坦尼克号上买票花了多少钱。</li>
</ul>
<p>接下来，我们将使用一些基本的探索性数据分析技术，详细了解我们的数据集。</p>
<h2 id="通过探索性数据分析了解我们的数据集"><a href="#通过探索性数据分析了解我们的数据集" class="headerlink" title="通过探索性数据分析了解我们的数据集"></a>通过探索性数据分析了解我们的数据集</h2><h3 id="每个分类类别的流行程度"><a href="#每个分类类别的流行程度" class="headerlink" title="每个分类类别的流行程度"></a>每个分类类别的流行程度</h3><p>当使用机器学习技术对分类问题进行建模时，最好了解类别之间的比率。对于这个具体问题，了解我们的培训数据中有多少幸存者与非幸存者是很有用的。</p>
<p>可视化的一种简单方法是使用绘图。在此示例中，您可以使用以下 Python 代码创建相应的绘图：<code>seaborn``````countplot``````seasborn</code></p>
<p>  <code>sns.countplot(x='Survived', data=titanic_data)</code> </p>
<p>这将生成以下绘图：</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/logistic-regression/seaborn-countplot.png" alt="A seaborn countplot"></p>
<p>正如你们所看到的，非幸存者的发生率比幸存者多得多。</p>
<h3 id="性别之间的生存率"><a href="#性别之间的生存率" class="headerlink" title="性别之间的生存率"></a>性别之间的生存率</h3><p>比较与其他数据功能相关的存活率也很有用。例如，我们可以比较使用以下 Python 代码的值之间的生存率：<code>Male``````Female``````Sex</code></p>
<p>  <code>sns.countplot(x='Survived', hue='Sex', data=titanic_data)</code> </p>
<p>这将生成以下绘图：</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/logistic-regression/seaborn-countplot-hue-sex.png" alt="A seaborn countplot with a Sex hue"></p>
<p>正如您所看到的，有一个乘客更有可能是非幸存者比乘客与.<code>Sex``````Male``````Sex``````Female</code></p>
<h3 id="乘客舱位之间的生存率"><a href="#乘客舱位之间的生存率" class="headerlink" title="乘客舱位之间的生存率"></a>乘客舱位之间的生存率</h3><p>我们可以使用变量执行类似的分析，看看哪些乘客级别是最有可能（也是最少）的乘客是幸存者。<code>Pclass</code></p>
<p>下面是执行此操作的代码：</p>
<p>  <code>sns.countplot(x='Survived', hue='Pclass', data=titanic_data)</code> </p>
<p>这将生成以下绘图：</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/logistic-regression/seaborn-countplot-hue-pclass.png" alt="A seaborn countplot with a Pclass hue"></p>
<p>从这个阴谋中最引人注目的观察是，在泰坦尼克号坠毁时，价值为三等舱的乘客更有可能死亡。因为第三类飞机是最便宜的，最不豪华的。<code>Pclass``````3</code></p>
<h3 id="泰坦尼克号乘客的年龄分布"><a href="#泰坦尼克号乘客的年龄分布" class="headerlink" title="泰坦尼克号乘客的年龄分布"></a>泰坦尼克号乘客的年龄分布</h3><p>我们可以进行的另一个有用的分析是调查泰坦尼克号乘客的年龄分布。<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-visualization/histogram/">直方图</a>是一个很好的工具。</p>
<p>您可以使用以下代码生成变量的直方图：<code>Age</code></p>
<p>  <code>plt.hist(titanic_data['Age'].dropna())</code> </p>
<p>请注意，该方法是必要的，因为<code>dropna()</code></p>
<p>下面是此代码生成的直方图：</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/logistic-regression/age-histogram.png" alt="A histogram of age variables from the titanic data set"></p>
<p>正如您所看到的，泰坦尼克号乘客的集中值介于 和 之间。<code>Age``````20``````40</code></p>
<h3 id="泰坦尼克号乘客的票价分配"><a href="#泰坦尼克号乘客的票价分配" class="headerlink" title="泰坦尼克号乘客的票价分配"></a>泰坦尼克号乘客的票价分配</h3><p>我们将使用的最后一种探索性数据分析技术是调查泰坦尼克号数据集中票价的分布情况。</p>
<p>您可以使用以下代码执行此操作：</p>
<p>  <code>plt.hist(titanic_data['Fare'])</code> </p>
<p>这将生成以下绘图：</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/logistic-regression/fare-histogram.png" alt="A histogram of fare variables from the titanic data set"></p>
<p>正如您所看到的，泰坦尼克号数据集中有三个不同的价格组。这是有道理的，因为变量还有三个唯一值。差异组对应于不同的类别。<code>Fare``````Pclass``````Fare``````Pclass</code></p>
<p>由于泰坦尼克号数据集是一个真实世界的数据集，它包含一些丢失的数据。我们将在下一节中<a href="https://zshipu.com/t?url=https://nickmccullum.com/advanced-python/missing-data-pandas/">学习如何处理缺失的数据</a>。</p>
<h2 id="从我们的数据集中删除空数据"><a href="#从我们的数据集中删除空数据" class="headerlink" title="从我们的数据集中删除空数据"></a>从我们的数据集中删除空数据</h2><p>首先，让我们检查数据集包含缺失数据的位置。为此，运行以下命令：</p>
<p>  <code>titanic_data.isnull()</code> </p>
<p>这将生成布尔值的 DataFrame，如果单元格为空值，则单元格包含该值。下面是一个图像，如下所示：<code>True``````False</code></p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/logistic-regression/missing-values-dataframe.png" alt="A DataFrame of boolean values indicating where null data exists"></p>
<p>评估此数据集中缺少的数据的一个更有用的方法是创建快速可视化。为此，我们可以使用可视化库。下面是可用于使用库创建 的快速命令：<code>seaborn``````heatmap``````seaborn</code></p>
<p>  <code>sns.heatmap(titanic_data.isnull(), cbar=False)</code> </p>
<p>下面是生成的可视化效果：</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/logistic-regression/missing-values-heatmap.png" alt="A DataFrame of boolean values indicating where null data exists"></p>
<p>在此可视化中，白线表示数据集中缺少的值。您可以看到 和 列包含泰坦尼克号数据集中的大部分缺失数据。<code>Age``````Cabin</code></p>
<p>该列特别包含足够少的缺失量，以便我们可以使用某种形式的数学来填充缺失的数据。另一方面，数据缺少足够的数据，我们可能完全将其从模型中删除。<code>Age``````Cabin</code></p>
<p>使用数据集的其余部分的平均数据填充缺失数据的过程称为 。现在，我们将使用 来填充列中缺少的数据。<code>imputation``````imputation``````Age</code></p>
<p>最基本的形式是用整个数据集的平均值填充缺失的数据。但是，有更好的方法。<code>imputation``````Age``````Age</code></p>
<p>我们将用乘客所属的特定乘客舱的平均值填充缺失值。要了解此功能为什么有用，请考虑以下框图：<code>Age``````Age``````Pclass</code></p>
<p>  <code>sns.boxplot(titanic_data['Pclass'], titanic_data['Age'])</code> </p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/logistic-regression/age-boxplot.png" alt="A boxplot of age values stratified by passenger classes"></p>
<p>正如您所看到的，价值（最昂贵的乘客舱）的乘客往往是最年长的，而价值（最便宜的）的乘客往往是最年轻的。这是非常合乎逻辑的，所以我们将使用不同数据中的平均值到列中缺少的数据。<code>Pclass``````1``````Pclass``````3``````Age``````Pclass``````imputate``````Age</code></p>
<p>对像泰坦尼克号数据集这样的数据集执行最简单的方法是构建自定义函数。首先，我们需要确定每个值的平均值。<code>imputation``````Age``````Pclass</code></p>
<p>  <code>#Pclass value 1<br>titanic_data[titanic_data['Pclass'] == 1]['Age'].mean()</p>
<p>#Pclass value 2<br>titanic_data[titanic_data[‘Pclass’] == 2][‘Age’].mean()</p>
<p>#Pclass 3<br>titanic_data[titanic_data[‘Pclass’] == 2][‘Age’].mean()</code> </p>
<p>下面是我们将用于缺少变量的最终函数：<code>imputate``````Age</code></p>
<p>  <code>def impute_missing_age(columns):</p>
<pre><code>age = columns[0]

passenger_class = columns[1]

if pd.isnull(age):

    if(passenger_class == 1):

        return titanic_data[titanic_data[&#39;Pclass&#39;] == 1][&#39;Age&#39;].mean()

    elif(passenger_class == 2):

        return titanic_data[titanic_data[&#39;Pclass&#39;] == 2][&#39;Age&#39;].mean()

    elif(passenger_class == 3):

        return titanic_data[titanic_data[&#39;Pclass&#39;] == 3][&#39;Age&#39;].mean()

else:

    return age&lt;/code&gt; </code></pre>
<p>现在，此归给函数已完成，我们需要将其应用于 DataFrame 中的每一行。Python 的方法是一个很好的工具：<code>titanic_data``````apply</code></p>
<p>  <code>titanic_data['Age'] = titanic_data[['Age', 'Pclass']].apply(impute_missing_age, axis = 1)</code> </p>
<p>现在，我们已经对每行执行了处理丢失数据，让我们来调查一下我们的原始框图：<code>imputation``````Age</code></p>
<p>  <code>sns.heatmap(titanic_data.isnull(), cbar=False)</code> </p>
<p>正如您所看到的，我们的熊猫数据框架的列中不再有任何缺失的数据！<code>Age</code></p>
<p>您可能想知道为什么我们花了这么多时间专门处理列中缺少的数据。这是因为鉴于对大多数灾害和疾病生存的影响，它是一个变量，在我们的数据集中可能具有较高的预测价值。<code>Age``````Age</code></p>
<p>现在，我们已经了解了此数据集的结构并删除了缺少的数据，让我们开始构建逻辑回归机器学习模型。</p>
<h2 id="构建逻辑回归模型"><a href="#构建逻辑回归模型" class="headerlink" title="构建逻辑回归模型"></a>构建逻辑回归模型</h2><p>现在是删除逻辑回归模型的时候了。</p>
<h3 id="删除缺少过多数据的列"><a href="#删除缺少过多数据的列" class="headerlink" title="删除缺少过多数据的列"></a>删除缺少过多数据的列</h3><p>首先，让我们删除该列。正如我们提到的，此列中缺失数据的高流行率意味着缺少的数据是不明智的，因此我们将使用以下代码完全删除它：<code>Cabin``````impute</code></p>
<p>  <code>titanic_data.drop('Cabin', axis=1, inplace = True)</code> </p>
<p>接下来，让我们删除包含熊猫方法缺少数据的任何其他列：<code>dropna()</code></p>
<p>  <code>titanic_data.dropna(inplace = True)</code> </p>
<h3 id="使用虚拟变量处理分类数据"><a href="#使用虚拟变量处理分类数据" class="headerlink" title="使用虚拟变量处理分类数据"></a>使用虚拟变量处理分类数据</h3><p>我们需要处理的下一个任务是处理分类功能。也就是说，我们需要找到一种方法，在数值上处理非自然数值的观测值。</p>
<p>这方面的一个很好的例子是列，它有两个值： 和 。同样，该列包含一个字母，指示乘客离开哪个城市。<code>Sex``````Male``````Female``````Embarked</code></p>
<p>为了解决这个问题，我们将创建 。这些为非数字要素的每个类别分配一个数值。<code>dummy variables</code></p>
<p>幸运的是，有一个内置的方法，它可以很容易地创建虚拟变量。该方法确实存在一个问题 - 它将为 DataFrame 列中的每个值创建一个新列。<code>pandas``````get_dummies()``````get_dummies</code></p>
<p>让我们考虑一个示例来帮助更好地理解这一点。如果我们在列上调用 方法，我们会得到以下输出：<code>get_dummies()``````Age</code></p>
<p>  <code>pd.get_dummies(titanic_data['Sex'])</code> </p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/logistic-regression/get-dummies.png" alt="An example of the pandas get_dummies method"></p>
<p>正如您所看到的，这将创建两个新列： 和 。这些列都是彼此的完美预测变量，因为列中的值表示列中的值，反之亦然。<code>female``````male``````0``````female``````1``````male</code></p>
<p>这称为，它显著降低了算法的预测能力。要删除此参数，我们可以将 参数添加到如下所示的方法：<code>multicollinearity``````drop_first = True``````get_dummies</code></p>
<p>  <code>pd.get_dummies(titanic_data['Sex'], drop_first = True)</code> </p>
<p>现在，让我们为和列创建虚拟变量列，并将它们分配给调用 和 的变量。<code>Sex``````Embarked``````sex``````embarked</code></p>
<p>  <code>sex_data = pd.get_dummies(titanic_data['Sex'], drop_first = True)</p>
<p>embarked_data = pd.get_dummies(titanic_data[‘Embarked’], drop_first = True)</code> </p>
<p>关于下面定义的变量，有一件重要的事情需要注意。它有两个列：和，但由于我们已经删除了另一列（列），其余两列都不是彼此的完美预测变量，因此在新的修改后的数据集中不存在。<code>embarked``````Q``````S``````C``````multicollinearity</code></p>
<h3 id="将虚拟变量添加到数据帧pandas"><a href="#将虚拟变量添加到数据帧pandas" class="headerlink" title="将虚拟变量添加到数据帧pandas"></a>将虚拟变量添加到数据帧<code>pandas</code></h3><p>接下来，我们需要将我们的和列添加到 DataFrame 中。<code>sex``````embarked</code></p>
<p>您可以使用以下代码将这些数据列<a href="https://zshipu.com/t?url=https://nickmccullum.com/advanced-python/how-to-concatenate-pandas-dataframes-practice-problems/">串联</a>到现有 DataFrame 中：<code>pandas</code></p>
<p>  <code>titanic_data = pd.concat([titanic_data, sex_data, embarked_data], axis = 1)</code> </p>
<p>现在，如果您运行该命令，您的 Jupyter 笔记本将生成以下输出：<code>print(titanic_data.columns)</code></p>
<p>  <code>Index(['PassengerId', 'Survived', 'Pclass', 'Name', 'Sex', 'Age', 'SibSp',</p>
<pre><code>   &#39;Parch&#39;, &#39;Ticket&#39;, &#39;Fare&#39;, &#39;Embarked&#39;, &#39;male&#39;, &#39;Q&#39;, &#39;S&#39;],

  dtype=&#39;object&#39;)&lt;/code&gt; </code></pre>
<p>和 列的存在表明我们的数据已成功串联。<code>male``````Q``````S</code></p>
<h2 id="从数据集中删除不必要的列"><a href="#从数据集中删除不必要的列" class="headerlink" title="从数据集中删除不必要的列"></a>从数据集中删除不必要的列</h2><p>这意味着我们现在可以从 DataFrame 中删除原始和列。还有其他列（如，，）不预测泰坦尼克号的坠机存活率，所以我们也将删除这些。以下代码为我们处理此问题：<code>Sex``````Embarked``````Name``````PassengerId``````Ticket</code></p>
<p>  <code>titanic_data.drop(['Name', 'Ticket', 'Sex', 'Embarked'], axis = 1, inplace = True)</code> </p>
<p>如果现在打印，您的犹太笔记本将生成以下输出：<code>titanic_data.columns</code></p>
<p>  <code>Index(['Survived', 'Pclass', 'Age', 'SibSp', 'Parch', 'Fare',</p>
<pre><code>   &#39;male&#39;, &#39;Q&#39;, &#39;S&#39;],

  dtype=&#39;object&#39;&lt;/code&gt; </code></pre>
<p>DataFrame 现在具有以下外观：</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/logistic-regression/final-data-frame.png" alt="The final DataFrame for our logistic regression model"></p>
<p>正如您所看到的，此数据集中的每个字段现在都是数字字段，这使得它成为逻辑回归机器学习算法的优秀候选项。</p>
<h2 id="创建训练数据和测试数据"><a href="#创建训练数据和测试数据" class="headerlink" title="创建训练数据和测试数据"></a>创建训练数据和测试数据</h2><p>接下来，是时候将我们拆分为训练数据和测试数据了。与以前一样，我们将使用内置功能来执行此操作。<code>titatnic_data``````scikit-learn</code></p>
<p>首先，我们需要将数据划分为值（我们将用于预测的数据）和值（我们试图预测的数据）。以下代码处理此问题：<code>x``````y</code></p>
<p>  <code>y_data = titanic_data['Survived']</p>
<p>x_data = titanic_data.drop(‘Survived’, axis = 1)</code> </p>
<p>接下来，我们需要从 导入 函数。以下代码执行此导入：<code>train_test_split``````scikit-learn</code></p>
<p>  <code>from sklearn.model_selection import train_test_split</code> </p>
<p>最后，我们可以使用该函数与列表解包相结合来生成我们的训练数据和测试数据：<code>train_test_split</code></p>
<p>  <code>x_training_data, x_test_data, y_training_data, y_test_data = train_test_split(x_data, y_data, test_size = 0.3)</code> </p>
<p>请注意，在这种情况下，测试数据是参数指定的原始数据集的 30%。<code>test_size = 0.3</code></p>
<p>现在，我们已经为我们的逻辑回归模型创建了我们的培训数据和测试数据。我们将在本教程的下一节中训练我们的模型。</p>
<h2 id="训练逻辑回归模型"><a href="#训练逻辑回归模型" class="headerlink" title="训练逻辑回归模型"></a>训练逻辑回归模型</h2><p>要训练模型，我们首先需要使用以下命令导入相应的模型：<code>scikit-learn</code></p>
<p>  <code>from sklearn.linear_model import LogisticRegression</code> </p>
<p>接下来，我们需要通过实例化对象的实例来创建模型：<code>LogisticRegression</code></p>
<p>  <code>model = LogisticRegression()</code> </p>
<p>要训练模型，我们需要调用我们刚刚创建并在和变量中传递的对象上的方法，如下所示：<code>fit``````LogisticRegression``````x_training_data``````y_training_data</code></p>
<p>  <code>model.fit(x_training_data, y_training_data)</code> </p>
<p>我们的模型现在已经接受培训。我们将在本教程的下一节中使用此模型进行预测。</p>
<h2 id="使用我们的逻辑回归模型进行预测"><a href="#使用我们的逻辑回归模型进行预测" class="headerlink" title="使用我们的逻辑回归模型进行预测"></a>使用我们的逻辑回归模型进行预测</h2><p>让我们使用我们刚刚创建的逻辑回归模型对我们的测试数据进行一组预测。我们将将这些预测存储在一个变量中，称为 ：<code>model``````predictions</code></p>
<p>  <code>predictions = model.predict(x_test_data)</code> </p>
<p>我们的预测已经作出。接下来，让我们来检查模型的准确性。</p>
<h2 id="衡量逻辑回归机器学习模型的性能"><a href="#衡量逻辑回归机器学习模型的性能" class="headerlink" title="衡量逻辑回归机器学习模型的性能"></a>衡量逻辑回归机器学习模型的性能</h2><p><code>scikit-learn</code>具有出色的内置模块，便于测量分类机器学习模型的性能。我们将使用此模块来测量我们刚刚创建的模型的性能。<code>classification_report</code></p>
<p>首先，让我们导入模块：</p>
<p>  <code>from sklearn.metrics import classification_report</code> </p>
<p>接下来，让我们使用该模块计算逻辑回归机器学习模块的性能指标：</p>
<p>  <code>classification_report(y_test_data, predictions)</code> </p>
<p>下面是此命令的输出：</p>
<p>  <code>precision    recall  f1-score   support</p>
<pre><code>       0       0.83      0.87      0.85       169

       1       0.75      0.68      0.72        98

accuracy                           0.80       267</code></pre>
<p>   macro avg       0.79      0.78      0.78       267</p>
<p>weighted avg       0.80      0.80      0.80       267</code> </p>
<p>如果您有兴趣查看原始混淆矩阵并手动计算性能指标，则可以使用以下代码执行此操作：</p>
<p>  <code>from sklearn.metrics import confusion_matrix</p>
<p>print(confusion_matrix(y_test_data, predictions))</code> </p>
<p>这将生成以下输出：</p>
<p>  <code>[[145  22]</p>
<p> [ 30  70]]</code> </p>
<h2 id="本教程的完整代码"><a href="#本教程的完整代码" class="headerlink" title="本教程的完整代码"></a>本教程的完整代码</h2><p>您可以在<a href="https://zshipu.com/t?url=https://github.com/nicholasmccullum/python-machine-learning">此 GitHub 存储库</a>中查看本教程的完整代码。下面还粘贴如下，供参考：</p>
<p>  <code>import pandas as pd</p>
<p>import numpy as np</p>
<p>import matplotlib.pyplot as plt</p>
<p>%matplotlib inline</p>
<p>import seaborn as sns</p>
<p>#Import the data set<br>titanic_data = pd.read_csv(‘titanic_train.csv’)</p>
<p>#Exploratory data analysis<br>sns.heatmap(titanic_data.isnull(), cbar=False)</p>
<p>sns.countplot(x=’Survived’, data=titanic_data)</p>
<p>sns.countplot(x=’Survived’, hue=’Sex’, data=titanic_data)</p>
<p>sns.countplot(x=’Survived’, hue=’Pclass’, data=titanic_data)</p>
<p>plt.hist(titanic_data[‘Age’].dropna())</p>
<p>plt.hist(titanic_data[‘Fare’])</p>
<p>sns.boxplot(titanic_data[‘Pclass’], titanic_data[‘Age’])</p>
<p>#Imputation function<br>def impute_missing_age(columns):</p>
<pre><code>age = columns[0]

passenger_class = columns[1]

if pd.isnull(age):

    if(passenger_class == 1):

        return titanic_data[titanic_data[&#39;Pclass&#39;] == 1][&#39;Age&#39;].mean()

    elif(passenger_class == 2):

        return titanic_data[titanic_data[&#39;Pclass&#39;] == 2][&#39;Age&#39;].mean()

    elif(passenger_class == 3):

        return titanic_data[titanic_data[&#39;Pclass&#39;] == 3][&#39;Age&#39;].mean()

else:

    return age</code></pre>
<p>#Impute the missing Age data<br>titanic_data[‘Age’] = titanic_data[[‘Age’, ‘Pclass’]].apply(impute_missing_age, axis = 1)</p>
<p>#Reinvestigate missing data<br>sns.heatmap(titanic_data.isnull(), cbar=False)</p>
<p>#Drop null data<br>titanic_data.drop(‘Cabin’, axis=1, inplace = True)</p>
<p>titanic_data.dropna(inplace = True)</p>
<p>#Create dummy variables for Sex and Embarked columns<br>sex_data = pd.get_dummies(titanic_data[‘Sex’], drop_first = True)</p>
<p>embarked_data = pd.get_dummies(titanic_data[‘Embarked’], drop_first = True)</p>
<p>#Add dummy variables to the DataFrame and drop non-numeric data<br>titanic_data = pd.concat([titanic_data, sex_data, embarked_data], axis = 1)</p>
<p>titanic_data.drop([‘Name’, ‘PassengerId’, ‘Ticket’, ‘Sex’, ‘Embarked’], axis = 1, inplace = True)</p>
<p>#Print the finalized data set<br>titanic_data.head()</p>
<p>#Split the data set into x and y data<br>y_data = titanic_data[‘Survived’]</p>
<p>x_data = titanic_data.drop(‘Survived’, axis = 1)</p>
<p>#Split the data set into training data and test data<br>from sklearn.model_selection import train_test_split</p>
<p>x_training_data, x_test_data, y_training_data, y_test_data = train_test_split(x_data, y_data, test_size = 0.3)</p>
<p>#Create the model<br>from sklearn.linear_model import LogisticRegression</p>
<p>model = LogisticRegression()</p>
<p>#Train the model and create predictions<br>model.fit(x_training_data, y_training_data)</p>
<p>predictions = model.predict(x_test_data)</p>
<p>#Calculate performance metrics<br>from sklearn.metrics import classification_report</p>
<p>print(classification_report(y_test_data, predictions))</p>
<p>#Generate a confusion matrix<br>from sklearn.metrics import confusion_matrix</p>
<p>print(confusion_matrix(y_test_data, predictions))</code> </p>
<h2 id="最后的想法"><a href="#最后的想法" class="headerlink" title="最后的想法"></a>最后的想法</h2><p>在本教程中，您学习了如何在 Python 中构建逻辑回归机器学习模型。</p>
<p>以下是您在本文中学到的内容的简要摘要：</p>
<ul>
<li>为什么泰坦尼克号数据集经常用于学习机器学习分类技术</li>
<li>在使用分类机器学习问题的数据集时如何执行探索性数据分析</li>
<li>如何处理熊猫数据框架中缺少的数据</li>
<li>使用它来填充缺失的数据意味着什么以及如何<code>imputation</code></li>
<li>如何为机器学习数据集中的分类数据创建虚拟变量</li>
<li>如何在Python中训练逻辑回归机器学习模型</li>
<li>如何使用 Python 中的逻辑回归模型进行预测</li>
<li>如何快速计算机器学习分类问题的性能指标<code>scikit-learn``````classification_report</code></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-06-21T03:19:43.000Z" title="2020-06-21T03:19:43.000Z">2020-06-21</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.397Z" title="2020-09-08T14:03:00.397Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">25 分钟读完 (大约3809个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/21/Python%20%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%20-%20%E5%88%86%E6%AD%A5%E6%8C%87%E5%8D%97/">Python 中的线性回归 - 分步指南</a></h1><div class="content"><p>在本课程的最后一课中，您了解了线性回归机器学习算法背后的历史和理论。</p>
<p>本教程将教您如何使用库在 Python 中创建、训练和测试第一个线性回归机器学习模型。<code>scikit-learn</code></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>您可以使用下面的目录跳到此 Python 机器学习教程的特定部分：</p>
<ul>
<li><a href="https://zshipu.com/t?url=#the-data-set-we-will-use-in-this-tutorial">我们将在本教程中使用数据集</a></li>
<li><a href="https://zshipu.com/t?url=#the-libraries-we-will-use-in-this-tutorial">我们将在本教程中使用库</a></li>
<li><a href="https://zshipu.com/t?url=#importing-the-data-set">导入数据集</a></li>
<li><a href="https://zshipu.com/t?url=#understanding-the-data-set">了解数据集</a></li>
<li><a href="https://zshipu.com/t?url=#building-a-machine-learning-linear-regression-model">构建机器学习线性回归模型</a></li>
<li><a href="https://zshipu.com/t?url=#splitting-our-data-set-into-training-data-and-test-data">将我们的数据集拆分为训练数据和测试数据</a></li>
<li><a href="https://zshipu.com/t?url=#building-and-training-the-model">构建和培训模型</a></li>
<li><a href="https://zshipu.com/t?url=#making-predictions-from-our-model">从我们的模型进行预测</a></li>
<li><a href="https://zshipu.com/t?url=#testing-the-performance-of-our-model">测试模型的性能</a><ul>
<li><a href="https://zshipu.com/t?url=#mean-absolute-error-mae">平均绝对误差 （MAE）</a></li>
<li><a href="https://zshipu.com/t?url=#mean-squared-error-mse">平均平方误差 （MSE）</a></li>
<li><a href="https://zshipu.com/t?url=#root-mean-squared-error-rmse">根均值平方错误 （RMSE）</a></li>
</ul>
</li>
<li><a href="https://zshipu.com/t?url=#the-complete-code-for-this-tutorial">本教程的完整代码</a></li>
<li><a href="https://zshipu.com/t?url=#final-thoughts">最后的想法</a></li>
</ul>
<h2 id="我们将在本教程中使用数据集"><a href="#我们将在本教程中使用数据集" class="headerlink" title="我们将在本教程中使用数据集"></a>我们将在本教程中使用数据集</h2><p>由于线性回归是我们在本课程中学习的第一个机器学习模型，我们将在本教程中使用人工创建的数据集。这将使您能够专注于学习机器学习概念，并避免花费不必要的时间来清理或操作数据。</p>
<p>更具体地说，我们将使用一组住房数据，并试图预测房价。在构建模型之前，我们首先需要导入所需的库。</p>
<h2 id="我们将在本教程中使用库"><a href="#我们将在本教程中使用库" class="headerlink" title="我们将在本教程中使用库"></a>我们将在本教程中使用库</h2><p>我们需要导入的第一个库是<a href="https://zshipu.com/t?url=https://nickmccullum.com/advanced-python/pandas-dataframes/">熊猫</a>，它是”面板数据”的波特曼托，是最常用的Python库，用于处理表格数据。</p>
<p>在别名下导入是约定的。您可以使用以下语句导入：<code>pandas``````pd``````pandas</code></p>
<p>  <code>import pandas as pd</code> </p>
<p>接下来，我们需要导入<a href="https://zshipu.com/t?url=https://nickmccullum.com/advanced-python/numpy/">NumPy，</a>这是一个流行的数值计算库。Numpy 以其<a href="https://zshipu.com/t?url=https://nickmccullum.com/advanced-python/numpy-arrays/">NumPy 数组</a>数据结构及其有用的方法<a href="https://zshipu.com/t?url=https://nickmccullum.com/numpy-np-reshape/">重塑</a>、<a href="https://zshipu.com/t?url=https://nickmccullum.com/how-to-use-numpy-arange/">进行和</a><a href="https://zshipu.com/t?url=https://nickmccullum.com/numpy-np-append/">追加</a>而闻名。</p>
<p>在别名下导入 NumPy 是约定的。您可以使用以下语句导入：<code>np``````numpy</code></p>
<p>  <code>import numpy as np</code> </p>
<p>接下来，我们需要导入<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-visualization/how-to-import-matplotlib/">matplotlib，</a>这是 Python 最受欢迎的<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-visualization/">数据可视化</a>库。</p>
<p><code>matplotlib</code>通常导入在别名 下。您可以使用以下语句导入：<code>plt``````matplotlib</code></p>
<p>  <code>import matplotlib.pyplot as plt</p>
<p>%matplotlib inline</code> </p>
<p>该语句将导致我们的可视化效果直接嵌入到 Jupyter 笔记本中，从而更易于访问和解释。<code>%matplotlib inline``````matplotlib</code></p>
<p>最后，您需要导入 ，这是另一个 Python 数据可视化库，它使得使用 matplotlib 创建美丽的可视化效果变得更加容易。<code>seaborn</code></p>
<p>您可以使用以下语句导入：<code>seaborn</code></p>
<p>  <code>import seaborn as sns</code> </p>
<p>总之，以下是本教程中所需的所有导入：</p>
<p>  <code>import pandas as pd</p>
<p>import numpy as np</p>
<p>import matplotlib.pyplot as plt</p>
<p>%matplotlib inline</p>
<p>import seaborn as sns</code> </p>
<p>在未来的课程中，我将具体说明哪些进口是必要的，但我不会像我在这里那样详细解释每个进口。</p>
<h2 id="导入数据集"><a href="#导入数据集" class="headerlink" title="导入数据集"></a>导入数据集</h2><p>如前所述，我们将使用一组房屋信息。我们将使用</p>
<p>数据集已上载到我的网站，作为以下 URL 的文件：<code>.csv</code></p>
<p> <code><a target="_blank" rel="noopener" href="https://nickmccullum.com/files/Housing_Data.csv">https://nickmccullum.com/files/Housing_Data.csv</a></code> </p>
<p>要将数据集导入<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-course/jupyter-notebook-basics/">Jupyter 笔记本</a>，您首先应该通过复制此 URL 并将其粘贴到浏览器中来下载文件。然后，将文件移动到与 Jupyter 笔记本相同的目录中。</p>
<p>完成此操作后，以下<a href="https://zshipu.com/t?url=https://courses.nickmccullum.com/courses/enroll/python-for-finance/">Python</a>语句将住宅数据集导入到 Jupyter 笔记本中：</p>
<p>  <code>raw_data = pd.read_csv('Housing_Data.csv')</code> </p>
<p>此数据集具有许多功能，包括：</p>
<ul>
<li>房屋面积的平均收入</li>
<li>该地区平均客房数</li>
<li>房子卖的价格</li>
<li>房子的地址</li>
</ul>
<p>此数据是随机生成的，因此您将看到一些通常没有意义的细微差别（例如，在数字后大量小数位数，该数字应该是整数）。</p>
<h2 id="了解数据集"><a href="#了解数据集" class="headerlink" title="了解数据集"></a>了解数据集</h2><p>现在，数据集已在变量下导入，您可以使用 方法获取有关数据集的一些高级信息。具体来说，跑步可以：<code>raw_data``````info``````raw_data.info()</code></p>
<p> <code><class 'pandas.core.frame.DataFrame'></p>
<p>RangeIndex: 5000 entries, 0 to 4999</p>
<p>Data columns (total 7 columns):</p>
<p>Avg. Area Income                5000 non-null float64</p>
<p>Avg. Area House Age             5000 non-null float64</p>
<p>Avg. Area Number of Rooms       5000 non-null float64</p>
<p>Avg. Area Number of Bedrooms    5000 non-null float64</p>
<p>Area Population                 5000 non-null float64</p>
<p>Price                           5000 non-null float64</p>
<p>Address                         5000 non-null object</p>
<p>dtypes: float64(6), object(1)</p>
<p>memory usage: 273.6+ KB</code> </p>
<p>了解此数据集的另一个有用方法是生成对图。可以为此使用 方法，并将整个方法作为参数传递。下面是用于此项的整个语句：<code>seaborn``````pairplot``````DataFrame</code></p>
<p>  <code>sns.pairplot(raw_data)</code> </p>
<p>此语句的输出如下：</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/linear-regression/machine-learning-pairplot.png" alt="A seaborn pairplot"></p>
<p>接下来，让我们开始构建线性回归模型。</p>
<h2 id="构建机器学习线性回归模型"><a href="#构建机器学习线性回归模型" class="headerlink" title="构建机器学习线性回归模型"></a>构建机器学习线性回归模型</h2><p>我们需要做的第一件事是将数据拆分为（其中包含我们将用于进行预测的数据）和 a（其中包含我们试图预测的数据）。<code>x-array``````y-array</code></p>
<p>首先，我们应该决定要包括哪些列。您可以使用 生成 DataFrame 列的列表，该列表输出：<code>raw_data.columns</code></p>
<p> <code>Index(['Avg. Area Income', 'Avg. Area House Age', 'Avg. Area Number of Rooms',</p>
<pre><code>   &#39;Avg. Area Number of Bedrooms&#39;, &#39;Area Population&#39;, &#39;Price&#39;, &#39;Address&#39;],

  dtype=&#39;object&#39;)&lt;/code&gt; </code></pre>
<p>我们将在 除 外将使用所有这些变量（因为这是我们试图预测的变量）和（因为它仅包含文本）。<code>x-array``````Price``````Address</code></p>
<p>让我们创建我们的，并将其分配给一个称为 的变量。<code>x-array``````x</code></p>
<p>  <code>x = raw_data[['Avg. Area Income', 'Avg. Area House Age', 'Avg. Area Number of Rooms',</p>
<pre><code>   &#39;Avg. Area Number of Bedrooms&#39;, &#39;Area Population&#39;]]&lt;/code&gt; </code></pre>
<p>接下来，让我们创建我们的，并将其分配给一个称为 的变量。<code>y-array``````y</code></p>
<p>  <code>y = raw_data['Price']</code> </p>
<p>我们成功地将数据集划分为（即模型的输入值）和 （即模型的输出值）。我们将在下一节中了解如何将数据集进一步拆分为训练数据和测试数据。<code>x-array``````y-array</code></p>
<h2 id="将我们的数据集拆分为训练数据和测试数据"><a href="#将我们的数据集拆分为训练数据和测试数据" class="headerlink" title="将我们的数据集拆分为训练数据和测试数据"></a>将我们的数据集拆分为训练数据和测试数据</h2><p><code>scikit-learn</code>使将数据集划分为训练数据和测试数据非常容易。为此，我们需要从 模块导入函数。<code>train_test_split``````model_selection``````scikit-learn</code></p>
<p>下面是执行此操作的完整代码：</p>
<p>  <code>from sklearn.model_selection import train_test_split</code> </p>
<p>数据接受三个参数：<code>train_test_split</code></p>
<ul>
<li>我们<code>x-array</code></li>
<li>我们<code>y-array</code></li>
<li>测试数据所需的大小</li>
</ul>
<p>有了这些参数，函数将为我们拆分我们的数据！如果我们希望我们的测试数据占整个数据集的 30%，则下面是执行此操作的代码：<code>train_test_split</code></p>
<p>  <code>x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.3)</code> </p>
<p>让我们解压缩这里发生的事情。</p>
<p>该函数返回长度为 4 的<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-course/lists/">Python 列表</a>，其中列表中的每个项目分别为 、和 。然后，我们使用列表解包将正确的值分配给正确的变量名称。<code>train_test_split``````x_train``````x_test``````y_train``````y_test</code></p>
<p>现在，我们已经正确地划分了我们的数据集，是时候构建和训练我们的线性回归机器学习模型了。</p>
<h2 id="构建和培训模型"><a href="#构建和培训模型" class="headerlink" title="构建和培训模型"></a>构建和培训模型</h2><p>我们需要做的第一件事是从导入估计器。下面是用于此的 Python 语句：<code>LinearRegression``````scikit-learn</code></p>
<p>  <code>from sklearn.linear_model import LinearRegression</code> </p>
<p>接下来，我们需要创建 Python 对象的实例。我们将将其分配给一个称为 的变量。下面是用于此代码的代码：<code>Linear Regression``````model</code></p>
<p>  <code>model = LinearRegression()</code> </p>
<p>我们可以使用’的方法，根据我们的训练数据来训练这个模型。<code>scikit-learn``````fit</code></p>
<p>  <code>model.fit(x_train, y_train)</code> </p>
<p>我们的模型现在已经接受培训。您可以使用以下语句检查模型的每个系数：</p>
<p>  <code>print(model.coef_)</code> </p>
<p>此打印件：</p>
<p> <code>[2.16176350e+01 1.65221120e+05 1.21405377e+05 1.31871878e+03</p>
<p> 1.52251955e+01]</code> </p>
<p>同样，下面是如何查看回归方程的截取：</p>
<p>  <code>print(model.intercept_)</code> </p>
<p>此打印件：</p>
<p> <code>-2641372.6673013503</code> </p>
<p>查看系数的更好方法是将它们放置在 DataFrame 中。这可以通过以下语句完成：</p>
<p>  <code>pd.DataFrame(model.coef_, x.columns, columns = ['Coeff'])</code> </p>
<p>在这种情况下，输出更易于解释：</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/linear-regression/coefficient-dataframe.png" alt="A coefficient DataFrame in a Jupyter Notebook"></p>
<p>让我们花点时间了解一下这些系数的含义。让我们具体看一下变量，其系数约为 。<code>Area Population``````15</code></p>
<p>这意味着，如果保持所有其他变量常数，则一个单位的增加将导致预测变量中的单位增加 - 在这种情况下，<code>Area Population``````15``````Price</code></p>
<p>不同地说，特定变量上的大系数意味着该变量对您尝试预测的变量的值有很大的影响。同样，小值的影响很小。</p>
<p>现在，我们已经生成了第一个机器学习线性回归模型，是时候使用该模型从测试数据集进行预测了。</p>
<h2 id="从我们的模型进行预测"><a href="#从我们的模型进行预测" class="headerlink" title="从我们的模型进行预测"></a>从我们的模型进行预测</h2><p><code>scikit-learn</code>使从机器学习模型进行预测变得非常容易。您只需调用前面创建的变量上的方法。<code>predict``````model</code></p>
<p>由于变量旨在进行预测，因此它仅接受参数。它将为您生成值！<code>predict``````x-array``````y</code></p>
<p>下面是使用 方法从我们的模型生成预测所需的代码：<code>predict</code></p>
<p>  <code>predictions = model.predict(x_test)</code> </p>
<p>变量保存存储在 中的要素_的预测_值。由于我们使用 方法将_实际_值存储在 中，接下来我们要执行的是将数组的值与 的值进行比较。<code>predictions``````x_test``````train_test_split``````y_test``````predictions``````y_test</code></p>
<p>一个简单的方法是使用散点图绘制两个数组。使用 方法轻松构建<a href="https://zshipu.com/t?url=https://nickmccullum.com/python-visualization/scatterplot/">垫图利布散点图</a>。下面是以下代码：<code>plt.scatter</code></p>
<p>  <code>plt.scatter(y_test, predictions)</code> </p>
<p>下面是此代码生成的散点图：</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/linear-regression/regression-scatterplot.png" alt="A scatterplot of predicted values against realized values in a machine learning linear regression model"></p>
<p>如您所见，我们的预测值非常接近数据集中观测值的实际值。此散点图中完全直线对角线表示我们的模型完美地预测了这些值。<code>y-array</code></p>
<p>直观地评估模型性能的另一种方法是绘制其 ，即实际值和预测值之间的差异。<code>residuals``````y-array``````y-array</code></p>
<p>一个简单的方法是使用以下语句：</p>
<p>  <code>plt.hist(y_test - predictions)</code> </p>
<p>下面是此代码生成的可视化效果：</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/linear-regression/residuals-histogram.png" alt="A residual histogram from our linear regression machine learning model"></p>
<p>这是我们机器学习模型中残差的直方图。</p>
<p>您可能会注意到，我们机器学习模型中的残差似乎正常分布。这是一个非常好的迹象！</p>
<p>它表明我们选择了适当的模型类型（在本例中为线性回归），以便从数据集进行预测。我们将在本课程的后面部分学习有关如何确保您使用正确的模型。</p>
<h2 id="测试模型的性能"><a href="#测试模型的性能" class="headerlink" title="测试模型的性能"></a>测试模型的性能</h2><p>我们在本课程的开头了解到，回归机器学习模型有三个主要性能指标：</p>
<ul>
<li>平均绝对误差</li>
<li>均方误差</li>
<li>根均方误差</li>
</ul>
<p>现在，我们将了解如何计算本教程中构建的模型的每个指标。在继续操作之前，请在 Jupyter 笔记本中运行以下导入语句：</p>
<p>  <code>from sklearn import metrics</code> </p>
<h3 id="平均绝对误差-（MAE）"><a href="#平均绝对误差-（MAE）" class="headerlink" title="平均绝对误差 （MAE）"></a>平均绝对误差 （MAE）</h3><p>您可以使用以下语句计算 Python 中的平均绝对错误：</p>
<p>  <code>metrics.mean_absolute_error(y_test, predictions)</code> </p>
<h3 id="平均平方误差-（MSE）"><a href="#平均平方误差-（MSE）" class="headerlink" title="平均平方误差 （MSE）"></a>平均平方误差 （MSE）</h3><p>同样，您可以使用以下语句计算 Python 中的平均平方错误：</p>
<p>  <code>metrics.mean_squared_error(y_test, predictions)</code> </p>
<h3 id="根均值平方错误-（RMSE）"><a href="#根均值平方错误-（RMSE）" class="headerlink" title="根均值平方错误 （RMSE）"></a>根均值平方错误 （RMSE）</h3><p>与均值绝对误差和均方误差不同，实际上没有用于计算根均方误差的内置方法。<code>scikit-learn</code></p>
<p>幸运的是，它真的不需要。由于根平均平方误差只是均方误差的平方根，因此您可以使用 NumPy 的方法轻松计算它：<code>sqrt</code></p>
<p>  <code>np.sqrt(metrics.mean_squared_error(y_test, predictions))</code> </p>
<h2 id="本教程的完整代码"><a href="#本教程的完整代码" class="headerlink" title="本教程的完整代码"></a>本教程的完整代码</h2><p>下面是此 Python 机器学习教程的整个代码。您也可以<a href="https://zshipu.com/t?url=https://github.com/nicholasmccullum/python-machine-learning/tree/master">在此 GitHub 存储库</a>中查看它。</p>
<p>  <code>import pandas as pd</p>
<p>import numpy as np</p>
<p>import matplotlib.pyplot as plt</p>
<p>import seaborn as sns</p>
<p>%matplotlib inline</p>
<p>raw_data = pd.read_csv(‘Housing_Data.csv’)</p>
<p>x = raw_data[[‘Avg. Area Income’, ‘Avg. Area House Age’, ‘Avg. Area Number of Rooms’,</p>
<pre><code>   &#39;Avg. Area Number of Bedrooms&#39;, &#39;Area Population&#39;]]</code></pre>
<p>y = raw_data[‘Price’]</p>
<p>from sklearn.model_selection import train_test_split</p>
<p>x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.3)</p>
<p>from sklearn.linear_model import LinearRegression</p>
<p>model = LinearRegression()</p>
<p>model.fit(x_train, y_train)</p>
<p>print(model.coef_)</p>
<p>print(model.intercept_)</p>
<p>pd.DataFrame(model.coef_, x.columns, columns = [‘Coeff’])</p>
<p>predictions = model.predict(x_test)</p>
<h1 id="plt-scatter-y-test-predictions"><a href="#plt-scatter-y-test-predictions" class="headerlink" title="plt.scatter(y_test, predictions)"></a>plt.scatter(y_test, predictions)</h1><p>plt.hist(y_test - predictions)</p>
<p>from sklearn import metrics</p>
<p>metrics.mean_absolute_error(y_test, predictions)</p>
<p>metrics.mean_squared_error(y_test, predictions)</p>
<p>np.sqrt(metrics.mean_squared_error(y_test, predictions))</code> </p>
<h2 id="最后的想法"><a href="#最后的想法" class="headerlink" title="最后的想法"></a>最后的想法</h2><p>在本教程中，您学习了如何创建、训练和测试第一个线性回归机器学习算法。</p>
<p>以下是您在本教程中学到的内容的简要摘要：</p>
<ul>
<li>如何导入构建线性回归机器学习算法所需的库</li>
<li>如何使用将数据集拆分为训练数据和测试数据<code>scikit-learn</code></li>
<li>如何使用该模型训练线性回归模型并做出预测<code>scikit-learn</code></li>
<li>如何使用线性回归性能指标<code>scikit-learn</code></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-06-21T03:18:15.000Z" title="2020-06-21T03:18:15.000Z">2020-06-21</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.465Z" title="2020-09-08T14:03:00.465Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">6 分钟读完 (大约935个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/21/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/">推荐算法简介</a></h1><div class="content"><p>在本教程中，您将收到一份简短的、无代码的建议系统介绍。我们将在下一教程中编写第一个推荐系统来跟进这一点。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>您可以使用下面的目录跳到本建议系统教程的特定部分：</p>
<ul>
<li><a href="https://zshipu.com/t?url=#what-are-recommendation-systems">什么是推荐系统？</a></li>
<li><a href="https://zshipu.com/t?url=#recommendation-systems-and-linear-algebra">推荐系统和线性代数</a></li>
<li><a href="https://zshipu.com/t?url=#how-do-recommendation-systems-work">推荐系统如何工作？</a></li>
<li><a href="https://zshipu.com/t?url=#final-thoughts">最后的想法</a></li>
</ul>
<h2 id="什么是推荐系统？"><a href="#什么是推荐系统？" class="headerlink" title="什么是推荐系统？"></a>什么是推荐系统？</h2><p>建议系统用于在数据集中查找类似的条目。</p>
<p>也许最常见的建议真实示例存在于 Netflix 中。更具体地说，其视频流媒体服务将推荐基于你已经观看的内容的电影和电视节目。</p>
<p>另一个推荐系统是Facebook的”你可能认识的人”功能，它建议你可能的朋友，根据你现有的朋友名单。</p>
<p>充分开发和部署的建议系统极其复杂。它们也非常耗费资源。因此，我们仅在本课程中讨论推荐系统的基础知识。</p>
<h2 id="推荐系统和线性代数"><a href="#推荐系统和线性代数" class="headerlink" title="推荐系统和线性代数"></a>推荐系统和线性代数</h2><p>成熟的推荐系统需要线性代数的深层背景，才能从头开始构建。</p>
<p>因此，如果您以前从未研究过线性代数，则本节中可能有些概念无法理解。</p>
<p>不过，不要担心 - 使构建推荐系统变得非常容易，而且实际上不需要任何线性代数背景来继续完成本课程。<code>scikit-learn</code></p>
<h2 id="推荐系统如何工作？"><a href="#推荐系统如何工作？" class="headerlink" title="推荐系统如何工作？"></a>推荐系统如何工作？</h2><p>推荐系统主要有两种类型：</p>
<ul>
<li>基于内容的建议系统</li>
<li>协作筛选建议系统</li>
</ul>
<p>基于内容的推荐系统会根据已使用的项目的相似性提供建议。他们完全按照你期望的推荐系统的方式。</p>
<p>协作筛选建议系统根据用户与项目交互的知识生成建议。换句话说，他们使用人群的智慧（因此，它的名字是”协作”一词）。</p>
<p>在现实世界中，协作筛选建议系统比基于内容的系统更常见。这主要是因为它们通常能产生更好的结果。一些从业者还发现协作筛选建议系统更易于理解。</p>
<p>协作筛选推荐系统还具有基于内容的系统所缺少的独特功能。也就是说，他们有能力自己学习功能。</p>
<p>这意味着他们可以开始根据您甚至未告诉他们考虑的属性来识别项之间的相似性！</p>
<p>协作筛选中有两个子类别：</p>
<ul>
<li>基于内存的协作筛选</li>
<li>基于模型的协作筛选</li>
</ul>
<p>您无需了解这两种类型的协作筛选建议系统之间的差异，就可在本课程中取得成功。这足以识别存在多种类型。</p>
<h2 id="最后的想法"><a href="#最后的想法" class="headerlink" title="最后的想法"></a>最后的想法</h2><p>在本教程中，您收到了机器学习推荐系统的第一个无代码介绍。我们将在下一课中编写第一个 Python 推荐系统，以对此进行跟踪。</p>
<p>以下是我们在本教程中讨论的简要摘要：</p>
<ul>
<li>现实世界中推荐制度的例子</li>
<li>不同类型的推荐系统，以及协作筛选系统如何比基于内容的建议系统更常用</li>
<li>推荐系统与线性代数的关系</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-06-21T03:17:12.000Z" title="2020-06-21T03:17:12.000Z">2020-06-21</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.318Z" title="2020-09-08T14:03:00.318Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">1 小时读完 (大约7138个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/21/9%20%E7%A7%8D%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/">9 种常用关键机器学习算法</a></h1><div class="content"><p>机器学习正在改变世界。谷歌使用机器学习向用户推荐搜索结果。Netflix 使用它推荐电影供您观看。Facebook 使用机器学习来推荐您可能认识的人。</p>
<p>机器学习从未像现在这样重要。同时，理解机器学习也很难。田野里充满了行话。不同的 ML 算法数量每年都在增长。</p>
<p>本文将向您介绍机器学习领域的基本概念。更具体地说，我们将讨论当今 9 个最重要的机器学习算法背后的基本概念。</p>
<h1 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h1><h3 id="什么是推荐系统？"><a href="#什么是推荐系统？" class="headerlink" title="什么是推荐系统？"></a>什么是推荐系统？</h3><p><a href="https://zshipu.com/t?url=https://nickmccullum.com/python-machine-learning/introduction-recommendation-systems/">建议系统</a>用于在数据集中查找类似的条目。</p>
<p>也许最常见的建议真实示例存在于 Netflix 中。更具体地说，其视频流媒体服务将推荐基于你已经观看的内容的电影和电视节目。</p>
<p>另一个推荐系统是Facebook的”你可能认识的人”功能，它建议你可能的朋友，根据你现有的朋友名单。</p>
<p>充分开发和部署的建议系统极其复杂。它们也非常耗费资源。</p>
<h3 id="推荐系统和线性代数"><a href="#推荐系统和线性代数" class="headerlink" title="推荐系统和线性代数"></a>推荐系统和线性代数</h3><p>成熟的推荐系统需要线性代数的深层背景，才能从头开始构建。</p>
<p>因此，如果您以前从未研究过线性代数，则本节中可能有些概念无法理解。</p>
<p>不过，别担心——学习的 Python 库使得构建推荐系统变得非常简单。S0 你不需要太多的线性代数背景来构建真实世界的建议系统。</p>
<h3 id="推荐系统如何工作？"><a href="#推荐系统如何工作？" class="headerlink" title="推荐系统如何工作？"></a>推荐系统如何工作？</h3><p>推荐系统主要有两种类型：</p>
<ul>
<li>基于内容的建议系统</li>
<li>协作筛选建议系统</li>
</ul>
<p>基于内容的推荐系统根据已使用的项目的相似性为您提供建议。他们完全按照你期望的推荐系统来做。</p>
<p>协作筛选建议系统根据用户与项目交互的知识生成建议。换句话说，他们利用了人群的智慧。（因此，其名称中的术语”协作”。</p>
<p>在现实世界中，协作筛选建议系统比基于内容的系统更常见。这主要是因为它们通常能产生更好的结果。一些从业者还发现协作筛选建议系统更易于理解。</p>
<p>协作筛选建议系统还具有缺少基于内容的系统的独特功能。也就是说，他们有能力自己学习功能。</p>
<p>这意味着他们甚至可以开始根据您甚至未告诉他们要考虑的属性来识别项之间的相似性。</p>
<p>协作筛选中有两个子类别：</p>
<ul>
<li>基于内存的协作筛选</li>
<li>基于模型的协作筛选</li>
</ul>
<p>在机器学习中取得成功，您无需了解这两种类型的协作筛选建议系统之间的区别。这足以识别存在多种类型。</p>
<h3 id="章节总结"><a href="#章节总结" class="headerlink" title="章节总结"></a>章节总结</h3><p>以下是我们在本教程中讨论的关于建议系统的简要摘要：</p>
<ul>
<li>现实世界中推荐制度的例子</li>
<li>不同类型的推荐系统，以及协作筛选系统如何比基于内容的建议系统更常用</li>
<li>推荐系统与线性代数的关系</li>
</ul>
<h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><p><a href="https://zshipu.com/t?url=https://nickmccullum.com/python-machine-learning/linear-regression-python/">线性回归</a>用于根据另一组值的值预测某些值。<code>y``````x</code></p>
<h3 id="线性回归的历史"><a href="#线性回归的历史" class="headerlink" title="线性回归的历史"></a>线性回归的历史</h3><p>线性回归是由<a href="https://zshipu.com/t?url=https://en.wikipedia.org/wiki/Francis_Galton">弗朗西斯·加尔顿</a>在19世纪创建的。</p>
<p>高尔顿是研究父母和孩子之间关系的科学家。更具体地说，高尔顿正在调查父亲身高和儿子身高之间的关系。</p>
<p>高尔顿的第一个发现是，儿子往往和父亲一样高。这并不奇怪。</p>
<p>后来，加尔顿发现了一些更有趣的东西。儿子的身高往往<strong>更接近于所有人的总平均身高__，而不是他自己的父亲__。</strong></p>
<p>加尔顿给这种现象起一个名称：**<strong>回归**</strong>。具体来说，他说”父亲的儿子的身高倾向于倒退（或向）平均（平均）高度漂移”。</p>
<p>这导致了整个统计和机器学习领域称为回归。</p>
<h3 id="线性回归数学"><a href="#线性回归数学" class="headerlink" title="线性回归数学"></a>线性回归数学</h3><p>创建回归模型时，我们尝试的只是绘制一条尽可能接近数据集中每个点的线。</p>
<p>典型的示例是线性回归的”最小平方法”，该方法仅计算向上和向下方向的直线的接近度。</p>
<p>下面是一个示例，可帮助说明这一点：</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/introduction-linear-regression/least-squares-regression.gif" alt="An example of the math behind least squares regression"></p>
<p>创建回归模型时，最终产品是一个方程，可用于预测 x 值的 y 值，而无需事先实际知道 y 值。</p>
<h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><p><a href="https://zshipu.com/t?url=https://nickmccullum.com/python-machine-learning/logistic-regression-python/">逻辑回归</a>类似于线性回归，只不过它不是计算数值，而是估计数据点属于哪个_类别_。<code>y</code></p>
<h3 id="什么是逻辑回归？"><a href="#什么是逻辑回归？" class="headerlink" title="什么是逻辑回归？"></a>什么是逻辑回归？</h3><p>逻辑回归是一种机器学习模型，用于解决分类问题。</p>
<p>以下是机器学习分类问题的一些示例：</p>
<ul>
<li>垃圾邮件（垃圾邮件还是垃圾邮件？</li>
<li>汽车保险索赔（注销或修理？</li>
<li>疾病诊断</li>
</ul>
<p>每个分类问题都有两个类别，这使得它们成为<strong>二进制分类</strong>问题的示例。</p>
<p>逻辑回归非常适合解决<strong>二进制分类</strong>问题 - 我们只是为每个类别指定值和分别。<code>0``````1</code></p>
<p>为什么我们需要逻辑回归？因为不能使用线性回归模型进行二进制分类预测。它不会导致良好的拟合，因为您尝试通过只有两个可能的值的数据集拟合直线。</p>
<p>此图像可以帮助您理解为什么线性回归模型不适合二进制分类问题：</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/introduction-logistic-regression/linear-regression-classification.png" alt="Linear Regression Classification"></p>
<p>在此图像中， 表示肿瘤是恶性的概率.相反，该值表示肿瘤不是恶性肿瘤的概率。如您所见，线性回归模型在预测数据集中大多数观测值的此概率方面做得很差。<code>y-axis``````1-y</code></p>
<p>这就是为什么逻辑回归模型很有用。它们有一个弯曲到他们的最佳拟合线，这使得他们更适合预测分类数据。</p>
<p>下面是一个使用相同训练数据将线性回归模型与逻辑回归模型进行比较的示例：</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/introduction-logistic-regression/linear-vs-logistic-regression.png" alt="Linear Regression vs Logistic Regression"></p>
<h3 id="西格莫伊德函数"><a href="#西格莫伊德函数" class="headerlink" title="西格莫伊德函数"></a>西格莫伊德函数</h3><p>逻辑回归模型在其曲线中具有折弯的原因是因为它没有使用线性方程计算。相反，逻辑回归模型是使用 Sigmoid 函数构建的（由于逻辑回归中使用，因此也称为逻辑函数）。</p>
<p>您不必记住<a href="https://zshipu.com/t?url=https://en.wikipedia.org/wiki/Sigmoid_function">Sigmoid 函数</a>即可在机器学习中取得成功。话虽如此，对它的外观有一些了解是有用的。</p>
<p>公式如下所示：</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/introduction-logistic-regression/sigmoid-equation.png" alt="The Sigmoid Equation"></p>
<p>Sigmoid 函数的主要特征值得理解：无论您向它传递什么价值，它始终都会在 0 和 1 之间生成输出。</p>
<h3 id="使用逻辑回归模型进行预测"><a href="#使用逻辑回归模型进行预测" class="headerlink" title="使用逻辑回归模型进行预测"></a>使用逻辑回归模型进行预测</h3><p>要使用线性回归模型进行预测，通常需要指定截止点。此截止点通常是 。<code>0.5</code></p>
<p>让我们用我们早期图像中的癌症诊断示例来在实践中看到这一原则。如果逻辑回归模型输出的值低于 0.5，则数据点被归类为非恶性肿瘤。同样，如果 Sigmoid 函数输出的值高于 0.5，则肿瘤将归类为恶性肿瘤。</p>
<h3 id="使用混淆矩阵测量逻辑回归性能"><a href="#使用混淆矩阵测量逻辑回归性能" class="headerlink" title="使用混淆矩阵测量逻辑回归性能"></a>使用混淆矩阵测量逻辑回归性能</h3><p>混淆矩阵可用作比较机器学习中真实正值、真负数、误报和假负数的工具。</p>
<p>当用于测量逻辑回归模型的性能时，混淆矩阵特别有用。下面是一个示例，演示如何使用混淆矩阵：</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/introduction-logistic-regression/confusion-matrix.png" alt="An Example Confusion Matrix">在此图中，TN 代表”真负”，FN 代表”假负”。FP 代表”误报”，TP 代表”真实正”。</p>
<p>混淆矩阵可用于评估模型在混淆矩阵的特定象限中是否特别弱。例如，它可能有异常数量的误报。</p>
<p>在某些应用程序中，确保模型在混淆矩阵的异常危险区域中表现良好也很有帮助。</p>
<p>例如，在这个癌症示例中，您希望非常确定模型的假阴性率不会很高，因为这将表明某人的恶性肿瘤被错误地归类为非恶性肿瘤。</p>
<h3 id="章节总结-1"><a href="#章节总结-1" class="headerlink" title="章节总结"></a>章节总结</h3><p>在本节中，您首次接触了逻辑回归机器学习模型。</p>
<p>以下是您学到的有关逻辑回归的简要摘要：</p>
<ul>
<li>使用逻辑回归模型解决的分类问题类型</li>
<li>物流函数（也称为 Sigmoid 函数）始终输出介于 0 和 1 之间的值</li>
<li>如何使用截止点使用逻辑回归机器学习模型进行预测</li>
<li>为什么混淆矩阵可用于测量逻辑回归模型的性能</li>
</ul>
<h1 id="K-最近邻域"><a href="#K-最近邻域" class="headerlink" title="K-最近邻域"></a>K-最近邻域</h1><p><a href="https://zshipu.com/t?url=https://nickmccullum.com/python-machine-learning/k-nearest-neighbors-python/">K 最近邻域</a>算法可以帮助您解决分类问题，其中有两个以上类别。</p>
<h3 id="什么是-K-最近邻域算法？"><a href="#什么是-K-最近邻域算法？" class="headerlink" title="什么是 K-最近邻域算法？"></a>什么是 K-最近邻域算法？</h3><p>K 最近邻域算法是基于简单原理的分类算法。事实上，这个原则是如此简单，最好通过实例来理解它。</p>
<p>想象一下，你有关于足球运动员和篮球运动员身高和体重的数据。K 近邻算法可用于预测新运动员是足球运动员还是篮球运动员。</p>
<p>为此，K 最近的邻域算法标识最接近新观测点的数据点。<code>K</code></p>
<p>下图以 K 值的 K 值显示此情况，K 值为 ：<code>3</code></p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/introduction-k-nearest-neighbors/k-nearest-neighbors.jpg" alt="A visualization of k nearest neighbors"></p>
<p>在此图像中，足球运动员被标记为蓝色数据点，篮球运动员标记为橙色点。我们尝试分类的数据点标记为绿色。</p>
<p>由于新数据点的壁橱数据点中的大部分（3个中的2个）是蓝色足球运动员，因此K最近的邻域算法将预测新数据点也是足球运动员。</p>
<h3 id="构建-K-最近邻域算法的步骤"><a href="#构建-K-最近邻域算法的步骤" class="headerlink" title="构建 K-最近邻域算法的步骤"></a>构建 K-最近邻域算法的步骤</h3><p>构建 K 最近邻域算法的一般步骤是：</p>
<ol>
<li>存储所有数据</li>
<li>计算<a href="https://zshipu.com/t?url=https://en.wikipedia.org/wiki/Euclidean_distance">欧几里登</a>距离的新数据点到数据集中的所有其他点<code>x</code></li>
<li>按与<code>x</code></li>
<li>使用与大多数最近数据点相同的类别进行预测<code>K``````x</code></li>
</ol>
<h3 id="K-最近邻域算法中-K-的重要性"><a href="#K-最近邻域算法中-K-的重要性" class="headerlink" title="K-最近邻域算法中 K 的重要性"></a>K-最近邻域算法中 K 的重要性</h3><p>尽管从一开始可能并不明显，但更改 K-最近邻域算法中 的值将更改新点分配给哪个类别。<code>K</code></p>
<p>更具体地说，值非常低将导致模型完全预测您的训练数据，并预测测试数据不足。同样，值过高会使模型不必要地复杂。<code>K``````K</code></p>
<p>以下可视化效果很好地说明了这一点：</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/introduction-k-nearest-neighbors/k-value-error-rates.png" alt="K value and error rates"></p>
<h3 id="K-最近邻域算法的优缺点"><a href="#K-最近邻域算法的优缺点" class="headerlink" title="K-最近邻域算法的优缺点"></a>K-最近邻域算法的优缺点</h3><p>最后，对 K-最近邻域算法的介绍，我想简要地讨论使用此模型的一些利弊。</p>
<p>以下是 K 最接近邻域算法的一些主要优点：</p>
<ul>
<li>该算法简单易懂</li>
<li>根据新的训练数据对模型进行培训是微不足道的</li>
<li>它适用于分类问题中的任意数量的类别</li>
<li>可以轻松地向数据集添加更多数据</li>
<li>模型仅接受两个参数：以及您要使用的距离指标（通常为欧几里得距离）<code>K</code></li>
</ul>
<p>同样，以下是算法的一些主要缺点：</p>
<ul>
<li>进行预测的计算成本很高，因为您需要对整个数据集进行排序</li>
<li>它不适用于分类功能</li>
</ul>
<h3 id="章节总结-2"><a href="#章节总结-2" class="headerlink" title="章节总结"></a>章节总结</h3><p>以下是您刚刚了解到的关于 k-最近邻域算法的简要摘要：</p>
<ul>
<li>K 近邻算法可以解决的分类问题（足球运动员与篮球运动员）的示例</li>
<li>K 最近邻域如何使用相邻数据点的欧几里得距离来预测新数据点属于哪个类别</li>
<li>为什么进行预测的价值<code>K</code></li>
<li>使用 K 最近邻域算法的优缺点</li>
</ul>
<h1 id="决策树和随机林"><a href="#决策树和随机林" class="headerlink" title="决策树和随机林"></a>决策树和随机林</h1><p><a href="https://zshipu.com/t?url=https://nickmccullum.com/python-machine-learning/decision-trees-random-forests-python/">决策树和随机林</a>都是树方法的示例。</p>
<p>更具体地说，决策树是机器学习模型，用于通过逐个循环浏览数据集中的每个要素来进行预测。随机林是决策树的集中，它们使用数据集中要素的随机顺序。</p>
<h3 id="什么是树方法？"><a href="#什么是树方法？" class="headerlink" title="什么是树方法？"></a>什么是树方法？</h3><p>在深入探讨机器学习中树方法的理论基础之前，先从示例开始是很有帮助的。</p>
<p>想象一下你每个星期一打篮球。此外，你总是邀请同一个朋友来和你一起玩。</p>
<p>有时朋友真的来了。有时他们没有。</p>
<p>决定是否来取决于许多因素，如天气，温度，风和疲劳。您开始注意到这些功能，并开始跟踪它们，同时您朋友决定是否播放。</p>
<p>您可以使用这些数据来预测你的朋友是否会出现打篮球。可以使用的一种技术是决策树。以下是此决策树的外观：</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/introduction-decision-tree/decision-tree.png" alt="An example of a decision tree"></p>
<p>每个决策树都有两种类型的元素：</p>
<ul>
<li><code>Nodes</code>：树根据某些属性的值拆分的位置</li>
<li><code>Edges</code>：拆分到下一个节点的结果</li>
</ul>
<p>您可以在上面的图像中看到 ， 和 的 节点。每个属性的每个潜在值都有一个边。<code>outlook``````humidity``````windy</code></p>
<p>下面是在继续操作之前应了解的另外两个决策树术语：</p>
<ul>
<li><code>Root</code>：执行第一次拆分的节点</li>
<li><code>Leaves</code>：预测最终结果的终端节点</li>
</ul>
<p>现在，您对决策树有了基本的了解。我们将在下一节中了解如何从头开始构建决策树。</p>
<h3 id="如何从头开始构建决策树"><a href="#如何从头开始构建决策树" class="headerlink" title="如何从头开始构建决策树"></a>如何从头开始构建决策树</h3><p>建立决策树比你想象的要难。这是因为决定要拆分数据的功能（这是属于<a href="https://zshipu.com/t?url=https://en.wikipedia.org/wiki/Entropy">熵</a>和信息<a href="https://zshipu.com/t?url=https://machinelearningmastery.com/information-gain-and-mutual-information/#:~:text=Information+gain+is+the+reduction,before+and+after+a+transformation.">增益</a>领域的主题）是一个数学上复杂的问题。</p>
<p>为了解决这个问题，机器学习从业者通常使用许多决策树，使用选择为拆分的要素的随机样本。</p>
<p>换句话说，每次拆分时，都会为每个树选择新的要素随机样本。这种技术称为<strong>随机林</strong>。</p>
<p>通常，从业者通常选择要素随机样本（表示）的大小作为数据集（表示）中总要素数的平方根。简洁，是 的平方根，然后从 随机选择特定要素。<code>m``````p``````m``````p``````m</code></p>
<p>如果这现在不完全有意义，不要担心。当您最终构建第一个随机林模型时，它将更加清晰。</p>
<h3 id="使用随机林的好处"><a href="#使用随机林的好处" class="headerlink" title="使用随机林的好处"></a>使用随机林的好处</h3><p>假设您正在使用具有非常强大功能的数据集。换句话说，数据集有一个功能比数据集中的其他功能更具有预测最终结果。</p>
<p>如果要手动构建决策树，则使用此功能作为决策树的顶部拆分是有意义的。这意味着您将有多个预测高度相关的树。</p>
<p>我们希望避免这种情况，因为取高度相关变量的平均值不会显著降低方差。通过随机选择随机林中每个树的特征，树变得不相关，并减小生成的模型的方差。这种相互性是使用随机林而不是手工决策树的主要优点</p>
<h3 id="章节总结-3"><a href="#章节总结-3" class="headerlink" title="章节总结"></a>章节总结</h3><p>本文简要总结了您学到的关于决策树和随机林的知识：</p>
<ul>
<li>可以使用决策树预测的问题示例</li>
<li>决策树的元素： 、 、 和<code>nodes``````edges``````roots``````leaves</code></li>
<li>如何随机采样决策树特征，使我们能够构建一个随机林</li>
<li>为什么使用随机林来关联变量有助于降低最终模型的方差</li>
</ul>
<h1 id="支持矢量机"><a href="#支持矢量机" class="headerlink" title="支持矢量机"></a>支持矢量机</h1><p><a href="https://zshipu.com/t?url=https://nickmccullum.com/python-machine-learning/support-vector-machines-python/">支持向量机</a>是分类算法（尽管从技术上讲，它们也可用于解决回归问题），它们通过切片划分类别之间的最广泛差距将数据集划分为多个类别。这一概念将在一瞬间通过可视化来更加清晰。</p>
<h3 id="什么是支持向量机？"><a href="#什么是支持向量机？" class="headerlink" title="什么是支持向量机？"></a>什么是支持向量机？</h3><p><a href="https://zshipu.com/t?url=https://en.wikipedia.org/wiki/Support_vector_machine">支持向量机</a>（简称 SVM）是受监督的机器学习模型，具有分析数据和识别模式的相关学习算法。</p>
<p>支持向量机可用于分类问题和回归问题。在本文中，我们将专门研究支持向量机用于解决分类问题。</p>
<h3 id="支持矢量机的工作原理是什么？"><a href="#支持矢量机的工作原理是什么？" class="headerlink" title="支持矢量机的工作原理是什么？"></a>支持矢量机的工作原理是什么？</h3><p>让我们深入了解支持向量机的真正工作方式。</p>
<p>给定一组训练示例（每个示例都标记为属于两个类别之一），支持向量机器训练算法可生成模型。此模型将新示例分配给两个类别之一。这使得支持向量机成为非概率二进制线性分类器。</p>
<p>SVM 使用几何进行分类预测。</p>
<p>更具体地说，SVM 模型将数据点映射为空间中的点，并将单独的类别进行划分，以便它们除以尽可能宽的开放间隙。根据它们所属的间隙的哪一侧，预测新数据点属于一个类别。</p>
<p>下面是一个示例可视化，可帮助您了解支持向量机背后的直觉：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2020/06/image-57.png"></p>
<p>正如您所看到的，如果新数据点落在绿线的左侧，它将使用红色类别标记。同样，如果新数据点落在绿线的右侧，它将被贴上属于蓝色类别的标签。</p>
<p>这条绿线被称为<strong>超平面</strong>，它是支持向量机算法的重要词汇。</p>
<p>让我们来看看支持向量机的不同可视表示形式：</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2020/06/image-58.png"></p>
<p>在此图中，超平面标记为<strong>最佳超平面</strong>。支持向量机理论将<strong>最佳超平面</strong>定义为最大化每个类别最近数据点之间的边距。</p>
<p>如您所见，边距线实际上触及三个数据点 - 两个来自红色类别，一个来自蓝色类别。这些接触边距线的数据点称为<strong>支持向量</strong>，是支持向量机从中获取其名称的位置。</p>
<h3 id="章节总结-4"><a href="#章节总结-4" class="headerlink" title="章节总结"></a>章节总结</h3><p>以下是您刚刚了解到的支持向量机的简要摘要：</p>
<ul>
<li>支持向量机是受监督机器学习算法的一个示例</li>
<li>支持向量机可用于解决分类和回归问题</li>
<li>支持向量机如何使用超平面对数据点进行分类，该<strong>超平面</strong>可最大化数据集中类别之间的差值</li>
<li>在支持向量机中触摸边距线的数据点称为<strong>支持向量</strong>。这些数据点是支持向量机从中派生其名称的位置。</li>
</ul>
<h1 id="K-意味着聚类"><a href="#K-意味着聚类" class="headerlink" title="K-意味着聚类"></a>K-意味着聚类</h1><p><a href="https://zshipu.com/t?url=https://nickmccullum.com/python-machine-learning/k-means-clustering-python/">K-意味着聚类</a>是一种机器学习算法，允许您识别数据集中类似数据段。</p>
<h3 id="什么是-K-意味着聚类？"><a href="#什么是-K-意味着聚类？" class="headerlink" title="什么是 K-意味着聚类？"></a>什么是 K-意味着聚类？</h3><p>K-意味着聚类是一种不受监督的机器学习算法。</p>
<p>这意味着它占用了未标记的数据，并尝试将数据中的相似观测组分组在一起。</p>
<p>K-意味着聚类算法对于解决实际问题非常有用。以下是此机器学习模型的一些用例：</p>
<ul>
<li>营销团队的客户细分</li>
<li>文档分类</li>
<li>亚马逊、UPS 或联邦快递等公司的交付路线优化</li>
<li>识别和应对城市内的犯罪中心</li>
<li>专业体育分析</li>
<li>预测和预防网络犯罪</li>
</ul>
<p>K 表示聚类算法的主要目标是将数据集划分为不同的组，以便每个组中的观测值彼此相似。</p>
<p>下面是实际外观的视觉表示形式：</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/introduction-k-means-clustering/k-means-clustering.png" alt="A Visualization of a K Means Clustering Algorithm"></p>
<p>我们将在本教程的下一节中探讨 K 表示聚类背后的数学。</p>
<h3 id="K-意味着聚类算法的工作原理是什么？"><a href="#K-意味着聚类算法的工作原理是什么？" class="headerlink" title="K-意味着聚类算法的工作原理是什么？"></a>K-意味着聚类算法的工作原理是什么？</h3><p>运行 K-表示聚类算法的第一步是选择要将数据划分为的群集数。此群集数是算法名称中引用的值。<code>K</code></p>
<p>在 K-表示聚类算法中选择值是一个重要的选择。在本文中，我们将更多地讨论如何选择后面的正确值。<code>K``````K</code></p>
<p>接下来，必须随机将数据集中的每个点分配给随机群集。这提供了我们的初始赋值，然后运行以下迭代，直到群集停止更改：</p>
<ul>
<li>通过取取该群集内点的平均矢量来计算每个群集的质心</li>
<li>将每个数据点重新分配给具有最近质心的群集</li>
</ul>
<p>下面是一个动画，说明对于值 为 的 K-表示聚类算法来说，这在实践中是如何工作的。您可以看到由黑色字符表示的每个群集的质心。<code>K``````3``````+</code></p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/introduction-k-means-clustering/k-means-iteration.gif" alt="A Visualization of a K Means Clustering Algorithm"></p>
<p>如您所见，此迭代将继续，直到群集停止更改 - 这意味着数据点不再分配给新的群集。</p>
<h3 id="为-K-选择正确的-K-值意味着聚类算法"><a href="#为-K-选择正确的-K-值意味着聚类算法" class="headerlink" title="为 K 选择正确的 K 值意味着聚类算法"></a>为 K 选择正确的 K 值意味着聚类算法</h3><p>为 K-意味着聚类算法选择适当的值实际上相当困难。选择”最佳”值没有”正确”答案。<code>K``````K</code></p>
<p>机器学习从业者经常使用的一种方法称为<strong>肘部方法</strong>。</p>
<p>要使用弯头方法，您需要做的第一件事是计算一组值的 K 表示聚类算法的平方误差 （SSE） 的总和。K 中的 SSE 表示聚类算法定义为群集中每个数据点与群集的质心之间的平方距离之和。<code>K</code></p>
<p>作为此步骤的示例，您可以计算 SSE 的值， 和 。<code>K``````2``````4``````6``````8``````10</code></p>
<p>接下来，您需要针对这些不同的值生成 SSE 的绘图。您将看到错误会随着值的增加而减小。<code>K``````K</code></p>
<p>这是有道理的 - 在数据集中创建的类别越多，每个数据点都越接近其特定群集的中心。</p>
<p>话虽如此，肘部法背后的理念是选择一个值，即上证所突然放慢下跌速度。此突然减少在图形中生成 。<code>K``````elbow</code></p>
<p>例如，下面是 SSE 反对 的图表。在这种情况下，弯头方法建议使用近似 值。<code>K``````K``````6</code></p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/introduction-k-means-clustering/elbow-method.png" alt="A Visualization of a K Means Clustering Algorithm"></p>
<p>重要的是，只是对使用价值的估计。K-表示聚类算法中永远不会有”最佳”值。与机器学习领域的许多内容一样，这是一个高度依赖于情况的决策。<code>6``````K``````K</code></p>
<h3 id="章节总结-5"><a href="#章节总结-5" class="headerlink" title="章节总结"></a>章节总结</h3><p>以下是您在本文中学到的内容的简要摘要：</p>
<ul>
<li>K-意味着聚类算法能够解决的无监督机器学习问题示例</li>
<li>K-意味着聚类算法的基本原理</li>
<li>K-意味着聚类算法的工作原理</li>
<li>如何使用弯头方法在 K 表示聚类模型中选择 适当的值<code>K</code></li>
</ul>
<h1 id="主要组件分析"><a href="#主要组件分析" class="headerlink" title="主要组件分析"></a>主要组件分析</h1><p><a href="https://zshipu.com/t?url=https://nickmccullum.com/python-machine-learning/principal-component-analysis-python/">主要组件分析</a>用于将多要素数据集转换为具有较少功能的转换数据集，其中每个新功能都是预先存在的要素的线性组合。此转换数据集旨在以更简单得多来解释原始数据集的大部分差异。</p>
<h3 id="什么是主要组件分析？"><a href="#什么是主要组件分析？" class="headerlink" title="什么是主要组件分析？"></a>什么是主要组件分析？</h3><p>主要组件分析是一种机器学习技术，用于检查变量集之间的相互关系。</p>
<p>说的不同，主要成分分析研究变量集，以便确定这些变量的基础结构。</p>
<p>主要成分分析有时称为**<strong>因子分析**</strong>。</p>
<p>基于此描述，您可能会认为主要分量分析与线性回归非常相似。</p>
<p>事实并非如此。事实上，这两种技术有一些重要的区别。</p>
<h3 id="线性回归与主分量分析的区别"><a href="#线性回归与主分量分析的区别" class="headerlink" title="线性回归与主分量分析的区别"></a>线性回归与主分量分析的区别</h3><p>线性回归确定数据集的最佳拟合线。主组件分析确定几个最适合数据集的正交行。</p>
<p>如果您不熟悉正<strong>交</strong>一词，则只表示线彼此成直角（90 度），如地图上的北、东、南和西。</p>
<p>让我们考虑一个示例，以帮助您更好地理解这一点。</p>
<p><img src="https://nickmccullum.com/images/python-machine-learning/introduction-principal-component-analysis/principal-component-analysis.png" alt="A principal component analysis"></p>
<p>查看此图像中的轴标签。</p>
<p>在此图像中，x 轴主组件示例数据集中 73% 的方差。y 轴主组件解释了数据集中大约 23% 的方差。</p>
<p>这意味着数据集中 4% 的方差仍无法解释。您可以通过向分析添加更多主要组件来进一步减少此数字。</p>
<h3 id="章节总结-6"><a href="#章节总结-6" class="headerlink" title="章节总结"></a>章节总结</h3><p>以下是您在本教程中学到的关于主要组件分析的简要摘要：</p>
<ul>
<li>该主要组件分析试图找到确定数据集中可变性的正交因子</li>
<li>主分量分析与线性回归的区别</li>
<li>在数据集内部可视化时，正交主体组件的外观</li>
<li>添加更多主要组件可以帮助您解释数据集中的更多差异</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-06-21T03:08:27.000Z" title="2020-06-21T03:08:27.000Z">2020-06-21</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.467Z" title="2020-09-08T14:03:00.467Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">4 分钟读完 (大约638个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/21/%E6%9C%80%E6%96%B0%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A%2001/">最新技术周刊 01</a></h1><div class="content"><p>  这是本周值得您花时间的五个链接：</p>
<p>1.以下是9种最常用的机器学习算法，所有算法均以纯英文解释。本文将以初学者友好的方式向您介绍随机森林，K最近邻，线性回归和其他方法。 （阅读18分钟）： <a href="https://zshipu.com/t?url=https://www.freecodecamp.org/news/a-no-code-intro-to-the-9-most-important-machine-learning-algorithms-today/">https://www.freecodecamp.org/news/a-no-code-intro-to-the-9-most-important-machine-learning-algorithms-today/</a> : <a href="https://zshipu.com/t?url=https://www.freecodecamp.org/news/a-no-code-intro-to-the-9-most-important-machine-learning-algorithms-today/">https://www.freecodecamp.org/news/a-no-code-intro-to-the-9-most-important-machine-learning-algorithms-today/</a></p>
<p>2.如果您想获得云认证，这是一个免费的Azure云认证课程。它将教您通过AZ-900考试所需了解的概念。 （观看3小时）： <a href="https://zshipu.com/t?url=https://www.freecodecamp.org/news/azure-fundamentals-course-az900/">https://www.freecodecamp.org/news/azure-fundamentals-course-az900/</a> : <a href="https://zshipu.com/t?url=https://www.freecodecamp.org/news/azure-fundamentals-course-az900/">https://www.freecodecamp.org/news/azure-fundamentals-course-az900/</a></p>
<p>3. Flutter是Google提供的功能强大的新框架，可让您使用相同的代码库同时为iPhone，Android，Web和PC生成应用程序。本课程将教您Flutter基础知识。 （观看3小时）： <a href="https://zshipu.com/t?url=https://www.freecodecamp.org/news/flutter-app-course-mobile-web-desktop/">https://www.freecodecamp.org/news/flutter-app-course-mobile-web-desktop/</a> : <a href="https://zshipu.com/t?url=https://www.freecodecamp.org/news/flutter-app-course-mobile-web-desktop/">https://www.freecodecamp.org/news/flutter-app-course-mobile-web-desktop/</a></p>
<p>4.从统计学上讲，DevOps是您可以进入的收入最高的非管理开发人员领域。此免费课程将教您一些Linux，网络以及其他一些入门学习DevOps所需的概念。这不是入门级的职业，但是如果您已经具备一些基本的编程技能，那么这将使您朝着正确的方向前进。 （观看3小时）： <a href="https://zshipu.com/t?url=https://www.freecodecamp.org/news/devops-prerequisites-course/">https://www.freecodecamp.org/news/devops-prerequisites-course/</a> : <a href="https://zshipu.com/t?url=https://www.freecodecamp.org/news/devops-prerequisites-course/">https://www.freecodecamp.org/news/devops-prerequisites-course/</a></p>
<p>5.如何使用Node.js和Web套接字创建专业的聊天API。这个全面的教程将帮助您逐步构建自己的API，并为您提供许多编码实践。 （阅读35分钟）： <a href="https://zshipu.com/t?url=https://www.freecodecamp.org/news/create-a-professional-node-express/">https://www.freecodecamp.org/news/create-a-professional-node-express/</a> : <a href="https://zshipu.com/t?url=https://www.freecodecamp.org/news/create-a-professional-node-express/">https://www.freecodecamp.org/news/create-a-professional-node-express/</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-06-20T09:19:35.000Z" title="2020-06-20T09:19:35.000Z">2020-06-20</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.449Z" title="2020-09-08T14:03:00.449Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">25 分钟读完 (大约3822个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/20/%E5%88%9D%E5%88%9B%E5%9B%A2%E9%98%9F%E9%80%89%E6%8B%A9%20Vert.x%20/">初创团队选择 Vert.x</a></h1><div class="content"><p>（2019-12-04更新：增加 REST 一篇教程）</p>
<p>（2019-01-02更新：增加采用 Vert.x 和 RxJava 不用 Redis 做数据缓存的做法，进阶阅读</p>
<p>（2018-06-05更新：增加对Real World demo评述，增加一篇 Clement Escoffier 的教程</p>
<p>（2018-04-17更新：修正关于 <a href="https://zshipu.com/t?url=http://escoffier.me/vertx-hol/">Vert.x - From zero to (micro)-hero</a> 的评述）</p>
<p>（2018-02-22更新：增加关于多语言选择内容，增加一篇教程）</p>
<p>最近需要做一个可穿戴 IoT 的全栈应用，决定采用关注了很久的 Vert.x 框架。 团队只有不到3人，之前的项目经历多是 C/C++, Clojure 和 Python，所以迁移到 Vert.x 有些学习成本。一方面是对概念和工具不熟悉，另一方面则是希望了解 Vert.x 在项目中的最佳实践，尽量少踩坑。</p>
<p>这篇文章列出一些我们在技术选型时的考虑，以及觉得很有启发的参考项目或教程，希望对于其他迁移型 Vert.x 初学者有所帮助。</p>
<h2 id="Vert-x-能解决的问题"><a href="#Vert-x-能解决的问题" class="headerlink" title="Vert.x 能解决的问题"></a>Vert.x 能解决的问题</h2><p>开源的 Vert.x 其实不是一个框架，而是一个以“异步非阻塞”编程模型为核心思想的工具集。它基本上囊括了开发网络应用时需要用到的所有组件，不管是搭建服务、路由管理、用户权限理、数据库对接、网络通讯、集群管理……都可以用 Vert.x 搞定。</p>
<p>Vert.x 的另一个重要特性是支持7种编程语言，需要糙快猛时可以用脚本语言（如 Ruby/Groovy，可惜暂不支持 Python），需要专注数据处理则可以用函数式语言（如 Scala/Kotlin，后面有望加入 <a href="https://zshipu.com/t?url=https://eta-lang.org/contribute/gsoc/2018#vertx">Haskell</a> 和 <a href="https://zshipu.com/t?url=https://zhuanlan.zhihu.com/p/33841273">Clojure</a>），需要兼顾前后端时可以用 Javascript（最近还推出了基于 GraalVM 的 <a href="https://zshipu.com/t?url=https://reactiverse.io/es4x/">es4x</a>）.</p>
<p>支持7种开发语言是 Vert.x 主打的一项特性</p>
<p>而且，Vert.x 允许同一个项目的不同模块用不同语言来开发，也就是 polyglot. 考虑到初创团队成员加入时的自带技能往往并不一致，所以 polyglot 也是一个对初创团队很友好的特性。</p>
<p>截至2019年12月4日， Vert.x 发布了3.8.4 版本，接下来会有一个大版本号4.0的升级。目前Github 星标超过 1w，充分显示了这个工具集的健壮程度。值得一提的是，Vert.x 的好几位贡献者来自中国。一项重要功能——对 kotlin-coroutine 的支持——就是出自上海网友 steam1984 之手。</p>
<p>补充一段知乎 Vert.x 著名答主</p>
<p> <a href="https://zshipu.com/t?url=//www.zhihu.com/people/019f06627adc51d9cd030517a6f14c26">@圆胖肿</a></p>
<p>的评论，Vert.x 应该使用那种语言开发？</p>
<blockquote>
<p>如果之前熟悉c/c++的，直接上java<br>如果之前熟悉python的，用groovy，groovy跟python很接近，是java化的python<br>如果之前熟悉clojure的，那就用<a href="https://zshipu.com/t?url=https://zhuanlan.zhihu.com/p/33841273">我们提供的支持</a><br>这样三个人都学点新的东西，就可以通过vert.x整合起来了，具体的整合可以参考专栏之前的文章：<a href="https://zshipu.com/t?url=https://zhuanlan.zhihu.com/p/30913753">Vert.x的一个常见问题以及多语言制霸环境配置</a></p>
</blockquote>
<h2 id="初创团队为什么选择-Vert-x"><a href="#初创团队为什么选择-Vert-x" class="headerlink" title="初创团队为什么选择 Vert.x"></a>初创团队为什么选择 Vert.x</h2><p>初创阶段，由于 Vert.x 功能全面、允许用多种语言开发，所以对初创小团队而言能够激发出较高的生产力。而且开发者社区活跃，所以技术虽新，却也不至于掉到坑里没人捞。</p>
<p>等到用户规模上去以后，Vert.x 具有 JVM 娘胎里带来的稳定性优势，而又通过类似 Node.js 的异步范式保证了多用户性能和可扩展性。据此分析，采用 Vert.x 做的软件项目如果一不小心起飞了，不用经历“脚本 -&gt; Java”这种互联网业常见的转平台之痛。</p>
<p>总结一下，我们认为：</p>
<blockquote>
<p><strong>Vert.x 是一个不管“从0到1”还是“从1到N”阶段都适用的工具集。</strong></p>
</blockquote>
<h2 id="Vert-x-参考项目及上手资料（不断更新中）"><a href="#Vert-x-参考项目及上手资料（不断更新中）" class="headerlink" title="Vert.x 参考项目及上手资料（不断更新中）"></a>Vert.x 参考项目及上手资料（不断更新中）</h2><p>官方的 <a href="https://zshipu.com/t?url=https://github.com/vert-x3/vertx-examples">vertx-examples</a> 应该是上手的最佳资料了。它与 Vert.x 同步更新，所有例子都给出了直接可以运行的工程文件，用 Intellij IDEA 等 IDE 可以直接跑。不过， vertx-examples 里面给出的都是一个个小品级的例程，拿来作为项目的参考还是零散了一点。</p>
<p>此外，由于Vert.x 不是框架，所以对代码的组织结构没有什么限制。这对于项目经验丰富的开发者而言是加分项，但对于初学者来说太 free style 了也会增加上手难度。</p>
<p>还有一点比较遗憾的是，Vert.x 还没有一套比较完整的 RealWorld demo. 基本上现在能找到的流行框架都把这个 Medium 的克隆项目写了一遍（ <a href="https://zshipu.com/t?url=https://github.com/gothinkster/realworld">Github 链接</a>），方便大家上手和比较。但至今为止 Vert.x 的克隆还基本等于没有，有兴趣的同学可以追踪一下这个 <a href="https://zshipu.com/t?url=https://github.com/skanjo/realworld-vertx">repo</a>。</p>
<p>下面把网上能够找到的 Vert.x 参考项目和教程汇总一下，方便初学者们找到一款与自己需求类似的原型，目的是通过阅读和重构来上手。评述部分比较侧重我们的可穿戴 IoT 需求，即数据实时性要求较高，几乎类似于网络游戏。</p>
<p>1）官方的用 Vert.x 搭建 Wiki 教程:</p>
<ul>
<li>网址：<a href="https://zshipu.com/t?url=http://vertx.io/docs/guide-for-java-devs/">教程</a>，<a href="https://zshipu.com/t?url=https://github.com/vert-x3/vertx-guide-for-java-devs">GitHub repo</a></li>
<li>要点：前后端通信，Verticle 间通信，异步模型</li>
<li>评述：如果做对实时性要求没有那么高的应用（非游戏、非 IoT），那么这个教程就非常够用了。</li>
</ul>
<p>2）A multi-user realtime game by Burr Sutter:</p>
<ul>
<li>网址：<a href="https://zshipu.com/t?url=https://www.youtube.com/watch?v=MydhJVPEnzU">Youtube 视频</a>，<a href="https://zshipu.com/t?url=https://github.com/burrsutter/vertx-game-server">GitHub repo</a></li>
<li>要点：Reactive 编程，eventbus 通信</li>
<li>评述：非常惊艳的现场演示，服务器—客户端实时互动，玩家间实时互动，绝对的一 demo 胜千言。不过除了几个视频以外没找到任何的文字教程，Github 上的文档也写的比较简单，所以没有实际测试过。但 Burr Sutter 的几次演讲视频的确是我们最初对 Vert.x 动心的原因。</li>
</ul>
<p>3）Vert.x console:</p>
<ul>
<li>网址：<a href="https://zshipu.com/t?url=https://github.com/yunyu/vertx-console">GitHub repo</a>，<a href="https://zshipu.com/t?url=https://www.youtube.com/watch?v=I3ZWuOngesU">Youtube 演示视频</a></li>
<li>要点：Vue.js，docker，实时监控</li>
<li>评述：由英语很棒的青年开发者 Yunyu Li 在 GSoC 2017 中贡献，由于 Vert.x 3.5.1 刚刚修复了此前 web client 的一个 bug，新版 vertx-console 还没来得及测试。整体上是一个完成度相当高的全栈项目，尤其是监控部分对于 IoT 应用非常关键。</li>
</ul>
<p>4）InMood4Life:</p>
<ul>
<li>网址：<a href="https://zshipu.com/t?url=https://medium.com/inmoodforlife/vert-x-the-perfect-reactor-for-iot-devices-5d0b3cb36a98">博客文章</a>，<a href="https://zshipu.com/t?url=https://github.com/BreizhBeans/InTheMood4Life">GitHub Repo</a></li>
<li>要点： Gradle 项目，完全 Groovy 开发，IoT，外设协同</li>
<li>评述：众多上手项目中唯一一个不用 Java 开发的，使用了 Gradle + Groovy 这个组合。同时这个项目桥接了蓝牙设备，体现了 Vert.x 在软硬件协同项目中的前景。这类项目常见的上手难度在于没有那几样外设则无法跑起来，只能看看代码过过干瘾。</li>
</ul>
<p>5）Vert.x starter:</p>
<ul>
<li>网址：<a href="https://zshipu.com/t?url=https://vertx-starter.jetdrone.xyz/">https://vertx-starter.jetdrone.xyz/</a>, <a href="https://zshipu.com/t?url=https://www.youtube.com/watch?v=WA9P-khaWI4">视频演示</a></li>
<li>要点：增减组件、配置依赖关系、前后端匹配</li>
<li>评述：Vert.x 主程之一 pmlopes 做的最小项目生成器，点点按钮就能生成工程文件。我们主要研究了一下用 Maven (Java/Kotlin)+ Vue.js 配置出来的起步工程，觉得是很好的全栈上手参考。Java + Maven 组合应该是作者主要精力所在，经测可用; Java + Gradle 的可配置项少一点，但也经测可用。Kotlin + Maven 生成项目有 bug，反映给作者后打了补丁，但也可以看出可能暂时不是维护重点。添加 Vert.x 的模块很方便，但只是添加了 maven 包依赖，没有起始代码。相比之下， Clojure 的 <a href="https://zshipu.com/t?url=http://www.luminusweb.net/">Luminus</a> 项目功能与之类似，但每加一个包都会生成相应的起始代码，大大降低了上手难度。另外一个问题是几乎没有文档，牵涉到前端的运行过程要看上面的视频演示。Vert.x 官方也有一个 <a href="https://zshipu.com/t?url=http://start.vertx.io/">starter</a>，与 pmlopes 自己的私房 xyz starter 功能类似，但是要简单一点。猜测两个 starter 同源，应该会合并。</li>
</ul>
<p>5）一个基于 microservice 的实时商品报价平台样例</p>
<ul>
<li>网址：<a href="https://zshipu.com/t?url=http://escoffier.me/vertx-hol/">Vert.x - From zero to (micro)-hero</a></li>
<li>要点：分布式、微服务 microservice、RxJava、实时监控</li>
<li>评述：重点推荐。Vert.x 主创人员 Clement Escoffier 和 Julien Viet 创作的一个内容翔实的教程，把框架代码写好了，让初学者把核心业务代码填到需要的地方去。提供了懒人式打开即用的源代码，最终的效果是一个有前后端、实时曲线、服务追踪的比较全面的样例工程。</li>
</ul>
<p>6）Vertx Blueprint (三个项目）：</p>
<ul>
<li>网址：<a href="https://zshipu.com/t?url=http://vertx.io/blog/vert-x-blueprint-tutorials/">博客文章</a>，GitHub repo (<a href="https://zshipu.com/t?url=https://github.com/sczyh30/vertx-blueprint-todo-backend">Todo</a>, <a href="https://zshipu.com/t?url=https://github.com/sczyh30/vertx-blueprint-job-queue">Kue</a>, <a href="https://zshipu.com/t?url=https://github.com/sczyh30/vertx-blueprint-microservice">Micro Shop</a>)</li>
<li>要点： 前后端全栈、Eventbus 通信、微服务 microservice 架构、docker</li>
<li>评述： 由杭州网友 <a href="https://zshipu.com/t?url=https://github.com/sczyh30/vertx-blueprint-microservice">sczyh30</a> 在 GSoC 2016 中贡献，三个例子循序渐进，质量很高。第三个 Micro Shop 的例子是一个全栈的电子商务网站，全部 docker 部署，啃下来就基本上明白 Vert.x microservice 在生产中怎么做了。不过 Micro Shop 跑起来需要自己配置 docker-machine 环境。在测试中发现代码与最新版本的 Keycloak 用户权限管理模块有点冲突，作者正在修改中。</li>
</ul>
<p>7）VertxUp / VertxZero:</p>
<ul>
<li>网址：<a href="https://zshipu.com/t?url=http://www.vertxup.cn/">Vertx Zero Up Framework</a></li>
<li>要点：Dependency Injection、与 Spring 的对应理解、复杂项目组织方式</li>
<li>评述：我们之前没有 Spring 开发经验，这个项目理解起来有些困难。但对于熟悉 Spring 的开发者是很好的迁移途径，由重庆网友 <a href="https://zshipu.com/t?url=https://github.com/silentbalanceyh">silentbalanceyh</a> 开发。</li>
</ul>
<p>8）基于Vert.x和RxJava 2构建通用的爬虫框架</p>
<ul>
<li>网址：<a href="https://zshipu.com/t?url=http://blog.csdn.net/slfq6of5o7ah/article/details/79227286">文章</a>，<a href="https://zshipu.com/t?url=https://github.com/fengzhizi715/NetDiscovery">GitHub repo</a></li>
<li>要点：爬虫、http client</li>
<li>评述：爬虫功能与我们这次的 IoT 应用稍有不同，但也是web app 中的一个常见需求。由网友沈哲开发。</li>
</ul>
<p>9）另一个基于微服务的例子</p>
<ul>
<li>网址：<a href="https://zshipu.com/t?url=https://piotrminkowski.wordpress.com/2017/08/24/asynchronous-microservices-with-vert-x/">文章</a>，<a href="https://zshipu.com/t?url=https://github.com/piomin/sample-vertx-microservices.git">GitHub repo</a></li>
<li>要点：异步与 MongoDB 通信，vertx-config，Consul 服务发现</li>
<li>评述：主要阅读了教程文章，测试环境介绍得不太全所以没有实际测试。但项目就两个模块，结构比较清晰，适合初学时阅读理解。</li>
</ul>
<p>10）<a href="https://zshipu.com/t?url=https://developers.redhat.com/blog/author/cescoffier/">Clement Escoffier</a> 写的又一套新手教程</p>
<ul>
<li>网址：<a href="https://zshipu.com/t?url=https://developers.redhat.com/blog/2018/03/13/eclipse-vertx-first-application/">文章</a>，<a href="https://zshipu.com/t?url=https://github.com/redhat-developer/introduction-to-eclipse-vertx">GitHub repo</a></li>
<li>要点： web app 入门，异步通讯，简单 REST，RxJava 解决 callback hell</li>
<li>评述：主要开发者 Clement 可谓在 Vert.x 的教学推广上不遗余力。可惜的是仍然没有一个完整的类似 RealWorld demo (conduit) 的例子。不过 vertx-examples 里面的例子是很全的，对于不想当伸手党的新手来说，其实弹药充足的很。</li>
</ul>
<p>11）采用 Vert.x 和 RxJava 做数据缓存</p>
<ul>
<li>网址：<a href="https://zshipu.com/t?url=https://blog.danlew.net/2015/06/22/loading-data-from-multiple-sources-with-rxjava/">文章</a>，<a href="https://zshipu.com/t?url=https://github.com/dlew/rxjava-multiple-sources-sample">Github repo</a></li>
<li>要点： vert.x 做缓存，适用场合类似 Redis 但据说性能更高，原因是节省了很多 IO</li>
<li>评述：新手如果学做 Hello world 应用应该不需要这篇教程。然而缓存是任何严肃应用很早期就会遇到的问题。个人认为如果在 vert.x 中再开设一个 redis，好处是搭积木起应用快，坏处是需要多维护一个 redis 服务。这对初创团队来说增加了部署复杂度，也分散运维精力。考虑到 vert.x+postgres 几乎是可以标配到所有初创应用，只依赖这2个标配工具如果能顺带做起高性能缓存，那么对初创团队而言是节省精力的。</li>
</ul>
<p>12）在 Vert.x 上面做 REST 的一个教程</p>
<ul>
<li>网址：<a href="https://zshipu.com/t?url=https://medium.com/pharos-production/vert-x-restful-services-on-java-6a4ed8a30489">文章</a>，<a href="https://zshipu.com/t?url=https://github.com/PharosProduction/tutorial-vertx-rest-on-java">GitHub repo</a></li>
<li>要点：平实的一篇 Vert.x + REST 的教程，不多不少</li>
<li>评述：难得有一篇从 Maven 配置开始讲起，小白友好，尤其是对非 Java 生态转过来的开发者友好。有项目以后自己从头开始建 Maven 工程的情况并不多，但是这种手把手的教程对于新手是非常有意义的。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-06-19T12:06:53.000Z" title="2020-06-19T12:06:53.000Z">2020-06-19</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.346Z" title="2020-09-08T14:03:00.346Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">28 分钟读完 (大约4130个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/19/GraphQL%20%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/">GraphQL 入门指南</a></h1><div class="content"><p>今天最常讨论的术语之一是 API。很多人不知道 API 的确切内容。基本上，API 代表<strong>应用程序编程接口。</strong>顾名下，这是一个界面，人们——开发人员、用户、消费者——可以与之交互。</p>
<p>您可以将 API 视为调酒师。你请酒保喝一杯，他们给你你想要的。简单。那么，为什么这是个问题呢？</p>
<p>自现代网络开始以来，构建 API 并不像听起来那么难。但是，学习和理解 API 是。开发人员组成使用 API 构建某些内容或仅使用数据的用户。因此，您的 API 应该尽可能干净和直观。设计良好的 API 非常容易使用和学习。这也是直观的，在开始设计 API 时要记住这一点。</p>
<p>长期以来，我们一直在使用 REST 来构建 API。随之而来的是一些问题。使用 REST 设计构建 API 时，您将面临一些问题，例如：</p>
<p>1） 您将有很多端点</p>
<p>2） 开发人员将更难学习和了解您的 API</p>
<p>3） 信息获取过度和不足</p>
<p>为了解决这些问题，Facebook 创建了 GraphQL。今天，我认为 GraphQL 是构建 API 的最佳方式。本文将告诉您为什么今天应该开始学习它。</p>
<p>在本文中，您将了解 GraphQL 的工作原理。我将向您展示如何使用 GraphQL 创建设计良好、高效、功能强大的 API。</p>
<p>您可能已经听说过 GraphQL，因为很多人和公司都在使用它。由于 GraphQL 是开源的，其社区已经变得庞大。</p>
<p>现在，是时候开始在实践中学习GraphQL是如何工作的，以及所有关于它的魔力。</p>
<h2 id="什么是GraphQL？"><a href="#什么是GraphQL？" class="headerlink" title="什么是GraphQL？"></a><a href="https://zshipu.com/t?url=#what-is-graphql"></a>什么是GraphQL？</h2><p><a href="https://zshipu.com/t?url=https://graphql.org"><strong>GraphQL</strong></a>是 Facebook 开发的开源查询语言。它为我们提供了一种更有效的方法来设计、创建和使用我们的 API。基本上，它是REST的替代品。</p>
<p>GraphQL 有很多功能，例如：</p>
<ol>
<li><p>编写所需的数据，并准确获取所需的数据。不再像我们习惯的 REST 那样<strong>过度提取信息</strong>。</p>
</li>
<li><p>它为我们提供了一<strong>个终结点</strong>，没有更多的版本2或版本3为相同的API。</p>
</li>
<li><p>GraphQL 是<strong>强类型</strong>，因此可以在执行之前验证 GraphQL 类型系统中的查询。它帮助我们构建更强大的 API。</p>
</li>
</ol>
<p>这是 GraphQL 的基本介绍 - 为什么它如此强大，为什么它现在越来越受欢迎。如果你想了解更多关于它，我建议你去<a href="https://zshipu.com/t?url=https://graphql.org/">GraphQL网站</a>，并检查出来。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a><a href="https://zshipu.com/t?url=#getting-started"></a>开始</h2><p>本文的主要目标是学习如何设置 GraphQL 服务器，因此我们目前不会深入探讨这一点。目标是了解 GraphQL 在实践中是如何工作的，因此我们将使用称为 ☄️ <a href="https://zshipu.com/t?url=https://github.com/glennreyes/graphpack">Graphpack</a>的零配置 GraphQL 服务器。</p>
<p>为了开始我们的项目，我们将创建一个新文件夹，您可以随心所欲地命名它。我要命名它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">graphql-server</span><br></pre></td></tr></table></figure>


<p>打开终端并键入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mkdir graphql-server</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>现在，您应该在机器中安装或安装。如果您不知道这些是什么，并且是 JavaScript 编程语言的包管理器。对于 Node.js，默认包管理器为 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br></pre></td></tr></table></figure>




<p>在创建的文件夹中键入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm init -y</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>或者，如果您使用 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">yarn init</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>将为你创建一个文件，并且您安装的所有依赖项和命令都将在那里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package.json</span><br></pre></td></tr></table></figure>


<p>因此，现在，我们将安装我们将使用<strong>的唯一依赖项</strong>。</p>
<p>☄️<a href="https://zshipu.com/t?url=https://github.com/glennreyes/graphpack">图形包</a>允许您创建<strong>具有零配置的</strong>GraphQL 服务器。由于我们刚刚开始使用 GraphQL，这将帮助我们继续前进并学习更多，而不必担心服务器配置。</p>
<p>在终端中，在根文件夹中，安装它像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm install --save-dev graphpack</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>或者，如果您使用 ，则应如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">yarn add --dev graphpack</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>安装_Graphpack_后，转到文件中的脚本，并将以下代码放在其中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package.json</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;dev&quot;: &quot;graphpack&quot;,</span><br><span class="line">   &quot;build&quot;: &quot;graphpack build&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>我们将创建一个名为 的文件夹，它将是我们整个服务器中唯一的文件夹。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src</span><br></pre></td></tr></table></figure>


<p>在文件夹内创建一个名为 “之后”的文件夹，我们将仅创建三个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src</span><br></pre></td></tr></table></figure>


<p>在我们的文件夹中创建一个名为 的文件。在此第一个文件中，放置以下代码：   </p>
<p>src   </p>
<p>schema.graphql   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> type Query &#123;    </span><br><span class="line">    hello: String    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在此文件中将是我们的整个 GraphQL 架构。如果你不知道它是什么，我稍后会解释——别担心。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schema.graphql</span><br></pre></td></tr></table></figure>


<p>现在，在我们的文件夹中，创建第二个文件。调用它，并在此第二个文件中放置以下代码：   </p>
<p>src   </p>
<p>resolvers.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> import &#123; users &#125; from &quot;.&#x2F;db&quot;;</span><br><span class="line"></span><br><span class="line">const resolvers &#x3D; &#123;    </span><br><span class="line">    Query: &#123;    </span><br><span class="line">        hello: () &#x3D;&gt; &quot;Hello World!&quot;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default resolvers;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>此文件将是我们提供将 GraphQL 操作转换为数据的说明的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolvers.js</span><br></pre></td></tr></table></figure>


<p>最后，在_src_文件夹中创建第三个文件。调用此，并在此第三个文件中放置以下代码：   </p>
<p>db.js   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> export let users &#x3D; [    </span><br><span class="line">    &#123; id: 1, name: &quot;John Doe&quot;, email: &quot;john@gmail.com&quot;, age: 22 &#125;,    </span><br><span class="line">    &#123; id: 2, name: &quot;Jane Doe&quot;, email: &quot;jane@gmail.com&quot;, age: 23 &#125;    </span><br><span class="line">];</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在本教程中，我们不使用真实数据库。因此，此文件将模拟数据库，只是为了学习目的。<br>db.js   </p>
<p>现在，我们的文件夹应该如下所示：   </p>
<p>src</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">src</span><br><span class="line"> |--db.js</span><br><span class="line"> |--resolvers.js</span><br><span class="line"> |--schema.graphql</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>现在，如果您运行该命令，或者，如果您使用的 是 ，则应在终端中看到此输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn dev</span><br></pre></td></tr></table></figure>


<p><a href="https://zshipu.com/t?url=https://res.cloudinary.com/practicaldev/image/fetch/s--5vvAFZtb--/c_limit,f_auto,fl_progressive,q_auto,w_880/https://cdn-images-1.medium.com/max/2096/1*FKJYY9qqg4PLBvziWPlhVg.png"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--5vvAFZtb--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/2096/1%2AFKJYY9qqg4PLBvziWPlhVg.png"></a></p>
<p>您现在可以转到 。这意味着我们已经准备好开始编写 GraphQL 中的第一个查询、突变和订阅。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost:4000</span><br></pre></td></tr></table></figure>


<p>您将看到 GraphQL 游乐场，这是一款功能强大的 GraphQL IDE，用于更好的开发工作流。如果您想了解有关 GraphQL 游乐场的更多信息，<a href="https://zshipu.com/t?url=https://www.prisma.io/blog/introducing-graphql-playground-f1e0a018f05d/">请单击此处</a>。</p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a><a href="https://zshipu.com/t?url=#schema"></a>模式</h2><p>GraphQL 有它自己的语言类型，用于编写架构。这是一种称为<strong>架构定义语言 （SDL）</strong>的人类可读架构语法。无论您使用何种技术，SDL 都将相同 ， 您可以将其用于所需的任何语言或框架。</p>
<p>这种架构语言非常有用，因为它很容易理解 API 将具有哪些类型。你可以理解它，只是看对了它。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a><a href="https://zshipu.com/t?url=#types"></a>类型</h2><p>类型是 GraphQL 最重要的特征之一。类型是表示 API 外观的自定义对象。例如，如果要构建社交媒体应用程序，您的 API 应具有帖子、用户、赞、组等类型。</p>
<p>类型具有字段，这些字段返回特定类型的数据。例如，我们将创建一个用户类型，我们应该有一些名称、电子邮件和年龄字段。类型字段可以是任何内容，并且始终返回数据类型为 Int、Float、字符串、布尔、ID、对象类型列表或自定义对象类型。</p>
<p>因此，现在编写我们的第一个类型，转到您的文件，并将已经存在的类型查询替换为以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schema.graphql</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> type User &#123;    </span><br><span class="line">    id: ID!    </span><br><span class="line">    name: String!    </span><br><span class="line">    email: String!    </span><br><span class="line">    age: Int    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>每个用户都有一个 ID，所以我们给它一个 ID 类型。用户也将有一个名称和电子邮件，所以我们给它一个字符串类型，和一个年龄，我们给了一个Int类型。很简单，对吧？</p>
<p>但是，那些呢！在每行的末尾？感叹号表示字段<strong>是不可空的</strong>，这意味着每个字段都必须返回每个查询中的一些数据。我们将在 User 类型中具有的唯一<strong>空</strong>字段是年龄。</p>
<p>在 GraphQL 中，您将处理三个主要概念：</p>
<ol>
<li><p><strong>查询</strong>- 从服务器获取数据的方式。</p>
</li>
<li><p><strong>突变</strong>- 修改服务器上的数据并恢复更新数据（创建、更新、删除）的方式。</p>
</li>
<li><p><strong>订阅</strong>- 保持与服务器的实时连接的方式。</p>
</li>
</ol>
<p>我要向你解释所有。让我们从查询开始。</p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a><a href="https://zshipu.com/t?url=#queries"></a>查询</h2><p>为了简单解释这一点，GraphQL 中的查询是获取数据的方式。在 GraphQL 中查询最美丽的事情之一是，您只是要获得所需的确切数据。没有更多，没有更少。这在我们的 API 中产生了巨大的积极影响 - 不再像使用 REST API 那样过度获取或获取不足的信息。</p>
<p>我们将在 GraphQL 中创建第一个类型查询。我们所有的查询都将在此类类型内结束。因此，首先，我们将转到我们并编写一个名为 Query 的新类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schema.graphql</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> type Query &#123;    </span><br><span class="line">    users: [User!]!    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>很简单：用户查询<strong>将返回给我们一个或多个用户的数组</strong>。它不返回 null，因为我们放入<strong>！</strong>， 这意味着它是一个不可空的查询。它应该总是返回的东西。</p>
<p>但是，我们也可以返回特定的用户。为此，我们将创建一个名为”用户”的新查询。在我们的查询类型中，放置以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">user(id: ID!): User!</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>现在，我们的查询类型应如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> type Query &#123;    </span><br><span class="line">    users: [User!]!    </span><br><span class="line">    user(id: ID!): User!    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>如您所见，在 GraphQL 中查询时，我们还可以传递参数。在这种情况下，要查询特定用户，我们将传递其 ID。</p>
<p>但是，您可能想知道：GraphQL 如何知道数据从何处获取？这就是为什么我们应该有一个文件。该文件告诉 GraphQL 如何以及从何处获取数据。</p>
<p>resolvers.js</p>
<p>首先，转到我们的文件并导入我们刚刚创建的文件。您的文件应如下所示：</p>
<p>resolvers.js</p>
<p>db.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> import &#123; users &#125; from &quot;.&#x2F;db&quot;;</span><br><span class="line"></span><br><span class="line">const resolvers &#x3D; &#123;    </span><br><span class="line">    Query: &#123;    </span><br><span class="line">        hello: () &#x3D;&gt; &quot;Hello World!&quot;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default resolvers;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>现在，我们将创建第一个查询。转到您的文件并替换 hello 函数。现在，查询类型应如下所示：</p>
<p>resolvers.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> import &#123; users &#125; from &quot;.&#x2F;db&quot;;</span><br><span class="line"></span><br><span class="line">const resolvers &#x3D; &#123;    </span><br><span class="line">    Query: &#123;    </span><br><span class="line">        user: (parent, &#123; id &#125;, context, info) &#x3D;&gt; &#123;    </span><br><span class="line">        return users.find(user &#x3D;&gt; user.id &#x3D;&#x3D; id);    </span><br><span class="line">        &#125;,    </span><br><span class="line">        users: (parent, args, context, info) &#x3D;&gt; &#123;    </span><br><span class="line">            return users;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default resolvers;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>现在，要解释它是如何工作的：</p>
<p>每个查询解析器有四个参数。在用户函数中，我们将将 ID 作为参数传递，然后返回与传递的 ID 匹配的特定用户。很简单</p>
<p>在用户函数中，我们只需返回已存在的用户数组。它总是会回到我们所有的用户。</p>
<p>现在，我们将测试我们的查询是否正常工作。转到并放入以下代码：   </p>
<p>localhost:4000</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> query &#123;    </span><br><span class="line">    users &#123;    </span><br><span class="line">        id    </span><br><span class="line">        name    </span><br><span class="line">        email    </span><br><span class="line">        age    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>它应该返回到我们所有的用户。</p>
<p>或者，如果要返回特定用户：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> query &#123;    </span><br><span class="line">    user(id: 1) &#123;    </span><br><span class="line">        id    </span><br><span class="line">        name    </span><br><span class="line">        email    </span><br><span class="line">        age    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>现在，我们将开始学习<strong>突变</strong>，这是GraphQL中最重要的特征之一。</p>
<h2 id="突变"><a href="#突变" class="headerlink" title="突变"></a><a href="https://zshipu.com/t?url=#mutations"></a>突变</h2><p>在 GraphQL 中，突变是修改服务器上的数据并恢复更新数据的方式。您可以像 REST 的 CUD（创建、更新、删除）一样思考。</p>
<p>我们将在 GraphQL 中创建我们的第一个类型突变，并且我们所有的突变都将在这种类型的类型中结束。所以，首先，去我们的，并写一个新的类型称为突变：</p>
<p>schema.graphql</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> type Mutation &#123;    </span><br><span class="line">    createUser(id: ID!, name: String!, email: String!, age: Int): User!    </span><br><span class="line">    updateUser(id: ID!, name: String, email: String, age: Int): User!    </span><br><span class="line">    deleteUser(id: ID!): User!    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>正如您所看到的，我们将有三个突变：</p>
<p><strong>创建用户</strong>：我们应该传递 ID、姓名、电子邮件和年龄。它应该将新用户返回给我们。</p>
<p><strong>更新用户</strong>：我们应该传递一个ID，以及一个新的名称，电子邮件，或年龄。它应该将新用户返回给我们。</p>
<p><strong>删除用户</strong>：我们应该传递一个ID。它应该将删除的用户退还给我们。</p>
<p>现在，转到我们的文件和查询对象<strong>下方</strong>，创建一个新的突变对象，如下所示：</p>
<p>resolvers.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> Mutation: &#123;    </span><br><span class="line">    createUser: (parent, &#123; id, name, email, age &#125;, context, info) &#x3D;&gt; &#123;    </span><br><span class="line">        const newUser &#x3D; &#123; id, name, email, age &#125;;    </span><br><span class="line">        users.push(newUser);    </span><br><span class="line">        return newUser;    </span><br><span class="line">&#125;,   </span><br><span class="line">    updateUser: (parent, &#123; id, name, email, age &#125;, context, info) &#x3D;&gt; &#123;    </span><br><span class="line">        let newUser &#x3D; users.find(user &#x3D;&gt; user.id &#x3D;&#x3D; id);    </span><br><span class="line">        newUser.name &#x3D; name;    </span><br><span class="line">        newUser.email &#x3D; email;    </span><br><span class="line">        newUser.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">        return newUser;</span><br><span class="line">    &#125;,    </span><br><span class="line">    deleteUser: (parent, &#123; id &#125;, context, info) &#x3D;&gt; &#123;    </span><br><span class="line">        const userIndex &#x3D; users.findIndex(user &#x3D;&gt; user.id &#x3D;&#x3D; id);</span><br><span class="line"></span><br><span class="line">        if (userIndex &#x3D;&#x3D;&#x3D; -1) throw new Error(&quot;User not found.&quot;);</span><br><span class="line"></span><br><span class="line">        const deletedUsers &#x3D; users.splice(userIndex, 1);</span><br><span class="line"></span><br><span class="line">        return deletedUsers[0];     </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>现在，我们的文件应该如下所示：</p>
<p>resolvers.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> import &#123; users &#125; from &quot;.&#x2F;db&quot;;</span><br><span class="line"></span><br><span class="line">const resolvers &#x3D; &#123;    </span><br><span class="line">    Query: &#123;        </span><br><span class="line">        user: (parent, &#123; id &#125;, context, info) &#x3D;&gt; &#123;      </span><br><span class="line">            return users.find(user &#x3D;&gt; user.id &#x3D;&#x3D; id);       </span><br><span class="line">        &#125;,      </span><br><span class="line">        users: (parent, args, context, info) &#x3D;&gt; &#123;       </span><br><span class="line">            return users;       </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;,    </span><br><span class="line">    Mutation: &#123;    </span><br><span class="line">        createUser: (parent, &#123; id, name, email, age &#125;, context, info) &#x3D;&gt; &#123;    </span><br><span class="line">            const newUser &#x3D; &#123; id, name, email, age &#125;;    </span><br><span class="line">            users.push(newUser);    </span><br><span class="line">            return newUser;    </span><br><span class="line">    &#125;,   </span><br><span class="line">        updateUser: (parent, &#123; id, name, email, age &#125;, context, info) &#x3D;&gt; &#123;    </span><br><span class="line">            let newUser &#x3D; users.find(user &#x3D;&gt; user.id &#x3D;&#x3D; id);    </span><br><span class="line">            newUser.name &#x3D; name;    </span><br><span class="line">            newUser.email &#x3D; email;    </span><br><span class="line">            newUser.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">            return newUser;</span><br><span class="line">        &#125;,    </span><br><span class="line">        deleteUser: (parent, &#123; id &#125;, context, info) &#x3D;&gt; &#123;    </span><br><span class="line">            const userIndex &#x3D; users.findIndex(user &#x3D;&gt; user.id &#x3D;&#x3D;&#x3D; id);</span><br><span class="line"></span><br><span class="line">            if (userIndex &#x3D;&#x3D;&#x3D; -1) throw new Error(&quot;User not found.&quot;);</span><br><span class="line"></span><br><span class="line">            const deletedUsers &#x3D; users.splice(userIndex, 1);</span><br><span class="line"></span><br><span class="line">            return deletedUsers[0];         </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default resolvers;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>现在，我们将测试我们的突变是否正常。转到并放入以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost:4000</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> mutation &#123;    </span><br><span class="line">    createUser(id: 3, name: &quot;Robert&quot;, email: &quot;robert@gmail.com&quot;, age: 21) &#123;    </span><br><span class="line">        id    </span><br><span class="line">        name    </span><br><span class="line">        email    </span><br><span class="line">        age    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>它应将新用户返回给您。如果你想尝试制造新的突变，我建议你自己尝试一下！尝试删除您创建的同一用户，以查看其是否正常工作。</p>
<p>最后，我们将开始了解<strong>订阅</strong>，以及为什么它们如此强大。</p>
<h2 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a><a href="https://zshipu.com/t?url=#subscriptions"></a>订阅</h2><p>正如我以前说过的，订阅是您与服务器保持实时连接的方式。这意味着，每当服务器中发生事件，并且每当调用该事件时，服务器都会向客户端发送相应的数据。</p>
<p>通过使用订阅，可以使应用更新到不同用户之间的最新更改。</p>
<p><a href="https://zshipu.com/t?url=https://res.cloudinary.com/practicaldev/image/fetch/s--5ZxE4cuA--/c_limit,f_auto,fl_progressive,q_auto,w_880/https://cdn-images-1.medium.com/max/2000/1*NaIPy126r9Ie5NwjS3g-rg.png"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--5ZxE4cuA--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/2000/1%2ANaIPy126r9Ie5NwjS3g-rg.png"></a></p>
<p>基本订阅如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> subscription &#123;    </span><br><span class="line">    users &#123;    </span><br><span class="line">        id    </span><br><span class="line">        name    </span><br><span class="line">        email    </span><br><span class="line">        age    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>你会说它非常类似于查询，是的。但它的工作方式不同。</p>
<p>在服务器中更新某些内容时，服务器将运行订阅中指定的 GraphQL 查询，并将新更新的结果发送到客户端。</p>
<p>我们不会在本文中使用订阅，但如果您想阅读有关订阅的更多信息，<a href="https://zshipu.com/t?url=https://hackernoon.com/from-zero-to-graphql-subscriptions-416b9e0284f3">请单击此处</a>。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><a href="https://zshipu.com/t?url=#conclusion"></a>结论</h2><p>正如您所看到的，GraphQL 是一项非常强大的新技术。它为我们提供了构建更好且设计良好的 API 的真正能力。这就是为什么我建议你现在开始学习它。对我来说，它最终将取代REST。</p>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/3/">上一页</a></div><div class="pagination-next"><a href="/page/5/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link is-current" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/19/">19</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://www.gravatar.com/avatar/2396bdfe5aadb513e676094004dde830?s=128" alt="edwin"></figure><p class="title is-size-4 is-block line-height-inherit">edwin</p><p class="is-size-6 is-block">知识铺</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国 杭州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">189</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">2</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/liliang8858" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/liliang8858"><i class="Github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="社区"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="设计"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/go/"><span class="level-start"><span class="level-item">go</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T10:43:02.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/Spring%20Cloud%20Gateway+Nacos%EF%BC%8Cyml+properties%E4%B8%A4%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BA%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1/">Spring Cloud Gateway+Nacos，yml+properties两种配置文件方式搭建网关服务</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T10:39:59.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/Spring%20Cloud+nacos+Feign%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/">Spring Cloud+nacos+Feign，实现注册中心及配置中心</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T10:32:26.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/Nacos%E4%BD%9C%E4%B8%BA%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%97%B6%EF%BC%8C%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AAdataId%E7%9A%84%E9%85%8D%E7%BD%AE/">Nacos作为配置中心时，多个服务共用一个dataId的配置</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T09:34:29.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/SpringCloudAlibaba(%E4%B8%89)%EF%BC%9A%E4%BD%BF%E7%94%A8Nacos%E4%BD%9C%E4%B8%BA%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/">SpringCloudAlibaba(三)：使用Nacos作为配置中心</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T09:31:53.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/Nacos%20%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/">Nacos 集群部署</a></p><p class="is-uppercase"></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">37</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">62</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web/"><span class="tag">web</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">广告</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="2183476622" data-ad-slot="pub-2874221941555456" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="知识铺" height="28"></a><p class="size-small"><span>&copy; 2020 edwin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://zshipu.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>