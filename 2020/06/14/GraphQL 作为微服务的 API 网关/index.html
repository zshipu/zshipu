<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>GraphQL 作为微服务的 API 网关 - 知识铺</title><meta description="GraphQL早在2015年就向公众发布，就像一只在圈养中饲养的动物一样，它在野外的第一步是胆怯的，基本上被忽视了。然而，到目前为止，它已经获得了一些重大的轰动，而且有充分的理由：它解决了标准 REST API 体系结构中固有的一些最棘手的问题。 具体来说，GraphQL 允许您在不进行版本控制的情况下自然地发展 API，它提供了可行的文档，避免了过度和不足提取的问题，并且它提供了一种通过单个请求"><meta property="og:type" content="blog"><meta property="og:title" content="GraphQL 作为微服务的 API 网关"><meta property="og:url" content="https://zshipu.com/2020/06/14/GraphQL%20%E4%BD%9C%E4%B8%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%20API%20%E7%BD%91%E5%85%B3/"><meta property="og:site_name" content="知识铺"><meta property="og:description" content="GraphQL早在2015年就向公众发布，就像一只在圈养中饲养的动物一样，它在野外的第一步是胆怯的，基本上被忽视了。然而，到目前为止，它已经获得了一些重大的轰动，而且有充分的理由：它解决了标准 REST API 体系结构中固有的一些最棘手的问题。 具体来说，GraphQL 允许您在不进行版本控制的情况下自然地发展 API，它提供了可行的文档，避免了过度和不足提取的问题，并且它提供了一种通过单个请求"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://i1.wp.com/blog.codeship.com/wp-content/uploads/2017/03/scopes.png?resize=350,200&amp;ssl=1"><meta property="article:published_time" content="2020-06-14T13:10:27.000Z"><meta property="article:modified_time" content="2020-09-08T14:03:00.345Z"><meta property="article:author" content="知识铺"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://i1.wp.com/blog.codeship.com/wp-content/uploads/2017/03/scopes.png?resize=350,200&amp;ssl=1"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zshipu.com/2020/06/14/GraphQL%20%E4%BD%9C%E4%B8%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%20API%20%E7%BD%91%E5%85%B3/"},"headline":"知识铺","image":[],"datePublished":"2020-06-14T13:10:27.000Z","dateModified":"2020-09-08T14:03:00.345Z","author":{"@type":"Person","name":"知识铺"},"description":"GraphQL早在2015年就向公众发布，就像一只在圈养中饲养的动物一样，它在野外的第一步是胆怯的，基本上被忽视了。然而，到目前为止，它已经获得了一些重大的轰动，而且有充分的理由：它解决了标准 REST API 体系结构中固有的一些最棘手的问题。 具体来说，GraphQL 允许您在不进行版本控制的情况下自然地发展 API，它提供了可行的文档，避免了过度和不足提取的问题，并且它提供了一种通过单个请求"}</script><link rel="canonical" href="https://zshipu.com/2020/06/14/GraphQL%20%E4%BD%9C%E4%B8%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%20API%20%E7%BD%91%E5%85%B3/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script data-ad-client="2183476622" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="generator" content="Hexo 5.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="知识铺" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-06-14T13:10:27.000Z" title="2020-06-14T13:10:27.000Z">2020-06-14</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.345Z" title="2020-09-08T14:03:00.345Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">25 分钟读完 (大约3724个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">GraphQL 作为微服务的 API 网关</h1><div class="content"><p><a href="https://zshipu.com/t?url=http://graphql.org/">GraphQL</a>早在2015年就向公众发布，就像一只在圈养中饲养的动物一样，它在野外的第一步是胆怯的，基本上被忽视了。然而，到目前为止，它已经获得了一些重大的轰动，而且有充分的理由：它解决了标准 REST API 体系结构中固有的一些最棘手的问题。</p>
<p>具体来说，GraphQL 允许您在不进行版本控制的情况下自然地发展 API，它提供了可行的文档，避免了过度和不足提取的问题，并且它提供了一种通过单个请求聚合来自多个源的数据的便捷方法。一旦您通过非常规的方法和欺骗性的”类似 JSON”语法（这来自那些带给我们 React 及其”类似 HTML”语法的人），您可以开始欣赏其功能和灵活性。</p>
<p>如何在 API 网关中利用 GraphQL？它似乎是一个完美的解决方案，用于与多个微服务交互，每个微服务都专用于单个资源类型。好消息是，_您可以在_API 网关中使用 GraphQL，并且它可以与标准 REST 路由并驾齐驱。所以在某些情况下，你可以有你的蛋糕，也吃它。</p>
<p>[推文””GraphQL 可能是与多个微服务交互的完美解决方案”]</p>
<h2 id="GraphQL-in-a-Nutshell"><a href="#GraphQL-in-a-Nutshell" class="headerlink" title="GraphQL in a Nutshell"></a>GraphQL in a Nutshell</h2><p>在进入网关代码之前，让我们先回顾一下 GraphQL 的横向。与 REST 应用程序不同，GraphQL 实现依赖于单个终结点。所有 GraphQL 都使用查询向该终结点请求将数据（_始终_发布，永远不会获取）到该终结点，该查询描述正在请求哪些资源和字段。</p>
<p>GraphQL 将读取操作区分为”查询”，将操作区分为”突变”。为了支持查询，GraphQL 实现将定义一个根查询对象，该对象枚举所有可供查询的资源类型（以及它们的字段和数据类型）。您可以将其视为定义表和列的数据库架构。</p>
<p>为了支持突变，GraphQL 实现将定义一个根突变对象，该对象枚举所有可用的突变及其属性。突变可以被认为是行动，_例如_，或。即使在单个语言或框架中，对于这些 GraphQL 组件应存在的位置也没有标准结构，但这些关键元素必须存在于任何 GraphQL 实现中的某处。<code>createUser``````updateOrder</code></p>
<h2 id="同时使用GraphQL-和-REST-端点"><a href="#同时使用GraphQL-和-REST-端点" class="headerlink" title="同时使用GraphQL 和 REST 端点"></a>同时使用GraphQL 和 REST 端点</h2><p>仅仅因为我们的 API 网关定义了 GraphQL 终结点，并不意味着我们也不能有其他终结点！完全可以在相同的应用程序中定义传统的 REST 路由。</p>
<p>由于我们希望避免在网关中复制代码，尤其是向微服务发出请求的代码，因此我们必须选择由哪种方法负责。我们可以剖析 GraphQL 查询并将其转换为相应的 REST 请求，也可以将 REST 请求转换为其 GraphQL 等效项。</p>
<p>事实证明，后者更简单，所以我们建议的诀窍是：将对REST路由的请求转换为GraphQL。不需要复制与微服务交互的代码，因为 REST 路由只是充当 GraphQL 的转换层。</p>
<h2 id="在代码中"><a href="#在代码中" class="headerlink" title="在代码中"></a>在代码中</h2><p>现在我们已经描述了我们的攻击计划，让我们来看看一些代码！演示这些示例的<a href="https://zshipu.com/t?url=https://github.com/fireproofsocks/graphql-example">存储库</a>在<a href="https://zshipu.com/t?url=https://github.com/fireproofsocks/graphql-example">Github</a>上可用</p>
<p>这是一个Node.js应用程序使用流行的<a href="https://zshipu.com/t?url=http://expressjs.com/">快速框架</a>。您应该能够按照 README 中的说明克隆和安装应用程序。</p>
<p>从命令行运行应启动应用程序并开始侦听端口 4000。将浏览器指向查看 GraphQL 终结点。右侧将显示任何已注册的资源类型及其字段，因此您可以马上查看 GraphQL 如何提供一些可行的文档。<code>yarn run start``````http://localhost:4000/graphql</code></p>
<p>我们可以运行示例查询来按其 ID 查找单个用户：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; users(_id: 3)&#123; name &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The result should be:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;users&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;Tammy&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理此代码位于 内部，它围绕对象旋转。这就是响应的结构并提供可行的文档的原因。<code>src/users.js``````GraphQLObjectType</code></p>
<h2 id="REST-等效项"><a href="#REST-等效项" class="headerlink" title="REST 等效项"></a>REST 等效项</h2><p>接下来，让我们来看看如何支持获取相同数据的 REST 终结点。查找单个用户记录的传统路由将遵循 的模式。查看 内部，看看它是如何注册路由的：<code>/users/:userId``````index.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const users &#x3D; require(&#39;.&#x2F;src&#x2F;rest&#x2F;user&#39;);</span><br><span class="line">&#x2F;&#x2F; ... app.use(&#39;&#x2F;users&#39;, users);</span><br></pre></td></tr></table></figure>

<p>这是相当标准的快速路由的东西。让我们看一下该文件，看看它是如何将请求转换为 GraphQL 的。<code>src/rest/user.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const app &#x3D; require(&#39;express&#39;);</span><br><span class="line">const router &#x3D; app.Router();</span><br><span class="line">import rootSchema from &#39;..&#x2F;app&#39;;</span><br><span class="line">import &#123;graphql&#125; from &#39;graphql&#39;</span><br><span class="line">const query &#x3D; (q, vars) &#x3D;&gt; &#123;</span><br><span class="line">    return graphql(rootSchema, q, null, null, vars)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Transform response to JSON API format</span><br><span class="line">&#x2F;&#x2F; (if desired)</span><br><span class="line">const transform &#x3D; (result) &#x3D;&gt; &#123;</span><br><span class="line">    const user &#x3D; result.data.users[0];</span><br><span class="line">    return &#123; data: &#123; type: &#39;user&#39;, id: user._id, attributes: &#123; name: user.name &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; REST request to get a user router.get(&#39;&#x2F;:userId&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; Convert the request into a GraphQL query string query(&quot;query&#123;users(_id:&quot; + req.params.userId + &quot;)&#123;_id, name&#125;&#125;&quot;)</span><br><span class="line">        .then(result &#x3D;&gt; &#123;</span><br><span class="line">            const transformed &#x3D; transform(result) res.send(transformed)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(err &#x3D;&gt; &#123; res.sendStatus(500)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">module.exports &#x3D; router;</span><br></pre></td></tr></table></figure>

<p>这真的是魔法发生的地方。路由的已注册回调将收集查询字符串并将其传递给 GraphQL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query(&quot;query&#123;users(_id:&quot; + req.params.userId + &quot;)&#123;_id, name&#125;&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p>查询字符串映射出该”类似 JSON”语法中的查询对象 - 是的，它似乎是多余的，但有一个根查询节点，它包裹我们在交互式 GraphQL 页上使用的查询部分。</p>
<p>此方法可能会提醒您以前，在 ORM 之前，您必须手动组装查询字符串。在将请求参数放入查询字符串之前对其进行筛选可能更合适，但由于它由 GraphQL 解释，因此可能是安全的 — 如果字符串无效，GraphQL 会简单地阻塞。</p>
<p>此输出中包括一个变压器功能，该函数将默认 GraphQL 响应转换为<a href="https://zshipu.com/t?url=http://jsonapi.org/">JSON API</a>格式，但这可能是您希望保留的内容，也可能不是您希望保留的内容。</p>
<p>您应该能够通过请求<a href="https://zshipu.com/t?url=http://localhost:4000/users/2">http://localhost:4000/users/2</a>等 URL 并获取响应（如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;user&quot;,</span><br><span class="line">        &quot;id&quot;: &quot;2&quot;,</span><br><span class="line">        &quot;attributes&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &quot;João&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="微服务的请求"><a href="#微服务的请求" class="headerlink" title="微服务的请求"></a>微服务的请求</h2><p>更复杂的示例涉及使用web请求实际触及微服务。这可以通过请求某天的励志名言来实现 <a href="https://zshipu.com/t?url=http://quotes.rest/qod.json?category=inspire">http://quotes.rest/qod.json?category=inspire</a>.</p>
<p>为了为这个数据添加GraphQL支持，我们需要做三件事:</p>
<ol>
<li>修改根查询对象 <code>src/app.js</code></li>
<li>中定义引用资源类型 .<code>src/quote.js</code></li>
<li>定义一个将从远程API中获取数据的服务<code>src/services/quote.js</code></li>
</ol>
<h3 id="修改根查询"><a href="#修改根查询" class="headerlink" title="修改根查询"></a>修改根查询</h3><p>首先，我们需要将资源类型添加到内部的GraphQL根查询对象</p>
<p>inside :<code>src/app.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; src&#x2F;app.js</span><br><span class="line">import &#123;</span><br><span class="line">    GraphQLObjectType,</span><br><span class="line">    GraphQLSchema,</span><br><span class="line">&#125; from &#39;graphql&#x2F;type&#39;;</span><br><span class="line">import userQuery from &#39;.&#x2F;users&#39;;</span><br><span class="line">import agendaQuery from &#39;.&#x2F;agenda-interface&#39;;</span><br><span class="line">import quoteQuery from &#39;.&#x2F;quote&#39;;</span><br><span class="line">const query &#x3D; new GraphQLObjectType(&#123; name: &#39;RootQueryType&#39;, fields: &#123; users: userQuery, agenda: agendaQuery, quote: quoteQuery &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">export default new GraphQLSchema(&#123; query,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="定义查询类型"><a href="#定义查询类型" class="headerlink" title="定义查询类型"></a>定义查询类型</h3><p>引号查询对象在 中定义 - 这几乎与用于用户查询的结构完全相同，但它引用一个服务类，其作业将是与远程微服务交互。<code>src/quote.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; src&#x2F;quote.js</span><br><span class="line">import &#123;</span><br><span class="line">    GraphQLObjectType,</span><br><span class="line">    GraphQLNonNull,</span><br><span class="line">    GraphQLString</span><br><span class="line">&#125; from &#39;graphql&#x2F;type&#39;;</span><br><span class="line">import &#123; getQuote &#125; from &#39;.&#x2F;services&#x2F;quote&#39;</span><br><span class="line">export const QuoteType &#x3D; new GraphQLObjectType(&#123; name: &#39;Quote&#39;, description: &#39;Quote of the day from API service&#39;, fields: () &#x3D;&gt; (&#123; id: &#123; type: GraphQLString, description: &#39;Quote id&#39;,</span><br><span class="line">        &#125;, quote: &#123; type: new GraphQLNonNull(GraphQLString), description: &#39;The text of the quote&#39;,</span><br><span class="line">        &#125;, author: &#123; type: GraphQLString, description: &#39;The person to whom the quote is attributed&#39;,</span><br><span class="line">        &#125;, date: &#123; type: GraphQLString, description: &#39;Date in YYYY-MM-DD format&#39;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">export default &#123; type: QuoteType, resolve: getQuote &#125;</span><br></pre></td></tr></table></figure>

<p>这完全取决于函数，我们接下来将讨论该函数。<code>getQuote()</code></p>
<h3 id="定义用于检索远程数据的服务"><a href="#定义用于检索远程数据的服务" class="headerlink" title="定义用于检索远程数据的服务"></a>定义用于检索远程数据的服务</h3><p>函数在 中定义：<code>getQuote()``````src/services/quote.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; src&#x2F;services&#x2F;quote.js</span><br><span class="line">&#x2F;**</span><br><span class="line"> * This is where the app calls the microservice responsible for the &quot;Quote&quot; resource type.</span><br><span class="line"> *&#x2F;</span><br><span class="line">import fetch from &#39;universal-fetch&#39;</span><br><span class="line">export const getQuote &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        const url &#x3D; &#39;http:&#x2F;&#x2F;quotes.rest&#x2F;qod.json?category&#x3D;inspire&#39;</span><br><span class="line">        return fetch(url)</span><br><span class="line">            .then(response &#x3D;&gt; &#123;</span><br><span class="line">                return response.json()</span><br><span class="line">            &#125;)</span><br><span class="line">            .then(json &#x3D;&gt; &#123;</span><br><span class="line">                return transform(json)</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(err &#x3D;&gt; &#123; console.trace(err)</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; Transform the raw microservice output into</span><br><span class="line">&#x2F;&#x2F; fields&#x2F;types defined by the GraphQL type</span><br><span class="line">const transform &#x3D; (json) &#x3D;&gt; &#123;</span><br><span class="line">    const</span><br><span class="line">        &#123; contents &#125; &#x3D; json,</span><br><span class="line">        &#123; quotes &#125; &#x3D; contents, quote &#x3D; quotes[0]</span><br><span class="line">    return &#123; id: quote.id, quote: quote.quote, author: quote.author, date: quote.date &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处的方法将微服务使用的任何格式转换为 GraphQL 为此资源类型定义的格式。如果需要将字段添加到响应中，必须将它们添加到 中的对象。<code>transform``````QuoteType``````src/quote.js</code></p>
<p>完成这些部件后，您应该能够使用 GraphQL 进行查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123; quote&#123; quote, author &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="添加-REST-支持"><a href="#添加-REST-支持" class="headerlink" title="添加 REST 支持"></a>添加 REST 支持</h3><p>与以前一样，路由在文件中注册：<code>index.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const quotes &#x3D; require(&#39;.&#x2F;src&#x2F;rest&#x2F;quote&#39;);</span><br><span class="line">&#x2F;&#x2F; ... app.use(&#39;&#x2F;quote&#39;, quotes);</span><br></pre></td></tr></table></figure>

<p>REST 请求充当 GraphQL 语法的转换器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; src&#x2F;rest&#x2F;quote.js</span><br><span class="line">const app &#x3D; require(&#39;express&#39;);</span><br><span class="line">const router &#x3D; app.Router();</span><br><span class="line">import rootSchema from &#39;..&#x2F;app&#39;;</span><br><span class="line">import &#123;graphql&#125; from &#39;graphql&#39;</span><br><span class="line">const query &#x3D; (q, vars) &#x3D;&gt; &#123;</span><br><span class="line">    return graphql(rootSchema, q, null, null, vars)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Transform response to JSON API format</span><br><span class="line">const transform &#x3D; (result) &#x3D;&gt; &#123;</span><br><span class="line">    const quote &#x3D; result.data.quote;</span><br><span class="line">    return &#123; data: &#123; type: &#39;quote&#39;, id: quote.id, attributes: &#123; quote: quote.quote, author: quote.author, date: quote.date &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; REST request to get a quote router.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; Convert the request into a GraphQL query string query(&quot;query&#123;quote&#123;id, quote, author, date&#125;&#125;&quot;)</span><br><span class="line">        .then(result &#x3D;&gt; &#123;</span><br><span class="line">            const transformed &#x3D; transform(result) res.send(transformed)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(err &#x3D;&gt; &#123; res.sendStatus(500)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">module.exports &#x3D; router;</span><br></pre></td></tr></table></figure>


<p>完成后，REST 终结点在<a href="https://zshipu.com/t?url=http://localhost:4000/quote">http://localhost:4000/quote</a>可用。</p>
<blockquote>
<p>请注意，报价服务每小时有 10 个请求的限制，因此只能适度使用演示。</p>
</blockquote>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>现在，您已经了解如何将 API 网关既具有 GraphQL 实现，又支持标准 REST 路由，因此优势应该显而易见：</p>
<ul>
<li>你可以有你的API蛋糕，也吃它。图形QL还是REST？两者！</li>
<li>您可以利用 GraphQL 的内置优势，从多个服务聚合数据。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>这种方法的大多数缺点通常与 GraphQL 有关。在填充 API 网关的角色时，GraphQL 最大的问题是它在_单个_终结点上运行。</p>
<p>API 网关通常_为每个路由_定义授权规则、限制速率和缓存时间。但是，由于 GraphQL 仅使用一个终结点，因此几乎不可能为任何内容定义特定于路由的规则。因此，您可能需要在单独的层中，甚至微服务本身中写入授权、限制和缓存逻辑。</p>
<p>这会产生自己的臭代码混乱，因为解决方案最终将削弱我们期望从网关获得的一些最基本的功能。</p>
<p>如果您的 API 未公开使用，则您不会进行无限数量的查询变体，因此，使用允许客户端请求任何可能的资源和字段组合的 GraphQL 解释器可以说是超量计算。长期以来，支持少数具有已知响应属性的用例在很多设置中效果很好，因此可能不需要重新发明该特定车轮。</p>
<p>尝试同时使用 GraphQL 和 REST 的另一个缺点是文档：无法保证 REST 终结点具有任何文档，更不用说与 GraphQL 查询对象保持同步的文档，因此，如果您选择在 API 网关中同时支持 GraphQL 和 REST，则可能会邀请一些不一致和忙碌工作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我在这里介绍的解决方案对一些人来说可能是一个有趣的分心，或者它可能是一个可行的解决方案，这取决于您的需求。尽管可以在单个应用程序中将 GraphQL 和 REST API 共存，但更困难的问题是这种组合是否可行。</p>
<p>与围绕微服务和 API 网关的大多数问题一样，没有简单的正确和错误答案，只有权衡，只有您才能决定哪些解决方案最适合您的需求。</p>
<p>[通过@fireproofsocks”将”GraphQL 作为微服务的 API 网关”推文”</p>
<h3 id="与朋友分享这个帖子！"><a href="#与朋友分享这个帖子！" class="headerlink" title="与朋友分享这个帖子！"></a>与朋友分享这个帖子！</h3><h3 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a><em>相关内容</em></h3><p> [<img src="https://i1.wp.com/blog.codeship.com/wp-content/uploads/2017/03/scopes.png?resize=350,200&ssl=1" alt="An Introduction to GraphQL via the GitHub API">](<a href="https://zshipu.com/t?url=https://rollout.io/blog/an-introduction-to-graphql-via-the-github-api/">https://zshipu.com/t?url=https://rollout.io/blog/an-introduction-to-graphql-via-the-github-api/</a> “An Introduction to GraphQL via the GitHub API</p>
<p>RESTful, JSON-delivering APIs are today’s default choice when building an API. However, there’s a new API kid on the block that’s generating considerable attention: GraphQL. GraphQL is an entirely new way to consume and build APIs. Done right, you can build wonderfully tight integrations that aren’t possible with REST APIs.…”)</p>
<h4 id="通过-GitHub-API-对-GraphQL-的简介-https-zshipu-com-t-url-https-rollout-io-blog-an-introduction-to-graphql-via-the-github-api-“An-Introduction-to-GraphQL-via-the-GitHub-API"><a href="#通过-GitHub-API-对-GraphQL-的简介-https-zshipu-com-t-url-https-rollout-io-blog-an-introduction-to-graphql-via-the-github-api-“An-Introduction-to-GraphQL-via-the-GitHub-API" class="headerlink" title="[通过 GitHub API 对 GraphQL 的简介](https://zshipu.com/t?url=https://rollout.io/blog/an-introduction-to-graphql-via-the-github-api/ “An Introduction to GraphQL via the GitHub API"></a>[通过 GitHub API 对 GraphQL 的简介](<a href="https://zshipu.com/t?url=https://rollout.io/blog/an-introduction-to-graphql-via-the-github-api/">https://zshipu.com/t?url=https://rollout.io/blog/an-introduction-to-graphql-via-the-github-api/</a> “An Introduction to GraphQL via the GitHub API</h4><p>RESTful, JSON-delivering APIs are today’s default choice when building an API. However, there’s a new API kid on the block that’s generating considerable attention: GraphQL. GraphQL is an entirely new way to consume and build APIs. Done right, you can build wonderfully tight integrations that aren’t possible with REST APIs.…”)</p>
<p>RESTful, JSON-delivering APIs are today’s default choice when building an API. However, there’s a new API kid on the block that’s generating considerable attention: GraphQL. GraphQL is an entirely new way to consume and build APIs. Done right, you can build wonderfully tight integrations that aren’t possible with REST APIs.…</p>
<p>三月 8， 2017</p>
<p>在”发展”</p>
<h4 id="API-网关和微服务的设计模式-https-zshipu-com-t-url-https-rollout-io-blog-design-patterns-in-api-gateways-and-microservices-“Design-Patterns-in-API-Gateways-and-Microservices"><a href="#API-网关和微服务的设计模式-https-zshipu-com-t-url-https-rollout-io-blog-design-patterns-in-api-gateways-and-microservices-“Design-Patterns-in-API-Gateways-and-Microservices" class="headerlink" title="[API 网关和微服务的设计模式](https://zshipu.com/t?url=https://rollout.io/blog/design-patterns-in-api-gateways-and-microservices/ “Design Patterns in API Gateways and Microservices"></a>[API 网关和微服务的设计模式](<a href="https://zshipu.com/t?url=https://rollout.io/blog/design-patterns-in-api-gateways-and-microservices/">https://zshipu.com/t?url=https://rollout.io/blog/design-patterns-in-api-gateways-and-microservices/</a> “Design Patterns in API Gateways and Microservices</h4><p>For all the buzz about microservices and API gateways, finding specifics can prove surprisingly difficult. I am reminded of the cartoon by Sidney Harris where the first step of a complex mathematical formula is presented, then a miracle occurs, and the sudden appearance of the glorious solution prompts an observer…”)</p>
<p>对于关于微服务和 API 网关的所有热议，查找细节可能证明极其困难。我想起了西德尼·哈里斯的漫画，其中提出了复杂数学公式的第一步，然后奇迹发生，而光荣解决方案的突然出现促使观察者…</p>
<p>十月 26， 2017</p>
<p>在”发展”</p>
<h4 id="如何在-Rails-中实现图形QL-API-https-zshipu-com-t-url-https-rollout-io-blog-how-to-implement-a-graphql-api-in-rails-“How-to-Implement-a-GraphQL-API-in-Rails"><a href="#如何在-Rails-中实现图形QL-API-https-zshipu-com-t-url-https-rollout-io-blog-how-to-implement-a-graphql-api-in-rails-“How-to-Implement-a-GraphQL-API-in-Rails" class="headerlink" title="[如何在 Rails 中实现图形QL API](https://zshipu.com/t?url=https://rollout.io/blog/how-to-implement-a-graphql-api-in-rails/ “How to Implement a GraphQL API in Rails"></a>[如何在 Rails 中实现图形QL API](<a href="https://zshipu.com/t?url=https://rollout.io/blog/how-to-implement-a-graphql-api-in-rails/">https://zshipu.com/t?url=https://rollout.io/blog/how-to-implement-a-graphql-api-in-rails/</a> “How to Implement a GraphQL API in Rails</h4><p>GraphQL came out of Facebook a number of years ago as a way to solve a few different issues that typical RESTful APIs are prone to. One of those was the issue of under- or over-fetching data. Under-fetching is when the client has to make multiple roundtrips to the server…”)</p>
<p>GraphQL在几年前从Facebook上出来，作为解决一些典型的RESTful API容易出现的不同问题的方法。其中之一是数据提取不足或过度提取的问题。正在获取不足是客户端必须多次往返服务器…</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>GraphQL 作为微服务的 API 网关</p><p><a href="https://zshipu.com/2020/06/14/GraphQL%20%E4%BD%9C%E4%B8%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%20API%20%E7%BD%91%E5%85%B3/">https://zshipu.com/2020/06/14/GraphQL%20%E4%BD%9C%E4%B8%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%20API%20%E7%BD%91%E5%85%B3/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>知识铺</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-06-14</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2020-09-08</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=5f58e448b1477000121881fb&amp;product=inline-share-buttons" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/weixin.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/06/15/GraphQL%E6%9E%B6%E6%9E%84%E6%8B%BC%E6%8E%A5%E8%A7%A3%E9%87%8A%EF%BC%9A%E6%9E%B6%E6%9E%84%E5%A7%94%E6%B4%BE/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">GraphQL架构拼接解释：架构委派</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/06/14/GraphQL%20%E5%9C%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/"><span class="level-item">GraphQL 在微服务架构中的实践</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://zshipu.com/2020/06/14/GraphQL%20%E4%BD%9C%E4%B8%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%20API%20%E7%BD%91%E5%85%B3/';
            this.page.identifier = '2020/06/14/GraphQL 作为微服务的 API 网关/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'zsp' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://www.gravatar.com/avatar/2396bdfe5aadb513e676094004dde830?s=128" alt="edwin"></figure><p class="title is-size-4 is-block line-height-inherit">edwin</p><p class="is-size-6 is-block">知识铺</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国 杭州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">189</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">2</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/liliang8858" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/liliang8858"><i class="Github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="社区"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="设计"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/go/"><span class="level-start"><span class="level-item">go</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T10:43:02.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/Spring%20Cloud%20Gateway+Nacos%EF%BC%8Cyml+properties%E4%B8%A4%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BA%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1/">Spring Cloud Gateway+Nacos，yml+properties两种配置文件方式搭建网关服务</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T10:39:59.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/Spring%20Cloud+nacos+Feign%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/">Spring Cloud+nacos+Feign，实现注册中心及配置中心</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T10:32:26.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/Nacos%E4%BD%9C%E4%B8%BA%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%97%B6%EF%BC%8C%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AAdataId%E7%9A%84%E9%85%8D%E7%BD%AE/">Nacos作为配置中心时，多个服务共用一个dataId的配置</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T09:34:29.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/SpringCloudAlibaba(%E4%B8%89)%EF%BC%9A%E4%BD%BF%E7%94%A8Nacos%E4%BD%9C%E4%B8%BA%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/">SpringCloudAlibaba(三)：使用Nacos作为配置中心</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T09:31:53.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/Nacos%20%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/">Nacos 集群部署</a></p><p class="is-uppercase"></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">37</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">62</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web/"><span class="tag">web</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">广告</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="2183476622" data-ad-slot="pub-2874221941555456" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="知识铺" height="28"></a><p class="size-small"><span>&copy; 2020 知识铺</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://zshipu.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>