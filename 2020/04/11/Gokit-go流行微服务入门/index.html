<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Gokit go流行微服务入门 - 知识铺</title><meta description="快速开始让我们创建一个最小的 Go 工具包服务。现在，我们将为此使用单个文件。 12main.go   您的业务逻辑您的服务从业务逻辑开始。在 Go 工具包中，我们将服务建模为接口。 12345678910111213141516&amp;#x2F;&amp;#x2F; StringService provides operations on strings.import &amp;quot;context&amp;quot;t"><meta property="og:type" content="blog"><meta property="og:title" content="Gokit go流行微服务入门"><meta property="og:url" content="https://zshipu.com/2020/04/11/Gokit-go%E6%B5%81%E8%A1%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/"><meta property="og:site_name" content="知识铺"><meta property="og:description" content="快速开始让我们创建一个最小的 Go 工具包服务。现在，我们将为此使用单个文件。 12main.go   您的业务逻辑您的服务从业务逻辑开始。在 Go 工具包中，我们将服务建模为接口。 12345678910111213141516&amp;#x2F;&amp;#x2F; StringService provides operations on strings.import &amp;quot;context&amp;quot;t"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zshipu.com/img/og_image.png"><meta property="article:published_time" content="2020-04-11T03:39:44.000Z"><meta property="article:modified_time" content="2020-09-08T14:03:00.343Z"><meta property="article:author" content="知识铺"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zshipu.com/2020/04/11/Gokit-go%E6%B5%81%E8%A1%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/"},"headline":"知识铺","image":["https://zshipu.com/img/og_image.png"],"datePublished":"2020-04-11T03:39:44.000Z","dateModified":"2020-09-08T14:03:00.343Z","author":{"@type":"Person","name":"知识铺"},"description":"快速开始让我们创建一个最小的 Go 工具包服务。现在，我们将为此使用单个文件。 12main.go   您的业务逻辑您的服务从业务逻辑开始。在 Go 工具包中，我们将服务建模为接口。 12345678910111213141516&#x2F;&#x2F; StringService provides operations on strings.import &quot;context&quot;t"}</script><link rel="canonical" href="https://zshipu.com/2020/04/11/Gokit-go%E6%B5%81%E8%A1%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script data-ad-client="2183476622" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="generator" content="Hexo 5.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="知识铺" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-04-11T03:39:44.000Z" title="2020-04-11T03:39:44.000Z">2020-04-11</time>发表</span><span class="level-item"><time dateTime="2020-09-08T14:03:00.343Z" title="2020-09-08T14:03:00.343Z">2020-09-08</time>更新</span><span class="level-item"> 知识铺 </span><span class="level-item">26 分钟读完 (大约3968个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Gokit go流行微服务入门</h1><div class="content"><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>让我们创建一个最小的 Go 工具包服务。现在，我们将为此使用单个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main.go</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="您的业务逻辑"><a href="#您的业务逻辑" class="headerlink" title="您的业务逻辑"></a>您的业务逻辑</h2><p>您的服务从业务逻辑开始。在 Go 工具包中，我们将服务建模为<strong>接口</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; StringService provides operations on strings.</span><br><span class="line">import &quot;context&quot;</span><br><span class="line"></span><br><span class="line">type StringService interface &#123;</span><br><span class="line">	Uppercase(string) (string, error)</span><br><span class="line">	Count(string) int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">该接口将具有实现。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>import (<br>    “context”<br>    “errors”<br>    “strings”<br>)</p>
<p>type stringService struct{}</p>
<p>func (stringService) Uppercase(s string) (string, error) {<br>    if s == “” {<br>        return “”, ErrEmpty<br>    }<br>    return strings.ToUpper(s), nil<br>}</p>
<p>func (stringService) Count(s string) int {<br>    return len(s)<br>}</p>
<p>// ErrEmpty is returned when input string is empty<br>var ErrEmpty = errors.New(“Empty string”)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 请求和响应</span><br><span class="line"></span><br><span class="line">在 Go 工具包中，主要消息传递模式是 RPC。因此，我们接口中的每个方法都将建模为远程过程调用。对于每种方法，我们定义**请求和响应**结构，分别捕获所有输入和输出参数。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>type uppercaseRequest struct {<br>    S string <code>json:&quot;s&quot;</code><br>}</p>
<p>type uppercaseResponse struct {<br>    V   string <code>json:&quot;v&quot;</code><br>    Err string <code>json:&quot;err,omitempty&quot;</code> // errors don’t JSON-marshal, so we use a string<br>}</p>
<p>type countRequest struct {<br>    S string <code>json:&quot;s&quot;</code><br>}</p>
<p>type countResponse struct {<br>    V int <code>json:&quot;v&quot;</code><br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 节点</span><br><span class="line"></span><br><span class="line">Go 工具包通过称为**终结点**的抽象提供其大部分功能。</span><br><span class="line"></span><br><span class="line">终结点的定义如下（您不必将其放在代码的任意位置，它由 提供。</span><br></pre></td></tr></table></figure>
<p>go-kit</p>
<p>type Endpoint func(ctx context.Context, request interface{}) (response interface{}, err error)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">它表示单个 RPC。也就是说，我们的服务接口中的一种方法。我们将编写简单的适配器，将服务的每个方法转换为终结点。每个适配器采用 StringService，并返回对应于其中一种方法的终结点。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>import (<br>    “context”<br>    “github.com/go-kit/kit/endpoint”<br>)</p>
<p>func makeUppercaseEndpoint(svc StringService) endpoint.Endpoint {<br>    return func(_ context.Context, request interface{}) (interface{}, error) {<br>        req := request.(uppercaseRequest)<br>        v, err := svc.Uppercase(req.S)<br>        if err != nil {<br>            return uppercaseResponse{v, err.Error()}, nil<br>        }<br>        return uppercaseResponse{v, “”}, nil<br>    }<br>}</p>
<p>func makeCountEndpoint(svc StringService) endpoint.Endpoint {<br>    return func(_ context.Context, request interface{}) (interface{}, error) {<br>        req := request.(countRequest)<br>        v := svc.Count(req.S)<br>        return countResponse{v}, nil<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 传输</span><br><span class="line"></span><br><span class="line">现在，我们需要将您的服务暴露给外部世界，以便可以调用它。您的组织可能已经对服务应该如何相互对话了。也许你使用节俭，或自定义JSON通过HTTP。Go 套件支持开箱即用的许多**传输**。</span><br><span class="line"></span><br><span class="line">对于此最小示例服务，让我们在 HTTP 上使用 JSON。Go 套件在包传输&#x2F;http 中提供了帮助器结构。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>import (<br>    “context”<br>    “encoding/json”<br>    “log”<br>    “net/http”</p>
<pre><code>httptransport &quot;github.com/go-kit/kit/transport/http&quot;</code></pre>
<p>)</p>
<p>func main() {<br>    svc := stringService{}</p>
<pre><code>uppercaseHandler := httptransport.NewServer(
    makeUppercaseEndpoint(svc),
    decodeUppercaseRequest,
    encodeResponse,
)

countHandler := httptransport.NewServer(
    makeCountEndpoint(svc),
    decodeCountRequest,
    encodeResponse,
)

http.Handle(&quot;/uppercase&quot;, uppercaseHandler)
http.Handle(&quot;/count&quot;, countHandler)
log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))</code></pre>
<p>}</p>
<p>func decodeUppercaseRequest(_ context.Context, r *http.Request) (interface{}, error) {<br>    var request uppercaseRequest<br>    if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil {<br>        return nil, err<br>    }<br>    return request, nil<br>}</p>
<p>func decodeCountRequest(_ context.Context, r *http.Request) (interface{}, error) {<br>    var request countRequest<br>    if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil {<br>        return nil, err<br>    }<br>    return request, nil<br>}</p>
<p>func encodeResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {<br>    return json.NewEncoder(w).Encode(response)<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 字符串vc1</span><br><span class="line"></span><br><span class="line">到目前为止，完整的服务是[stringsvc1。](https:&#x2F;&#x2F;zshipu.com&#x2F;t?url&#x3D;https:&#x2F;&#x2F;github.com&#x2F;go-kit&#x2F;kit&#x2F;blob&#x2F;master&#x2F;examples&#x2F;stringsvc1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>$ go get github.com/go-kit/kit/examples/stringsvc1<br>$ stringsvc1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>$ curl -XPOST -d’{“s”:”hello, world”}’ localhost:8080/uppercase<br>{“v”:”HELLO, WORLD”}<br>$ curl -XPOST -d’{“s”:”hello, world”}’ localhost:8080/count<br>{“v”:12}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 中间件</span><br><span class="line"></span><br><span class="line">如果没有彻底的日志记录和检测，任何服务都无法被视为生产就绪。</span><br><span class="line"></span><br><span class="line">## 关切事项的分离</span><br><span class="line"></span><br><span class="line">将标注图的每一层分离到单个文件中，使 go-kit 项目在增加服务终结点数量时更易于阅读。我们的第一个示例[stringsvc1](https:&#x2F;&#x2F;zshipu.com&#x2F;t?url&#x3D;https:&#x2F;&#x2F;github.com&#x2F;go-kit&#x2F;kit&#x2F;blob&#x2F;master&#x2F;examples&#x2F;stringsvc1)在单个主文件中包含所有这些层。在增加更复杂的内容之前，让我们将代码分离到以下文件中，并将所有剩余的代码保留在 main.go 中。</span><br><span class="line"></span><br><span class="line">将**服务**放入服务.go 文件中，包含以下功能和类型。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>type StringService<br>type stringService<br>func Uppercase<br>func Count<br>var ErrEmpty</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">将**传输**放入具有以下函数和类型的文件中。</span><br></pre></td></tr></table></figure>
<p>transport.go</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>func makeUppercaseEndpoint<br>func makeCountEndpoint<br>func decodeUppercaseRequest<br>func decodeCountRequest<br>func encodeResponse<br>type uppercaseRequest<br>type uppercaseResponse<br>type countRequest<br>type countResponse</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 传输日志记录</span><br><span class="line"></span><br><span class="line">任何需要记录的组件都应将记录器视为依赖项，与数据库连接相同。因此，我们在 中构造我们的记录器，并将其传递给需要它的组件。我们从不使用全局范围的记录器。</span><br></pre></td></tr></table></figure>
<p>func main</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">我们可以将记录器直接传递到我们的 stringService 实现中，但有更好的方法。让我们使用**中间件**，也称为装饰器。中间件是获取终结点并返回终结点的函数。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>type Middleware func(Endpoint) Endpoint</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 请注意，中间件类型由 go-kit 为您提供。</span><br><span class="line"></span><br><span class="line">在这两者之间，它可以做任何事情。下面您可以看到如何实现基本日志记录中间件（您无需在任何地方复制&#x2F;粘贴此代码）：</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>func loggingMiddleware(logger log.Logger) Middleware {<br>    return func(next endpoint.Endpoint) endpoint.Endpoint {<br>        return func(ctx context.Context, request interface{}) (interface{}, error) {<br>            logger.Log(“msg”, “calling endpoint”)<br>            defer logger.Log(“msg”, “called endpoint”)<br>            return next(ctx, request)<br>        }<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">使用[go-kit 日志](https:&#x2F;&#x2F;zshipu.com&#x2F;t?url&#x3D;https:&#x2F;&#x2F;gokit.io&#x2F;faq&#x2F;#logging-mdash-why-is-package-log-so-different)包并删除标准库[日志](https:&#x2F;&#x2F;zshipu.com&#x2F;t?url&#x3D;https:&#x2F;&#x2F;golang.org&#x2F;pkg&#x2F;log&#x2F;)。您需要从文件底部删除。</span><br><span class="line"></span><br><span class="line">log.Fatal</span><br></pre></td></tr></table></figure>
<p>main.go</p>
<p>import (<br> “github.com/go-kit/kit/log”<br>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">并将其连接到我们的每个处理程序中。请注意，下一个代码部分_不会_编译，直到您遵循**应用程序日志记录**部分，该部分定义日志记录中间件。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>logger := log.NewLogfmtLogger(os.Stderr)</p>
<p>svc := stringService{}</p>
<p>var uppercase endpoint.Endpoint<br>uppercase = makeUppercaseEndpoint(svc)<br>uppercase = loggingMiddleware(log.With(logger, “method”, “uppercase”))(uppercase)</p>
<p>var count endpoint.Endpoint<br>count = makeCountEndpoint(svc)<br>count = loggingMiddleware(log.With(logger, “method”, “count”))(count)</p>
<p>uppercaseHandler := httptransport.NewServer(<br>    uppercase,<br>    // …<br>)</p>
<p>countHandler := httptransport.NewServer(<br>    count,<br>    // …<br>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">事实证明，这种技术对于不仅仅是日志记录非常有用。许多 Go 工具包组件都作为端点中间件实现。</span><br><span class="line"></span><br><span class="line">## 应用程序日志记录</span><br><span class="line"></span><br><span class="line">但是，如果我们想要登录应用程序域，如传入的参数，该怎么办？事实证明，我们可以为我们的服务定义一个中间件，并获得同样好和可组合的效果。由于我们的 StringService 被定义为接口，因此我们只需要制作一种新类型，以包装现有的 StringService 并执行额外的日志记录职责。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>type loggingMiddleware struct {<br>    logger log.Logger<br>    next   StringService<br>}</p>
<p>func (mw loggingMiddleware) Uppercase(s string) (output string, err error) {<br>    defer func(begin time.Time) {<br>        mw.logger.Log(<br>            “method”, “uppercase”,<br>            “input”, s,<br>            “output”, output,<br>            “err”, err,<br>            “took”, time.Since(begin),<br>        )<br>    }(time.Now())</p>
<pre><code>output, err = mw.next.Uppercase(s)
return</code></pre>
<p>}</p>
<p>func (mw loggingMiddleware) Count(s string) (n int) {<br>    defer func(begin time.Time) {<br>        mw.logger.Log(<br>            “method”, “count”,<br>            “input”, s,<br>            “n”, n,<br>            “took”, time.Since(begin),<br>        )<br>    }(time.Now())</p>
<pre><code>n = mw.next.Count(s)
return</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">And wire it in.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>import (<br>    “os”</p>
<pre><code>&quot;github.com/go-kit/kit/log&quot;
httptransport &quot;github.com/go-kit/kit/transport/http&quot;</code></pre>
<p>)</p>
<p>func main() {<br>    logger := log.NewLogfmtLogger(os.Stderr)</p>
<pre><code>var svc StringService
svc = stringService&#123;&#125;
svc = loggingMiddleware&#123;logger, svc&#125;

// ...

uppercaseHandler := httptransport.NewServer(
    makeUppercaseEndpoint(svc),
    // ...
)

countHandler := httptransport.NewServer(
    makeCountEndpoint(svc),
    // ...
)</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">使用端点中间件解决传输域问题，如电路中断和速率限制。将服务中间件用于业务领域问题，如日志记录和检测。说到仪器...</span><br><span class="line"></span><br><span class="line">## 应用仪器</span><br><span class="line"></span><br><span class="line">在 Go 工具包中，检测意味着使用**包指标**记录有关服务运行时行为的统计信息。计算处理的作业数、记录请求完成后的持续时间以及跟踪在飞行中操作的数量都将被视为检测。</span><br><span class="line"></span><br><span class="line">我们可以使用与用于日志记录相同的中间件模式。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>type instrumentingMiddleware struct {<br>    requestCount   metrics.Counter<br>    requestLatency metrics.Histogram<br>    countResult    metrics.Histogram<br>    next           StringService<br>}</p>
<p>func (mw instrumentingMiddleware) Uppercase(s string) (output string, err error) {<br>    defer func(begin time.Time) {<br>        lvs := []string{“method”, “uppercase”, “error”, fmt.Sprint(err != nil)}<br>        mw.requestCount.With(lvs…).Add(1)<br>        mw.requestLatency.With(lvs…).Observe(time.Since(begin).Seconds())<br>    }(time.Now())</p>
<pre><code>output, err = mw.next.Uppercase(s)
return</code></pre>
<p>}</p>
<p>func (mw instrumentingMiddleware) Count(s string) (n int) {<br>    defer func(begin time.Time) {<br>        lvs := []string{“method”, “count”, “error”, “false”}<br>        mw.requestCount.With(lvs…).Add(1)<br>        mw.requestLatency.With(lvs…).Observe(time.Since(begin).Seconds())<br>        mw.countResult.Observe(float64(n))<br>    }(time.Now())</p>
<pre><code>n = mw.next.Count(s)
return</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">并连接到我们的服务。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>import (<br>    stdprometheus “github.com/prometheus/client_golang/prometheus”<br>    kitprometheus “github.com/go-kit/kit/metrics/prometheus”<br>    “github.com/go-kit/kit/metrics”<br>)</p>
<p>func main() {<br>    logger := log.NewLogfmtLogger(os.Stderr)</p>
<pre><code>fieldKeys := []string&#123;&quot;method&quot;, &quot;error&quot;&#125;
requestCount := kitprometheus.NewCounterFrom(stdprometheus.CounterOpts&#123;
    Namespace: &quot;my_group&quot;,
    Subsystem: &quot;string_service&quot;,
    Name:      &quot;request_count&quot;,
    Help:      &quot;Number of requests received.&quot;,
&#125;, fieldKeys)
requestLatency := kitprometheus.NewSummaryFrom(stdprometheus.SummaryOpts&#123;
    Namespace: &quot;my_group&quot;,
    Subsystem: &quot;string_service&quot;,
    Name:      &quot;request_latency_microseconds&quot;,
    Help:      &quot;Total duration of requests in microseconds.&quot;,
&#125;, fieldKeys)
countResult := kitprometheus.NewSummaryFrom(stdprometheus.SummaryOpts&#123;
    Namespace: &quot;my_group&quot;,
    Subsystem: &quot;string_service&quot;,
    Name:      &quot;count_result&quot;,
    Help:      &quot;The result of each count method.&quot;,
&#125;, []string&#123;&#125;) // no fields here

var svc StringService
svc = stringService&#123;&#125;
svc = loggingMiddleware&#123;logger, svc&#125;
svc = instrumentingMiddleware&#123;requestCount, requestLatency, countResult, svc&#125;

uppercaseHandler := httptransport.NewServer(
    makeUppercaseEndpoint(svc),
    decodeUppercaseRequest,
    encodeResponse,
)

countHandler := httptransport.NewServer(
    makeCountEndpoint(svc),
    decodeCountRequest,
    encodeResponse,
)

http.Handle(&quot;/uppercase&quot;, uppercaseHandler)
http.Handle(&quot;/count&quot;, countHandler)
http.Handle(&quot;/metrics&quot;, promhttp.Handler())
logger.Log(&quot;msg&quot;, &quot;HTTP&quot;, &quot;addr&quot;, &quot;:8080&quot;)
logger.Log(&quot;err&quot;, http.ListenAndServe(&quot;:8080&quot;, nil))</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 字符串vc2</span><br><span class="line"></span><br><span class="line">The complete service so far is [stringsvc2](https:&#x2F;&#x2F;zshipu.com&#x2F;t?url&#x3D;https:&#x2F;&#x2F;github.com&#x2F;go-kit&#x2F;kit&#x2F;blob&#x2F;master&#x2F;examples&#x2F;stringsvc2).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>$ go get github.com/go-kit/kit/examples/stringsvc2<br>$ stringsvc2<br>msg=HTTP addr=:8080</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>$ curl -XPOST -d’{“s”:”hello, world”}’ localhost:8080/uppercase<br>{“v”:”HELLO, WORLD”}<br>$ curl -XPOST -d’{“s”:”hello, world”}’ localhost:8080/count<br>{“v”:12}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>method=uppercase input=”hello, world” output=”HELLO, WORLD” err=null took=2.455µs<br>method=count input=”hello, world” n=12 took=743ns</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Calling other services</span><br><span class="line"></span><br><span class="line">It’s rare that a service exists in a vacuum. Often, you need to call other services. **This is where Go kit shines**. We provide transport middlewares to solve many of the problems that come up.</span><br><span class="line"></span><br><span class="line">Let’s say that we want to have our string service call out to a _different_ string service to satisfy the Uppercase method. In effect, proxying the request to another service. Let’s implement the proxying middleware as a ServiceMiddleware, same as a logging or instrumenting middleware.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>// proxymw implements StringService, forwarding Uppercase requests to the<br>// provided endpoint, and serving all other (i.e. Count) requests via the<br>// next StringService.<br>type proxymw struct {<br>    next      StringService     // Serve most requests via this service…<br>    uppercase endpoint.Endpoint // …except Uppercase, which gets served by this endpoint<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 客户端终结点</span><br><span class="line"></span><br><span class="line">我们有完全相同的终结点，我们已经知道，但我们会使用它调用，而不是服务，一个请求。以这种方式使用时，我们称之为_客户端_终结点。为了调用客户端终结点，我们只需执行一些简单的转换。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>func (mw proxymw) Uppercase(s string) (string, error) {<br>    response, err := mw.uppercase(uppercaseRequest{S: s})<br>    if err != nil {<br>        return “”, err<br>    }<br>    resp := response.(uppercaseResponse)<br>    if resp.Err != “” {<br>        return resp.V, errors.New(resp.Err)<br>    }<br>    return resp.V, nil<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">现在，为了构造这些代理中间件之一，我们将代理 URL 字符串转换为终结点。如果我们假设 JSON 通过 HTTP，我们可以在传输&#x2F;http 包中使用帮助程序。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>import (<br>    httptransport “github.com/go-kit/kit/transport/http”<br>)</p>
<p>func proxyingMiddleware(proxyURL string) ServiceMiddleware {<br>    return func(next StringService) StringService {<br>        return proxymw{next, makeUppercaseProxy(proxyURL)}<br>    }<br>}</p>
<p>func makeUppercaseProxy(proxyURL string) endpoint.Endpoint {<br>    return httptransport.NewClient(<br>        “GET”,<br>        mustParseURL(proxyURL),<br>        encodeUppercaseRequest,<br>        decodeUppercaseResponse,<br>    ).Endpoint()<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 服务发现和负载平衡</span><br><span class="line"></span><br><span class="line">如果我们只有一个远程服务，这很好。但在现实中，我们可能有许多可用的服务实例。我们希望通过一些服务发现机制来发现它们，并将我们的负载分散到所有这些机制中。如果其中任何一个实例开始表现不佳，我们希望处理这一点，而不会影响我们服务的可靠性。</span><br><span class="line"></span><br><span class="line">Go 工具包为不同的服务发现系统提供适配器，以获取最新实例集，这些实例作为单个终结点公开。这些适配器称为订阅者。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>type Subscriber interface {<br>    Endpoints() ([]endpoint.Endpoint, error)<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">在内部，订阅者使用提供的工厂函数将每个发现的实例字符串（通常是主机：端口）转换为可用的终结点。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>type Factory func(instance string) (endpoint.Endpoint, error)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">到目前为止，我们的工厂功能，使上文代理，只是直接调用URL。但是，将一些安全中间件（如断路器和限速器）放入工厂也很重要。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>var e endpoint.Endpoint<br>e = makeUppercaseProxy(instance)<br>e = circuitbreaker.Gobreaker(gobreaker.NewCircuitBreaker(gobreaker.Settings{}))(e)<br>e = kitratelimit.NewTokenBucketLimiter(jujuratelimit.NewBucketWithRate(float64(maxQPS), int64(maxQPS)))(e)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">现在，我们有一组终结点，我们需要选择一个。负载均衡器包装订阅者，并从多个中选择一个终结点。Go 套件提供了几个基本的负载均衡器，如果您想要更高级的启发式方法，则很容易编写您自己的设备。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>type Balancer interface {<br>    Endpoint() (endpoint.Endpoint, error)<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">现在，我们有能力根据一些启发式选择端点。我们可以用它来向使用者提供单个、逻辑的、可靠的终结点。重试策略将包装负载均衡器，并返回可用的终结点。重试策略将重试失败的请求，直到达到最大尝试或超时。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>func Retry(max int, timeout time.Duration, lb Balancer) endpoint.Endpoint</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">让我们电汇我们最后的代理中间件。为简单起见，我们假设用户将指定多个带有标志的逗号分隔实例终结点。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>func proxyingMiddleware(instances string, logger log.Logger) ServiceMiddleware {<br>    // If instances is empty, don’t proxy.<br>    if instances == “” {<br>        logger.Log(“proxy_to”, “none”)<br>        return func(next StringService) StringService { return next }<br>    }</p>
<pre><code>// Set some parameters for our client.
var (
    qps         = 100                    // beyond which we will return an error
    maxAttempts = 3                      // per request, before giving up
    maxTime     = 250 * time.Millisecond // wallclock time, before giving up
)

// Otherwise, construct an endpoint for each instance in the list, and add
// it to a fixed set of endpoints. In a real service, rather than doing this
// by hand, you&#39;d probably use package sd&#39;s support for your service
// discovery system.
var (
    instanceList = split(instances)
    subscriber   sd.FixedSubscriber
)
logger.Log(&quot;proxy_to&quot;, fmt.Sprint(instanceList))
for _, instance := range instanceList &#123;
    var e endpoint.Endpoint
    e = makeUppercaseProxy(instance)
    e = circuitbreaker.Gobreaker(gobreaker.NewCircuitBreaker(gobreaker.Settings&#123;&#125;))(e)
    e = kitratelimit.NewTokenBucketLimiter(jujuratelimit.NewBucketWithRate(float64(qps), int64(qps)))(e)
    subscriber = append(subscriber, e)
&#125;

// Now, build a single, retrying, load-balancing endpoint out of all of
// those individual endpoints.
balancer := lb.NewRoundRobin(subscriber)
retry := lb.Retry(maxAttempts, maxTime, balancer)

// And finally, return the ServiceMiddleware, implemented by proxymw.
return func(next StringService) StringService &#123;
    return proxymw&#123;next, retry&#125;
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 字符串vc3</span><br><span class="line"></span><br><span class="line">The complete service so far is [stringsvc3](https:&#x2F;&#x2F;zshipu.com&#x2F;t?url&#x3D;https:&#x2F;&#x2F;github.com&#x2F;go-kit&#x2F;kit&#x2F;blob&#x2F;master&#x2F;examples&#x2F;stringsvc3).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>$ go get github.com/go-kit/kit/examples/stringsvc3<br>$ stringsvc3 -listen=:8001 &amp;<br>listen=:8001 caller=proxying.go:25 proxy_to=none<br>listen=:8001 caller=main.go:72 msg=HTTP addr=:8001<br>$ stringsvc3 -listen=:8002 &amp;<br>listen=:8002 caller=proxying.go:25 proxy_to=none<br>listen=:8002 caller=main.go:72 msg=HTTP addr=:8002<br>$ stringsvc3 -listen=:8003 &amp;<br>listen=:8003 caller=proxying.go:25 proxy_to=none<br>listen=:8003 caller=main.go:72 msg=HTTP addr=:8003<br>$ stringsvc3 -listen=:8080 -proxy=localhost:8001,localhost:8002,localhost:8003<br>listen=:8080 caller=proxying.go:29 proxy_to=”[localhost:8001 localhost:8002 localhost:8003]”<br>listen=:8080 caller=main.go:72 msg=HTTP addr=:8080</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>$ for s in foo bar baz ; do curl -d”{&quot;s&quot;:&quot;$s&quot;}” localhost:8080/uppercase ; done<br>{“v”:”FOO”}<br>{“v”:”BAR”}<br>{“v”:”BAZ”}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>listen=:8001 caller=logging.go:28 method=uppercase input=foo output=FOO err=null took=5.168µs<br>listen=:8080 caller=logging.go:28 method=uppercase input=foo output=FOO err=null took=4.39012ms<br>listen=:8002 caller=logging.go:28 method=uppercase input=bar output=BAR err=null took=5.445µs<br>listen=:8080 caller=logging.go:28 method=uppercase input=bar output=BAR err=null took=2.04831ms<br>listen=:8003 caller=logging.go:28 method=uppercase input=baz output=BAZ err=null took=3.285µs<br>listen=:8080 caller=logging.go:28 method=uppercase input=baz output=BAZ err=null took=1.388155ms</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 高级主题</span><br><span class="line"></span><br><span class="line">## 线程上下文</span><br><span class="line"></span><br><span class="line">上下文对象用于在单个请求的范围内跨概念边界传递信息。在我们的示例中，我们还没有通过业务逻辑来线程化上下文。但这几乎总是一个好主意。它允许您在业务逻辑和中间件之间传递请求范围的信息，对于更复杂的任务（如粒度分布式跟踪注释）是必需的。</span><br><span class="line"></span><br><span class="line">具体来说，这意味着您的业务逻辑接口将看起来像</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>type MyService interface {<br>    Foo(context.Context, string, int) (string, error)<br>    Bar(context.Context, string) error<br>    Baz(context.Context) (int, error)<br>}</p>
<pre><code>
## 分布式跟踪

一旦基础结构增长到超过特定规模，通过多个服务跟踪请求就变得非常重要，因此您可以识别和排除热点。有关详细信息，请参阅[包跟踪](https://zshipu.com/t?url=https://github.com/go-kit/kit/blob/master/tracing)。

## 创建客户端包

可以使用 Go 工具包为服务创建客户端包，以便从其他 Go 程序更轻松地使用服务。实际上，客户端包将提供服务接口的实现，该服务接口使用特定传输调用远程服务实例。有关示例，请参阅[添加vc/cmd/addcli](https://zshipu.com/t?url=https://github.com/go-kit/kit/blob/master/examples/addsvc/cmd/addcli)或[包配置文件/客户端](https://zshipu.com/t?url=https://github.com/go-kit/kit/blob/master/examples/profilesvc/client)。</code></pre>
</div><div class="article-licensing box"><div class="licensing-title"><p>Gokit go流行微服务入门</p><p><a href="https://zshipu.com/2020/04/11/Gokit-go%E6%B5%81%E8%A1%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/">https://zshipu.com/2020/04/11/Gokit-go%E6%B5%81%E8%A1%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>知识铺</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-04-11</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2020-09-08</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=5f58e448b1477000121881fb&amp;product=inline-share-buttons" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/weixin.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/04/11/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9go-kit/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">为什么选择go-kit</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/04/10/JVM%E8%87%AA%E5%8A%A8%E6%8E%A8%E8%8D%90%E6%96%87%E7%AB%A0%E5%88%97%E8%A1%A8-1/"><span class="level-item">JVM自动推荐文章列表</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://zshipu.com/2020/04/11/Gokit-go%E6%B5%81%E8%A1%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/';
            this.page.identifier = '2020/04/11/Gokit-go流行微服务入门/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'zsp' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://www.gravatar.com/avatar/2396bdfe5aadb513e676094004dde830?s=128" alt="edwin"></figure><p class="title is-size-4 is-block line-height-inherit">edwin</p><p class="is-size-6 is-block">知识铺</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国 杭州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">189</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">2</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/liliang8858" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/liliang8858"><i class="Github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="社区"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="设计"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/go/"><span class="level-start"><span class="level-item">go</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T10:43:02.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/Spring%20Cloud%20Gateway+Nacos%EF%BC%8Cyml+properties%E4%B8%A4%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BA%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1/">Spring Cloud Gateway+Nacos，yml+properties两种配置文件方式搭建网关服务</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T10:39:59.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/Spring%20Cloud+nacos+Feign%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/">Spring Cloud+nacos+Feign，实现注册中心及配置中心</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T10:32:26.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/Nacos%E4%BD%9C%E4%B8%BA%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%97%B6%EF%BC%8C%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AAdataId%E7%9A%84%E9%85%8D%E7%BD%AE/">Nacos作为配置中心时，多个服务共用一个dataId的配置</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T09:34:29.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/SpringCloudAlibaba(%E4%B8%89)%EF%BC%9A%E4%BD%BF%E7%94%A8Nacos%E4%BD%9C%E4%B8%BA%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/">SpringCloudAlibaba(三)：使用Nacos作为配置中心</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-16T09:31:53.000Z">2020-07-16</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/16/Nacos%20%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/">Nacos 集群部署</a></p><p class="is-uppercase"></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">37</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">62</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web/"><span class="tag">web</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">广告</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="2183476622" data-ad-slot="pub-2874221941555456" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="知识铺" height="28"></a><p class="size-small"><span>&copy; 2020 知识铺</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://zshipu.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>