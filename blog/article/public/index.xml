<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>知识铺</title>
    <link>https://blog.zshipu.com/article/public/</link>
    <description>Recent content on 知识铺</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    
	<atom:link href="https://blog.zshipu.com/article/public/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson0/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson0/readme/</guid>
      <description>《搭建 Node.js 开发环境》 本课程假设大家都是在 Linux 或者 Mac 下面。至于使用 Windows 并坚持玩新技术的同学，我坚信他们一定有着过人的、甚至是不可告人的兼容性 bug 处理能力，所以这部分同学麻烦在课程无法继续时，自行兼容一下。
不久前公司刚发一台新 Mac 给我，所以我对于在新环境中安装 Node.js 的过程还是记忆犹新的。
其实这过程特别简单:
先安装一个 nvm（ https://github.com/creationix/nvm ） $ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.25.2/install.sh | bash  nvm 的全称是 Node Version Manager，之所以需要这个工具，是因为 Node.js 的各种特性都没有稳定下来，所以我们经常由于老项目或尝新的原因，需要切换各种版本。
安装完成后，你的 shell 里面应该就有个 nvm 命令了，调用它试试
$ nvm  当看到有输出时，则 nvm 安装成功。
安装 Node.js 使用 nvm 的命令安装 Node.js 最新稳定版，现在是 v0.12.3。
$ nvm install 0.12  安装完成后，查看一下
$ nvm ls  这时候可以看到自己安装的所有 Node.js 版本，输出应如下：
（图1）</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson10/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson10/readme/</guid>
      <description>《benchmark 怎么写》 目标 有一个字符串 var number = &#39;100&#39;，我们要将它转换成 Number 类型的 100。
目前有三个选项：+, parseInt, Number
请测试哪个方法更快。
知识点  学习使用 benchmark 库 学习使用 http://jsperf.com/ 分享你的 benchmark  课程内容 首先去弄个 benchmark 库，https://github.com/bestiejs/benchmark.js 。
 这个库已经两年没有更新了，两年前发了个 1.0.0 版本，直到现在。 
这个库的最新版本是 2.1.4
用法也特别简单，照着官网的 copy 下来就好。
我们先来实现这三个函数：
var int1 = function (str) { return +str; }; var int2 = function (str) { return parseInt(str, 10); }; var int3 = function (str) { return Number(str); };  然后照着官方的模板写 benchmark suite：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson11/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson11/readme/</guid>
      <description>《作用域与闭包：this，var，(function () {})》 目标 无具体目标
知识点  理解 js 中 var 的作用域 了解闭包的概念 理解 this 的指向  课程内容 es6中新增了 let 关键词，与块级作用域，相关知识参考： http://es6.ruanyifeng.com/#docs/let
var 作用域 先来看个简单的例子：
var parent = function () { var name = &amp;quot;parent_name&amp;quot;; var age = 13; var child = function () { var name = &amp;quot;child_name&amp;quot;; var childAge = 0.3; // =&amp;gt; child_name 13 0.3 console.log(name, age, childAge); }; child(); // will throw Error // ReferenceError: childAge is not defined console.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson12/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson12/readme/</guid>
      <description>《线上部署：heroku》 目标 将 https://github.com/Ricardo-Li/node-practice-2 (这个项目已经被删了。参照 https://github.com/alsotang/node-lessons/tree/master/lesson3 的代码自己操作一下吧。)这个项目部署上 heroku，成为一个线上项目
我部署的在这里 http://serene-falls-9294.herokuapp.com/
知识点  学习 heroku 的线上部署(https://www.heroku.com/ )  课程内容 什么是 heroku heroku 是弄 ruby 的 paas 起家，现在支持多种语言环境，更甚的是它强大的 add-on 服务。
paas 平台相信大家都不陌生。Google 有 gae，国内新浪有 sae。paas 平台相对 vps 来说，不需要你配置服务器，不需要装数据库，也不需要理会负载均衡。这一切都可以在平台上直接获取。
你只要专注自己的业务，把应用的逻辑写好，然后发布上去，应用自然就上线了。数据库方面，如果你用 mysql，那么你可以从平台商那里得到一个 mysql 的地址、账号和密码，直接连接就能用。如果应用的流量增大，需要横向拓展，则只用去到 paas 平台的管理页面，增大服务器实例的数量即可，负载均衡会自动帮你完成。
说起来，我之所以对于 web 开发产生兴趣也是因为当年 gae 的关系。那时候除了 gae 之外，没有别的 paas 平台，gae 是横空出世的。有款翻墙的软件，叫 gappproxy(https://code.google.com/p/gappproxy/ )——可以认为是 goagent 的前身——就是搭建在 gae 上面的，不仅快，而且免费。于是我就很想弄懂这样一个程序是如何开发的。好在 gappproxy 是开源的，于是我下了源码来看，那时候才大一，只学过 c，看到那些 python 代码就凌乱了。于是转头也去学 python，后来渐渐发现了 web 开发的乐趣，于是 ruby 和 node.js 也碰碰。后来 goagent 火起来了，我又去看了看它的代码，发现非常难看，就自己写了个 https://github.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson13/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson13/readme/</guid>
      <description>《持续集成平台：travis》 目标 无明确目标
知识点  学习使用 travis-ci 对项目进行持续集成测试 (https://travis-ci.org/ )  课程内容 首先来看看这个项目：https://github.com/Ricardo-Li/node-practice-3
（图1）
类似这样的 badges，在很多项目中都可以看到。前者是告诉我们，这个项目的测试目前是通过的；后者是告诉我们，这个测试的行覆盖率是多少。行覆盖率当然是越多越好。测试的重要性我就不说了。
为什么要使用 travis 这样的平台，是因为它可以让你明白自己的项目在一个“空白环境”中，是否能正确运行；也可以让你知道，用不同的 Node.js 版本运行的话，有没有兼容性问题。
当你在自己的机器上跑测试的时候，你用着特定的 Node.js 版本，比如 0.10，如果测试过了，你也还是不懂在 0.11 下，你的测试能不能通过。你可以手动地切换 node 版本再跑一次，也可以选择让 travis 帮你把不同的 node 版本跑一次。而且有时候，我们 npm 安装了某个包，但却忘记将它写入 package.json 里面了，在自己的机器上，测试没问题，但当别的用户安装你的包时，会发现有依赖缺失。
travis 应该是把虚拟机的技术玩得比较好，它每次跑测试时，都会提供一个空白的环境。这个环境只有 Linux 基本的 build-essential 和 wget、git 那些依赖。连 Node.js 的运行时都是现跑现安装的。
travis 默认带有的那些依赖，都是每个用户的机器上都会有的，所以一旦你的应用在 travis 上面能够跑通，那么就不用担心别的用户安装不上了。
我们来讲讲接入 travis 的步骤。
travis 的价格是免费的，对于 github 上的开源项目来说。它默认当然不可能帮 github 的每个用户都跑测试，所以你需要去注册一下 travis，然后告诉它你需要开启集成测试的仓库。
比如上图，可以看到我帮自己的 alsohosts 项目以及 adsf 项目开启了测试。
当你在 travis 授权了仓库之后，每当你 push 代码到 github，travis 都会自动帮你跑测试。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson14/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson14/readme/</guid>
      <description>《js 中的那些最佳实践》 这个章节需要大家帮忙补充，一次性想不完那么多
JavaScript 语言精粹 http://book.douban.com/subject/3590768/
这本书很薄，只有 155 页，但该讲的几乎都讲了。大家想办法搞来看看吧（我总不能很没节操地给个电子版 PDF 链接在这里吧）。
js 这门语言，水很浅。没有太复杂的地方可以钻，但特么的坑又多。
上面的那本书是一定要看的。这本书专注在讲 js 语法，其他 js 的书都过多地涉及了浏览器知识。
JavaScript 之美  其一：http://fxck.it/post/72326363595 其二：http://fxck.it/post/73513189448  继承 js 前端不懂有什么好办法，后端的话，很方便。
用 node 官方的 util 库，下面是直接从官网摘抄来的：
var util = require(&amp;quot;util&amp;quot;); var events = require(&amp;quot;events&amp;quot;); function MyStream() { events.EventEmitter.call(this); } util.inherits(MyStream, events.EventEmitter); MyStream.prototype.write = function(data) { this.emit(&amp;quot;data&amp;quot;, data); } var stream = new MyStream(); console.log(stream instanceof events.EventEmitter); // true console.log(MyStream.super_ === events.EventEmitter); // true stream.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson14/%E8%A7%A3%E5%AF%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8E%8B%E5%9E%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson14/%E8%A7%A3%E5%AF%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8E%8B%E5%9E%A0/</guid>
      <description>有些人问我，你说学习操作系统的最好办法是学习程序设计。那我们是不是应该学习一些“设计模式”（design patterns）。这是一个我很早就有定论，而且经过实践检验的问题，所以想在这里做一个总结。
　总的来说，如果光从字面上讲，程序里总是有一些“模式”可以发掘的。因为你总是可以借鉴以前的经验，来构造新的程序。你可以把这种“经验”叫做“模式”。可是自从《设计模式》（通常叫做 GoF，“Gang of Four”）这本书在 1994 年发表以来，“设计模式”这个词有了新的，扭曲的含义。它变成了一种教条，带来了公司里程序的严重复杂化。
　GoF 借鉴的是一个叫 Christopher Alexander 的建筑师的做法。Alexander 给一些建筑学里的“设计模式”起了名字，试图让建筑师们有一些“共同语言”。可惜的是，Alexander 后来自己都承认，他的实验失败了。因为这些固定的模式，并没有有效地传递精髓的知识，没有能让新手设计出好的建筑。照搬模式东拼西凑，而不能看透事物的本质，其实是设计不出好东西的。
　当我听说这本书的时候，我已经学会了函数式编程，正在 Cornell 读 PhD，专攻程序语言设计。有一天由于好奇这书为什么名气这么大，我从图书馆借了一本回来看。我很快的发现，其实这本书的作者只是给早已经存在的编程方法起了一些新的名字而已。当时我就拿起一张纸，把所有的 20 来个设计模式跟我常用的编程概念做了一个映射。这个映射居然是“多对一”（many-to-one）的。也就是说，多个 GoF 设计模式，居然只对应同一个我每天都用的概念。有些概念是如此的不值一提，以至于我根本不需要一个名字来描述它，更不要说多个名字！
　其中极少数值得一提的“模式”，也许是 visitor 和 interpreter。很可惜的是，只有很少的人明白如何使用它们。所谓的 visitor，其实本质上就是函数式语言里的含有“模式匹配”（pattern matching）的递归函数。在函数式语言里，这是多么轻松的事情。可是因为 Java 没有模式匹配，所以很多人使用 visitor pattern。为了所谓的“通用性”，他们往往把 visitor pattern 搞出多层继承关系，让你转几道弯也搞不清楚到底哪个 visitor 才是干实事的。
　其实，函数式语言的研究者们早就知道 visitor pattern 是怎么得来的。如果你想知道如何从无到有，“发明”出 Java 的 visitor pattern，可以参考 Dan Friedman 跟他的学生 Matthias Felleisen 合写的的另一本“小人书”《A Little Java, A Few Patterns》（发表于 1997 年）。
　而 interpreter （解释器）模式呢？看了作者们写的例子程序之后，我发现他们其实并不会写解释器，或者说他们不知道如何写出优雅的，正确的解释器。如果你想知道如何写出好的解释器，可以参考我的博文《怎样写一个解释器》。
　你说我在贬低这本书的真正价值，因为 GoF 说了：“我们的贡献，就是给这些编程方式起名字。这样让广大程序员有共同的语言。” 如果这也叫贡献的话，我就可以写本书，给“空气”，“水”，“猪肉”这些东西全都起个新名字，让大家有“共同的语言”。这不是搞笑吗。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson15/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson15/readme/</guid>
      <description>《Mongodb 与 Mongoose 的使用》 目标 无明确目标
知识点  了解 mongodb (http://www.mongodb.org/ ) 学习 mongoose 的使用 (http://mongoosejs.com/ )  课程内容 mongodb mongodb 这个名词相信大家不会陌生吧。有段时间 nosql 的概念炒得特别火，其中 hbase redis mongodb couchdb 之类的名词都相继进入了大众的视野。
hbase 和 redis 和 mongodb 和 couchdb 虽然都属于 nosql 的大范畴。但它们关注的领域是不一样的。hbase 是存海量数据的，redis 用来做缓存，而 mongodb 和 couchdb 则试图取代一些使用 mysql 的场景。
mongodb 的官网是这样介绍自己的：
 MongoDB (from &amp;ldquo;humongous&amp;rdquo;) is an open-source document database, and the leading NoSQL database. Written in C++
 开源、文档型、nosql。
其中文档型是个重要的概念需要理解。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson16/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson16/readme/</guid>
      <description>cookie 和 session 众所周知，HTTP 是一个无状态协议，所以客户端每次发出请求时，下一次请求无法得知上一次请求所包含的状态数据，如何能把一个用户的状态数据关联起来呢？
比如在淘宝的某个页面中，你进行了登陆操作。当你跳转到商品页时，服务端如何知道你是已经登陆的状态？
cookie 首先产生了 cookie 这门技术来解决这个问题，cookie 是 http 协议的一部分，它的处理分为如下几步：
 服务器向客户端发送 cookie。  通常使用 HTTP 协议规定的 set-cookie 头操作。 规范规定 cookie 的格式为 name = value 格式，且必须包含这部分。  浏览器将 cookie 保存。 每次请求浏览器都会将 cookie 发向服务器。  其他可选的 cookie 参数会影响将 cookie 发送给服务器端的过程，主要有以下几种：
 path：表示 cookie 影响到的路径，匹配该路径才发送这个 cookie。 expires 和 maxAge：告诉浏览器这个 cookie 什么时候过期，expires 是 UTC 格式时间，maxAge 是 cookie 多久后过期的相对时间。当不设置这两个选项时，会产生 session cookie，session cookie 是 transient 的，当用户关闭浏览器时，就被清除。一般用来保存 session 的 session_id。 secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。 httpOnly：浏览器不允许脚本操作 document.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson17/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson17/readme/</guid>
      <description>《使用 promise 替代回调函数》 知识点  理解 Promise 概念，为什么需要 promise 学习 q 的 API，利用 q 来替代回调函数(https://github.com/kriskowal/q )  课程内容 第五课(https://github.com/alsotang/node-lessons/tree/master/lesson5 )讲述了如何使用 async 来控制并发。async 的本质是一个流程控制。其实在异步编程中，还有一个更为经典的模型，叫做 Promise/Deferred 模型。
本节我们就来学习这个模型的代表实现：q
首先，我们思考一个典型的异步编程模型，考虑这样一个题目：读取一个文件，在控制台输出这个文件内容。
var fs = require(&#39;fs&#39;); fs.readFile(&#39;sample.txt&#39;, &#39;utf8&#39;, function (err, data) { console.log(data); });  看起来很简单，再进一步: 读取两个文件，在控制台输出这两个文件内容。
var fs = require(&#39;fs&#39;); fs.readFile(&#39;sample01.txt&#39;, &#39;utf8&#39;, function (err, data) { console.log(data); fs.readFile(&#39;sample02.txt&#39;, &#39;utf8&#39;, function (err,data) { console.log(data); }); });  要是读取更多的文件呢?
var fs = require(&#39;fs&#39;); fs.readFile(&#39;sample01.txt&#39;, &#39;utf8&#39;, function (err, data) { fs.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson18/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson18/readme/</guid>
      <description>《何为 connect 中间件》 目标  理解中间件的概念 了解 Connect 的实现  课程内容  原生 httpServer 遇到的问题 中间件思想 Connect 实现 Express 简介  这是从 httpServer 到 Express 的升级过程。
HTTP Nodejs 的经典 httpServer 代码
var http = require(&#39;http&#39;); var server = http.createServer(requestHandler); function requestHandler(req, res) { res.end(&#39;hello visitor!&#39;); } server.listen(3000);  里面的函数 requestHandler 就是所有http请求的响应函数，即所有的请求都经过这个函数的处理，是所有请求的入口函数。
通过 requestHandler 函数我们能写一些简单的 http 逻辑，比如上面的例子，所有请求都返回 hello visitor!。
然而，我们的业务逻辑不可能这么简单。例如：需要实现一个接口，要做的是当请求过来时，先判断来源的请求是否包含请求体，然后判断请求体中的id是不是在数据库中存在，最后若存在则返回true，不存在则返回false。
1. 检测请求中请求体是否存在，若存在则解析请求体； 1. 查看请求体中的id是否存在，若存在则去数据库查询； 1. 根据数据库结果返回约定的值；  我们首先想到的，抽离函数，每个逻辑一个函数，简单好实现低耦合好维护。
实现代码:
function parseBody(req, callback) { //根据http协议从req中解析body callback(null, body); } function checkIdInDatabase(body, callback) { //根据body.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson1/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson1/readme/</guid>
      <description>《一个最简单的 express 应用》 目标 建立一个 lesson1 项目，在其中编写代码。当在浏览器中访问 http://localhost:3000/ 时，输出 Hello World。
挑战 访问 http://localhost:3000/ 时，输出 你好，世界。
知识点  包管理器 npm 。使用 npm 安装包，并自动安装所需依赖。 框架 express 。学习新建 express 实例，并定义 routes ，产生输出。  课程内容 按照惯例，我们来个 helloworld 入门。
包管理器 npm npm 可以自动管理包的依赖. 只需要安装你想要的包, 不必考虑这个包的依赖包.
在 PHP 中, 包管理使用的 Composer, python 中，包管理使用 easy_install 或者 pip，ruby 中我们使用 gem。而在 Node.js 中，对应就是 npm，npm 是 Node.js Package Manager 的意思。
框架 Express express 是 Node.js 应用最广泛的 web 框架，现在是 4.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson2/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson2/readme/</guid>
      <description>《学习使用外部模块》 目标 建立一个 lesson2 项目，在其中编写代码。
当在浏览器中访问 http://localhost:3000/?q=alsotang 时，输出 alsotang 的 md5 值，即 bdd5e57b5c0040f9dc23d430846e68a3。
挑战 访问 http://localhost:3000/?q=alsotang 时，输出 alsotang 的 sha1 值，即 e3c766d71667567e18f77869c65cd62f6a1b9ab9。
知识点  学习 req.query 的用法 学习建立 package.json 来管理 Node.js 项目。  课程内容 卧槽，不写 package.json 就写项目我觉得好不爽啊，所以这个 lesson2 我就得跟大家介绍一下 package.json 这个文件的用法了。
简单说来呢，这个 package.json 文件就是定义了项目的各种元信息，包括项目的名称，git repo 的地址，作者等等。最重要的是，其中定义了我们项目的依赖，这样这个项目在部署时，我们就不必将 node_modules 目录也上传到服务器，服务器在拿到我们的项目时，只需要执行 npm install，则 npm 会自动读取 package.json 中的依赖并安装在项目的 node_modules 下面，然后程序就可以在服务器上跑起来了。
本课程的每个 lesson 里面的示例代码都会带上一份 package.json，大家可以去看看它的大概样子。
我们来新建一个 lesson2 项目，并生成一份它的 package.json。
$ mkdir lesson2 &amp;amp;&amp;amp; cd lesson2 $ npm init  OK，这时会要求我们输入一些信息，乱填就好了，反正这个地方也不用填依赖关系。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson3/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson3/readme/</guid>
      <description>《使用 superagent 与 cheerio 完成简单爬虫》 目标 建立一个 lesson3 项目，在其中编写代码。
当在浏览器中访问 http://localhost:3000/ 时，输出 CNode(https://cnodejs.org/ ) 社区首页的所有帖子标题和链接，以 json 的形式。
输出示例：
[ { &amp;quot;title&amp;quot;: &amp;quot;【公告】发招聘帖的同学留意一下这里&amp;quot;, &amp;quot;href&amp;quot;: &amp;quot;http://cnodejs.org/topic/541ed2d05e28155f24676a12&amp;quot; }, { &amp;quot;title&amp;quot;: &amp;quot;发布一款 Sublime Text 下的 JavaScript 语法高亮插件&amp;quot;, &amp;quot;href&amp;quot;: &amp;quot;http://cnodejs.org/topic/54207e2efffeb6de3d61f68f&amp;quot; } ]  挑战 访问 http://localhost:3000/ 时，输出包括主题的作者，
示例：
[ { &amp;quot;title&amp;quot;: &amp;quot;【公告】发招聘帖的同学留意一下这里&amp;quot;, &amp;quot;href&amp;quot;: &amp;quot;http://cnodejs.org/topic/541ed2d05e28155f24676a12&amp;quot;, &amp;quot;author&amp;quot;: &amp;quot;alsotang&amp;quot; }, { &amp;quot;title&amp;quot;: &amp;quot;发布一款 Sublime Text 下的 JavaScript 语法高亮插件&amp;quot;, &amp;quot;href&amp;quot;: &amp;quot;http://cnodejs.org/topic/54207e2efffeb6de3d61f68f&amp;quot;, &amp;quot;author&amp;quot;: &amp;quot;otheruser&amp;quot; } ]  知识点  学习使用 superagent 抓取网页 学习使用 cheerio 分析网页  课程内容 Node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson4/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson4/readme/</guid>
      <description>《使用 eventproxy 控制并发》 目标 建立一个 lesson4 项目，在其中编写代码。
代码的入口是 app.js，当调用 node app.js 时，它会输出 CNode(https://cnodejs.org/ ) 社区首页的所有主题的标题，链接和第一条评论，以 json 的格式。
输出示例：
[ { &amp;quot;title&amp;quot;: &amp;quot;【公告】发招聘帖的同学留意一下这里&amp;quot;, &amp;quot;href&amp;quot;: &amp;quot;http://cnodejs.org/topic/541ed2d05e28155f24676a12&amp;quot;, &amp;quot;comment1&amp;quot;: &amp;quot;呵呵呵呵&amp;quot; }, { &amp;quot;title&amp;quot;: &amp;quot;发布一款 Sublime Text 下的 JavaScript 语法高亮插件&amp;quot;, &amp;quot;href&amp;quot;: &amp;quot;http://cnodejs.org/topic/54207e2efffeb6de3d61f68f&amp;quot;, &amp;quot;comment1&amp;quot;: &amp;quot;沙发！&amp;quot; } ]  挑战 以上文目标为基础，输出 comment1 的作者，以及他在 cnode 社区的积分值。
示例：
[ { &amp;quot;title&amp;quot;: &amp;quot;【公告】发招聘帖的同学留意一下这里&amp;quot;, &amp;quot;href&amp;quot;: &amp;quot;http://cnodejs.org/topic/541ed2d05e28155f24676a12&amp;quot;, &amp;quot;comment1&amp;quot;: &amp;quot;呵呵呵呵&amp;quot;, &amp;quot;author1&amp;quot;: &amp;quot;auser&amp;quot;, &amp;quot;score1&amp;quot;: 80 }, ... ]  知识点  体会 Node.js 的 callback hell 之美 学习使用 eventproxy 这一利器控制并发  课程内容 注意，cnodejs.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson5/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson5/readme/</guid>
      <description>《使用 async 控制并发》 目标 建立一个 lesson5 项目，在其中编写代码。
代码的入口是 app.js，当调用 node app.js 时，它会输出 CNode(https://cnodejs.org/ ) 社区首页的所有主题的标题，链接和第一条评论，以 json 的格式。
注意：与上节课不同，并发连接数需要控制在 5 个。
输出示例：
[ { &amp;quot;title&amp;quot;: &amp;quot;【公告】发招聘帖的同学留意一下这里&amp;quot;, &amp;quot;href&amp;quot;: &amp;quot;http://cnodejs.org/topic/541ed2d05e28155f24676a12&amp;quot;, &amp;quot;comment1&amp;quot;: &amp;quot;呵呵呵呵&amp;quot; }, { &amp;quot;title&amp;quot;: &amp;quot;发布一款 Sublime Text 下的 JavaScript 语法高亮插件&amp;quot;, &amp;quot;href&amp;quot;: &amp;quot;http://cnodejs.org/topic/54207e2efffeb6de3d61f68f&amp;quot;, &amp;quot;comment1&amp;quot;: &amp;quot;沙发！&amp;quot; } ]  知识点  学习 async(https://github.com/caolan/async ) 的使用。这里有个详细的 async demo 演示：https://github.com/alsotang/async_demo 学习使用 async 来控制并发连接数。  课程内容 lesson4 的代码其实是不完美的。为什么这么说，是因为在 lesson4 中，我们一次性发了 40 个并发请求出去，要知道，除去 CNode 的话，别的网站有可能会因为你发出的并发连接数太多而当你是在恶意请求，把你的 IP 封掉。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson6/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson6/readme/</guid>
      <description>《测试用例：mocha，should，istanbul》 目标 建立一个 lesson6 项目，在其中编写代码。
main.js: 其中有个 fibonacci 函数。fibonacci 的介绍见：http://en.wikipedia.org/wiki/Fibonacci_number 。
此函数的定义为 int fibonacci(int n)
 当 n === 0 时，返回 0；n === 1时，返回 1; n &amp;gt; 1 时，返回 fibonacci(n) === fibonacci(n-1) + fibonacci(n-2)，如 fibonacci(10) === 55; n 不可大于10，否则抛错，因为 Node.js 的计算性能没那么强。 n 也不可小于 0，否则抛错，因为没意义。 n 不为数字时，抛错。  test/main.test.js: 对 main 函数进行测试，并使行覆盖率和分支覆盖率都达到 100%。
知识点  学习使用测试框架 mocha : http://mochajs.org/ 学习使用断言库 should : https://github.com/tj/should.js 学习使用测试率覆盖工具 istanbul : https://github.com/gotwarlost/istanbul 简单 Makefile 的编写 : http://blog.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson7/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson7/readme/</guid>
      <description>《浏览器端测试：mocha，chai，phantomjs》 目标 建立一个 lesson7 项目，在其中编写代码，我们暂时命名为 vendor 根据下面的步骤，最终的项目结构应该长这样
这次我们测试的对象是上文提到的 fibonacci 函数
此函数的定义为 int fibonacci(int n)
 当 n === 0 时，返回 0；n === 1时，返回 1; n &amp;gt; 1 时，返回 fibonacci(n) === fibonacci(n-1) + fibonacci(n-2)，如 fibonacci(10) === 55;  知识点  学习使用测试框架 mocha 进行前端测试 : http://mochajs.org/ 了解全栈的断言库 chai: http://chaijs.com/ 了解 headless 浏览器 phantomjs: http://phantomjs.org/  前端脚本单元测试 lesson6 的内容都是针对后端环境中 node 的一些单元测试方案，出于应用健壮性的考量，针对前端 js 脚本的单元测试也非常重要。而前后端通吃，也是 mocha 的一大特点。
首先，前端脚本的单元测试主要有两个困难需要解决。
 运行环境应当在浏览器中，可以操纵浏览器的DOM对象，且可以随意定义执行时的 html 上下文。
 测试结果应当可以直接反馈给 mocha，判断测试是否通过。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson7/vendor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson7/vendor/</guid>
      <description>Mochavar fibonacci = function (n) {if (n === 0) {return 0;}if (n === 1) {return 1;}return fibonacci(n-1) + fibonacci(n-2);};mocha.setup(&#39;bdd&#39;)if (window.initMochaPhantomJS) {initMochaPhantomJS();mocha.ui(&#39;bdd&#39;);expect = chai.expect;}mocha.run();</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson8/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson8/readme/</guid>
      <description>《测试用例：supertest》 目标 建立一个 lesson8 项目，在其中编写代码。
app.js: 其中有个 fibonacci 接口。fibonacci 的介绍见：http://en.wikipedia.org/wiki/Fibonacci_number 。
fibonacci 函数的定义为 int fibonacci(int n)，调用函数的路径是 &amp;lsquo;/fib?n=10&amp;rsquo;，然后这个接口会返回 &amp;lsquo;55&amp;rsquo;。函数的行为定义如下：
 当 n === 0 时，返回 0；n === 1时，返回 1; n &amp;gt; 1 时，返回 fibonacci(n) === fibonacci(n-1) + fibonacci(n-2)，如 fibonacci(10) === 55; n 不可大于10，否则抛错，http status 500，因为 Node.js 的计算性能没那么强。 n 也不可小于 0，否则抛错，500，因为没意义。 n 不为数字时，抛错，500。  test/main.test.js: 对 app 的接口进行测试，覆盖以上所有情况。
知识点  学习 supertest 的使用 (https://github.com/tj/supertest ) 复习 mocha，should 的使用  课程内容 这是连续第三节课讲测试了..我自己都烦..看着烦的可以考虑跳下一课。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson9/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/lesson9/readme/</guid>
      <description>《正则表达式》 目标 var web_development = &amp;quot;python php ruby javascript jsonp perhapsphpisoutdated&amp;quot;;  找出其中 包含 p 但不包含 ph 的所有单词，即
[ &#39;python&#39;, &#39;javascript&#39;, &#39;jsonp&#39; ]
知识点  正则表达式的使用 js 中的正则表达式与 pcre(http://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions ) 的区别  课程内容 开始这门课之前，大家先去看两篇文章。
《正则表达式30分钟入门教程》：http://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html
上面这篇介绍了正则表达式的基础知识，但是对于零宽断言没有展开来讲，零宽断言看下面这篇：
《正则表达式之：零宽断言不『消费』》：http://fxck.it/post/50558232873
好了。
在很久很久以前，有一门语言一度是字符串处理领域的王者，叫 perl。
伴随着 perl，有一个类似正则表达式的标准被实现了出来，叫 pcre：Perl Compatible Regular Expressions。
不过遗憾的是，js 里面的正则与 pcre 不是兼容的。很多语言都这样。
如果需要测试你自己写的正则表达式，建议上这里：http://refiddle.com/ ，可以所见即所得地调试。
接下来我们主要讲讲 js 中需要注意的地方，至于正则表达式的内容，上面那两篇文章足够学习了。
第一，
js 中，对于四种零宽断言，只支持 零宽度正预测先行断言 和 零宽度负预测先行断言 这两种。
第二，
js 中，正则表达式后面可以跟三个 flag，比如 /something/igm。
他们的意义分别是，
 i 的意义是不区分大小写 g 的意义是，匹配多个 m 的意义是，是 ^ 和 $ 可以匹配每一行的开头。  分别举个例子：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.zshipu.com/article/public/posts/20191020/node-lessons/readme/</guid>
      <description>《Node.js 包教不包会》 &amp;ndash; by alsotang 为何写作此课程 在 CNode(https://cnodejs.org/) 混了那么久，解答了不少 Node.js 初学者们的问题。回头想想，那些问题所需要的思路都不难，但大部分人由于练手机会少，所以在遇到问题的时候很无措。国内唯一一本排的上号的 Node.js 书是 @朴灵(https://github.com/JacksonTian) 的 《深入浅出Node.js》(http://book.douban.com/subject/25768396/ )，但这本书离实战还是比较远的。
这个课程是希望提供更多的 Node.js 实战机会，通过每一节精心安排的课程目标，让 Node.js 的初学者们可以循序渐进地，有目的有挑战地开展 Node.js 的学习。
广告 需要内推腾讯的同学请参照此贴： https://cnodejs.org/topic/58351689bde2b59e06141e9f
更多 Node.js 入门资料请前往：https://cnodejs.org/getstart
新手搭建 Node.js 云主机，推荐使用无需备案的 DigitalOcean(https://www.digitalocean.com/)
课程列表  Lesson 0: 《搭建 Node.js 开发环境》 Lesson 1: 《一个最简单的 express 应用》 Lesson 2: 《学习使用外部模块》 Lesson 3: 《使用 superagent 与 cheerio 完成简单爬虫》 Lesson 4: 《使用 eventproxy 控制并发》 Lesson 5: 《使用 async 控制并发》 Lesson 6: 《测试用例：mocha，should，istanbul》 Lesson 7: 《浏览器端测试：mocha，chai，phantomjs》 &amp;ndash; by @elrrrrrrr Lesson 8: 《测试用例：supertest》 Lesson 9: 《正则表达式》 Lesson 10: 《benchmark 怎么写》 Lesson 11: 《作用域与闭包：this，var，(function () {})》 &amp;ndash; by @Ricardo-Li Lesson 12: 《线上部署：heroku》 Lesson 13: 《持续集成平台：travis》 Lesson 14: 《js 中的那些最佳实践》 Lesson 15: 《Mongodb 与 Mongoose 的使用》 Lesson 16: 《cookie 与 session》 &amp;ndash; by @Ricardo-Li Lesson 17: 《使用 promise 替代回调函数》 &amp;ndash; by @eeandrew Lesson 18: 《何为 connect 中间件》 &amp;ndash; by @albin3  计划  《http 中各个 header 的含义》 《操作 mysql》 《在全新的 vps 上搭建 node.</description>
    </item>
    
  </channel>
</rss>