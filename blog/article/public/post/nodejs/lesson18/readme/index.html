<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="keywords" content="知识铺">
        <meta name="description" content="《何为 connect 中间件》 目标 理解中间件的概念 了解 Connect 的实现 课程内容 原生 httpServer 遇到的问题 中间件思想 Connect 实现 Express 简介 这是从 httpServer 到 Express 的升级过程。 HTTP Nodejs 的经典 httpServer 代码 var http =">
        <link rel="alternate" href="https://blog.zshipu.com/article/feed.xml" type="application/rss+xml" title="知识铺">
        <link rel="icon" href="https://blog.zshipu.com/article/favicon.ico">
        <title>lesson18- 何为 connect 中间件 - 知识铺</title>
        <link rel="stylesheet" href="https://blog.zshipu.com/article/css/highlight.js.min.css">
        <link rel="stylesheet" href="https://blog.zshipu.com/article/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://blog.zshipu.com/article/css/bootstrap-theme.css">
        <link rel="stylesheet" href="https://blog.zshipu.com/article/css/font-awesome/css/font-awesome.min.css" />
        
        <link rel="stylesheet" href="https://blog.zshipu.com/article/css/hugo-org.css">
        
        <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
            })(window,document,'script','dataLayer','GTM-WLWJSST');</script>
        
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <script>
            (adsbygoogle = window.adsbygoogle || []).push({
                google_ad_client: "ca-pub-2874221941555456",
                enable_page_level_ads: true
            });
        </script>
    </head>

<body role="document">
    <nav class="navbar navbar-inverse navbar-fixed-top">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="https://blog.zshipu.com/article/">知识铺</a>
            </div>
            <div id="navbar" class="navbar-collapse collapse">
                <ul class="nav navbar-nav">
                    <li ><a href="https://blog.zshipu.com/">主页</a></li>
                    
                    
                    <li ><a href="https://blog.zshipu.com/article/post/">文章列表</a></li>
                    
                </ul>
            </div>
        </div>
    </nav>



<div class="container">
<div class="row">
    <div class="col-xs-12 col-sm-11 doc-main">
        <main role="main">
            <article>
                <a id="title"></a>
                <h1 class="doc-entry-title">lesson18- 何为 connect 中间件</h1>
                
                <div class="doc-entry-meta small">
                    <span><time datetime="2019-10-20">2019-10-20</time> by 知识铺 </span>
                </div>
                
                <section>
                    

<h1 id="何为-connect-中间件">《何为 connect 中间件》</h1>

<h2 id="目标">目标</h2>

<ol>
<li>理解中间件的概念</li>
<li>了解 Connect 的实现</li>
</ol>

<h2 id="课程内容">课程内容</h2>

<ol>
<li>原生 httpServer 遇到的问题</li>
<li>中间件思想</li>
<li>Connect 实现</li>
<li>Express 简介</li>
</ol>

<p>这是从 httpServer 到 Express 的升级过程。</p>

<h1 id="http">HTTP</h1>

<p>Nodejs 的经典 httpServer 代码</p>

<pre><code class="language-js">var http = require('http');

var server = http.createServer(requestHandler);
function requestHandler(req, res) {
  res.end('hello visitor!');
}
server.listen(3000);
</code></pre>

<p>里面的函数 <code>requestHandler</code> 就是所有http请求的响应函数，即所有的请求都经过这个函数的处理，是所有请求的入口函数。</p>

<p>通过 requestHandler 函数我们能写一些简单的 http 逻辑，比如上面的例子，所有请求都返回 <code>hello visitor!</code>。</p>

<p>然而，我们的业务逻辑不可能这么简单。例如：需要实现一个接口，要做的是当请求过来时，先判断来源的请求是否包含请求体，然后判断请求体中的id是不是在数据库中存在，最后若存在则返回true，不存在则返回false。</p>

<pre><code>1. 检测请求中请求体是否存在，若存在则解析请求体；
1. 查看请求体中的id是否存在，若存在则去数据库查询；
1. 根据数据库结果返回约定的值；
</code></pre>

<p>我们首先想到的，抽离函数，每个逻辑一个函数，简单好实现低耦合好维护。</p>

<p>实现代码:</p>

<pre><code class="language-js">function parseBody(req, callback) {
  //根据http协议从req中解析body
  callback(null, body);
}
function checkIdInDatabase(body, callback) {
  //根据body.id在Database中检测，返回结果
  callback(null, dbResult);
}
function returnResult(dbResult, res) {
  if (dbResult &amp;&amp; dbResult.length &gt; 0) {
    res.end('true');
  } else {
    res.end('false')
  }
}
function requestHandler(req, res) {
  parseBody(req, function(err, body) {
    checkIdInDatabase(body, function(err, dbResult) {
      returnResult(dbResult, res);
    });
  });
}
</code></pre>

<p>上面的解决方案解决了包含三个步骤的业务问题，出现了3个 <code>});</code> 还有3个 <code>err</code> 需要处理，上面的写法可以得达到预期效果。</p>

<p>然而，业务逻辑越来越复杂，会出发展成30个回调逻辑，那么就出现了30个 <code>});</code> 及30个 <code>err</code>异常。更严重的是，到时候写代码根本看不清自己写的逻辑在30层中的哪一层，极其容易出现 <strong>多次返回</strong> 或返回地方不对等问题，这就是 <strong>回调金字塔</strong> 问题了。</p>

<p>大多数同学应该能想到解决回调金字塔的办法，朴灵的《深入浅出Node.js》里讲到的三种方法。下面列举了这三种方法加上ES6新增的Generator，共四种解决办法。</p>

<ul>
<li><a href="https://github.com/JacksonTian/eventproxy">EventProxy</a> —— 事件发布订阅模式(第四课讲到)</li>
<li><a href="https://github.com/petkaantonov/bluebird">BlueBird</a> —— Promise方案(第十七课讲到)</li>
<li><a href="https://github.com/caolan/async">Async</a> —— 异步流程控制库(第五课讲到)</li>
<li><a href="http://es6.ruanyifeng.com/#docs/generator">Generator</a> —— ES6原生Generator</li>
</ul>

<p>理论上，这四种都能解决回调金字塔问题。而Connect和Express用的是 <code>类似异步流程控制的思想</code> 。</p>

<p><a name="next"></a>
关于异步流程控制库下面简要介绍下，或移步<a href="https://github.com/alsotang/node-lessons/tree/master/lesson5">@第五课</a>。
异步流程控制库首先要求用户传入待执行的函数列表，记为funlist。流程控制库的任务是让这些函数 <strong>顺序执行</strong> 。</p>

<p>callback是控制顺序执行的关键，funlist里的函数每当调用callback会执行下一个funlist里的函数</p>

<p>我们动手实现一个类似的链式调用，其中 <code>funlist</code> 更名为 <code>middlewares</code>、<code>callback</code> 更名为 <code>next</code>，码如下：</p>

<p><a name="middlewares" comment="middlewares锚点"></a></p>

<pre><code class="language-js">var middlewares = [
  function fun1(req, res, next) {
    parseBody(req, function(err, body) {
      if (err) return next(err);
      req.body = body;
      next();
    });
  },
  function fun2(req, res, next) {
    checkIdInDatabase(req.body.id, function(err, rows) {
      if (err) return next(err);
      res.dbResult = rows;
      next();
    });
  },
  function fun3(req, res, next) {
    if (res.dbResult &amp;&amp; res.dbResult.length &gt; 0) {
      res.end('true');
    }
    else {
      res.end('false');
    }
    next();
  }
]

function requestHandler(req, res) {
  var i=0;

  //由middlewares链式调用
  function next(err) {

    if (err) {
      return res.end('error:', err.toString());
    }

    if (i&lt;middlewares.length) {
      middlewares[i++](req, res, next);
    } else {
      return ;
    }
  }

  //触发第一个middleware
  next();
}
</code></pre>

<p>上面用middlewares+next完成了业务逻辑的 <code>链式调用</code>，而middlewares里的每个函数，都是一个 <code>中间件</code>。</p>

<p>整体思路是：</p>

<ol>
<li>将所有 <code>处理逻辑函数(中间件)</code> 存储在一个list中；</li>
<li>请求到达时 <code>循环调用</code> list中的 <code>处理逻辑函数(中间件)</code>；</li>
</ol>

<h1 id="connect-https-github-com-senchalabs-connect-的实现"><a href="https://github.com/senchalabs/connect">Connect</a>的实现</h1>

<p>Connect的思想跟上面阐述的思想基本一样，先将处理逻辑存起来，然后循环调用。</p>

<p>Connect中主要有五个函数
PS: Connect的核心代码是200+行，建议对照<a href="https://github.com/senchalabs/connect/blob/master/index.js" target="_blank">源码</a>看下面的函数介绍。</p>

<table>
<thead>
<tr>
<th>函数名</th>
<th align="center">作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>createServer</td>
<td align="center">包装httpServer形成app</td>
</tr>

<tr>
<td>listen</td>
<td align="center">监听端口函数</td>
</tr>

<tr>
<td>use</td>
<td align="center">向middlewares里面放入业务逻辑</td>
</tr>

<tr>
<td>handle</td>
<td align="center">上一章的requestHandler函数增强版</td>
</tr>

<tr>
<td>call</td>
<td align="center">业务逻辑的真正执行者</td>
</tr>
</tbody>
</table>

<h2 id="createserver">createServer()</h2>

<p><strong>输入</strong>:</p>

<p>无</p>

<p><strong>执行过程</strong>:</p>

<ol>
<li>app是一个函数对象(包含handle方法)</li>
<li>app具有Event所有属性(详见<a href="https://github.com/jaredhanson/utils-merge">utils-merge</a>，十行代码)</li>
<li>app有route属性(路由)、和stack属性(用于存储中间件，类似上面的<a href="#middlewares">middlewares</a>)</li>
</ol>

<p><strong>输出</strong>:</p>

<pre><code>       app is function(req, res, next) {...};
        |
    +---+---+
    |  has  |
  route   stack
</code></pre>

<h2 id="app-use-route-fn">app.use(route, fn)</h2>

<p>作用是向stack中添加 <code>逻辑处理函数</code> (中间件)。</p>

<p><strong>输入</strong>:</p>

<ol>
<li>route 可省略，默认&rsquo;/&rsquo;</li>
<li>fn 具体的业务处理逻辑</li>
</ol>

<p><strong>tips:</strong></p>

<p>上面的fn表示处理逻辑，它可以是</p>

<ol>
<li>一个普通的 <code>function(req,res[,next]){}</code>；</li>
<li>一个<a href="https://lodejs.org/api/http.html#http_class_http_server">httpServer</a>；</li>
<li>另一个connect的app对象(<strong>sub app特性</strong>)；</li>
</ol>

<p>由于它们的本质都是 <code>处理逻辑</code>，都可以用一个 <code>function(req,res,next){}</code>将它们概括起来，Connect把他们都转化为这个函数，然后把它们存起来。</p>

<p>如何将这三种分别转换为 function(req, res, next) {}的形式呢？</p>

<ol>
<li>不用转换；</li>
<li>httpServer的定义是“对事件&rsquo;request&rsquo;后handler的对象”，我们可以从httpServer.listeners(&lsquo;request&rsquo;)中得到这个函数；</li>
<li>另一个connect对象，而connect()返回的app就是function(req, res, out) {}；</li>
</ol>

<p><strong>执行过程</strong>:</p>

<ol>
<li>将三种<code>处理逻辑</code>统一转换为<code>function(req,res,next){}</code>的形式表示。</li>
<li>把这个<code>处理逻辑</code>与route一起，放入<code>stack</code>中(存储处理逻辑，route用来匹配路由)</li>
</ol>

<p>核心代码片段</p>

<pre><code class="language-js">//route是路由路径，handle是一个`function(req, res, next) {...}`形式的业务逻辑
this.stack.push({ route: path, handle: handle });
</code></pre>

<p><strong>返回</strong>:</p>

<pre><code class="language-js">//返回自己，可以完成链式调用
return this;
</code></pre>

<p><strong>总结:</strong>:</p>

<pre><code class="language-js">var app = connect();
app.use('/api', function(req, res, next) {});
</code></pre>

<p>等价于</p>

<pre><code class="language-js">var app = connect();
app.stack.push({route: '/api', handle: function(req, res, next) {}});
</code></pre>

<p>最后，app.stack里 <strong>顺序存储</strong> 了所有的 <strong>逻辑处理函数</strong> (中间件)。</p>

<pre><code class="language-js">app.stack = [function1, function2, function3, ... function30];
</code></pre>

<h2 id="app-handle-req-res-out">app.handle(req, res, out)</h2>

<p>这个函数就是请求到达时，负责 <code>顺序调用</code> 我们存储在stack中的 <code>逻辑处理函数</code> (中间件)函数，类似上一章的requestHandler。</p>

<p><strong>输入:</strong></p>

<ol>
<li>req是Nodejs本身的可读流，不做过多介绍</li>
<li>res是Nodejs本身的可写流，不做过多介绍</li>
<li>out是为了Connect的 <strong>sub app特性</strong> 而设计的参数，这个特性可以暂时忽略，这个参数我们暂时不关心</li>
</ol>

<p><strong>处理过程:</strong></p>

<p>可以回头看一下上面的<a href="#middlewares">requestHandler函数</a>，handle的实现是这个函数的增强版</p>

<ol>
<li>取得stack(存储<code>逻辑处理函数</code>列表)，index(列表下标)</li>
<li>构建next函数，next的作用是执行下一个<code>逻辑处理函数</code></li>
<li>触发第一个next，触发链式调用</li>
</ol>

<p><strong>next函数实现:</strong></p>

<p>next函数实现在handle函数体内，用来<code>顺序执行处理逻辑</code>，它是异步流程控制库的核心，不明白它的作用请看<a href="#next">上面的异步流程控制库简介</a></p>

<p>path是请求路径，route是<code>逻辑处理函数</code>自带的属性。</p>

<ol>
<li>取得下一个<code>逻辑处理函数</code>;</li>
<li>若路由不匹配，跳过此逻辑;</li>
<li>若路由匹配<a href="#call">下面的call</a>执行匹配到的<code>逻辑处理函数</code></li>
</ol>

<p>tips: 跟上一章最后的代码一样，每个<code>逻辑处理函数</code>调用<code>next</code>来让后面的函数执行，存储在stack中的函数就实现了<code>链式调用</code>。不一定所有的函数都在返回的时候才调用<code>next</code>，为了不影响效率，有的函数可能先调用next，然而自己还没有返回，继续做自己的事情。</p>

<p>核心代码：</p>

<pre><code class="language-js">//取下一个逻辑逻辑处理函数
1:  var layer = stack[index++];
//不匹配时跳过
2:  if (path.toLowerCase().substr(0, route.length) !== route.toLowerCase()) {
      return next(err);
    }
//匹配时执行
3:  call(layer.handle, route, err, req, res, next);
</code></pre>

<p><strong>返回:</strong></p>

<p>无</p>

<p><strong>总结:</strong></p>

<p>画图总结</p>

<pre><code>request come
     |
     v
middleware1 :  不匹配路由，skip
     |
     v
middleware2 :  匹配路由，执行
     |
     v
middleware3 :  匹配路由，执行
     |
     v
middleware4 :  不匹配路由，skip
     |
     v
    end
</code></pre>

<p><a name="call"></a></p>

<h2 id="call-handle-route-err-req-res-next">call(handle, route, err, req, res, next)</h2>

<blockquote>
<p>这里有个比较有趣的知识，<code>console.log(Function.length)</code>会返回函数定义的参数个数。值跟在函数体内执行<code>arguments.length</code>一样。</p>
</blockquote>

<p>Connect中规定<code>function(err, req, res, next) {}</code>形式为错误处理函数，<code>function(req, res, next) {}</code>为正常的业务逻辑处理函数。那么，可以根据Function.length以判断它是否为错误处理函数。</p>

<p><strong>输入:</strong></p>

<table>
<thead>
<tr>
<th>参数名</th>
<th align="center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>handle</td>
<td align="center">逻辑处理函数</td>
</tr>

<tr>
<td>route</td>
<td align="center">路由</td>
</tr>

<tr>
<td>err</td>
<td align="center">是否发生过错误</td>
</tr>

<tr>
<td>req</td>
<td align="center">Nodejs对象</td>
</tr>

<tr>
<td>res</td>
<td align="center">Nodejs对象</td>
</tr>

<tr>
<td>next</td>
<td align="center">next函数</td>
</tr>
</tbody>
</table>

<p><strong>处理过程:</strong></p>

<ol>
<li>是否有错误，本次handle是否是错误处理函数;</li>
<li>若有错误且handle为错误处理函数，则执行handle，本函数返回;</li>
<li>若没错误且handle不是错误处理函数，则执行handle，本函数返回;</li>
<li>如果上面两个都不满足，不执行handle，本函数调用next，返回;</li>
</ol>

<p><strong>返回:</strong></p>

<p>无</p>

<p><strong>总结:</strong></p>

<p>call函数是一个执行者，根据当前<code>错误情况</code>和<code>handle类型</code>决定<code>是否执行</code>当前的handle。</p>

<h2 id="listen">listen</h2>

<p>创建一个httpServer，将Connect自己的业务逻辑作为requestHandler，监听端口</p>

<p>代码</p>

<pre><code class="language-js">var server = http.createServer(this);
return server.listen.apply(server, arguments);
</code></pre>

<h2 id="图解connect">图解Connect</h2>

<p>Connect将中间件存储在app.stack中，通过构造handle中的next函数在请求到来时依次调用这些中间件。</p>

<p>图形总结</p>

<pre><code>request               app(out)
   |                          yes
   +------------------&gt;match?-----&gt;middleware1
                         | no          |
                         v             |
                        next&lt;----------+
                         |
                         v    yes
                      match?------&gt;middleware2
                         | no          |
                         v             |
                        next&lt;----------+
                         |
                         v    yes
                      match?------&gt;middleware3
                         | no          |
                         v             |
                        out&lt;-----------+
                         |
   +---------------------+
   |
   v
  end(response在处理过程中已经返回了)
</code></pre>

<h2 id="connect的subapp特性">Connect的subapp特性</h2>

<p>我们再看看Connect是怎么实现subapp的，比较有趣。</p>

<p>什么是subapp?</p>

<pre><code>var sub_app = connect();
var app = connect();

app.use('/route1', sub_app);
// request path: '/route1/route2'
// 由app接收到请求后，切割 path为'/route2'转交给sub_app的处理逻辑处理
// 再由sub_app返回到app，由app继续向下执行处理逻辑
</code></pre>

<p>结合上面的函数画图</p>

<pre><code>request               app(out1)                 sub_app(out2)
   |
   +---------------&gt;middleware1     +------------&gt;middleware1
                         |          |                 |
                        next        |                next
                         |          |                 |
                         v          |                 v
                    middleware2-----+            middleware2
                                                      |
                       next&lt;--------+                next
                         |          |                 |
                         v          |                 v
                     middleware3    |            middleware3
                         |          |                 |
                         v          |                 v
                        out1        |                out2
                         |          |                 |
   +---------------------+          +-----------------+
   |
   v
  end(response在处理过程中已经返回了)
</code></pre>

<p>完成上面的sub_app只需要做到两点：</p>

<ol>
<li>从app的调用链进入到sub_app的调用链中;</li>
<li>从sub_app的逻辑回到app的调用链中;</li>
</ol>

<p>connect在handle函数中的第三个参数<code>out</code>为这个特性实现提供可能。<code>out</code>的特点是<code>在middlewares链式调用完成以后调用</code>。<strong>那么将app的next作为sub_app的out传入sub_app的handle中</strong>可以做到sub_app自己的业务逻辑处理完后调用<code>out</code>，即处理权回到了本app的<code>next</code>手里。</p>

<p>上面图中的<code>sub_app.out2===app.next</code>，所以能完成逻辑的交接和sub app调用。</p>

<h1 id="express-https-github-com-strongloop-express"><a href="https://github.com/strongloop/express">Express</a></h1>

<p>大家都知道Express是Connect的升级版。</p>

<p>Express不只是Connect的升级版，它还封装了很多对象来方便业务逻辑处理。Express里的Router是Connect的升级版。</p>

<p>Express大概可以分为几个模块</p>

<table>
<thead>
<tr>
<th>模块</th>
<th align="center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>router</td>
<td align="center">路由模块是Connect升级版</td>
</tr>

<tr>
<td>request</td>
<td align="center">经过Express封装的req对象</td>
</tr>

<tr>
<td>response</td>
<td align="center">经过Express封装的res对象</td>
</tr>

<tr>
<td>application</td>
<td align="center">app上面的各种默认设置</td>
</tr>
</tbody>
</table>

<p>简要介绍一下每个模块</p>

<h2 id="router">Router</h2>

<p>在Connect中间件特性的基础上，加入了如下特性，是Connect的升级版</p>

<ol>
<li>正则匹配route;</li>
<li>进行将http的方法在route中分解开;</li>
</ol>

<h2 id="request">Request</h2>

<p>在Request中集成了http.IncomingMessage(可读流+事件)，并在其上增加了新的属性，方便使用，我们最常用的应该是
req.param。</p>

<h2 id="response">Response</h2>

<p>在Response中集成了http.ServerResponse(可写流+事件)，并在其上增加了很多方便返回的函数，有我们熟悉的res.json、
res.render、res.redirect、res.sendFile等等。</p>

<p>我们可以拓展它写一个res.sendPersonInfoById。</p>

<blockquote>
<p>关于流的题外话：req.pipe(res)的形式可以“完成发什么就返回什么”，而req.pipe(mylogic).pipe(res)可以添加自己的逻辑，
我们的业务逻辑是把流读为String/Object再进行逻辑处理，处理完再推送给另一个stream，有没有可能在流的层面进行逻辑解
耦提供服务呢？求大神解答了…至少这种写法在大流量、逻辑简单的情况下是有用的。</p>
</blockquote>

<h2 id="application">Application</h2>

<p>除了上面的三个模块以外，还需要有个地方存储整个app的属性、设置等。比较常用的是app.engine函数设置模板引擎。</p>

<h2 id="express小结">Express小结</h2>

<p>Express是一个中间件机制的httpServer框架，它本身实现了中间件机制，它也包含了中间件。比如3.x版本的Express
本身自带bodyParser、cookieSession等中间件，而在4.x中去掉了。包括TJ也写了很多中间件，比如node-querystring、
connect-redis等。</p>

<p>实现业务逻辑解耦时，中间件是从纵向的方面进行的逻辑分解，前面的中间件处理的结果可以给后面用，比如bodyParser把解析
body的结果放在req.body中，后面的逻辑都可以从req.body中取值。由于中间件是顺序执行的，errHandler一般都放在最后，而log类的中间件则放在比较前面。</p>

<h1 id="总结">总结</h1>

<p>Connect用流程控制库的回调函数及中间件的思想来解耦回调逻辑；
<a href="https://github.com/koajs/koa">Koa</a>用Generator方法解决回调问题；</p>

<p>我们应该也可以用事件、Promise的方式实现；</p>

<p>PS: 用事件来实现的话还挺期待的，能形成网状的相互调用。</p>

                </section>
            </article>
        </main>
    </div> 
    
<div class="col-xs-12 col-sm-3 doc-sidebar">
	<div class="sidebar-module">
		<div class="sidebar-toc">
			<h4>Table of Contents</h4>
			<ul>
				<li><strong><a href="#title">lesson18- 何为 connect 中间件</a></strong></li>
			</ul>
			<nav id="TableOfContents">
<ul>
<li><a href="#何为-connect-中间件">《何为 connect 中间件》</a>
<ul>
<li><a href="#目标">目标</a></li>
<li><a href="#课程内容">课程内容</a></li>
</ul></li>
<li><a href="#http">HTTP</a></li>
<li><a href="#connect-https-github-com-senchalabs-connect-的实现"><a href="https://github.com/senchalabs/connect">Connect</a>的实现</a>
<ul>
<li><a href="#createserver">createServer()</a></li>
<li><a href="#app-use-route-fn">app.use(route, fn)</a></li>
<li><a href="#app-handle-req-res-out">app.handle(req, res, out)</a></li>
<li><a href="#call-handle-route-err-req-res-next">call(handle, route, err, req, res, next)</a></li>
<li><a href="#listen">listen</a></li>
<li><a href="#图解connect">图解Connect</a></li>
<li><a href="#connect的subapp特性">Connect的subapp特性</a></li>
</ul></li>
<li><a href="#express-https-github-com-strongloop-express"><a href="https://github.com/strongloop/express">Express</a></a>
<ul>
<li><a href="#router">Router</a></li>
<li><a href="#request">Request</a></li>
<li><a href="#response">Response</a></li>
<li><a href="#application">Application</a></li>
<li><a href="#express小结">Express小结</a></li>
</ul></li>
<li><a href="#总结">总结</a></li>
</ul>
</nav>
		</div>
	</div>
	<div class="sidebar-module">
		<h4>Tags</h4>
		<div class="tag-box">
		
		</div>
	</div>
</div>

</div> 



<hr />

<div class="row">
    <div class="col-sm-12">
        
	    <div class="text-center">
        
		    <p class="doc-footer-em"><a href="#">回到顶部↑</a></p>
	    </div>
	</div>
</div>

</div> 

<footer class="doc-footer">
	
    <p>Copyright © <a href="https://blog.zshipu.com/">知识铺</a> 2019. Generated by <a href="http://gohugo.io/">Hugo</a></p>
</footer>



<script src="https://blog.zshipu.com/article/js/jquery-1.11.2.min.js"></script>
<script src="https://blog.zshipu.com/article/js/bootstrap.min.js"></script>

<script src="https://blog.zshipu.com/article/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="https://blog.zshipu.com/article/js/ie10-viewport-bug-workaround.js"></script>

<div style="position:absolute; bottom: 0; right: 0;">
	<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=110 src="//music.163.com/outchain/player?type=0&id=962982601&auto=1&height=90"></iframe>
</div>
<script>
	(function(){
		var bp = document.createElement('script');
		var curProtocol = window.location.protocol.split(':')[0];
		if (curProtocol === 'https') {
			bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
		}
		else {
			bp.src = 'http://push.zhanzhang.baidu.com/push.js';
		}
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(bp, s);
	})();
</script>

</body>
</html>

