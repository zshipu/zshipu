<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="keywords" content="知识铺">
        <meta name="description" content="《测试用例：supertest》 目标 建立一个 lesson8 项目，在其中编写代码。 app.js: 其中有个 fibonacci 接口。fibonacci 的介绍见：http://en.wik">
        <link rel="alternate" href="https://blog.zshipu.com/article/feed.xml" type="application/rss+xml" title="知识铺">
        <link rel="icon" href="https://blog.zshipu.com/article/favicon.ico">
        <title>lesson8- 测试用例：supertest - 知识铺</title>
        <link rel="stylesheet" href="https://blog.zshipu.com/article/css/highlight.js.min.css">
        <link rel="stylesheet" href="https://blog.zshipu.com/article/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://blog.zshipu.com/article/css/bootstrap-theme.css">
        <link rel="stylesheet" href="https://blog.zshipu.com/article/css/font-awesome/css/font-awesome.min.css" />
        
        <link rel="stylesheet" href="https://blog.zshipu.com/article/css/hugo-org.css">
        
        <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
            })(window,document,'script','dataLayer','GTM-WLWJSST');</script>
        
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <script>
            (adsbygoogle = window.adsbygoogle || []).push({
                google_ad_client: "ca-pub-2874221941555456",
                enable_page_level_ads: true
            });
        </script>
    </head>

<body role="document">
    <nav class="navbar navbar-inverse navbar-fixed-top">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="https://blog.zshipu.com/article/">知识铺</a>
            </div>
            <div id="navbar" class="navbar-collapse collapse">
                <ul class="nav navbar-nav">
                    <li ><a href="https://blog.zshipu.com/">主页</a></li>
                    
                    
                    <li ><a href="https://blog.zshipu.com/article/post/">文章列表</a></li>
                    
                </ul>
            </div>
        </div>
    </nav>



<div class="container">
<div class="row">
    <div class="col-xs-12 col-sm-11 doc-main">
        <main role="main">
            <article>
                <a id="title"></a>
                <h1 class="doc-entry-title">lesson8- 测试用例：supertest</h1>
                
                <div class="doc-entry-meta small">
                    <span><time datetime="2019-10-20">2019-10-20</time> by 知识铺 </span>
                </div>
                
                <section>
                    

<h1 id="测试用例-supertest">《测试用例：supertest》</h1>

<h2 id="目标">目标</h2>

<p>建立一个 lesson8 项目，在其中编写代码。</p>

<p>app.js: 其中有个 fibonacci 接口。fibonacci 的介绍见：<a href="http://en.wikipedia.org/wiki/Fibonacci_number">http://en.wikipedia.org/wiki/Fibonacci_number</a> 。</p>

<p>fibonacci 函数的定义为 <code>int fibonacci(int n)</code>，调用函数的路径是 &lsquo;/fib?n=10&rsquo;，然后这个接口会返回 &lsquo;55&rsquo;。函数的行为定义如下：</p>

<ul>
<li>当 n === 0 时，返回 0；n === 1时，返回 1;</li>
<li>n &gt; 1 时，返回 <code>fibonacci(n) === fibonacci(n-1) + fibonacci(n-2)</code>，如 <code>fibonacci(10) === 55</code>;</li>
<li>n 不可大于10，否则抛错，http status 500，因为 Node.js 的计算性能没那么强。</li>
<li>n 也不可小于 0，否则抛错，500，因为没意义。</li>
<li>n 不为数字时，抛错，500。</li>
</ul>

<p>test/main.test.js: 对 app 的接口进行测试，覆盖以上所有情况。</p>

<h2 id="知识点">知识点</h2>

<ol>
<li>学习 supertest 的使用 (<a href="https://github.com/tj/supertest">https://github.com/tj/supertest</a> )</li>
<li>复习 mocha，should 的使用</li>
</ol>

<h2 id="课程内容">课程内容</h2>

<p>这是连续第三节课讲测试了..我自己都烦..看着烦的可以考虑跳下一课。</p>

<p>OK，基础知识前面都讲得很多了，这节课我不会事无巨细地写过程了。</p>

<p>噢，对了，说到 fibonacci，Node 中文圈的大神 @苏千(<a href="https://github.com/fengmk2">https://github.com/fengmk2</a> ) 写过一个页面，对各种语言的 fibonacci 效率进行了测试：<a href="http://fengmk2.cnpmjs.org/blog/2011/fibonacci/nodejs-python-php-ruby-lua.html">http://fengmk2.cnpmjs.org/blog/2011/fibonacci/nodejs-python-php-ruby-lua.html</a> 。其中，Node 的表现不知道比 Python 和 Ruby 高到哪里去了，与 CPU 谈笑风生。怀疑 js 的人啊，都 too simple，sometimes naive。</p>

<p>先来介绍一下 supertest。supertest 是 superagent 的孪生库。他的作者叫 tj，这是个在 Node.js 的历史上会永远被记住的名字，因为他一个人撑起了 npm 的半边天。别误会成他是 npm 的开发者，他的贡献是在 Node.js 的方方面面都贡献了非常高质量和口碑的库，比如 mocha 是他的，superagent 是他的，express 是他的，should 也是他的，还有其他很多很多，比如 koa，都是他的。如果你更详细点了解一些 Node 圈内的八卦，一定也会像我一样对 tj 佩服得五体投地。他的 github 首页是：<a href="https://github.com/tj">https://github.com/tj</a> 。</p>

<p>假使你作为一个有志之士，想要以他为榜样，跟随他前进的步伐，那么我指条明路给你，不收费的：<a href="http://tour.golang.org/">http://tour.golang.org/</a></p>

<p>为什么说 supertest 是 superagent 的孪生库呢，因为他们的 API 是一模一样的。superagent 是用来抓取页面用的，而 supertest，是专门用来配合 express （准确来说是所有兼容 connect 的 web 框架）进行集成测试的。</p>

<p>假使你有一个 app: <code>var app = express();</code>，想对它的 get 啊，post 接口啊之类的进行测试，那么只要把它传给 supertest：<code>var request = require('supertest')(app)</code>。之后调用 <code>requset.get('/path')</code> 时，就可以对 app 的 path 路径进行访问了。它的 API 参照 superagent 的来就好了：<a href="http://visionmedia.github.io/superagent/">http://visionmedia.github.io/superagent/</a> 。</p>

<p>我们来新建一个项目</p>

<pre><code class="language-shell">$ npm init # ..一阵乱填
</code></pre>

<p>然后安装我们的依赖（记得去弄清楚 <code>npm i --save</code> 与 <code>npm i --save-dev</code> 的区别）：</p>

<pre><code class="language-js">  &quot;devDependencies&quot;: {
    &quot;mocha&quot;: &quot;^1.21.4&quot;,
    &quot;should&quot;: &quot;^4.0.4&quot;,
    &quot;supertest&quot;: &quot;^0.14.0&quot;
  },
  &quot;dependencies&quot;: {
    &quot;express&quot;: &quot;^4.9.6&quot;
  }
</code></pre>

<p>接着，编写 app.js</p>

<pre><code class="language-js">var express = require('express');

// 与之前一样
var fibonacci = function (n) {
  // typeof NaN === 'number' 是成立的，所以要判断 NaN
  if (typeof n !== 'number' || isNaN(n)) {
    throw new Error('n should be a Number');
  }
  if (n &lt; 0) {
    throw new Error('n should &gt;= 0')
  }
  if (n &gt; 10) {
    throw new Error('n should &lt;= 10');
  }
  if (n === 0) {
    return 0;
  }
  if (n === 1) {
    return 1;
  }

  return fibonacci(n-1) + fibonacci(n-2);
};
// END 与之前一样

var app = express();

app.get('/fib', function (req, res) {
  // http 传来的东西默认都是没有类型的，都是 String，所以我们要手动转换类型
  var n = Number(req.query.n);
  try {
    // 为何使用 String 做类型转换，是因为如果你直接给个数字给 res.send 的话，
    // 它会当成是你给了它一个 http 状态码，所以我们明确给 String
    res.send(String(fibonacci(n)));
  } catch (e) {
    // 如果 fibonacci 抛错的话，错误信息会记录在 err 对象的 .message 属性中。
    // 拓展阅读：https://www.joyent.com/developers/node/design/errors
    res
      .status(500)
      .send(e.message);
  }
});

// 暴露 app 出去。module.exports 与 exports 的区别请看《深入浅出 Node.js》
module.exports = app;

app.listen(3000, function () {
  console.log('app is listening at port 3000');
});
</code></pre>

<p>好了，启动一下看看。</p>

<pre><code class="language-shell">$ node app.js
</code></pre>

<p>然后访问 <code>http://localhost:3000/fib?n=10</code>，看到 55 就说明启动成功了。再访问 <code>http://localhost:3000/fib?n=111</code>，会看到 <code>n should &lt;= 10</code>。</p>

<p>对了，大家去装个 <code>nodemon</code> <a href="https://github.com/remy/nodemon">https://github.com/remy/nodemon</a> 。</p>

<p><code>$ npm i -g nodemon</code></p>

<p>这个库是专门调试时候使用的，它会自动检测 node.js 代码的改动，然后帮你自动重启应用。在调试时可以完全用 nodemon 命令代替 node 命令。</p>

<p><code>$ nodemon app.js</code> 启动我们的应用试试，然后随便改两行代码，就可以看到 nodemon 帮我们重启应用了。</p>

<p>那么 app 写完了，接着开始测试，测试代码在 test/app.test.js。</p>

<pre><code class="language-js">var app = require('../app');
var supertest = require('supertest');
// 看下面这句，这是关键一句。得到的 request 对象可以直接按照
// superagent 的 API 进行调用
var request = supertest(app);

var should = require('should');

describe('test/app.test.js', function () {
  // 我们的第一个测试用例，好好理解一下
  it('should return 55 when n is 10', function (done) {
    // 之所以这个测试的 function 要接受一个 done 函数，是因为我们的测试内容
    // 涉及了异步调用，而 mocha 是无法感知异步调用完成的。所以我们主动接受它提供
    // 的 done 函数，在测试完毕时，自行调用一下，以示结束。
    // mocha 可以感知到我们的测试函数是否接受 done 参数。js 中，function
    // 对象是有长度的，它的长度由它的参数数量决定
    // (function (a, b, c, d) {}).length === 4
    // 所以 mocha 通过我们测试函数的长度就可以确定我们是否是异步测试。

    request.get('/fib')
    // .query 方法用来传 querystring，.send 方法用来传 body。
    // 它们都可以传 Object 对象进去。
    // 在这里，我们等于访问的是 /fib?n=10
      .query({n: 10})
      .end(function (err, res) {
        // 由于 http 返回的是 String，所以我要传入 '55'。
        res.text.should.equal('55');

        // done(err) 这种用法写起来很鸡肋，是因为偷懒不想测 err 的值
        // 如果勤快点，这里应该写成
        /*
        should.not.exist(err);
        res.text.should.equal('55');
        */
        done(err);
      });
  });

  // 下面我们对于各种边界条件都进行测试，由于它们的代码雷同，
  // 所以我抽象出来了一个 testFib 方法。
  var testFib = function (n, statusCode, expect, done) {
    request.get('/fib')
      .query({n: n})
      .expect(statusCode)
      .end(function (err, res) {
        res.text.should.equal(expect);
        done(err);
      });
  };
  it('should return 0 when n === 0', function (done) {
    testFib(0, 200, '0', done);
  });

  it('should equal 1 when n === 1', function (done) {
    testFib(1, 200, '1', done);
  });

  it('should equal 55 when n === 10', function (done) {
    testFib(10, 200, '55', done);
  });

  it('should throw when n &gt; 10', function (done) {
    testFib(11, 500, 'n should &lt;= 10', done);
  });

  it('should throw when n &lt; 0', function (done) {
    testFib(-1, 500, 'n should &gt;= 0', done);
  });

  it('should throw when n isnt Number', function (done) {
    testFib('good', 500, 'n should be a Number', done);
  });

  // 单独测试一下返回码 500
  it('should status 500 when error', function (done) {
    request.get('/fib')
      .query({n: 100})
      .expect(500)
      .end(function (err, res) {
        done(err);
      });
  });
});
</code></pre>

<p>完。</p>

<h2 id="关于-cookie-持久化">关于 cookie 持久化</h2>

<p>有两种思路</p>

<ol>
<li><p>在 supertest 中，可以通过 <code>var agent = supertest.agent(app)</code> 获取一个 agent 对象，这个对象的 API 跟直接在 superagent 上调用各种方法是一样的。agent 对象在被多次调用 <code>get</code> 和 <code>post</code> 之后，可以一路把 cookie 都保存下来。</p>

<pre><code class="language-js">var supertest = require('supertest');
var app = express();
var agent = supertest.agent(app);

agent.post('login').end(...);
// then ..
agent.post('create_topic').end(...); // 此时的 agent 中有用户登陆后的 cookie

</code></pre></li>

<li><p>在发起请求时，调用 <code>.set('Cookie', 'a cookie string')</code> 这样的方式。</p>

<pre><code class="language-js">var supertest = require('supertest');
var userCookie;
supertest.post('login').end(function (err, res) {
    userCookie = res.headers['set-cookie']
  });
// then ..

supertest.post('create_topic')
  .set('cookie', userCookie)
  .end(...)
</code></pre></li>
</ol>

<p>这里有个相关讨论：<a href="https://github.com/tj/supertest/issues/46">https://github.com/tj/supertest/issues/46</a></p>

<h2 id="拓展学习">拓展学习</h2>

<p>Nodeclub 里面的测试使用的技术跟前面介绍的是一样的，should mocha supertest 那套，应该是很容易看懂的:</p>

<p><a href="https://github.com/cnodejs/nodeclub/blob/master/test/controllers/topic.test.js">https://github.com/cnodejs/nodeclub/blob/master/test/controllers/topic.test.js</a></p>

                </section>
            </article>
        </main>
    </div> 
    
<div class="col-xs-12 col-sm-3 doc-sidebar">
	<div class="sidebar-module">
		<div class="sidebar-toc">
			<h4>Table of Contents</h4>
			<ul>
				<li><strong><a href="#title">lesson8- 测试用例：supertest</a></strong></li>
			</ul>
			<nav id="TableOfContents">
<ul>
<li><a href="#测试用例-supertest">《测试用例：supertest》</a>
<ul>
<li><a href="#目标">目标</a></li>
<li><a href="#知识点">知识点</a></li>
<li><a href="#课程内容">课程内容</a></li>
<li><a href="#关于-cookie-持久化">关于 cookie 持久化</a></li>
<li><a href="#拓展学习">拓展学习</a></li>
</ul></li>
</ul>
</nav>
		</div>
	</div>
	<div class="sidebar-module">
		<h4>Tags</h4>
		<div class="tag-box">
		
		</div>
	</div>
</div>

</div> 



<hr />

<div class="row">
    <div class="col-sm-12">
        
	    <div class="text-center">
        
		    <p class="doc-footer-em"><a href="#">回到顶部↑</a></p>
	    </div>
	</div>
</div>

</div> 

<footer class="doc-footer">
	
    <p>Copyright © <a href="https://blog.zshipu.com/">知识铺</a> 2019. Generated by <a href="http://gohugo.io/">Hugo</a></p>
</footer>



<script src="https://blog.zshipu.com/article/js/jquery-1.11.2.min.js"></script>
<script src="https://blog.zshipu.com/article/js/bootstrap.min.js"></script>

<script src="https://blog.zshipu.com/article/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="https://blog.zshipu.com/article/js/ie10-viewport-bug-workaround.js"></script>

<div style="position:absolute; bottom: 0; right: 0;">
	<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=110 src="//music.163.com/outchain/player?type=0&id=962982601&auto=1&height=90"></iframe>
</div>
<script>
	(function(){
		var bp = document.createElement('script');
		var curProtocol = window.location.protocol.split(':')[0];
		if (curProtocol === 'https') {
			bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
		}
		else {
			bp.src = 'http://push.zhanzhang.baidu.com/push.js';
		}
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(bp, s);
	})();
</script>

</body>
</html>

