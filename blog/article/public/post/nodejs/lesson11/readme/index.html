<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="keywords" content="知识铺">
        <meta name="description" content="《作用域与闭包：this，var，(function () {})》 目标 无具体目标 知识点 理解 js 中 var 的作用域 了解闭包的概念 理解 this 的指向 课程内容 es6">
        <link rel="alternate" href="https://blog.zshipu.com/article/feed.xml" type="application/rss+xml" title="知识铺">
        <link rel="icon" href="https://blog.zshipu.com/article/favicon.ico">
        <title>lesson11- 作用域与闭包：this，var，(function () {}) - 知识铺</title>
        <link rel="stylesheet" href="https://blog.zshipu.com/article/css/highlight.js.min.css">
        <link rel="stylesheet" href="https://blog.zshipu.com/article/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://blog.zshipu.com/article/css/bootstrap-theme.css">
        <link rel="stylesheet" href="https://blog.zshipu.com/article/css/font-awesome/css/font-awesome.min.css" />
        
        <link rel="stylesheet" href="https://blog.zshipu.com/article/css/hugo-org.css">
        
        <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
            })(window,document,'script','dataLayer','GTM-WLWJSST');</script>
        
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <script>
            (adsbygoogle = window.adsbygoogle || []).push({
                google_ad_client: "ca-pub-2874221941555456",
                enable_page_level_ads: true
            });
        </script>
    </head>

<body role="document">
    <nav class="navbar navbar-inverse navbar-fixed-top">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="https://blog.zshipu.com/article/">知识铺</a>
            </div>
            <div id="navbar" class="navbar-collapse collapse">
                <ul class="nav navbar-nav">
                    <li ><a href="https://blog.zshipu.com/">主页</a></li>
                    
                    
                    <li ><a href="https://blog.zshipu.com/article/post/">文章列表</a></li>
                    
                </ul>
            </div>
        </div>
    </nav>



<div class="container">
<div class="row">
    <div class="col-xs-12 col-sm-11 doc-main">
        <main role="main">
            <article>
                <a id="title"></a>
                <h1 class="doc-entry-title">lesson11- 作用域与闭包：this，var，(function () {})</h1>
                
                <div class="doc-entry-meta small">
                    <span><time datetime="2019-10-20">2019-10-20</time> by 知识铺 </span>
                </div>
                
                <section>
                    

<h1 id="作用域与闭包-this-var-function">《作用域与闭包：this，var，(function () {})》</h1>

<h2 id="目标">目标</h2>

<p>无具体目标</p>

<h2 id="知识点">知识点</h2>

<ol>
<li>理解 js 中 var 的作用域</li>
<li>了解闭包的概念</li>
<li>理解 this 的指向</li>
</ol>

<h2 id="课程内容">课程内容</h2>

<p><strong>es6中新增了 let 关键词，与块级作用域，相关知识参考： <a href="http://es6.ruanyifeng.com/#docs/let">http://es6.ruanyifeng.com/#docs/let</a></strong></p>

<h3 id="var-作用域">var 作用域</h3>

<p>先来看个简单的例子：</p>

<pre><code class="language-js">var parent = function () {
  var name = &quot;parent_name&quot;;
  var age = 13;

  var child = function () {
    var name = &quot;child_name&quot;;
    var childAge = 0.3;

    // =&gt; child_name 13 0.3
    console.log(name, age, childAge);
  };

  child();

  // will throw Error
  // ReferenceError: childAge is not defined
  console.log(name, age, childAge);
};

parent();
</code></pre>

<p>直觉地，内部函数可以访问外部函数的变量，外部不能访问内部函数的变量。上面的例子中内部函数 child 可以访问变量 age，而外部函数 parent 不可以访问 child 中的变量 childAge，因此会抛出没有定义变量的异常。</p>

<p>有个重要的事，如果忘记var，那么变量就被声明为全局变量了。</p>

<pre><code class="language-js">function foo() {
  value = &quot;hello&quot;;
}
foo();
console.log(value); // 输出hello
console.log(global.value) // 输出hello
</code></pre>

<p>这个例子可以很正常的输出 <code>hello</code>，是因为 <code>value</code> 变量在定义时，没有使用 <code>var</code> 关键词，所以被定义成了全局变量。在 Node 中，全局变量会被定义在 <code>global</code> 对象下；在浏览器中，全局变量会被定义在 <code>window</code> 对象下。</p>

<p>如果你确实要定义一个全局变量的话，请显示地定义在 <code>global</code> 或者 <code>window</code> 对象上。</p>

<p>这类不小心定义全局变量的问题可以被 jshint 检测出来，如果你使用 sublime 编辑器的话，记得装一个 <code>SublimeLinter</code> 插件，这是插件支持多语言的语法错误检测，js 的检测是原生支持的。</p>

<p>JavaScript 中，变量的局部作用域是函数级别的。不同于 C 语言，在 C 语言中，作用域是块级别的。
JavaScript 中没有块级作用域。</p>

<p>js 中，函数中声明的变量在整个函数中都有定义。比如如下代码段，变量 i 和 value 虽然是在 for 循环代码块中被定义，但在代码块外仍可以访问 i 和 value。</p>

<pre><code class="language-js">function foo() {
  for (var i = 0; i &lt; 10; i++) {
    var value = &quot;hello world&quot;;
  }
  console.log(i); //输出10
  console.log(value);//输出hello world
}
foo();
</code></pre>

<p>所以有种说法是：应该提前声明函数中需要用到的变量，即，在函数体的顶部声明可能用到的变量，这样就可以避免出现一些奇奇怪怪怪的 bug。</p>

<p>但我个人不喜欢遵守这一点，一般都是现用现声明的。这类错误的检测交给 jshint 来做就好了。</p>

<h3 id="闭包">闭包</h3>

<p>闭包这个概念，在函数式编程里很常见，简单的说，就是使内部函数可以访问定义在外部函数中的变量。</p>

<p>假如我们要实现一系列的函数：add10，add20，它们的定义是 <code>int add10(int n)</code>。</p>

<p>为此我们构造了一个名为 adder 的构造器，如下：</p>

<pre><code class="language-js">var adder = function (x) {
  var base = x;
  return function (n) {
    return n + base;
  };
};

var add10 = adder(10);
console.log(add10(5));

var add20 = adder(20);
console.log(add20(5));
</code></pre>

<p>每次调用 adder 时，adder 都会返回一个函数给我们。我们传给 adder 的值，会保存在一个名为 base 的变量中。由于返回的函数在其中引用了 base 的值，于是 base 的引用计数被 +1。当返回函数不被垃圾回收时，则 base 也会一直存在。</p>

<p>我暂时想不出什么实用的例子来，如果想深入理解这块，可以看看这篇 <a href="http://coolshell.cn/articles/6731.html">http://coolshell.cn/articles/6731.html</a></p>

<h4 id="闭包的一个坑">闭包的一个坑</h4>

<pre><code class="language-js">for (var i = 0; i &lt; 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, 5);
}
</code></pre>

<p>上面这个代码块会打印五个 <code>5</code> 出来，而我们预想的结果是打印 0 1 2 3 4。</p>

<p>之所以会这样，是因为 setTimeout 中的 i 是对外层 i 的引用。当 setTimeout 的代码被解释的时候，运行时只是记录了 i 的引用，而不是值。而当 setTimeout 被触发时，五个 setTimeout 中的 i 同时被取值，由于它们都指向了外层的同一个 i，而那个 i 的值在迭代完成时为 5，所以打印了五次 <code>5</code>。</p>

<p>为了得到我们预想的结果，我们可以把 i 赋值成一个局部的变量，从而摆脱外层迭代的影响。</p>

<pre><code class="language-js">for (var i = 0; i &lt; 5; i++) {
  (function (idx) {
    setTimeout(function () {
      console.log(idx);
    }, 5);
  })(i);
}
</code></pre>

<h3 id="this">this</h3>

<p>在函数执行时，this 总是指向调用该函数的对象。要判断 this 的指向，其实就是判断 this 所在的函数属于谁。</p>

<p>在《javaScript语言精粹》这本书中，把 this 出现的场景分为四类，简单的说就是：</p>

<ul>
<li>有对象就指向调用对象</li>
<li>没调用对象就指向全局对象</li>
<li>用new构造就指向新对象</li>
<li>通过 apply 或 call 或 bind 来改变 this 的所指。</li>
</ul>

<p>1）函数有所属对象时：指向所属对象</p>

<p>函数有所属对象时，通常通过 <code>.</code> 表达式调用，这时 <code>this</code> 自然指向所属对象。比如下面的例子：</p>

<pre><code class="language-js">var myObject = {value: 100};
myObject.getValue = function () {
  console.log(this.value);  // 输出 100

  // 输出 { value: 100, getValue: [Function] }，
  // 其实就是 myObject 对象本身
  console.log(this);

  return this.value;
};

console.log(myObject.getValue()); // =&gt; 100
</code></pre>

<p><code>getValue()</code> 属于对象 <code>myObject</code>，并由 <code>myOjbect</code> 进行 <code>.</code> 调用，因此 <code>this</code> 指向对象 <code>myObject</code>。</p>

<p>2) 函数没有所属对象：指向全局对象</p>

<pre><code class="language-js">var myObject = {value: 100};
myObject.getValue = function () {
  var foo = function () {
    console.log(this.value) // =&gt; undefined
    console.log(this);// 输出全局对象 global
  };

  foo();

  return this.value;
};

console.log(myObject.getValue()); // =&gt; 100
</code></pre>

<p>在上述代码块中，<code>foo</code> 函数虽然定义在 <code>getValue</code> 的函数体内，但实际上它既不属于 <code>getValue</code> 也不属于 <code>myObject</code>。<code>foo</code> 并没有被绑定在任何对象上，所以当调用时，它的 <code>this</code> 指针指向了全局对象 <code>global</code>。</p>

<p>据说这是个设计错误。</p>

<p>3）构造器中的 this：指向新对象</p>

<p>js 中，我们通过 <code>new</code> 关键词来调用构造函数，此时 this 会绑定在该新对象上。</p>

<pre><code class="language-js">
var SomeClass = function(){
  this.value = 100;
}

var myCreate = new SomeClass();

console.log(myCreate.value); // 输出100
</code></pre>

<p>顺便说一句，在 js 中，构造函数、普通函数、对象方法、闭包，这四者没有明确界线。界线都在人的心中。</p>

<p>4) apply 和 call 调用以及 bind 绑定：指向绑定的对象</p>

<p>apply() 方法接受两个参数第一个是函数运行的作用域，另外一个是一个参数数组(arguments)。</p>

<p>call() 方法第一个参数的意义与 apply() 方法相同，只是其他的参数需要一个个列举出来。</p>

<p>简单来说，call 的方式更接近我们平时调用函数，而 apply 需要我们传递 Array 形式的数组给它。它们是可以互相转换的。</p>

<pre><code class="language-js">var myObject = {value: 100};

var foo = function(){
  console.log(this);
};

foo(); // 全局变量 global
foo.apply(myObject); // { value: 100 }
foo.call(myObject); // { value: 100 }

var newFoo = foo.bind(myObject);
newFoo(); // { value: 100 }
</code></pre>

<p>完。</p>

                </section>
            </article>
        </main>
    </div> 
    
<div class="col-xs-12 col-sm-3 doc-sidebar">
	<div class="sidebar-module">
		<div class="sidebar-toc">
			<h4>Table of Contents</h4>
			<ul>
				<li><strong><a href="#title">lesson11- 作用域与闭包：this，var，(function () {})</a></strong></li>
			</ul>
			<nav id="TableOfContents">
<ul>
<li><a href="#作用域与闭包-this-var-function">《作用域与闭包：this，var，(function () {})》</a>
<ul>
<li><a href="#目标">目标</a></li>
<li><a href="#知识点">知识点</a></li>
<li><a href="#课程内容">课程内容</a>
<ul>
<li><a href="#var-作用域">var 作用域</a></li>
<li><a href="#闭包">闭包</a>
<ul>
<li><a href="#闭包的一个坑">闭包的一个坑</a></li>
</ul></li>
<li><a href="#this">this</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
		</div>
	</div>
	<div class="sidebar-module">
		<h4>Tags</h4>
		<div class="tag-box">
		
		</div>
	</div>
</div>

</div> 



<hr />

<div class="row">
    <div class="col-sm-12">
        
	    <div class="text-center">
        
		    <p class="doc-footer-em"><a href="#">回到顶部↑</a></p>
	    </div>
	</div>
</div>

</div> 

<footer class="doc-footer">
	
    <p>Copyright © <a href="https://blog.zshipu.com/">知识铺</a> 2019. Generated by <a href="http://gohugo.io/">Hugo</a></p>
</footer>



<script src="https://blog.zshipu.com/article/js/jquery-1.11.2.min.js"></script>
<script src="https://blog.zshipu.com/article/js/bootstrap.min.js"></script>

<script src="https://blog.zshipu.com/article/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="https://blog.zshipu.com/article/js/ie10-viewport-bug-workaround.js"></script>

<div style="position:absolute; bottom: 0; right: 0;">
	<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=110 src="//music.163.com/outchain/player?type=0&id=962982601&auto=1&height=90"></iframe>
</div>
<script>
	(function(){
		var bp = document.createElement('script');
		var curProtocol = window.location.protocol.split(':')[0];
		if (curProtocol === 'https') {
			bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
		}
		else {
			bp.src = 'http://push.zhanzhang.baidu.com/push.js';
		}
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(bp, s);
	})();
</script>

</body>
</html>

